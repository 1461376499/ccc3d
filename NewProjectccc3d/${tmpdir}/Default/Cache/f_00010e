(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "../../default-constants.js", "../../animation/transform-utils.js", "../../assets/asset-enum.js", "../../assets/material.js", "../../assets/mesh.js", "../../assets/skeleton.js", "../../assets/texture-2d.js", "../../data/class-decorator.js", "../../data/utils/attribute.js", "../../gfx/define.js", "../../math/index.js", "../misc/buffer.js", "./skinning-model-component.js", "../../platform/index.js"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("../../default-constants.js"), require("../../animation/transform-utils.js"), require("../../assets/asset-enum.js"), require("../../assets/material.js"), require("../../assets/mesh.js"), require("../../assets/skeleton.js"), require("../../assets/texture-2d.js"), require("../../data/class-decorator.js"), require("../../data/utils/attribute.js"), require("../../gfx/define.js"), require("../../math/index.js"), require("../misc/buffer.js"), require("./skinning-model-component.js"), require("../../platform/index.js"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.defaultConstants, global.transformUtils, global.assetEnum, global.material, global.mesh, global.skeleton, global.texture2d, global.classDecorator, global.attribute, global.define, global.index, global.buffer, global.skinningModelComponent, global.index);
    global.batchedSkinningModelComponent = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _defaultConstants, _transformUtils, _assetEnum, _material, _mesh, _skeleton, _texture2d, _classDecorator, _attribute, _define, _index, _buffer, _skinningModelComponent, _index2) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.BatchedSkinningModelComponent = _exports.SkinningModelUnit = void 0;

  var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _temp, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _class4, _class5, _descriptor7, _descriptor8, _descriptor9, _temp2;

  function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function set(target, property, value, receiver) { if (typeof Reflect !== "undefined" && Reflect.set) { set = Reflect.set; } else { set = function set(target, property, value, receiver) { var base = _superPropBase(target, property); var desc; if (base) { desc = Object.getOwnPropertyDescriptor(base, property); if (desc.set) { desc.set.call(receiver, value); return true; } else if (!desc.writable) { return false; } } desc = Object.getOwnPropertyDescriptor(receiver, property); if (desc) { if (!desc.writable) { return false; } desc.value = value; Object.defineProperty(receiver, property, desc); } else { _defineProperty(receiver, property, value); } return true; }; } return set(target, property, value, receiver); }

  function _set(target, property, value, receiver, isStrict) { var s = set(target, property, value, receiver || target); if (!s && isStrict) { throw new Error('failed to set property'); } return value; }

  function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

  function _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }

  var repeat = function repeat(n) {
    return n - Math.floor(n);
  };

  var batch_id = {
    name: _define.GFXAttributeName.ATTR_BATCH_ID,
    format: _define.GFXFormat.R32F,
    isNormalized: false
  };
  var batch_uv = {
    name: _define.GFXAttributeName.ATTR_BATCH_UV,
    format: _define.GFXFormat.RG32F,
    isNormalized: false
  };
  var batch_extras_size = _define.GFXFormatInfos[batch_id.format].size + _define.GFXFormatInfos[batch_uv.format].size;
  var SkinningModelUnit = (_dec = (0, _classDecorator.ccclass)('cc.SkinningModelUnit'), _dec2 = (0, _classDecorator.property)(_mesh.Mesh), _dec3 = (0, _classDecorator.property)(_skeleton.Skeleton), _dec4 = (0, _classDecorator.property)(_material.Material), _dec5 = (0, _classDecorator.property)({
    type: _skinningModelComponent.SkinningModelComponent
  }), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function () {
    function SkinningModelUnit() {
      _classCallCheck(this, SkinningModelUnit);

      _initializerDefineProperty(this, "mesh", _descriptor, this);

      _initializerDefineProperty(this, "skeleton", _descriptor2, this);

      _initializerDefineProperty(this, "material", _descriptor3, this);

      _initializerDefineProperty(this, "_localTransform", _descriptor4, this);

      _initializerDefineProperty(this, "_offset", _descriptor5, this);

      _initializerDefineProperty(this, "_size", _descriptor6, this);
    }

    _createClass(SkinningModelUnit, [{
      key: "offset",

      /**
       * @en UV offset on texture atlas.
       * @zh 在图集中的 uv 坐标偏移。
       */
      set: function set(offset) {
        _index.Vec2.copy(this._offset, offset);
      },
      get: function get() {
        return this._offset;
      }
      /**
       * @en UV extent on texture atlas.
       * @zh 在图集中占的 UV 尺寸。
       */

    }, {
      key: "size",
      set: function set(size) {
        _index.Vec2.copy(this._size, size);
      },
      get: function get() {
        return this._size;
      }
      /**
       * @en Convenient setter, copying all necessary information from target skinning model component.
       * @zh 复制目标 SkinningModelComponent 的所有属性到本单元，方便快速配置。
       */

    }, {
      key: "copyFrom",
      set: function set(comp) {
        if (!comp) {
          return;
        }

        this.mesh = comp.mesh;
        this.skeleton = comp.skeleton;
        this.material = comp.getMaterial(0);

        if (comp.skinningRoot) {
          (0, _transformUtils.getWorldTransformUntilRoot)(comp.node, comp.skinningRoot, this._localTransform);
        }
      },
      get: function get() {
        return null;
      }
    }]);

    return SkinningModelUnit;
  }(), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "mesh", [_dec2], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return null;
    }
  }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "skeleton", [_dec3], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return null;
    }
  }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "material", [_dec4], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return null;
    }
  }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "_localTransform", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return new _index.Mat4();
    }
  }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "_offset", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return new _index.Vec2(0, 0);
    }
  }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "_size", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return new _index.Vec2(1, 1);
    }
  }), _applyDecoratedDescriptor(_class2.prototype, "offset", [_classDecorator.property], Object.getOwnPropertyDescriptor(_class2.prototype, "offset"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "size", [_classDecorator.property], Object.getOwnPropertyDescriptor(_class2.prototype, "size"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "copyFrom", [_dec5], Object.getOwnPropertyDescriptor(_class2.prototype, "copyFrom"), _class2.prototype)), _class2)) || _class);
  _exports.SkinningModelUnit = SkinningModelUnit;
  var m4_local = new _index.Mat4();
  var m4_1 = new _index.Mat4();
  var v3_1 = new _index.Vec3();
  /**
   * @en The Batched Skinning Model Component, batches multiple skeleton-sharing skinning models.
   * @zh 蒙皮模型合批组件，用于合并绘制共享同一骨骼资源的所有蒙皮模型。
   */

  var BatchedSkinningModelComponent = (_dec6 = (0, _classDecorator.ccclass)('cc.BatchedSkinningModelComponent'), _dec7 = (0, _classDecorator.help)('i18n:cc.BatchedSkinningModelComponent'), _dec8 = (0, _classDecorator.executionOrder)(100), _dec9 = (0, _classDecorator.menu)('Components/BatchedSkinningModel'), _dec10 = (0, _classDecorator.property)({
    tooltip: 'i18n:batched_skinning_model.atlas_size'
  }), _dec11 = (0, _classDecorator.property)({
    type: [_attribute.CCString],
    tooltip: 'i18n:batched_skinning_model.batchable_texture_names'
  }), _dec12 = (0, _classDecorator.property)({
    type: [SkinningModelUnit],
    tooltip: 'i18n:batched_skinning_model.units'
  }), _dec13 = (0, _classDecorator.property)({
    override: true,
    visible: false
  }), _dec14 = (0, _classDecorator.property)({
    override: true,
    visible: false
  }), _dec6(_class4 = _dec7(_class4 = _dec8(_class4 = (0, _classDecorator.executeInEditMode)(_class4 = _dec9(_class4 = (_class5 = (_temp2 = /*#__PURE__*/function (_SkinningModelCompone) {
    _inherits(BatchedSkinningModelComponent, _SkinningModelCompone);

    function BatchedSkinningModelComponent() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, BatchedSkinningModelComponent);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(BatchedSkinningModelComponent)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _initializerDefineProperty(_this, "atlasSize", _descriptor7, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "batchableTextureNames", _descriptor8, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "units", _descriptor9, _assertThisInitialized(_this));

      _this._textures = {};
      _this._batchMaterial = null;
      return _this;
    }

    _createClass(BatchedSkinningModelComponent, [{
      key: "onLoad",
      value: function onLoad() {
        _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "onLoad", this).call(this);

        this.cook();
      }
    }, {
      key: "onDestroy",
      value: function onDestroy() {
        for (var tex in this._textures) {
          this._textures[tex].destroy();
        }

        this._textures = {};

        if (this._mesh) {
          this._mesh.destroy();

          this._mesh = null;
        }

        _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "onDestroy", this).call(this);
      }
    }, {
      key: "_onMaterialModified",
      value: function _onMaterialModified(idx, material) {
        this.cookMaterials();

        _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "_onMaterialModified", this).call(this, idx, this.getMaterialInstance(idx));
      }
    }, {
      key: "cook",
      value: function cook() {
        this.cookMaterials();
        this.cookSkeletons();
        this.cookMeshes();
      }
    }, {
      key: "cookMaterials",
      value: function cookMaterials() {
        var _this2 = this;

        if (!this._batchMaterial) {
          this._batchMaterial = this.getMaterial(0);
        }

        var mat = this.getMaterialInstance(0);

        if (!mat || !this._batchMaterial || !this._batchMaterial.effectAsset) {
          console.warn('incomplete batch material!');
          return;
        }

        mat.copy(this._batchMaterial);
        this.resizeAtlases();
        var tech = mat.effectAsset.techniques[mat.technique];

        var _loop = function _loop(i) {
          var pass = tech.passes[i];

          if (!pass.properties) {
            return "continue";
          }

          var _loop2 = function _loop2(prop) {
            if (pass.properties[prop].type >= _define.GFXType.SAMPLER1D) {
              // samplers
              var tex = null;

              if (_this2.batchableTextureNames.find(function (n) {
                return n === prop;
              })) {
                tex = _this2._textures[prop];

                if (!tex) {
                  tex = _this2.createTexture(prop);
                }

                _this2.cookTextures(tex, prop, i);
              } else {
                _this2.units.some(function (u) {
                  return tex = u.material && u.material.getProperty(prop, i);
                });
              }

              if (tex) {
                mat.setProperty(prop, tex, i);
              }
            } else {
              // vectors
              var value = [];

              for (var u = 0; u < _this2.units.length; u++) {
                var unit = _this2.units[u];

                if (!unit.material) {
                  continue;
                }

                value.push(unit.material.getProperty(prop.slice(0, -3), i));
              }

              mat.setProperty(prop, value, i);
            }
          };

          for (var prop in pass.properties) {
            _loop2(prop);
          }
        };

        for (var i = 0; i < tech.passes.length; i++) {
          var _ret = _loop(i);

          if (_ret === "continue") continue;
        }
      }
    }, {
      key: "cookSkeletons",
      value: function cookSkeletons() {
        var _this3 = this;

        if (!this._skinningRoot) {
          console.warn('no skinning root specified!');
          return;
        } // merge joints accordingly


        var joints = [];
        var bindposes = [];

        for (var u = 0; u < this.units.length; u++) {
          var unit = this.units[u];

          if (!unit || !unit.skeleton) {
            continue;
          }

          var partial = unit.skeleton;

          _index.Mat4.invert(m4_local, unit._localTransform);

          var _loop3 = function _loop3(i) {
            var path = partial.joints[i];
            var idx = joints.findIndex(function (p) {
              return p === path;
            });

            if (idx >= 0) {
              if (_defaultConstants.EDITOR) {
                // consistency check
                _index.Mat4.multiply(m4_1, partial.bindposes[i], m4_local);

                if (!m4_1.equals(bindposes[idx])) {
                  console.warn("".concat(_this3.node.name, ": Inconsistent bindpose at ").concat(joints[idx], " in unit ").concat(u, ", artifacts may present"));
                }
              }

              return "continue";
            }

            joints.push(path); // cancel out local transform

            bindposes.push(_index.Mat4.multiply(new _index.Mat4(), partial.bindposes[i] || _index.Mat4.IDENTITY, m4_local));
          };

          for (var i = 0; i < partial.joints.length; i++) {
            var _ret2 = _loop3(i);

            if (_ret2 === "continue") continue;
          }
        } // sort the array to be more cache-friendly


        var idxMap = Array.from(Array(joints.length).keys()).sort(function (a, b) {
          if (joints[a] > joints[b]) {
            return 1;
          }

          if (joints[a] < joints[b]) {
            return -1;
          }

          return 0;
        });
        var skeleton = new _skeleton.Skeleton();
        skeleton.joints = joints.map(function (_, idx, arr) {
          return arr[idxMap[idx]];
        });
        skeleton.bindposes = bindposes.map(function (_, idx, arr) {
          return arr[idxMap[idx]];
        }); // apply

        if (this._skeleton) {
          this._skeleton.destroy();
        }

        this.skeleton = skeleton;
      }
    }, {
      key: "cookMeshes",
      value: function cookMeshes() {
        var _this4 = this;

        var isValid = false;

        for (var u = 0; u < this.units.length; u++) {
          var unit = this.units[u];

          if (unit.mesh) {
            isValid = true;
            break;
          }
        }

        if (!isValid || !this._skinningRoot) {
          return;
        }

        if (this._mesh) {
          this._mesh.destroyRenderingMesh();
        } else {
          this._mesh = new _mesh.Mesh();
        }

        var posOffset = 0;
        var posFormat = _define.GFXFormat.UNKNOWN;
        var normalOffset = 0;
        var normalFormat = _define.GFXFormat.UNKNOWN;
        var tangentOffset = 0;
        var tangentFormat = _define.GFXFormat.UNKNOWN;
        var uvOffset = 0;
        var uvFormat = _define.GFXFormat.UNKNOWN;
        var jointOffset = 0;
        var jointFormat = _define.GFXFormat.UNKNOWN; // prepare joint index map

        var jointIndexMap = new Array(this.units.length);
        var unitLen = this.units.length;

        for (var i = 0; i < unitLen; i++) {
          var _unit = this.units[i];

          if (!_unit || !_unit.skeleton) {
            continue;
          }

          jointIndexMap[i] = _unit.skeleton.joints.map(function (j) {
            return _this4._skeleton.joints.findIndex(function (ref) {
              return j === ref;
            });
          });
        }

        var _loop4 = function _loop4(_i) {
          var unit = _this4.units[_i];

          if (!unit || !unit.mesh || !unit.mesh.data) {
            return "continue";
          }

          var newMesh = _this4._createUnitMesh(_i, unit.mesh);

          var dataView = new DataView(newMesh.data.buffer);

          _index.Mat4.inverseTranspose(m4_local, unit._localTransform);

          var offset = unit.offset;
          var size = unit.size;

          var _loop5 = function _loop5(b) {
            var bundle = newMesh.struct.vertexBundles[b]; // apply local transform to mesh

            posOffset = bundle.view.offset;
            posFormat = _define.GFXFormat.UNKNOWN;

            for (var a = 0; a < bundle.attributes.length; a++) {
              var attr = bundle.attributes[a];

              if (attr.name === _define.GFXAttributeName.ATTR_POSITION) {
                posFormat = attr.format;
                break;
              }

              posOffset += _define.GFXFormatInfos[attr.format].size;
            }

            if (posFormat) {
              var pos = (0, _buffer.readBuffer)(dataView, posFormat, posOffset, bundle.view.length, bundle.view.stride);

              for (var j = 0; j < pos.length; j += 3) {
                _index.Vec3.fromArray(v3_1, pos, j);

                _index.Vec3.transformMat4(v3_1, v3_1, unit._localTransform);

                _index.Vec3.toArray(pos, v3_1, j);
              }

              (0, _buffer.writeBuffer)(dataView, pos, posFormat, posOffset, bundle.view.stride);
            }

            normalOffset = bundle.view.offset;
            normalFormat = _define.GFXFormat.UNKNOWN;

            for (var _a = 0; _a < bundle.attributes.length; _a++) {
              var _attr = bundle.attributes[_a];

              if (_attr.name === _define.GFXAttributeName.ATTR_NORMAL) {
                normalFormat = _attr.format;
                break;
              }

              normalOffset += _define.GFXFormatInfos[_attr.format].size;
            }

            if (normalFormat) {
              var normal = (0, _buffer.readBuffer)(dataView, normalFormat, normalOffset, bundle.view.length, bundle.view.stride);

              for (var _j = 0; _j < normal.length; _j += 3) {
                _index.Vec3.fromArray(v3_1, normal, _j);

                _index.Vec3.transformMat4Normal(v3_1, v3_1, m4_local);

                _index.Vec3.toArray(normal, v3_1, _j);
              }

              (0, _buffer.writeBuffer)(dataView, normal, normalFormat, normalOffset, bundle.view.stride);
            }

            tangentOffset = bundle.view.offset;
            tangentFormat = _define.GFXFormat.UNKNOWN;

            for (var _a2 = 0; _a2 < bundle.attributes.length; _a2++) {
              var _attr2 = bundle.attributes[_a2];

              if (_attr2.name === _define.GFXAttributeName.ATTR_TANGENT) {
                tangentFormat = _attr2.format;
                break;
              }

              tangentOffset += _define.GFXFormatInfos[_attr2.format].size;
            }

            if (tangentFormat) {
              var tangent = (0, _buffer.readBuffer)(dataView, tangentFormat, tangentOffset, bundle.view.length, bundle.view.stride);

              for (var _j2 = 0; _j2 < tangent.length; _j2 += 3) {
                _index.Vec3.fromArray(v3_1, tangent, _j2);

                _index.Vec3.transformMat4Normal(v3_1, v3_1, m4_local);

                _index.Vec3.toArray(tangent, v3_1, _j2);
              }

              (0, _buffer.writeBuffer)(dataView, tangent, tangentFormat, tangentOffset, bundle.view.stride);
            } // merge UV


            uvOffset = bundle.view.offset;
            uvFormat = _define.GFXFormat.UNKNOWN;

            for (var _a3 = 0; _a3 < bundle.attributes.length; _a3++) {
              var _attr3 = bundle.attributes[_a3];

              if (_attr3.name === _define.GFXAttributeName.ATTR_BATCH_UV) {
                uvFormat = _attr3.format;
                break;
              }

              uvOffset += _define.GFXFormatInfos[_attr3.format].size;
            }

            if (uvFormat) {
              (0, _buffer.mapBuffer)(dataView, function (cur, idx) {
                cur = repeat(cur); // warp to [0, 1] first

                var comp = idx === 0 ? 'x' : 'y';
                return cur * size[comp] + offset[comp];
              }, uvFormat, uvOffset, bundle.view.length, bundle.view.stride, dataView);
            } // merge joint indices


            var idxMap = jointIndexMap[_i];

            if (!idxMap) {
              return "continue";
            }

            jointOffset = bundle.view.offset;
            jointFormat = _define.GFXFormat.UNKNOWN;

            for (var _a4 = 0; _a4 < bundle.attributes.length; _a4++) {
              var _attr4 = bundle.attributes[_a4];

              if (_attr4.name === _define.GFXAttributeName.ATTR_JOINTS) {
                jointFormat = _attr4.format;
                break;
              }

              jointOffset += _define.GFXFormatInfos[_attr4.format].size;
            }

            if (jointFormat) {
              (0, _buffer.mapBuffer)(dataView, function (cur) {
                return idxMap[cur];
              }, jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
            }
          };

          for (var b = 0; b < newMesh.struct.vertexBundles.length; b++) {
            var _ret4 = _loop5(b);

            if (_ret4 === "continue") continue;
          }

          _this4._mesh.merge(newMesh);
        };

        for (var _i = 0; _i < unitLen; _i++) {
          var _ret3 = _loop4(_i);

          if (_ret3 === "continue") continue;
        }

        this._onMeshChanged(this._mesh);

        this._updateModels();
      }
    }, {
      key: "cookTextures",
      value: function cookTextures(target, prop, passIdx) {
        var texImages = [];
        var texImageRegions = [];
        var texBuffers = [];
        var texBufferRegions = [];

        for (var u = 0; u < this.units.length; u++) {
          var unit = this.units[u];

          if (!unit.material) {
            continue;
          }

          var partial = unit.material.getProperty(prop, passIdx);

          if (partial && partial.image && partial.image.data) {
            var region = new _define.GFXBufferTextureCopy();
            region.texOffset.x = unit.offset.x * this.atlasSize;
            region.texOffset.y = unit.offset.y * this.atlasSize;
            region.texExtent.width = unit.size.x * this.atlasSize;
            region.texExtent.height = unit.size.y * this.atlasSize;
            var data = partial.image.data;

            if (data instanceof HTMLCanvasElement || data instanceof HTMLImageElement) {
              texImages.push(data);
              texImageRegions.push(region);
            } else {
              texBuffers.push(data);
              texBufferRegions.push(region);
            }
          }
        }

        var gfxTex = target.getGFXTexture();
        var device = cc.director.root.device;

        if (texBuffers.length > 0) {
          device.copyBuffersToTexture(texBuffers, gfxTex, texBufferRegions);
        }

        if (texImages.length > 0) {
          device.copyTexImagesToTexture(texImages, gfxTex, texImageRegions);
        }
      }
    }, {
      key: "createTexture",
      value: function createTexture(prop) {
        var tex = new _texture2d.Texture2D();
        tex.setFilters(_assetEnum.Filter.LINEAR, _assetEnum.Filter.LINEAR);
        tex.setMipFilter(_assetEnum.Filter.LINEAR);
        tex.reset({
          width: this.atlasSize,
          height: this.atlasSize,
          format: _assetEnum.PixelFormat.RGBA8888
        });
        tex.loaded = true;
        this._textures[prop] = tex;
        return tex;
      }
    }, {
      key: "resizeAtlases",
      value: function resizeAtlases() {
        for (var prop in this._textures) {
          var tex = this._textures[prop];
          tex.reset({
            width: this.atlasSize,
            height: this.atlasSize,
            format: _assetEnum.PixelFormat.RGBA8888
          });
        }
      }
    }, {
      key: "_createUnitMesh",
      value: function _createUnitMesh(unitIdx, mesh) {
        // add batch ID to this temp mesh
        // first, update bookkeeping
        var newMeshStruct = JSON.parse(JSON.stringify(mesh.struct));
        var modifiedBundles = {};

        for (var p = 0; p < mesh.struct.primitives.length; p++) {
          var primitive = mesh.struct.primitives[p];
          var uvOffset = 0;
          var uvFormat = _define.GFXFormat.UNKNOWN;
          var bundleIdx = 0;

          for (; bundleIdx < primitive.vertexBundelIndices.length; bundleIdx++) {
            var bundle = mesh.struct.vertexBundles[primitive.vertexBundelIndices[bundleIdx]];
            uvOffset = bundle.view.offset;
            uvFormat = _define.GFXFormat.UNKNOWN;

            for (var a = 0; a < bundle.attributes.length; a++) {
              var attr = bundle.attributes[a];

              if (attr.name === _define.GFXAttributeName.ATTR_TEX_COORD) {
                uvFormat = attr.format;
                break;
              }

              uvOffset += _define.GFXFormatInfos[attr.format].size;
            }

            if (uvFormat) {
              break;
            }
          }

          if (modifiedBundles[bundleIdx] !== undefined) {
            continue;
          }

          modifiedBundles[bundleIdx] = [uvFormat, uvOffset];
          var newBundle = newMeshStruct.vertexBundles[bundleIdx]; // put the new UVs in the same bundle with original UVs

          newBundle.attributes.push(batch_id);
          newBundle.attributes.push(batch_uv);
          newBundle.view.offset = 0;
          newBundle.view.length += newBundle.view.count * batch_extras_size;
          newBundle.view.stride += batch_extras_size;
        }

        var totalLength = 0;

        for (var b = 0; b < newMeshStruct.vertexBundles.length; b++) {
          totalLength += newMeshStruct.vertexBundles[b].view.length;
        }

        for (var _p = 0; _p < newMeshStruct.primitives.length; _p++) {
          var pm = newMeshStruct.primitives[_p];

          if (pm.indexView) {
            pm.indexView.offset = totalLength;
            totalLength += pm.indexView.length;
          }
        } // now, we ride!


        var newMeshData = new Uint8Array(totalLength);
        var oldMeshData = mesh.data;
        var newDataView = new DataView(newMeshData.buffer);
        var oldDataView = new DataView(oldMeshData.buffer);
        var isLittleEndian = _index2.sys.isLittleEndian;

        for (var _b in modifiedBundles) {
          var _newBundle = newMeshStruct.vertexBundles[_b];
          var oldBundle = mesh.struct.vertexBundles[_b];

          var _modifiedBundles$_b = _slicedToArray(modifiedBundles[_b], 2),
              _uvFormat = _modifiedBundles$_b[0],
              _uvOffset = _modifiedBundles$_b[1];

          var uvs = (0, _buffer.readBuffer)(oldDataView, _uvFormat, _uvOffset, oldBundle.view.length, oldBundle.view.stride);
          var oldView = oldBundle.view;
          var newView = _newBundle.view;
          var oldStride = oldView.stride;
          var newStride = newView.stride;
          var oldOffset = oldView.offset;
          var newOffset = newView.offset;

          for (var j = 0; j < newView.count; j++) {
            var srcVertex = oldMeshData.subarray(oldOffset, oldOffset + oldStride);
            newMeshData.set(srcVertex, newOffset); // insert batch ID

            newDataView.setFloat32(newOffset + oldStride, unitIdx); // insert batch UV

            newDataView.setFloat32(newOffset + oldStride + 4, uvs[j * 2], isLittleEndian);
            newDataView.setFloat32(newOffset + oldStride + 8, uvs[j * 2 + 1], isLittleEndian);
            newOffset += newStride;
            oldOffset += oldStride;
          }
        }

        for (var k = 0; k < newMeshStruct.primitives.length; k++) {
          var oldPrimitive = mesh.struct.primitives[k];
          var newPrimitive = newMeshStruct.primitives[k];

          if (oldPrimitive.indexView && newPrimitive.indexView) {
            var _oldStride = oldPrimitive.indexView.stride;
            var _newStride = newPrimitive.indexView.stride;
            var _oldOffset = oldPrimitive.indexView.offset;
            var _newOffset = newPrimitive.indexView.offset;

            for (var _j3 = 0; _j3 < newPrimitive.indexView.count; _j3++) {
              var srcIndices = oldMeshData.subarray(_oldOffset, _oldOffset + _oldStride);
              newMeshData.set(srcIndices, _newOffset);
              _newOffset += _newStride;
              _oldOffset += _oldStride;
            }
          }
        }

        var newMesh = new _mesh.Mesh();
        newMesh.reset({
          struct: newMeshStruct,
          data: newMeshData
        });
        return newMesh;
      }
    }, {
      key: "mesh",
      get: function get() {
        return _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "mesh", this);
      },
      set: function set(val) {
        _set(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "mesh", val, this, true);
      }
    }, {
      key: "skeleton",
      get: function get() {
        return _get(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "skeleton", this);
      },
      set: function set(val) {
        _set(_getPrototypeOf(BatchedSkinningModelComponent.prototype), "skeleton", val, this, true);
      }
    }]);

    return BatchedSkinningModelComponent;
  }(_skinningModelComponent.SkinningModelComponent), _temp2), (_descriptor7 = _applyDecoratedDescriptor(_class5.prototype, "atlasSize", [_dec10], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return 1024;
    }
  }), _descriptor8 = _applyDecoratedDescriptor(_class5.prototype, "batchableTextureNames", [_dec11], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return [];
    }
  }), _descriptor9 = _applyDecoratedDescriptor(_class5.prototype, "units", [_dec12], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return [];
    }
  }), _applyDecoratedDescriptor(_class5.prototype, "mesh", [_dec13], Object.getOwnPropertyDescriptor(_class5.prototype, "mesh"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "skeleton", [_dec14], Object.getOwnPropertyDescriptor(_class5.prototype, "skeleton"), _class5.prototype)), _class5)) || _class4) || _class4) || _class4) || _class4) || _class4);
  _exports.BatchedSkinningModelComponent = BatchedSkinningModelComponent;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkY6L2plbmtpbnMvd29ya3NwYWNlL0NyZWF0b3JfM0QvZWRpdG9yLTNkL3Jlc291cmNlcy8zZC9lbmdpbmUvY29jb3MvY29yZS8zZC9mcmFtZXdvcmsvYmF0Y2hlZC1za2lubmluZy1tb2RlbC1jb21wb25lbnQudHMiXSwibmFtZXMiOlsicmVwZWF0IiwibiIsIk1hdGgiLCJmbG9vciIsImJhdGNoX2lkIiwibmFtZSIsIkdGWEF0dHJpYnV0ZU5hbWUiLCJBVFRSX0JBVENIX0lEIiwiZm9ybWF0IiwiR0ZYRm9ybWF0IiwiUjMyRiIsImlzTm9ybWFsaXplZCIsImJhdGNoX3V2IiwiQVRUUl9CQVRDSF9VViIsIlJHMzJGIiwiYmF0Y2hfZXh0cmFzX3NpemUiLCJHRlhGb3JtYXRJbmZvcyIsInNpemUiLCJTa2lubmluZ01vZGVsVW5pdCIsIk1lc2giLCJTa2VsZXRvbiIsIk1hdGVyaWFsIiwidHlwZSIsIlNraW5uaW5nTW9kZWxDb21wb25lbnQiLCJvZmZzZXQiLCJWZWMyIiwiY29weSIsIl9vZmZzZXQiLCJfc2l6ZSIsImNvbXAiLCJtZXNoIiwic2tlbGV0b24iLCJtYXRlcmlhbCIsImdldE1hdGVyaWFsIiwic2tpbm5pbmdSb290Iiwibm9kZSIsIl9sb2NhbFRyYW5zZm9ybSIsInByb3BlcnR5IiwiTWF0NCIsIm00X2xvY2FsIiwibTRfMSIsInYzXzEiLCJWZWMzIiwiQmF0Y2hlZFNraW5uaW5nTW9kZWxDb21wb25lbnQiLCJ0b29sdGlwIiwiQ0NTdHJpbmciLCJvdmVycmlkZSIsInZpc2libGUiLCJleGVjdXRlSW5FZGl0TW9kZSIsIl90ZXh0dXJlcyIsIl9iYXRjaE1hdGVyaWFsIiwiY29vayIsInRleCIsImRlc3Ryb3kiLCJfbWVzaCIsImlkeCIsImNvb2tNYXRlcmlhbHMiLCJnZXRNYXRlcmlhbEluc3RhbmNlIiwiY29va1NrZWxldG9ucyIsImNvb2tNZXNoZXMiLCJtYXQiLCJlZmZlY3RBc3NldCIsImNvbnNvbGUiLCJ3YXJuIiwicmVzaXplQXRsYXNlcyIsInRlY2giLCJ0ZWNobmlxdWVzIiwidGVjaG5pcXVlIiwiaSIsInBhc3MiLCJwYXNzZXMiLCJwcm9wZXJ0aWVzIiwicHJvcCIsIkdGWFR5cGUiLCJTQU1QTEVSMUQiLCJiYXRjaGFibGVUZXh0dXJlTmFtZXMiLCJmaW5kIiwiY3JlYXRlVGV4dHVyZSIsImNvb2tUZXh0dXJlcyIsInVuaXRzIiwic29tZSIsInUiLCJnZXRQcm9wZXJ0eSIsInNldFByb3BlcnR5IiwidmFsdWUiLCJsZW5ndGgiLCJ1bml0IiwicHVzaCIsInNsaWNlIiwiX3NraW5uaW5nUm9vdCIsImpvaW50cyIsImJpbmRwb3NlcyIsInBhcnRpYWwiLCJpbnZlcnQiLCJwYXRoIiwiZmluZEluZGV4IiwicCIsIkVESVRPUiIsIm11bHRpcGx5IiwiZXF1YWxzIiwiSURFTlRJVFkiLCJpZHhNYXAiLCJBcnJheSIsImZyb20iLCJrZXlzIiwic29ydCIsImEiLCJiIiwibWFwIiwiXyIsImFyciIsIl9za2VsZXRvbiIsImlzVmFsaWQiLCJkZXN0cm95UmVuZGVyaW5nTWVzaCIsInBvc09mZnNldCIsInBvc0Zvcm1hdCIsIlVOS05PV04iLCJub3JtYWxPZmZzZXQiLCJub3JtYWxGb3JtYXQiLCJ0YW5nZW50T2Zmc2V0IiwidGFuZ2VudEZvcm1hdCIsInV2T2Zmc2V0IiwidXZGb3JtYXQiLCJqb2ludE9mZnNldCIsImpvaW50Rm9ybWF0Iiwiam9pbnRJbmRleE1hcCIsInVuaXRMZW4iLCJqIiwicmVmIiwiZGF0YSIsIm5ld01lc2giLCJfY3JlYXRlVW5pdE1lc2giLCJkYXRhVmlldyIsIkRhdGFWaWV3IiwiYnVmZmVyIiwiaW52ZXJzZVRyYW5zcG9zZSIsImJ1bmRsZSIsInN0cnVjdCIsInZlcnRleEJ1bmRsZXMiLCJ2aWV3IiwiYXR0cmlidXRlcyIsImF0dHIiLCJBVFRSX1BPU0lUSU9OIiwicG9zIiwic3RyaWRlIiwiZnJvbUFycmF5IiwidHJhbnNmb3JtTWF0NCIsInRvQXJyYXkiLCJBVFRSX05PUk1BTCIsIm5vcm1hbCIsInRyYW5zZm9ybU1hdDROb3JtYWwiLCJBVFRSX1RBTkdFTlQiLCJ0YW5nZW50IiwiY3VyIiwiQVRUUl9KT0lOVFMiLCJtZXJnZSIsIl9vbk1lc2hDaGFuZ2VkIiwiX3VwZGF0ZU1vZGVscyIsInRhcmdldCIsInBhc3NJZHgiLCJ0ZXhJbWFnZXMiLCJ0ZXhJbWFnZVJlZ2lvbnMiLCJ0ZXhCdWZmZXJzIiwidGV4QnVmZmVyUmVnaW9ucyIsImltYWdlIiwicmVnaW9uIiwiR0ZYQnVmZmVyVGV4dHVyZUNvcHkiLCJ0ZXhPZmZzZXQiLCJ4IiwiYXRsYXNTaXplIiwieSIsInRleEV4dGVudCIsIndpZHRoIiwiaGVpZ2h0IiwiSFRNTENhbnZhc0VsZW1lbnQiLCJIVE1MSW1hZ2VFbGVtZW50IiwiZ2Z4VGV4IiwiZ2V0R0ZYVGV4dHVyZSIsImRldmljZSIsImNjIiwiZGlyZWN0b3IiLCJyb290IiwiY29weUJ1ZmZlcnNUb1RleHR1cmUiLCJjb3B5VGV4SW1hZ2VzVG9UZXh0dXJlIiwiVGV4dHVyZTJEIiwic2V0RmlsdGVycyIsIkZpbHRlciIsIkxJTkVBUiIsInNldE1pcEZpbHRlciIsInJlc2V0IiwiUGl4ZWxGb3JtYXQiLCJSR0JBODg4OCIsImxvYWRlZCIsInVuaXRJZHgiLCJuZXdNZXNoU3RydWN0IiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwibW9kaWZpZWRCdW5kbGVzIiwicHJpbWl0aXZlcyIsInByaW1pdGl2ZSIsImJ1bmRsZUlkeCIsInZlcnRleEJ1bmRlbEluZGljZXMiLCJBVFRSX1RFWF9DT09SRCIsInVuZGVmaW5lZCIsIm5ld0J1bmRsZSIsImNvdW50IiwidG90YWxMZW5ndGgiLCJwbSIsImluZGV4VmlldyIsIm5ld01lc2hEYXRhIiwiVWludDhBcnJheSIsIm9sZE1lc2hEYXRhIiwibmV3RGF0YVZpZXciLCJvbGREYXRhVmlldyIsImlzTGl0dGxlRW5kaWFuIiwic3lzIiwib2xkQnVuZGxlIiwidXZzIiwib2xkVmlldyIsIm5ld1ZpZXciLCJvbGRTdHJpZGUiLCJuZXdTdHJpZGUiLCJvbGRPZmZzZXQiLCJuZXdPZmZzZXQiLCJzcmNWZXJ0ZXgiLCJzdWJhcnJheSIsInNldCIsInNldEZsb2F0MzIiLCJrIiwib2xkUHJpbWl0aXZlIiwibmV3UHJpbWl0aXZlIiwic3JjSW5kaWNlcyIsInZhbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4Q0EsTUFBTUEsTUFBTSxHQUFHLFNBQVRBLE1BQVMsQ0FBQ0MsQ0FBRDtBQUFBLFdBQWVBLENBQUMsR0FBR0MsSUFBSSxDQUFDQyxLQUFMLENBQVdGLENBQVgsQ0FBbkI7QUFBQSxHQUFmOztBQUNBLE1BQU1HLFFBQXVCLEdBQUc7QUFBRUMsSUFBQUEsSUFBSSxFQUFFQyx5QkFBaUJDLGFBQXpCO0FBQXdDQyxJQUFBQSxNQUFNLEVBQUVDLGtCQUFVQyxJQUExRDtBQUFnRUMsSUFBQUEsWUFBWSxFQUFFO0FBQTlFLEdBQWhDO0FBQ0EsTUFBTUMsUUFBdUIsR0FBRztBQUFFUCxJQUFBQSxJQUFJLEVBQUVDLHlCQUFpQk8sYUFBekI7QUFBd0NMLElBQUFBLE1BQU0sRUFBRUMsa0JBQVVLLEtBQTFEO0FBQWlFSCxJQUFBQSxZQUFZLEVBQUU7QUFBL0UsR0FBaEM7QUFDQSxNQUFNSSxpQkFBaUIsR0FBR0MsdUJBQWVaLFFBQVEsQ0FBQ0ksTUFBeEIsRUFBZ0NTLElBQWhDLEdBQXVDRCx1QkFBZUosUUFBUSxDQUFDSixNQUF4QixFQUFnQ1MsSUFBakc7TUFHYUMsaUIsV0FEWiw2QkFBUSxzQkFBUixDLFVBT0ksOEJBQVNDLFVBQVQsQyxVQU9BLDhCQUFTQyxrQkFBVCxDLFVBT0EsOEJBQVNDLGtCQUFULEMsVUFzQ0EsOEJBQVM7QUFBRUMsSUFBQUEsSUFBSSxFQUFFQztBQUFSLEdBQVQsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE1QkQ7Ozs7d0JBS1lDLE0sRUFBUTtBQUNoQkMsb0JBQUtDLElBQUwsQ0FBVSxLQUFLQyxPQUFmLEVBQXdCSCxNQUF4QjtBQUNILE87MEJB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QUFDQVgsY0FBQUEsV0FBVyxDQUFDaUIsR0FBWixDQUFnQkssVUFBaEIsRUFBNEJSLFVBQTVCO0FBQ0FBLGNBQUFBLFVBQVMsSUFBSUYsVUFBYjtBQUNBQyxjQUFBQSxVQUFTLElBQUlGLFVBQWI7QUFDSDtBQUNKO0FBQ0o7O0FBQ0QsWUFBTTNGLE9BQU8sR0FBRyxJQUFJL0csVUFBSixFQUFoQjtBQUNBK0csUUFBQUEsT0FBTyxDQUFDMkQsS0FBUixDQUFjO0FBQ1ZwRCxVQUFBQSxNQUFNLEVBQUV5RCxhQURFO0FBRVZqRSxVQUFBQSxJQUFJLEVBQUVpRjtBQUZJLFNBQWQ7QUFJQSxlQUFPaEYsT0FBUDtBQUNIOzs7MEJBeGFXO0FBQ1I7QUFDSCxPO3dCQUNTdUcsRyxFQUFLO0FBQ1gsK0VBQWFBLEdBQWI7QUFDSDs7OzBCQUdlO0FBQ1o7QUFDSCxPO3dCQUNhQSxHLEVBQUs7QUFDZixtRkFBaUJBLEdBQWpCO0FBQ0g7Ozs7SUFuRDhDbE4sOEM7Ozs7O2FBU3BCLEk7Ozs7Ozs7YUFhYyxFOzs7Ozs7O2FBVUwsRSIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiBDb3B5cmlnaHQgKGMpIDIwMTctMjAxOSBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC5cclxuXHJcbiBodHRwOi8vd3d3LmNvY29zMmQteC5vcmdcclxuXHJcbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXHJcbiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXHJcbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXHJcbiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcclxuIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XHJcblxyXG4gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cclxuIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gVEhFIFNPRlRXQVJFLlxyXG4qL1xyXG5cclxuLyoqXHJcbiAqIEBjYXRlZ29yeSBtb2RlbFxyXG4gKi9cclxuXHJcbmltcG9ydCB7IEVESVRPUiB9IGZyb20gJ2ludGVybmFsOmNvbnN0YW50cyc7XHJcbmltcG9ydCB7IGdldFdvcmxkVHJhbnNmb3JtVW50aWxSb290IH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL3RyYW5zZm9ybS11dGlscyc7XHJcbmltcG9ydCB7IEZpbHRlciwgUGl4ZWxGb3JtYXQgfSBmcm9tICcuLi8uLi9hc3NldHMvYXNzZXQtZW51bSc7XHJcbmltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSAnLi4vLi4vYXNzZXRzL21hdGVyaWFsJztcclxuaW1wb3J0IHsgTWVzaCB9IGZyb20gJy4uLy4uL2Fzc2V0cy9tZXNoJztcclxuaW1wb3J0IHsgU2tlbGV0b24gfSBmcm9tICcuLi8uLi9hc3NldHMvc2tlbGV0b24nO1xyXG5pbXBvcnQgeyBUZXh0dXJlMkQgfSBmcm9tICcuLi8uLi9hc3NldHMvdGV4dHVyZS0yZCc7XHJcbmltcG9ydCB7IGNjY2xhc3MsIGhlbHAsIGV4ZWN1dGVJbkVkaXRNb2RlLCBleGVjdXRpb25PcmRlciwgbWVudSwgcHJvcGVydHkgfSBmcm9tICcuLi8uLi9kYXRhL2NsYXNzLWRlY29yYXRvcic7XHJcbmltcG9ydCB7IENDU3RyaW5nIH0gZnJvbSAnLi4vLi4vZGF0YS91dGlscy9hdHRyaWJ1dGUnO1xyXG5pbXBvcnQgeyBHRlhBdHRyaWJ1dGVOYW1lLCBHRlhCdWZmZXJUZXh0dXJlQ29weSwgR0ZYRm9ybWF0SW5mb3MgfSBmcm9tICcuLi8uLi9nZngvZGVmaW5lJztcclxuaW1wb3J0IHsgR0ZYRm9ybWF0LCBHRlhUeXBlIH0gZnJvbSAnLi4vLi4vZ2Z4L2RlZmluZSc7XHJcbmltcG9ydCB7IEdGWERldmljZSB9IGZyb20gJy4uLy4uL2dmeC9kZXZpY2UnO1xyXG5pbXBvcnQgeyBJR0ZYQXR0cmlidXRlIH0gZnJvbSAnLi4vLi4vZ2Z4L2lucHV0LWFzc2VtYmxlcic7XHJcbmltcG9ydCB7IE1hdDQsIFZlYzIsIFZlYzMgfSBmcm9tICcuLi8uLi9tYXRoJztcclxuaW1wb3J0IHsgbWFwQnVmZmVyLCByZWFkQnVmZmVyLCB3cml0ZUJ1ZmZlciB9IGZyb20gJy4uL21pc2MvYnVmZmVyJztcclxuaW1wb3J0IHsgU2tpbm5pbmdNb2RlbENvbXBvbmVudCB9IGZyb20gJy4vc2tpbm5pbmctbW9kZWwtY29tcG9uZW50JztcclxuaW1wb3J0IHsgc3lzIH0gZnJvbSAnLi4vLi4vcGxhdGZvcm0nO1xyXG5cclxuY29uc3QgcmVwZWF0ID0gKG46IG51bWJlcikgPT4gbiAtIE1hdGguZmxvb3Iobik7XHJcbmNvbnN0IGJhdGNoX2lkOiBJR0ZYQXR0cmlidXRlID0geyBuYW1lOiBHRlhBdHRyaWJ1dGVOYW1lLkFUVFJfQkFUQ0hfSUQsIGZvcm1hdDogR0ZYRm9ybWF0LlIzMkYsIGlzTm9ybWFsaXplZDogZmFsc2UgfTtcclxuY29uc3QgYmF0Y2hfdXY6IElHRlhBdHRyaWJ1dGUgPSB7IG5hbWU6IEdGWEF0dHJpYnV0ZU5hbWUuQVRUUl9CQVRDSF9VViwgZm9ybWF0OiBHRlhGb3JtYXQuUkczMkYsIGlzTm9ybWFsaXplZDogZmFsc2UgfTtcclxuY29uc3QgYmF0Y2hfZXh0cmFzX3NpemUgPSBHRlhGb3JtYXRJbmZvc1tiYXRjaF9pZC5mb3JtYXRdLnNpemUgKyBHRlhGb3JtYXRJbmZvc1tiYXRjaF91di5mb3JtYXRdLnNpemU7XHJcblxyXG5AY2NjbGFzcygnY2MuU2tpbm5pbmdNb2RlbFVuaXQnKVxyXG5leHBvcnQgY2xhc3MgU2tpbm5pbmdNb2RlbFVuaXQge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFNraW5uaW5nIG1lc2ggb2YgdGhpcyB1bml0LlxyXG4gICAgICogQHpoIOWtkOiSmeearuaooeWei+eahOe9keagvOaooeWei+OAglxyXG4gICAgICovXHJcbiAgICBAcHJvcGVydHkoTWVzaClcclxuICAgIHB1YmxpYyBtZXNoOiBNZXNoIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gU2tlbGV0b24gb2YgdGhpcyB1bml0LlxyXG4gICAgICogQHpoIOWtkOiSmeearuaooeWei+eahOmqqOmqvOOAglxyXG4gICAgICovXHJcbiAgICBAcHJvcGVydHkoU2tlbGV0b24pXHJcbiAgICBwdWJsaWMgc2tlbGV0b246IFNrZWxldG9uIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gU2tpbm5pbmcgbWF0ZXJpYWwgb2YgdGhpcyB1bml0LlxyXG4gICAgICogQHpoIOWtkOiSmeearuaooeWei+S9v+eUqOeahOadkOi0qOOAglxyXG4gICAgICovXHJcbiAgICBAcHJvcGVydHkoTWF0ZXJpYWwpXHJcbiAgICBwdWJsaWMgbWF0ZXJpYWw6IE1hdGVyaWFsIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgQHByb3BlcnR5XHJcbiAgICBwdWJsaWMgX2xvY2FsVHJhbnNmb3JtID0gbmV3IE1hdDQoKTtcclxuICAgIEBwcm9wZXJ0eVxyXG4gICAgcHJpdmF0ZSBfb2Zmc2V0ID0gbmV3IFZlYzIoMCwgMCk7XHJcbiAgICBAcHJvcGVydHlcclxuICAgIHByaXZhdGUgX3NpemUgPSBuZXcgVmVjMigxLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBVViBvZmZzZXQgb24gdGV4dHVyZSBhdGxhcy5cclxuICAgICAqIEB6aCDlnKjlm77pm4bkuK3nmoQgdXYg5Z2Q5qCH5YGP56e744CCXHJcbiAgICAgKi9cclxuICAgIEBwcm9wZXJ0eVxyXG4gICAgc2V0IG9mZnNldCAob2Zmc2V0KSB7XHJcbiAgICAgICAgVmVjMi5jb3B5KHRoaXMuX29mZnNldCwgb2Zmc2V0KTtcclxuICAgIH1cclxuICAgIGdldCBvZmZzZXQgKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gVVYgZXh0ZW50IG9uIHRleHR1cmUgYXRsYXMuXHJcbiAgICAgKiBAemgg5Zyo5Zu+6ZuG5Lit5Y2g55qEIFVWIOWwuuWvuOOAglxyXG4gICAgICovXHJcbiAgICBAcHJvcGVydHlcclxuICAgIHNldCBzaXplIChzaXplKSB7XHJcbiAgICAgICAgVmVjMi5jb3B5KHRoaXMuX3NpemUsIHNpemUpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNpemUgKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIENvbnZlbmllbnQgc2V0dGVyLCBjb3B5aW5nIGFsbCBuZWNlc3NhcnkgaW5mb3JtYXRpb24gZnJvbSB0YXJnZXQgc2tpbm5pbmcgbW9kZWwgY29tcG9uZW50LlxyXG4gICAgICogQHpoIOWkjeWItuebruaghyBTa2lubmluZ01vZGVsQ29tcG9uZW50IOeahOaJgOacieWxnuaAp+WIsOacrOWNleWFg++8jOaWueS+v+W/q+mAn+mFjee9ruOAglxyXG4gICAgICovXHJcbiAgICBAcHJvcGVydHkoeyB0eXBlOiBTa2lubmluZ01vZGVsQ29tcG9uZW50IH0pXHJcbiAgICBzZXQgY29weUZyb20gKGNvbXA6IFNraW5uaW5nTW9kZWxDb21wb25lbnQgfCBudWxsKSB7XHJcbiAgICAgICAgaWYgKCFjb21wKSB7IHJldHVybjsgfVxyXG4gICAgICAgIHRoaXMubWVzaCA9IGNvbXAubWVzaDtcclxuICAgICAgICB0aGlzLnNrZWxldG9uID0gY29tcC5za2VsZXRvbjtcclxuICAgICAgICB0aGlzLm1hdGVyaWFsID0gY29tcC5nZXRNYXRlcmlhbCgwKTtcclxuICAgICAgICBpZiAoY29tcC5za2lubmluZ1Jvb3QpIHsgZ2V0V29ybGRUcmFuc2Zvcm1VbnRpbFJvb3QoY29tcC5ub2RlLCBjb21wLnNraW5uaW5nUm9vdCwgdGhpcy5fbG9jYWxUcmFuc2Zvcm0pOyB9XHJcbiAgICB9XHJcbiAgICBnZXQgY29weUZyb20gKCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBtNF9sb2NhbCA9IG5ldyBNYXQ0KCk7XHJcbmNvbnN0IG00XzEgPSBuZXcgTWF0NCgpO1xyXG5jb25zdCB2M18xID0gbmV3IFZlYzMoKTtcclxuXHJcbi8qKlxyXG4gKiBAZW4gVGhlIEJhdGNoZWQgU2tpbm5pbmcgTW9kZWwgQ29tcG9uZW50LCBiYXRjaGVzIG11bHRpcGxlIHNrZWxldG9uLXNoYXJpbmcgc2tpbm5pbmcgbW9kZWxzLlxyXG4gKiBAemgg6JKZ55qu5qih5Z6L5ZCI5om557uE5Lu277yM55So5LqO5ZCI5bm257uY5Yi25YWx5Lqr5ZCM5LiA6aqo6aq86LWE5rqQ55qE5omA5pyJ6JKZ55qu5qih5Z6L44CCXHJcbiAqL1xyXG5AY2NjbGFzcygnY2MuQmF0Y2hlZFNraW5uaW5nTW9kZWxDb21wb25lbnQnKVxyXG5AaGVscCgnaTE4bjpjYy5CYXRjaGVkU2tpbm5pbmdNb2RlbENvbXBvbmVudCcpXHJcbkBleGVjdXRpb25PcmRlcigxMDApXHJcbkBleGVjdXRlSW5FZGl0TW9kZVxyXG5AbWVudSgnQ29tcG9uZW50cy9CYXRjaGVkU2tpbm5pbmdNb2RlbCcpXHJcbmV4cG9ydCBjbGFzcyBCYXRjaGVkU2tpbm5pbmdNb2RlbENvbXBvbmVudCBleHRlbmRzIFNraW5uaW5nTW9kZWxDb21wb25lbnQge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFNpemUgb2YgdGhlIGdlbmVyYXRlZCB0ZXh0dXJlIGF0bGFzLlxyXG4gICAgICogQHpoIOWQiOWbvueUn+aIkOeahOacgOe7iOWbvumbhueahOi+uemVv+OAglxyXG4gICAgICovXHJcbiAgICBAcHJvcGVydHkoe1xyXG4gICAgICAgIHRvb2x0aXA6ICdpMThuOmJhdGNoZWRfc2tpbm5pbmdfbW9kZWwuYXRsYXNfc2l6ZScsXHJcbiAgICB9KVxyXG4gICAgcHVibGljIGF0bGFzU2l6ZTogbnVtYmVyID0gMTAyNDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogVGV4dHVyZSBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBhY3R1YWxseSB1c2luZyB0aGUgZ2VuZXJhdGVkIGF0bGFzLjxicj5cclxuICAgICAqIFRoZSBmaXJzdCB1bml0J3MgdGV4dHVyZSB3aWxsIGJlIHVzZWQgaWYgbm90IHNwZWNpZmllZC5cclxuICAgICAqIEB6aFxyXG4gICAgICog5p2Q6LSo5Lit55yf5q2j5Y+C5LiO5ZCI5Zu+55qE6LS05Zu+5bGe5oCn77yM5LiN5Y+C5LiO55qE5bGe5oCn57uf5LiA5L2/55So56ys5LiA5LiqIHVuaXQg55qE6LS05Zu+44CCXHJcbiAgICAgKi9cclxuICAgIEBwcm9wZXJ0eSh7XHJcbiAgICAgICAgdHlwZTogW0NDU3RyaW5nXSxcclxuICAgICAgICB0b29sdGlwOiAnaTE4bjpiYXRjaGVkX3NraW5uaW5nX21vZGVsLmJhdGNoYWJsZV90ZXh0dXJlX25hbWVzJyxcclxuICAgIH0pXHJcbiAgICBwdWJsaWMgYmF0Y2hhYmxlVGV4dHVyZU5hbWVzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFNvdXJjZSBza2lubmluZyBtb2RlbCBjb21wb25lbnRzLCBjb250YWluaW5nIGFsbCB0aGUgZGF0YSB0byBiZSBiYXRjaGVkLlxyXG4gICAgICogQHpoIOWQiOaJueWJjeeahOWtkOiSmeearuaooeWei+aVsOe7hO+8jOacgOS4u+imgeeahOaVsOaNruadpea6kOOAglxyXG4gICAgICovXHJcbiAgICBAcHJvcGVydHkoe1xyXG4gICAgICAgIHR5cGU6IFtTa2lubmluZ01vZGVsVW5pdF0sXHJcbiAgICAgICAgdG9vbHRpcDogJ2kxOG46YmF0Y2hlZF9za2lubmluZ19tb2RlbC51bml0cycsXHJcbiAgICB9KVxyXG4gICAgcHVibGljIHVuaXRzOiBTa2lubmluZ01vZGVsVW5pdFtdID0gW107XHJcblxyXG4gICAgcHJpdmF0ZSBfdGV4dHVyZXM6IFJlY29yZDxzdHJpbmcsIFRleHR1cmUyRD4gPSB7fTtcclxuICAgIHByaXZhdGUgX2JhdGNoTWF0ZXJpYWw6IE1hdGVyaWFsIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgQHByb3BlcnR5KHsgb3ZlcnJpZGU6IHRydWUsIHZpc2libGU6IGZhbHNlIH0pXHJcbiAgICBnZXQgbWVzaCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLm1lc2g7XHJcbiAgICB9XHJcbiAgICBzZXQgbWVzaCAodmFsKSB7XHJcbiAgICAgICAgc3VwZXIubWVzaCA9IHZhbDtcclxuICAgIH1cclxuXHJcbiAgICBAcHJvcGVydHkoeyBvdmVycmlkZTogdHJ1ZSwgdmlzaWJsZTogZmFsc2UgfSlcclxuICAgIGdldCBza2VsZXRvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNrZWxldG9uO1xyXG4gICAgfVxyXG4gICAgc2V0IHNrZWxldG9uICh2YWwpIHtcclxuICAgICAgICBzdXBlci5za2VsZXRvbiA9IHZhbDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25Mb2FkICgpIHtcclxuICAgICAgICBzdXBlci5vbkxvYWQoKTtcclxuICAgICAgICB0aGlzLmNvb2soKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25EZXN0cm95ICgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHRleCBpbiB0aGlzLl90ZXh0dXJlcykge1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlc1t0ZXhdLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdGV4dHVyZXMgPSB7fTtcclxuICAgICAgICBpZiAodGhpcy5fbWVzaCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tZXNoLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5fbWVzaCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyLm9uRGVzdHJveSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBfb25NYXRlcmlhbE1vZGlmaWVkIChpZHg6IG51bWJlciwgbWF0ZXJpYWw6IE1hdGVyaWFsIHwgbnVsbCkge1xyXG4gICAgICAgIHRoaXMuY29va01hdGVyaWFscygpO1xyXG4gICAgICAgIHN1cGVyLl9vbk1hdGVyaWFsTW9kaWZpZWQoaWR4LCB0aGlzLmdldE1hdGVyaWFsSW5zdGFuY2UoaWR4KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNvb2sgKCkge1xyXG4gICAgICAgIHRoaXMuY29va01hdGVyaWFscygpO1xyXG4gICAgICAgIHRoaXMuY29va1NrZWxldG9ucygpO1xyXG4gICAgICAgIHRoaXMuY29va01lc2hlcygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjb29rTWF0ZXJpYWxzICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2JhdGNoTWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fYmF0Y2hNYXRlcmlhbCA9IHRoaXMuZ2V0TWF0ZXJpYWwoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1hdCA9IHRoaXMuZ2V0TWF0ZXJpYWxJbnN0YW5jZSgwKTtcclxuICAgICAgICBpZiAoIW1hdCB8fCAhdGhpcy5fYmF0Y2hNYXRlcmlhbCB8fCAhdGhpcy5fYmF0Y2hNYXRlcmlhbC5lZmZlY3RBc3NldCkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2luY29tcGxldGUgYmF0Y2ggbWF0ZXJpYWwhJyk7IHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWF0LmNvcHkodGhpcy5fYmF0Y2hNYXRlcmlhbCk7IHRoaXMucmVzaXplQXRsYXNlcygpO1xyXG4gICAgICAgIGNvbnN0IHRlY2ggPSBtYXQuZWZmZWN0QXNzZXQhLnRlY2huaXF1ZXNbbWF0LnRlY2huaXF1ZV07XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZWNoLnBhc3Nlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwYXNzID0gdGVjaC5wYXNzZXNbaV07XHJcbiAgICAgICAgICAgIGlmICghcGFzcy5wcm9wZXJ0aWVzKSB7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwYXNzLnByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwYXNzLnByb3BlcnRpZXNbcHJvcF0udHlwZSA+PSBHRlhUeXBlLlNBTVBMRVIxRCkgeyAvLyBzYW1wbGVyc1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZXg6IFRleHR1cmUyRCB8IG51bGwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhdGNoYWJsZVRleHR1cmVOYW1lcy5maW5kKChuKSA9PiBuID09PSBwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXggPSB0aGlzLl90ZXh0dXJlc1twcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXgpIHsgdGV4ID0gdGhpcy5jcmVhdGVUZXh0dXJlKHByb3ApOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29va1RleHR1cmVzKHRleCwgcHJvcCwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bml0cy5zb21lKCh1KSA9PiB0ZXggPSB1Lm1hdGVyaWFsICYmIHUubWF0ZXJpYWwuZ2V0UHJvcGVydHkocHJvcCwgaSkgYXMgVGV4dHVyZTJEIHwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXgpIHsgbWF0LnNldFByb3BlcnR5KHByb3AsIHRleCwgaSk7IH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIHZlY3RvcnNcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZTogYW55W10gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHRoaXMudW5pdHMubGVuZ3RoOyB1KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5pdCA9IHRoaXMudW5pdHNbdV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdW5pdC5tYXRlcmlhbCkgeyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKHVuaXQubWF0ZXJpYWwuZ2V0UHJvcGVydHkocHJvcC5zbGljZSgwLCAtMyksIGkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0LnNldFByb3BlcnR5KHByb3AsIHZhbHVlLCBpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY29va1NrZWxldG9ucyAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9za2lubmluZ1Jvb3QpIHsgY29uc29sZS53YXJuKCdubyBza2lubmluZyByb290IHNwZWNpZmllZCEnKTsgcmV0dXJuOyB9XHJcbiAgICAgICAgLy8gbWVyZ2Ugam9pbnRzIGFjY29yZGluZ2x5XHJcbiAgICAgICAgY29uc3Qgam9pbnRzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGJpbmRwb3NlczogTWF0NFtdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCB0aGlzLnVuaXRzLmxlbmd0aDsgdSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVuaXQgPSB0aGlzLnVuaXRzW3VdO1xyXG4gICAgICAgICAgICBpZiAoIXVuaXQgfHwgIXVuaXQuc2tlbGV0b24pIHsgY29udGludWU7IH1cclxuICAgICAgICAgICAgY29uc3QgcGFydGlhbCA9IHVuaXQuc2tlbGV0b247XHJcbiAgICAgICAgICAgIE1hdDQuaW52ZXJ0KG00X2xvY2FsLCB1bml0Ll9sb2NhbFRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydGlhbC5qb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBwYXJ0aWFsLmpvaW50c1tpXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IGpvaW50cy5maW5kSW5kZXgoKHApID0+IHAgPT09IHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEVESVRPUikgeyAvLyBjb25zaXN0ZW5jeSBjaGVja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXQ0Lm11bHRpcGx5KG00XzEsIHBhcnRpYWwuYmluZHBvc2VzW2ldLCBtNF9sb2NhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbTRfMS5lcXVhbHMoYmluZHBvc2VzW2lkeF0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7dGhpcy5ub2RlLm5hbWV9OiBJbmNvbnNpc3RlbnQgYmluZHBvc2UgYXQgJHtqb2ludHNbaWR4XX0gaW4gdW5pdCAke3V9LCBhcnRpZmFjdHMgbWF5IHByZXNlbnRgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGpvaW50cy5wdXNoKHBhdGgpO1xyXG4gICAgICAgICAgICAgICAgLy8gY2FuY2VsIG91dCBsb2NhbCB0cmFuc2Zvcm1cclxuICAgICAgICAgICAgICAgIGJpbmRwb3Nlcy5wdXNoKE1hdDQubXVsdGlwbHkobmV3IE1hdDQoKSwgcGFydGlhbC5iaW5kcG9zZXNbaV0gfHwgTWF0NC5JREVOVElUWSwgbTRfbG9jYWwpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzb3J0IHRoZSBhcnJheSB0byBiZSBtb3JlIGNhY2hlLWZyaWVuZGx5XHJcbiAgICAgICAgY29uc3QgaWR4TWFwID0gQXJyYXkuZnJvbShBcnJheShqb2ludHMubGVuZ3RoKS5rZXlzKCkpLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgaWYgKGpvaW50c1thXSA+IGpvaW50c1tiXSkgeyByZXR1cm4gMTsgfVxyXG4gICAgICAgICAgICBpZiAoam9pbnRzW2FdIDwgam9pbnRzW2JdKSB7IHJldHVybiAtMTsgfVxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCBza2VsZXRvbiA9IG5ldyBTa2VsZXRvbigpO1xyXG4gICAgICAgIHNrZWxldG9uLmpvaW50cyA9IGpvaW50cy5tYXAoKF8sIGlkeCwgYXJyKSA9PiBhcnJbaWR4TWFwW2lkeF1dKTtcclxuICAgICAgICBza2VsZXRvbi5iaW5kcG9zZXMgPSBiaW5kcG9zZXMubWFwKChfLCBpZHgsIGFycikgPT4gYXJyW2lkeE1hcFtpZHhdXSk7XHJcbiAgICAgICAgLy8gYXBwbHlcclxuICAgICAgICBpZiAodGhpcy5fc2tlbGV0b24pIHsgdGhpcy5fc2tlbGV0b24uZGVzdHJveSgpOyB9XHJcbiAgICAgICAgdGhpcy5za2VsZXRvbiA9IHNrZWxldG9uO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjb29rTWVzaGVzICgpIHtcclxuICAgICAgICBsZXQgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgdGhpcy51bml0cy5sZW5ndGg7IHUrKykge1xyXG4gICAgICAgICAgICBjb25zdCB1bml0ID0gdGhpcy51bml0c1t1XTtcclxuICAgICAgICAgICAgaWYgKHVuaXQubWVzaCkge1xyXG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkIHx8ICF0aGlzLl9za2lubmluZ1Jvb3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX21lc2gpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWVzaC5kZXN0cm95UmVuZGVyaW5nTWVzaCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21lc2ggPSBuZXcgTWVzaCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHBvc09mZnNldCA9IDA7XHJcbiAgICAgICAgbGV0IHBvc0Zvcm1hdCA9IEdGWEZvcm1hdC5VTktOT1dOO1xyXG4gICAgICAgIGxldCBub3JtYWxPZmZzZXQgPSAwO1xyXG4gICAgICAgIGxldCBub3JtYWxGb3JtYXQgPSBHRlhGb3JtYXQuVU5LTk9XTjtcclxuICAgICAgICBsZXQgdGFuZ2VudE9mZnNldCA9IDA7XHJcbiAgICAgICAgbGV0IHRhbmdlbnRGb3JtYXQgPSBHRlhGb3JtYXQuVU5LTk9XTjtcclxuICAgICAgICBsZXQgdXZPZmZzZXQgPSAwO1xyXG4gICAgICAgIGxldCB1dkZvcm1hdCA9IEdGWEZvcm1hdC5VTktOT1dOO1xyXG4gICAgICAgIGxldCBqb2ludE9mZnNldCA9IDA7XHJcbiAgICAgICAgbGV0IGpvaW50Rm9ybWF0ID0gR0ZYRm9ybWF0LlVOS05PV047XHJcblxyXG4gICAgICAgIC8vIHByZXBhcmUgam9pbnQgaW5kZXggbWFwXHJcbiAgICAgICAgY29uc3Qgam9pbnRJbmRleE1hcDogbnVtYmVyW11bXSA9IG5ldyBBcnJheSh0aGlzLnVuaXRzLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgdW5pdExlbiA9IHRoaXMudW5pdHMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5pdExlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVuaXQgPSB0aGlzLnVuaXRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIXVuaXQgfHwgIXVuaXQuc2tlbGV0b24pIHsgY29udGludWU7IH1cclxuICAgICAgICAgICAgam9pbnRJbmRleE1hcFtpXSA9IHVuaXQuc2tlbGV0b24uam9pbnRzLm1hcCgoaikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NrZWxldG9uIS5qb2ludHMuZmluZEluZGV4KChyZWYpID0+IGogPT09IHJlZik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bml0TGVuOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdW5pdCA9IHRoaXMudW5pdHNbaV07XHJcbiAgICAgICAgICAgIGlmICghdW5pdCB8fCAhdW5pdC5tZXNoIHx8ICF1bml0Lm1lc2guZGF0YSkgeyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICBjb25zdCBuZXdNZXNoID0gdGhpcy5fY3JlYXRlVW5pdE1lc2goaSwgdW5pdC5tZXNoKTtcclxuICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcobmV3TWVzaC5kYXRhIS5idWZmZXIpO1xyXG4gICAgICAgICAgICBNYXQ0LmludmVyc2VUcmFuc3Bvc2UobTRfbG9jYWwsIHVuaXQuX2xvY2FsVHJhbnNmb3JtKTtcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdW5pdC5vZmZzZXQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSB1bml0LnNpemU7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgbmV3TWVzaC5zdHJ1Y3QudmVydGV4QnVuZGxlcy5sZW5ndGg7IGIrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVuZGxlID0gbmV3TWVzaC5zdHJ1Y3QudmVydGV4QnVuZGxlc1tiXTtcclxuICAgICAgICAgICAgICAgIC8vIGFwcGx5IGxvY2FsIHRyYW5zZm9ybSB0byBtZXNoXHJcbiAgICAgICAgICAgICAgICBwb3NPZmZzZXQgPSBidW5kbGUudmlldy5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBwb3NGb3JtYXQgPSBHRlhGb3JtYXQuVU5LTk9XTjtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGEgPSAwOyBhIDwgYnVuZGxlLmF0dHJpYnV0ZXMubGVuZ3RoOyBhKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyID0gYnVuZGxlLmF0dHJpYnV0ZXNbYV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHIubmFtZSA9PT0gR0ZYQXR0cmlidXRlTmFtZS5BVFRSX1BPU0lUSU9OKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc0Zvcm1hdCA9IGF0dHIuZm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zT2Zmc2V0ICs9IEdGWEZvcm1hdEluZm9zW2F0dHIuZm9ybWF0XS5zaXplO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBvc0Zvcm1hdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IHJlYWRCdWZmZXIoZGF0YVZpZXcsIHBvc0Zvcm1hdCwgcG9zT2Zmc2V0LCBidW5kbGUudmlldy5sZW5ndGgsIGJ1bmRsZS52aWV3LnN0cmlkZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwb3MubGVuZ3RoOyBqICs9IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjMy5mcm9tQXJyYXkodjNfMSwgcG9zLCBqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjMy50cmFuc2Zvcm1NYXQ0KHYzXzEsIHYzXzEsIHVuaXQuX2xvY2FsVHJhbnNmb3JtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjMy50b0FycmF5KHBvcywgdjNfMSwgaik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlQnVmZmVyKGRhdGFWaWV3LCBwb3MsIHBvc0Zvcm1hdCwgcG9zT2Zmc2V0LCBidW5kbGUudmlldy5zdHJpZGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbm9ybWFsT2Zmc2V0ID0gYnVuZGxlLnZpZXcub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsRm9ybWF0ID0gR0ZYRm9ybWF0LlVOS05PV047XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGJ1bmRsZS5hdHRyaWJ1dGVzLmxlbmd0aDsgYSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9IGJ1bmRsZS5hdHRyaWJ1dGVzW2FdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgPT09IEdGWEF0dHJpYnV0ZU5hbWUuQVRUUl9OT1JNQUwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsRm9ybWF0ID0gYXR0ci5mb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxPZmZzZXQgKz0gR0ZYRm9ybWF0SW5mb3NbYXR0ci5mb3JtYXRdLnNpemU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsRm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsID0gcmVhZEJ1ZmZlcihkYXRhVmlldywgbm9ybWFsRm9ybWF0LCBub3JtYWxPZmZzZXQsIGJ1bmRsZS52aWV3Lmxlbmd0aCwgYnVuZGxlLnZpZXcuc3RyaWRlKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vcm1hbC5sZW5ndGg7IGogKz0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWMzLmZyb21BcnJheSh2M18xLCBub3JtYWwsIGopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWMzLnRyYW5zZm9ybU1hdDROb3JtYWwodjNfMSwgdjNfMSwgbTRfbG9jYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWMzLnRvQXJyYXkobm9ybWFsLCB2M18xLCBqKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVCdWZmZXIoZGF0YVZpZXcsIG5vcm1hbCwgbm9ybWFsRm9ybWF0LCBub3JtYWxPZmZzZXQsIGJ1bmRsZS52aWV3LnN0cmlkZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0YW5nZW50T2Zmc2V0ID0gYnVuZGxlLnZpZXcub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgdGFuZ2VudEZvcm1hdCA9IEdGWEZvcm1hdC5VTktOT1dOO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCBidW5kbGUuYXR0cmlidXRlcy5sZW5ndGg7IGErKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBidW5kbGUuYXR0cmlidXRlc1thXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ci5uYW1lID09PSBHRlhBdHRyaWJ1dGVOYW1lLkFUVFJfVEFOR0VOVCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YW5nZW50Rm9ybWF0ID0gYXR0ci5mb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0YW5nZW50T2Zmc2V0ICs9IEdGWEZvcm1hdEluZm9zW2F0dHIuZm9ybWF0XS5zaXplO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRhbmdlbnRGb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YW5nZW50ID0gcmVhZEJ1ZmZlcihkYXRhVmlldywgdGFuZ2VudEZvcm1hdCwgdGFuZ2VudE9mZnNldCwgYnVuZGxlLnZpZXcubGVuZ3RoLCBidW5kbGUudmlldy5zdHJpZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFuZ2VudC5sZW5ndGg7IGogKz0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBWZWMzLmZyb21BcnJheSh2M18xLCB0YW5nZW50LCBqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjMy50cmFuc2Zvcm1NYXQ0Tm9ybWFsKHYzXzEsIHYzXzEsIG00X2xvY2FsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVmVjMy50b0FycmF5KHRhbmdlbnQsIHYzXzEsIGopO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB3cml0ZUJ1ZmZlcihkYXRhVmlldywgdGFuZ2VudCwgdGFuZ2VudEZvcm1hdCwgdGFuZ2VudE9mZnNldCwgYnVuZGxlLnZpZXcuc3RyaWRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG1lcmdlIFVWXHJcbiAgICAgICAgICAgICAgICB1dk9mZnNldCA9IGJ1bmRsZS52aWV3Lm9mZnNldDtcclxuICAgICAgICAgICAgICAgIHV2Rm9ybWF0ID0gR0ZYRm9ybWF0LlVOS05PV047XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGJ1bmRsZS5hdHRyaWJ1dGVzLmxlbmd0aDsgYSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9IGJ1bmRsZS5hdHRyaWJ1dGVzW2FdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgPT09IEdGWEF0dHJpYnV0ZU5hbWUuQVRUUl9CQVRDSF9VVikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1dkZvcm1hdCA9IGF0dHIuZm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdXZPZmZzZXQgKz0gR0ZYRm9ybWF0SW5mb3NbYXR0ci5mb3JtYXRdLnNpemU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodXZGb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXBCdWZmZXIoZGF0YVZpZXcsIChjdXIsIGlkeCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSByZXBlYXQoY3VyKTsgLy8gd2FycCB0byBbMCwgMV0gZmlyc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcCA9IGlkeCA9PT0gMCA/ICd4JyA6ICd5JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1ciAqIHNpemVbY29tcF0gKyBvZmZzZXRbY29tcF07XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgdXZGb3JtYXQsIHV2T2Zmc2V0LCBidW5kbGUudmlldy5sZW5ndGgsIGJ1bmRsZS52aWV3LnN0cmlkZSwgZGF0YVZpZXcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gbWVyZ2Ugam9pbnQgaW5kaWNlc1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaWR4TWFwID0gam9pbnRJbmRleE1hcFtpXTtcclxuICAgICAgICAgICAgICAgIGlmICghaWR4TWFwKSB7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICBqb2ludE9mZnNldCA9IGJ1bmRsZS52aWV3Lm9mZnNldDtcclxuICAgICAgICAgICAgICAgIGpvaW50Rm9ybWF0ID0gR0ZYRm9ybWF0LlVOS05PV047XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGJ1bmRsZS5hdHRyaWJ1dGVzLmxlbmd0aDsgYSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9IGJ1bmRsZS5hdHRyaWJ1dGVzW2FdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUgPT09IEdGWEF0dHJpYnV0ZU5hbWUuQVRUUl9KT0lOVFMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgam9pbnRGb3JtYXQgPSBhdHRyLmZvcm1hdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGpvaW50T2Zmc2V0ICs9IEdGWEZvcm1hdEluZm9zW2F0dHIuZm9ybWF0XS5zaXplO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGpvaW50Rm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFwQnVmZmVyKGRhdGFWaWV3LCAoY3VyKSA9PiBpZHhNYXBbY3VyXSwgam9pbnRGb3JtYXQsIGpvaW50T2Zmc2V0LCBidW5kbGUudmlldy5sZW5ndGgsIGJ1bmRsZS52aWV3LnN0cmlkZSwgZGF0YVZpZXcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX21lc2ghLm1lcmdlKG5ld01lc2gpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fb25NZXNoQ2hhbmdlZCh0aGlzLl9tZXNoKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVNb2RlbHMoKTtcclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY29va1RleHR1cmVzICh0YXJnZXQ6IFRleHR1cmUyRCwgcHJvcDogc3RyaW5nLCBwYXNzSWR4OiBudW1iZXIpIHtcclxuICAgICAgICBjb25zdCB0ZXhJbWFnZXM6IFRleEltYWdlU291cmNlW10gPSBbXTtcclxuICAgICAgICBjb25zdCB0ZXhJbWFnZVJlZ2lvbnM6IEdGWEJ1ZmZlclRleHR1cmVDb3B5W10gPSBbXTtcclxuICAgICAgICBjb25zdCB0ZXhCdWZmZXJzOiBBcnJheUJ1ZmZlclZpZXdbXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHRleEJ1ZmZlclJlZ2lvbnM6IEdGWEJ1ZmZlclRleHR1cmVDb3B5W10gPSBbXTtcclxuICAgICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHRoaXMudW5pdHMubGVuZ3RoOyB1KyspIHtcclxuICAgICAgICAgICAgY29uc3QgdW5pdCA9IHRoaXMudW5pdHNbdV07XHJcbiAgICAgICAgICAgIGlmICghdW5pdC5tYXRlcmlhbCkgeyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICBjb25zdCBwYXJ0aWFsID0gdW5pdC5tYXRlcmlhbC5nZXRQcm9wZXJ0eShwcm9wLCBwYXNzSWR4KSBhcyBUZXh0dXJlMkQgfCBudWxsO1xyXG4gICAgICAgICAgICBpZiAocGFydGlhbCAmJiBwYXJ0aWFsLmltYWdlICYmIHBhcnRpYWwuaW1hZ2UuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVnaW9uID0gbmV3IEdGWEJ1ZmZlclRleHR1cmVDb3B5KCk7XHJcbiAgICAgICAgICAgICAgICByZWdpb24udGV4T2Zmc2V0LnggPSB1bml0Lm9mZnNldC54ICogdGhpcy5hdGxhc1NpemU7XHJcbiAgICAgICAgICAgICAgICByZWdpb24udGV4T2Zmc2V0LnkgPSB1bml0Lm9mZnNldC55ICogdGhpcy5hdGxhc1NpemU7XHJcbiAgICAgICAgICAgICAgICByZWdpb24udGV4RXh0ZW50LndpZHRoID0gdW5pdC5zaXplLnggKiB0aGlzLmF0bGFzU2l6ZTtcclxuICAgICAgICAgICAgICAgIHJlZ2lvbi50ZXhFeHRlbnQuaGVpZ2h0ID0gdW5pdC5zaXplLnkgKiB0aGlzLmF0bGFzU2l6ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBwYXJ0aWFsLmltYWdlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50IHx8IGRhdGEgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4SW1hZ2VzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4SW1hZ2VSZWdpb25zLnB1c2gocmVnaW9uKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4QnVmZmVycy5wdXNoKGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleEJ1ZmZlclJlZ2lvbnMucHVzaChyZWdpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGdmeFRleCA9IHRhcmdldC5nZXRHRlhUZXh0dXJlKCkhO1xyXG4gICAgICAgIGNvbnN0IGRldmljZTogR0ZYRGV2aWNlID0gY2MuZGlyZWN0b3Iucm9vdCEuZGV2aWNlO1xyXG4gICAgICAgIGlmICh0ZXhCdWZmZXJzLmxlbmd0aCA+IDApIHsgZGV2aWNlLmNvcHlCdWZmZXJzVG9UZXh0dXJlKHRleEJ1ZmZlcnMsIGdmeFRleCwgdGV4QnVmZmVyUmVnaW9ucyk7IH1cclxuICAgICAgICBpZiAodGV4SW1hZ2VzLmxlbmd0aCA+IDApIHsgZGV2aWNlLmNvcHlUZXhJbWFnZXNUb1RleHR1cmUodGV4SW1hZ2VzLCBnZnhUZXgsIHRleEltYWdlUmVnaW9ucyk7IH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgY3JlYXRlVGV4dHVyZSAocHJvcDogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgdGV4ID0gbmV3IFRleHR1cmUyRCgpO1xyXG4gICAgICAgIHRleC5zZXRGaWx0ZXJzKEZpbHRlci5MSU5FQVIsIEZpbHRlci5MSU5FQVIpO1xyXG4gICAgICAgIHRleC5zZXRNaXBGaWx0ZXIoRmlsdGVyLkxJTkVBUik7XHJcbiAgICAgICAgdGV4LnJlc2V0KHtcclxuICAgICAgICAgICAgd2lkdGg6IHRoaXMuYXRsYXNTaXplLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuYXRsYXNTaXplLFxyXG4gICAgICAgICAgICBmb3JtYXQ6IFBpeGVsRm9ybWF0LlJHQkE4ODg4LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRleC5sb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmVzW3Byb3BdID0gdGV4O1xyXG4gICAgICAgIHJldHVybiB0ZXg7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHJlc2l6ZUF0bGFzZXMgKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiB0aGlzLl90ZXh0dXJlcykge1xyXG4gICAgICAgICAgICBjb25zdCB0ZXggPSB0aGlzLl90ZXh0dXJlc1twcm9wXTtcclxuICAgICAgICAgICAgdGV4LnJlc2V0KHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLmF0bGFzU2l6ZSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5hdGxhc1NpemUsXHJcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFBpeGVsRm9ybWF0LlJHQkE4ODg4LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfY3JlYXRlVW5pdE1lc2ggKHVuaXRJZHg6IG51bWJlciwgbWVzaDogTWVzaCkge1xyXG4gICAgICAgIC8vIGFkZCBiYXRjaCBJRCB0byB0aGlzIHRlbXAgbWVzaFxyXG4gICAgICAgIC8vIGZpcnN0LCB1cGRhdGUgYm9va2tlZXBpbmdcclxuICAgICAgICBjb25zdCBuZXdNZXNoU3RydWN0OiBNZXNoLklTdHJ1Y3QgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1lc2guc3RydWN0KSk7XHJcbiAgICAgICAgY29uc3QgbW9kaWZpZWRCdW5kbGVzOiBSZWNvcmQ8bnVtYmVyLCBbR0ZYRm9ybWF0LCBudW1iZXJdPiA9IHt9O1xyXG4gICAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbWVzaC5zdHJ1Y3QucHJpbWl0aXZlcy5sZW5ndGg7IHArKykge1xyXG4gICAgICAgICAgICBjb25zdCBwcmltaXRpdmUgPSBtZXNoLnN0cnVjdC5wcmltaXRpdmVzW3BdO1xyXG4gICAgICAgICAgICBsZXQgdXZPZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICBsZXQgdXZGb3JtYXQgPSBHRlhGb3JtYXQuVU5LTk9XTjtcclxuICAgICAgICAgICAgbGV0IGJ1bmRsZUlkeCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoOyBidW5kbGVJZHggPCBwcmltaXRpdmUudmVydGV4QnVuZGVsSW5kaWNlcy5sZW5ndGg7IGJ1bmRsZUlkeCsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBidW5kbGUgPSBtZXNoLnN0cnVjdC52ZXJ0ZXhCdW5kbGVzW3ByaW1pdGl2ZS52ZXJ0ZXhCdW5kZWxJbmRpY2VzW2J1bmRsZUlkeF1dO1xyXG4gICAgICAgICAgICAgICAgdXZPZmZzZXQgPSBidW5kbGUudmlldy5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB1dkZvcm1hdCA9IEdGWEZvcm1hdC5VTktOT1dOO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCBidW5kbGUuYXR0cmlidXRlcy5sZW5ndGg7IGErKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBidW5kbGUuYXR0cmlidXRlc1thXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ci5uYW1lID09PSBHRlhBdHRyaWJ1dGVOYW1lLkFUVFJfVEVYX0NPT1JEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2Rm9ybWF0ID0gYXR0ci5mb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB1dk9mZnNldCArPSBHRlhGb3JtYXRJbmZvc1thdHRyLmZvcm1hdF0uc2l6ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh1dkZvcm1hdCkgeyBicmVhazsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtb2RpZmllZEJ1bmRsZXNbYnVuZGxlSWR4XSAhPT0gdW5kZWZpbmVkKSB7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgIG1vZGlmaWVkQnVuZGxlc1tidW5kbGVJZHhdID0gWyB1dkZvcm1hdCwgdXZPZmZzZXQgXTtcclxuICAgICAgICAgICAgY29uc3QgbmV3QnVuZGxlID0gbmV3TWVzaFN0cnVjdC52ZXJ0ZXhCdW5kbGVzW2J1bmRsZUlkeF07IC8vIHB1dCB0aGUgbmV3IFVWcyBpbiB0aGUgc2FtZSBidW5kbGUgd2l0aCBvcmlnaW5hbCBVVnNcclxuICAgICAgICAgICAgbmV3QnVuZGxlLmF0dHJpYnV0ZXMucHVzaChiYXRjaF9pZCk7XHJcbiAgICAgICAgICAgIG5ld0J1bmRsZS5hdHRyaWJ1dGVzLnB1c2goYmF0Y2hfdXYpO1xyXG4gICAgICAgICAgICBuZXdCdW5kbGUudmlldy5vZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICBuZXdCdW5kbGUudmlldy5sZW5ndGggKz0gbmV3QnVuZGxlLnZpZXcuY291bnQgKiBiYXRjaF9leHRyYXNfc2l6ZTtcclxuICAgICAgICAgICAgbmV3QnVuZGxlLnZpZXcuc3RyaWRlICs9IGJhdGNoX2V4dHJhc19zaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdG90YWxMZW5ndGggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgbmV3TWVzaFN0cnVjdC52ZXJ0ZXhCdW5kbGVzLmxlbmd0aDsgYisrKSB7XHJcbiAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IG5ld01lc2hTdHJ1Y3QudmVydGV4QnVuZGxlc1tiXS52aWV3Lmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCBuZXdNZXNoU3RydWN0LnByaW1pdGl2ZXMubGVuZ3RoOyBwKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcG0gPSBuZXdNZXNoU3RydWN0LnByaW1pdGl2ZXNbcF07XHJcbiAgICAgICAgICAgIGlmIChwbS5pbmRleFZpZXcpIHtcclxuICAgICAgICAgICAgICAgIHBtLmluZGV4Vmlldy5vZmZzZXQgPSB0b3RhbExlbmd0aDtcclxuICAgICAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IHBtLmluZGV4Vmlldy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbm93LCB3ZSByaWRlIVxyXG4gICAgICAgIGNvbnN0IG5ld01lc2hEYXRhID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IG9sZE1lc2hEYXRhID0gbWVzaC5kYXRhITtcclxuICAgICAgICBjb25zdCBuZXdEYXRhVmlldyA9IG5ldyBEYXRhVmlldyhuZXdNZXNoRGF0YS5idWZmZXIpO1xyXG4gICAgICAgIGNvbnN0IG9sZERhdGFWaWV3ID0gbmV3IERhdGFWaWV3KG9sZE1lc2hEYXRhLmJ1ZmZlcik7XHJcbiAgICAgICAgY29uc3QgaXNMaXR0bGVFbmRpYW4gPSBzeXMuaXNMaXR0bGVFbmRpYW47XHJcbiAgICAgICAgZm9yIChjb25zdCBiIGluIG1vZGlmaWVkQnVuZGxlcykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdCdW5kbGUgPSBuZXdNZXNoU3RydWN0LnZlcnRleEJ1bmRsZXNbYl07XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZEJ1bmRsZSA9IG1lc2guc3RydWN0LnZlcnRleEJ1bmRsZXNbYl07XHJcbiAgICAgICAgICAgIGNvbnN0IFsgdXZGb3JtYXQsIHV2T2Zmc2V0IF0gPSBtb2RpZmllZEJ1bmRsZXNbYl07XHJcbiAgICAgICAgICAgIGNvbnN0IHV2cyA9IHJlYWRCdWZmZXIob2xkRGF0YVZpZXcsIHV2Rm9ybWF0LCB1dk9mZnNldCwgb2xkQnVuZGxlLnZpZXcubGVuZ3RoLCBvbGRCdW5kbGUudmlldy5zdHJpZGUpO1xyXG4gICAgICAgICAgICBjb25zdCBvbGRWaWV3ID0gb2xkQnVuZGxlLnZpZXc7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZpZXcgPSBuZXdCdW5kbGUudmlldztcclxuICAgICAgICAgICAgY29uc3Qgb2xkU3RyaWRlID0gb2xkVmlldy5zdHJpZGU7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0cmlkZSA9IG5ld1ZpZXcuc3RyaWRlO1xyXG4gICAgICAgICAgICBsZXQgb2xkT2Zmc2V0ID0gb2xkVmlldy5vZmZzZXQ7XHJcbiAgICAgICAgICAgIGxldCBuZXdPZmZzZXQgPSBuZXdWaWV3Lm9mZnNldDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuZXdWaWV3LmNvdW50OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNyY1ZlcnRleCA9IG9sZE1lc2hEYXRhLnN1YmFycmF5KG9sZE9mZnNldCwgb2xkT2Zmc2V0ICsgb2xkU3RyaWRlKTtcclxuICAgICAgICAgICAgICAgIG5ld01lc2hEYXRhLnNldChzcmNWZXJ0ZXgsIG5ld09mZnNldCk7XHJcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgYmF0Y2ggSURcclxuICAgICAgICAgICAgICAgIG5ld0RhdGFWaWV3LnNldEZsb2F0MzIobmV3T2Zmc2V0ICsgb2xkU3RyaWRlLCB1bml0SWR4LCApO1xyXG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGJhdGNoIFVWXHJcbiAgICAgICAgICAgICAgICBuZXdEYXRhVmlldy5zZXRGbG9hdDMyKG5ld09mZnNldCArIG9sZFN0cmlkZSArIDQsIHV2c1tqICogMl0sIGlzTGl0dGxlRW5kaWFuKTtcclxuICAgICAgICAgICAgICAgIG5ld0RhdGFWaWV3LnNldEZsb2F0MzIobmV3T2Zmc2V0ICsgb2xkU3RyaWRlICsgOCwgdXZzW2ogKiAyICsgMV0sIGlzTGl0dGxlRW5kaWFuKTtcclxuICAgICAgICAgICAgICAgIG5ld09mZnNldCArPSBuZXdTdHJpZGU7XHJcbiAgICAgICAgICAgICAgICBvbGRPZmZzZXQgKz0gb2xkU3RyaWRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbmV3TWVzaFN0cnVjdC5wcmltaXRpdmVzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9sZFByaW1pdGl2ZSA9IG1lc2guc3RydWN0LnByaW1pdGl2ZXNba107XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1ByaW1pdGl2ZSA9IG5ld01lc2hTdHJ1Y3QucHJpbWl0aXZlc1trXTtcclxuICAgICAgICAgICAgaWYgKG9sZFByaW1pdGl2ZS5pbmRleFZpZXcgJiYgbmV3UHJpbWl0aXZlLmluZGV4Vmlldykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkU3RyaWRlID0gb2xkUHJpbWl0aXZlLmluZGV4Vmlldy5zdHJpZGU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTdHJpZGUgPSBuZXdQcmltaXRpdmUuaW5kZXhWaWV3LnN0cmlkZTtcclxuICAgICAgICAgICAgICAgIGxldCBvbGRPZmZzZXQgPSBvbGRQcmltaXRpdmUuaW5kZXhWaWV3Lm9mZnNldDtcclxuICAgICAgICAgICAgICAgIGxldCBuZXdPZmZzZXQgPSBuZXdQcmltaXRpdmUuaW5kZXhWaWV3Lm9mZnNldDtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbmV3UHJpbWl0aXZlLmluZGV4Vmlldy5jb3VudDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3JjSW5kaWNlcyA9IG9sZE1lc2hEYXRhLnN1YmFycmF5KG9sZE9mZnNldCwgb2xkT2Zmc2V0ICsgb2xkU3RyaWRlKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdNZXNoRGF0YS5zZXQoc3JjSW5kaWNlcywgbmV3T2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdPZmZzZXQgKz0gbmV3U3RyaWRlO1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZE9mZnNldCArPSBvbGRTdHJpZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbmV3TWVzaCA9IG5ldyBNZXNoKCk7XHJcbiAgICAgICAgbmV3TWVzaC5yZXNldCh7XHJcbiAgICAgICAgICAgIHN0cnVjdDogbmV3TWVzaFN0cnVjdCxcclxuICAgICAgICAgICAgZGF0YTogbmV3TWVzaERhdGEsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ld01lc2g7XHJcbiAgICB9XHJcbn1cclxuIl19