(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "../../core/3d/builtin/index.js", "../../core/3d/framework/renderable-component.js", "../../core/components/ui-base/ui-render-component.js", "../../core/data/class-decorator.js", "../../core/director.js", "../../core/math/index.js", "../../core/renderer/index.js", "../assembler/graphics/types.js"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("../../core/3d/builtin/index.js"), require("../../core/3d/framework/renderable-component.js"), require("../../core/components/ui-base/ui-render-component.js"), require("../../core/data/class-decorator.js"), require("../../core/director.js"), require("../../core/math/index.js"), require("../../core/renderer/index.js"), require("../assembler/graphics/types.js"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.index, global.renderableComponent, global.uiRenderComponent, global.classDecorator, global.director, global.index, global.index, global.types);
    global.graphicsComponent = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _index, _renderableComponent, _uiRenderComponent, _classDecorator, _director, _index2, _index3, _types) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.GraphicsComponent = void 0;

  var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _class3, _temp;

  function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

  var _matInsInfo = {
    parent: null,
    owner: null,
    subModelIdx: 0
  };
  /**
   * @en
   * Graphics component.
   *
   * @zh
   * 自定义图形类
   */

  var GraphicsComponent = (_dec = (0, _classDecorator.ccclass)('cc.GraphicsComponent'), _dec2 = (0, _classDecorator.help)('i18n:cc.GraphicsComponent'), _dec3 = (0, _classDecorator.executionOrder)(110), _dec4 = (0, _classDecorator.menu)('UI/Render/Graphics'), _dec5 = (0, _classDecorator.property)({
    type: _types.LineJoin,
    tooltip: '两条线相交时，所创建的拐角类型'
  }), _dec6 = (0, _classDecorator.property)({
    type: _types.LineCap,
    tooltip: '线条的结束端点样式'
  }), _dec7 = (0, _classDecorator.property)({
    tooltip: '笔触的颜色'
  }), _dec8 = (0, _classDecorator.property)({
    tooltip: '填充绘画的颜色'
  }), _dec9 = (0, _classDecorator.property)({
    tooltip: '最大斜接长度'
  }), _dec10 = (0, _classDecorator.property)({
    override: true,
    visible: false
  }), _dec(_class = _dec2(_class = _dec3(_class = _dec4(_class = (_class2 = (_temp = _class3 = /*#__PURE__*/function (_UIRenderComponent) {
    _inherits(GraphicsComponent, _UIRenderComponent);

    _createClass(GraphicsComponent, [{
      key: "lineWidth",

      /**
       * @en
       * Current line width.
       *
       * @zh
       * 当前线条宽度。
       */
      get: function get() {
        return this._lineWidth;
      },
      set: function set(value) {
        this._lineWidth = value;

        if (!this.impl) {
          return;
        }

        this.impl.lineWidth = value;
      }
      /**
       * @en
       * Determines how two connecting segments (of lines, arcs or curves) with non-zero lengths in a shape are joined together.
       *
       * @zh
       * 用来设置2个长度不为0的相连部分（线段，圆弧，曲线）如何连接在一起的属性。
       */

    }, {
      key: "lineJoin",
      get: function get() {
        return this._lineJoin;
      },
      set: function set(value) {
        this._lineJoin = value;

        if (!this.impl) {
          return;
        }

        this.impl.lineJoin = value;
      }
      /**
       * @en
       * Determines how the end points of every line are drawn.
       *
       * @zh
       * 指定如何绘制每一条线段末端。
       */

    }, {
      key: "lineCap",
      get: function get() {
        return this._lineCap;
      },
      set: function set(value) {
        this._lineCap = value;

        if (!this.impl) {
          return;
        }

        this.impl.lineCap = value;
      }
      /**
       * @en
       * Stroke color.
       *
       * @zh
       * 线段颜色。
       */

    }, {
      key: "strokeColor",
      get: function get() {
        return this._strokeColor;
      },
      set: function set(value) {
        if (!this.impl) {
          return;
        }

        this._strokeColor.set(value);

        this.impl.strokeColor = this._strokeColor;
      }
      /**
       * @en
       * Fill color.
       *
       * @zh
       * 填充颜色。
       */

    }, {
      key: "fillColor",
      get: function get() {
        return this._fillColor;
      },
      set: function set(value) {
        if (!this.impl) {
          return;
        }

        this._fillColor.set(value);

        this.impl.fillColor = this._fillColor;
      }
      /**
       * @en
       * Sets the miter limit ratio.
       *
       * @zh
       * 设置斜接面限制比例。
       */

    }, {
      key: "miterLimit",
      get: function get() {
        return this._miterLimit;
      },
      set: function set(value) {
        this._miterLimit = value; // this.impl.miterLimit = value;
      }
    }, {
      key: "color",
      get: function get() {
        return this._color;
      },
      set: function set(value) {
        if (this._color === value) {
          return;
        }

        this._color.set(value);

        this._updateColor();

        this.markForUpdateRenderData();
      }
    }]);

    function GraphicsComponent() {
      var _this;

      _classCallCheck(this, GraphicsComponent);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(GraphicsComponent).call(this));
      _this.impl = null;
      _this.model = null;

      _initializerDefineProperty(_this, "_lineWidth", _descriptor, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_strokeColor", _descriptor2, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_lineJoin", _descriptor3, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_lineCap", _descriptor4, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_fillColor", _descriptor5, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_miterLimit", _descriptor6, _assertThisInitialized(_this));

      _this._instanceMaterialType = _uiRenderComponent.InstanceMaterialType.ADDCOLOR;
      return _this;
    }

    _createClass(GraphicsComponent, [{
      key: "onRestore",
      value: function onRestore() {
        if (!this.impl) {
          this._flushAssembler();
        }
      }
    }, {
      key: "__preload",
      value: function __preload() {
        if (_get(_getPrototypeOf(GraphicsComponent.prototype), "__preload", this)) {
          _get(_getPrototypeOf(GraphicsComponent.prototype), "__preload", this).call(this);
        } // this._flushAssembler();


        this.impl = this._assembler && this._assembler.createImpl(this);
      }
    }, {
      key: "onLoad",
      value: function onLoad() {
        this._sceneGetter = _director.director.root.ui.getRenderSceneGetter();

        if (!this.model) {
          this.model = _director.director.root.createModel(_index3.Model);
        }
      }
    }, {
      key: "onEnable",
      value: function onEnable() {
        _get(_getPrototypeOf(GraphicsComponent.prototype), "onEnable", this).call(this);

        this._activateMaterial();
      }
    }, {
      key: "onDisable",
      value: function onDisable() {
        this._detachFromScene();
      }
    }, {
      key: "onDestroy",
      value: function onDestroy() {
        _get(_getPrototypeOf(GraphicsComponent.prototype), "onDestroy", this).call(this);

        this._sceneGetter = null;

        if (this.model) {
          this.model.destroy();

          _director.director.root.destroyModel(this.model);

          this.model = null;
        }

        if (!this.impl) {
          return;
        }

        this.impl.clear();
        this.impl = null;
      }
    }, {
      key: "_activateMaterial",
      value: function _activateMaterial() {
        if (!this._material) {
          return;
        }

        this._updateMaterial(this._material);
      }
      /**
       * @en
       * Move path start point to (x,y).
       *
       * @zh
       * 移动路径起点到坐标(x, y)。
       *
       * @param x - 移动坐标 x 轴。
       * @param y - 移动坐标 y 轴。
       */

    }, {
      key: "moveTo",
      value: function moveTo(x, y) {
        if (!this.impl) {
          return;
        }

        this.impl.moveTo(x, y);
      }
      /**
       * @en
       * Adds a straight line to the path.
       *
       * @zh
       * 绘制直线路径。
       *
       * @param x - 绘制路径坐标 x 轴。
       * @param y - 绘制路径坐标 y 轴。
       */

    }, {
      key: "lineTo",
      value: function lineTo(x, y) {
        if (!this.impl) {
          return;
        }

        this.impl.lineTo(x, y);
      }
      /**
       * @en
       * Adds a cubic Bézier curve to the path.
       *
       * @zh
       * 绘制三次贝赛尔曲线路径。
       *
       * @param c1x - 第一个控制点的坐标 x 轴。
       * @param c1y - 第一个控制点的坐标 y 轴。
       * @param c2x - 第二个控制点的坐标 x 轴。
       * @param c2y - 第二个控制点的坐标 y 轴。
       * @param x - 最后一个控制点的坐标 x 轴。
       * @param y - 最后一个控制点的坐标 y 轴。
       */

    }, {
      key: "bezierCurveTo",
      value: function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
        if (!this.impl) {
          return;
        }

        this.impl.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
      }
      /**
       * @en
       * Adds a quadratic Bézier curve to the path.
       *
       * @zh
       * 绘制二次贝赛尔曲线路径。
       *
       * @param cx - 起始控制点的坐标 x 轴。
       * @param cy - 起始控制点的坐标 y 轴。
       * @param x - 终点控制点的坐标 x 轴。
       * @param y - 终点控制点的坐标 x 轴。
       */

    }, {
      key: "quadraticCurveTo",
      value: function quadraticCurveTo(cx, cy, x, y) {
        if (!this.impl) {
          return;
        }

        this.impl.quadraticCurveTo(cx, cy, x, y);
      }
      /**
       * @en
       * Adds an arc to the path which is centered at (cx, cy) position with radius r starting at startAngle
       * and ending at endAngle going in the given direction by counterclockwise (defaulting to false).
       *
       * @zh
       * 绘制圆弧路径。圆弧路径的圆心在 (cx, cy) 位置，半径为 r ，根据 counterclockwise （默认为false）指定的方向从 startAngle 开始绘制，到 endAngle 结束。
       *
       * @param cx - 中心控制点的坐标 x 轴。
       * @param cy - 中心控制点的坐标 y 轴。
       * @param r - 圆弧弧度。
       * @param startAngle - 开始弧度，从正 x 轴顺时针方向测量。
       * @param endAngle - 结束弧度，从正 x 轴顺时针方向测量。
       * @param counterclockwise 如果为真，在两个角度之间逆时针绘制。默认顺时针。
       */

    }, {
      key: "arc",
      value: function arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
        if (!this.impl) {
          return;
        }

        this.impl.arc(cx, cy, r, startAngle, endAngle, counterclockwise);
      }
      /**
       * @en
       * Adds an ellipse to the path.
       *
       * @zh
       * 绘制椭圆路径。
       *
       * @param cx - 中心点的坐标 x 轴。
       * @param cy - 中心点的坐标 y 轴。
       * @param rx - 椭圆 x 轴半径。
       * @param ry - 椭圆 y 轴半径。
       */

    }, {
      key: "ellipse",
      value: function ellipse(cx, cy, rx, ry) {
        if (!this.impl) {
          return;
        }

        this.impl.ellipse(cx, cy, rx, ry);
      }
      /**
       * @en
       * Adds a circle to the path.
       *
       * @zh
       * 绘制圆形路径。
       *
       * @param cx - 中心点的坐标 x 轴。
       * @param cy - 中心点的坐标 y 轴。
       * @param r - 圆半径。
       */

    }, {
      key: "circle",
      value: function circle(cx, cy, r) {
        if (!this.impl) {
          return;
        }

        this.impl.circle(cx, cy, r);
      }
      /**
       * @en
       * Adds a rectangle to the path.
       *
       * @zh
       * 绘制矩形路径。
       *
       * @param x - 矩形起始坐标 x 轴。
       * @param y - 矩形起始坐标 y 轴。
       * @param w - 矩形宽度。
       * @param h - 矩形高度。
       */

    }, {
      key: "rect",
      value: function rect(x, y, w, h) {
        if (!this.impl) {
          return;
        }

        this.impl.rect(x, y, w, h);
      }
      /**
       * @en
       * Adds a round corner rectangle to the path.
       *
       * @zh
       * 绘制圆角矩形路径。
       *
       * @param x - 矩形起始坐标 x 轴。
       * @param y - 矩形起始坐标 y 轴。
       * @param w - 矩形宽度。
       * @param h - 矩形高度。
       * @param r - 矩形圆角半径。
       */

    }, {
      key: "roundRect",
      value: function roundRect(x, y, w, h, r) {
        if (!this.impl) {
          return;
        }

        this.impl.roundRect(x, y, w, h, r);
      }
      /**
       * @en
       * Draws a filled rectangle.
       *
       * @zh
       * 绘制填充矩形。
       *
       * @param x - 矩形起始坐标 x 轴。
       * @param y - 矩形起始坐标 y 轴。
       * @param w - 矩形宽度。
       * @param h - 矩形高度。
       */

    }, {
      key: "fillRect",
      value: function fillRect(x, y, w, h) {
        this.rect(x, y, w, h);
        this.fill();
      }
      /**
       * @en
       * Erasing any previously drawn content.
       *
       * @zh
       * 擦除之前绘制的所有内容的方法。
       */

    }, {
      key: "clear",
      value: function clear() {
        var clean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        if (!this.impl) {
          return;
        }

        this.impl.clear(clean);

        this._detachFromScene();

        if (this.model) {
          this.model.destroy();
        }

        this.markForUpdateRenderData();
      }
      /**
       * @en
       * Causes the point of the pen to move back to the start of the current path.
       * It tries to add a straight line from the current point to the start.
       *
       * @zh
       * 将笔点返回到当前路径起始点的。它尝试从当前点到起始点绘制一条直线。
       */

    }, {
      key: "close",
      value: function close() {
        if (!this.impl) {
          return;
        }

        this.impl.close();
      }
      /**
       * @en
       * Strokes the current or given path with the current stroke style.
       *
       * @zh
       * 根据当前的画线样式，绘制当前或已经存在的路径。
       */

    }, {
      key: "stroke",
      value: function stroke() {
        this._assembler.stroke(this);

        this._attachToScene();
      }
      /**
       * @en
       * Fills the current or given path with the current fill style.
       *
       * @zh
       * 根据当前的画线样式，填充当前或已经存在的路径。
       */

    }, {
      key: "fill",
      value: function fill() {
        this._assembler.fill(this);

        this._attachToScene();
      }
      /**
       * @en
       * Manual instance material.
       *
       * @zh
       * 辅助材质实例化。可用于只取数据而无实体情况下渲染使用。特殊情况可参考：[[instanceMaterial]]
       */

    }, {
      key: "helpInstanceMaterial",
      value: function helpInstanceMaterial() {
        var mat = null;
        _matInsInfo.owner = new _renderableComponent.RenderableComponent();

        if (this._sharedMaterial) {
          _matInsInfo.parent = this._sharedMaterial;
          mat = new _index3.MaterialInstance(_matInsInfo);
        } else {
          _matInsInfo.parent = _index.builtinResMgr.get('ui-base-material');
          mat = new _index3.MaterialInstance(_matInsInfo);
          mat.recompileShaders({
            USE_LOCAL: true
          });
        }

        this._updateMaterial(mat);

        if (!this.impl) {
          this._flushAssembler();

          this.impl = this._assembler && this._assembler.createImpl(this);
        }
      }
    }, {
      key: "_render",
      value: function _render(render) {
        render.commitModel(this, this.model, this._material);
      }
    }, {
      key: "_instanceMaterial",
      value: function _instanceMaterial() {
        this.helpInstanceMaterial();
      }
    }, {
      key: "_flushAssembler",
      value: function _flushAssembler() {
        var assembler = GraphicsComponent.Assembler.getAssembler(this);

        if (this._assembler !== assembler) {
          this._assembler = assembler;
        }
      }
    }, {
      key: "_canRender",
      value: function _canRender() {
        if (!_get(_getPrototypeOf(GraphicsComponent.prototype), "_canRender", this).call(this)) {
          return false;
        }

        return !!this.model && this.model.inited;
      }
    }, {
      key: "_attachToScene",
      value: function _attachToScene() {
        var scene = _director.director.root.ui.renderScene;

        if (!this.model || this.model.scene === scene) {
          return;
        }

        if (this.model.scene !== null) {
          this._detachFromScene();
        }

        scene.addModel(this.model);
      }
    }, {
      key: "_detachFromScene",
      value: function _detachFromScene() {
        if (this.model && this.model.scene) {
          this.model.scene.removeModel(this.model);
          this.model.scene = null;
        }
      }
    }]);

    return GraphicsComponent;
  }(_uiRenderComponent.UIRenderComponent), _class3.LineJoin = _types.LineJoin, _class3.LineCap = _types.LineCap, _temp), (_applyDecoratedDescriptor(_class2.prototype, "lineWidth", [_classDecorator.property], Object.getOwnPropertyDescriptor(_class2.prototype, "lineWidth"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "lineJoin", [_dec5], Object.getOwnPropertyDescriptor(_class2.prototype, "lineJoin"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "lineCap", [_dec6], Object.getOwnPropertyDescriptor(_class2.prototype, "lineCap"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "strokeColor", [_dec7], Object.getOwnPropertyDescriptor(_class2.prototype, "strokeColor"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "fillColor", [_dec8], Object.getOwnPropertyDescriptor(_class2.prototype, "fillColor"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "miterLimit", [_dec9], Object.getOwnPropertyDescriptor(_class2.prototype, "miterLimit"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "color", [_dec10], Object.getOwnPropertyDescriptor(_class2.prototype, "color"), _class2.prototype), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "_lineWidth", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return 1;
    }
  }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_strokeColor", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return _index2.Color.BLACK.clone();
    }
  }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "_lineJoin", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return _types.LineJoin.MITER;
    }
  }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "_lineCap", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return _types.LineCap.BUTT;
    }
  }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "_fillColor", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return _index2.Color.WHITE.clone();
    }
  }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "_miterLimit", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return 10;
    }
  })), _class2)) || _class) || _class) || _class) || _class);
  _exports.GraphicsComponent = GraphicsComponent;
  cc.GraphicsComponent = GraphicsComponent;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkY6L2plbmtpbnMvd29ya3NwYWNlL0NyZWF0b3JfM0QvZWRpdG9yLTNkL3Jlc291cmNlcy8zZC9lbmdpbmUvY29jb3MvdWkvY29tcG9uZW50cy9ncmFwaGljcy1jb21wb25lbnQudHMiXSwibmFtZXMiOlsiX21hdEluc0luZm8iLCJwYXJlbnQiLCJvd25lciIsInN1Yk1vZGVsSWR4IiwiR3JhcGhpY3NDb21wb25lbnQiLCJ0eXBlIiwiTGluZUpvaW4iLCJ0b29sdGlwIiwiTGluZUNhcCIsIm92ZXJyaWRlIiwidmlzaWJsZSIsIl9saW5lV2lkdGgiLCJ2YWx1ZSIsImltcGwiLCJsaW5lV2lkdGgiLCJfbGluZUpvaW4iLCJsaW5lSm9pbiIsIl9saW5lQ2FwIiwibGluZUNhcCIsIl9zdHJva2VDb2xvciIsInNldCIsInN0cm9rZUNvbG9yIiwiX2ZpbGxDb2xvciIsImZpbGxDb2xvciIsIl9taXRlckxpbWl0IiwiX2NvbG9yIiwiX3VwZGF0ZUNvbG9yIiwibWFya0ZvclVwZGF0ZVJlbmRlckRhdGEiLCJtb2RlbCIsIl9pbnN0YW5jZU1hdGVyaWFsVHlwZSIsIkluc3RhbmNlTWF0ZXJpYWxUeXBlIiwiQUREQ09MT1IiLCJfZmx1c2hBc3NlbWJsZXIiLCJfYXNzZW1ibGVyIiwiY3JlYXRlSW1wbCIsIl9zY2VuZUdldHRlciIsImRpcmVjdG9yIiwicm9vdCIsInVpIiwiZ2V0UmVuZGVyU2NlbmVHZXR0ZXIiLCJjcmVhdGVNb2RlbCIsIk1vZGVsIiwiX2FjdGl2YXRlTWF0ZXJpYWwiLCJfZGV0YWNoRnJvbVNjZW5lIiwiZGVzdHJveSIsImRlc3Ryb3lNb2RlbCIsImNsZWFyIiwiX21hdGVyaWFsIiwiX3VwZGF0ZU1hdGVyaWFsIiwieCIsInkiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjMXgiLCJjMXkiLCJjMngiLCJjMnkiLCJiZXppZXJDdXJ2ZVRvIiwiY3giLCJjeSIsInF1YWRyYXRpY0N1cnZlVG8iLCJyIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwiY291bnRlcmNsb2Nrd2lzZSIsImFyYyIsInJ4IiwicnkiLCJlbGxpcHNlIiwiY2lyY2xlIiwidyIsImgiLCJyZWN0Iiwicm91bmRSZWN0IiwiZmlsbCIsImNsZWFuIiwiY2xvc2UiLCJzdHJva2UiLCJfYXR0YWNoVG9TY2VuZSIsIm1hdCIsIlJlbmRlcmFibGVDb21wb25lbnQiLCJfc2hhcmVkTWF0ZXJpYWwiLCJNYXRlcmlhbEluc3RhbmNlIiwiYnVpbHRpblJlc01nciIsImdldCIsInJlY29tcGlsZVNoYWRlcnMiLCJVU0VfTE9DQUwiLCJyZW5kZXIiLCJjb21taXRNb2RlbCIsImhlbHBJbnN0YW5jZU1hdGVyaWFsIiwiYXNzZW1ibGVyIiwiQXNzZW1ibGVyIiwiZ2V0QXNzZW1ibGVyIiwiaW5pdGVkIiwic2NlbmUiLCJyZW5kZXJTY2VuZSIsImFkZE1vZGVsIiwicmVtb3ZlTW9kZWwiLCJVSVJlbmRlckNvbXBvbmVudCIsInByb3BlcnR5IiwiQ29sb3IiLCJCTEFDSyIsImNsb25lIiwiTUlURVIiLCJCVVRUIiwiV0hJVEUiLCJjYyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQ0EsTUFBTUEsV0FBa0MsR0FBRztBQUN2Q0MsSUFBQUEsTUFBTSxFQUFFLElBRCtCO0FBRXZDQyxJQUFBQSxLQUFLLEVBQUUsSUFGZ0M7QUFHdkNDLElBQUFBLFdBQVcsRUFBRTtBQUgwQixHQUEzQztBQU1BOzs7Ozs7OztNQVdhQyxpQixXQUpaLDZCQUFRLHNCQUFSLEMsVUFDQSwwQkFBSywyQkFBTCxDLFVBQ0Esb0NBQWUsR0FBZixDLFVBQ0EsMEJBQUssb0JBQUwsQyxVQThCSSw4QkFBUztBQUNOQyxJQUFBQSxJQUFJLEVBQUVDLGVBREE7QUFFTkMsSUFBQUEsT0FBTyxFQUFFO0FBRkgsR0FBVCxDLFVBd0JBLDhCQUFTO0FBQ05GLElBQUFBLElBQUksRUFBRUcsY0FEQTtBQUVORCxJQUFBQSxPQUFPLEVBQUU7QUFGSCxHQUFULEMsVUF3QkEsOEJBQVM7QUFD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QWhqQmtDSSxvQyxXQTJKckI1RixRLEdBQVdBLGUsVUFDWEUsTyxHQUFVQSxjLHNFQW5KdkIyRix3QiwyaUNBc0pBQSx3Qjs7Ozs7YUFDc0IsQzs7bUZBQ3RCQSx3Qjs7Ozs7YUFDd0JDLGNBQU1DLEtBQU4sQ0FBWUMsS0FBWixFOztnRkFDeEJILHdCOzs7OzthQUNxQjdGLGdCQUFTaUcsSzs7K0VBQzlCSix3Qjs7Ozs7YUFDb0IzRixlQUFRZ0csSTs7aUZBQzVCTCx3Qjs7Ozs7YUFDc0JDLGNBQU1LLEtBQU4sQ0FBWUgsS0FBWixFOztrRkFDdEJILHdCOzs7OzthQUN1QixFOzs7O0FBeVk1Qk8sRUFBQUEsRUFBRSxDQUFDdEcsaUJBQUgsR0FBdUJBLGlCQUF2QiIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNiBDaHVrb25nIFRlY2hub2xvZ2llcyBJbmMuXHJcbiBDb3B5cmlnaHQgKGMpIDIwMTctMjAxOCBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC5cclxuXHJcbiBodHRwOi8vd3d3LmNvY29zLmNvbVxyXG5cclxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZW5naW5lIHNvdXJjZSBjb2RlICh0aGUgXCJTb2Z0d2FyZVwiKSwgYSBsaW1pdGVkLFxyXG4gIHdvcmxkd2lkZSwgcm95YWx0eS1mcmVlLCBub24tYXNzaWduYWJsZSwgcmV2b2NhYmxlIGFuZCBub24tZXhjbHVzaXZlIGxpY2Vuc2VcclxuIHRvIHVzZSBDb2NvcyBDcmVhdG9yIHNvbGVseSB0byBkZXZlbG9wIGdhbWVzIG9uIHlvdXIgdGFyZ2V0IHBsYXRmb3Jtcy4gWW91IHNoYWxsXHJcbiAgbm90IHVzZSBDb2NvcyBDcmVhdG9yIHNvZnR3YXJlIGZvciBkZXZlbG9waW5nIG90aGVyIHNvZnR3YXJlIG9yIHRvb2xzIHRoYXQnc1xyXG4gIHVzZWQgZm9yIGRldmVsb3BpbmcgZ2FtZXMuIFlvdSBhcmUgbm90IGdyYW50ZWQgdG8gcHVibGlzaCwgZGlzdHJpYnV0ZSxcclxuICBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgQ29jb3MgQ3JlYXRvci5cclxuXHJcbiBUaGUgc29mdHdhcmUgb3IgdG9vbHMgaW4gdGhpcyBMaWNlbnNlIEFncmVlbWVudCBhcmUgbGljZW5zZWQsIG5vdCBzb2xkLlxyXG4gWGlhbWVuIFlhamkgU29mdHdhcmUgQ28uLCBMdGQuIHJlc2VydmVzIGFsbCByaWdodHMgbm90IGV4cHJlc3NseSBncmFudGVkIHRvIHlvdS5cclxuXHJcbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuIFRIRSBTT0ZUV0FSRS5cclxuKi9cclxuXHJcbi8qKlxyXG4gKiBAY2F0ZWdvcnkgdWlcclxuICovXHJcblxyXG5pbXBvcnQgeyBidWlsdGluUmVzTWdyIH0gZnJvbSAnLi4vLi4vY29yZS8zZC9idWlsdGluJztcclxuaW1wb3J0IHsgUmVuZGVyYWJsZUNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2NvcmUvM2QvZnJhbWV3b3JrL3JlbmRlcmFibGUtY29tcG9uZW50JztcclxuaW1wb3J0IHsgSW5zdGFuY2VNYXRlcmlhbFR5cGUsIFVJUmVuZGVyQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vY29yZS9jb21wb25lbnRzL3VpLWJhc2UvdWktcmVuZGVyLWNvbXBvbmVudCc7XHJcbmltcG9ydCB7IGNjY2xhc3MsIGhlbHAsIGV4ZWN1dGlvbk9yZGVyLCBtZW51LCBwcm9wZXJ0eSB9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9jbGFzcy1kZWNvcmF0b3InO1xyXG5pbXBvcnQgeyBkaXJlY3RvciB9IGZyb20gJy4uLy4uL2NvcmUvZGlyZWN0b3InO1xyXG5pbXBvcnQgeyBDb2xvciB9IGZyb20gJy4uLy4uL2NvcmUvbWF0aCc7XHJcbmltcG9ydCB7IElNYXRlcmlhbEluc3RhbmNlSW5mbywgTWF0ZXJpYWxJbnN0YW5jZSwgTW9kZWwgfSBmcm9tICcuLi8uLi9jb3JlL3JlbmRlcmVyJztcclxuaW1wb3J0IHsgSUFzc2VtYmxlciB9IGZyb20gJy4uLy4uL2NvcmUvcmVuZGVyZXIvdWkvYmFzZSc7XHJcbmltcG9ydCB7IFVJIH0gZnJvbSAnLi4vLi4vY29yZS9yZW5kZXJlci91aS91aSc7XHJcbmltcG9ydCB7IExpbmVDYXAsIExpbmVKb2luIH0gZnJvbSAnLi4vYXNzZW1ibGVyL2dyYXBoaWNzL3R5cGVzJztcclxuaW1wb3J0IHsgSW1wbCB9IGZyb20gJy4uL2Fzc2VtYmxlci9ncmFwaGljcy93ZWJnbC9pbXBsJztcclxuXHJcbmNvbnN0IF9tYXRJbnNJbmZvOiBJTWF0ZXJpYWxJbnN0YW5jZUluZm8gPSB7XHJcbiAgICBwYXJlbnQ6IG51bGwhLFxyXG4gICAgb3duZXI6IG51bGwhLFxyXG4gICAgc3ViTW9kZWxJZHg6IDAsXHJcbn07XHJcblxyXG4vKipcclxuICogQGVuXHJcbiAqIEdyYXBoaWNzIGNvbXBvbmVudC5cclxuICpcclxuICogQHpoXHJcbiAqIOiHquWumuS5ieWbvuW9ouexu1xyXG4gKi9cclxuQGNjY2xhc3MoJ2NjLkdyYXBoaWNzQ29tcG9uZW50JylcclxuQGhlbHAoJ2kxOG46Y2MuR3JhcGhpY3NDb21wb25lbnQnKVxyXG5AZXhlY3V0aW9uT3JkZXIoMTEwKVxyXG5AbWVudSgnVUkvUmVuZGVyL0dyYXBoaWNzJylcclxuZXhwb3J0IGNsYXNzIEdyYXBoaWNzQ29tcG9uZW50IGV4dGVuZHMgVUlSZW5kZXJDb21wb25lbnQge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBDdXJyZW50IGxpbmUgd2lkdGguXHJcbiAgICAgKlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDlvZPliY3nur/mnaHlrr3luqbjgIJcclxuICAgICAqL1xyXG4gICAgQHByb3BlcnR5XHJcbiAgICBnZXQgbGluZVdpZHRoICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZVdpZHRoO1xyXG4gICAgfVxyXG4gICAgc2V0IGxpbmVXaWR0aCAodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9saW5lV2lkdGggPSB2YWx1ZTtcclxuICAgICAgICBpZiAoIXRoaXMuaW1wbCl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW1wbC5saW5lV2lkdGggPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogRGV0ZXJtaW5lcyBob3cgdHdvIGNvbm5lY3Rpbmcgc2VnbWVudHMgKG9mIGxpbmVzLCBhcmNzIG9yIGN1cnZlcykgd2l0aCBub24temVybyBsZW5ndGhzIGluIGEgc2hhcGUgYXJlIGpvaW5lZCB0b2dldGhlci5cclxuICAgICAqXHJcbiAgICAgKiBAemhcclxuICAgICAqIOeUqOadpeiuvue9rjLkuKrplb/luqbkuI3kuLow55qE55u46L+e6YOo5YiG77yI57q/5q6177yM5ZyG5byn77yM5puy57q/77yJ5aaC5L2V6L+e5o6l5Zyo5LiA6LW355qE5bGe5oCn44CCXHJcbiAgICAgKi9cclxuICAgIEBwcm9wZXJ0eSh7XHJcbiAgICAgICAgdHlwZTogTGluZUpvaW4sXHJcbiAgICAgICAgdG9vbHRpcDogJ+S4pOadoee6v+ebuOS6pOaXtu+8jOaJgOWIm+W7uueahOaLkOinkuexu+WeiycsXHJcbiAgICB9KVxyXG4gICAgZ2V0IGxpbmVKb2luICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZUpvaW47XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IGxpbmVKb2luICh2YWx1ZTogTGluZUpvaW4pIHtcclxuICAgICAgICB0aGlzLl9saW5lSm9pbiA9IHZhbHVlO1xyXG4gICAgICAgIGlmICghdGhpcy5pbXBsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW1wbC5saW5lSm9pbiA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBEZXRlcm1pbmVzIGhvdyB0aGUgZW5kIHBvaW50cyBvZiBldmVyeSBsaW5lIGFyZSBkcmF3bi5cclxuICAgICAqXHJcbiAgICAgKiBAemhcclxuICAgICAqIOaMh+WumuWmguS9lee7mOWItuavj+S4gOadoee6v+auteacq+err+OAglxyXG4gICAgICovXHJcbiAgICBAcHJvcGVydHkoe1xyXG4gICAgICAgIHR5cGU6IExpbmVDYXAsXHJcbiAgICAgICAgdG9vbHRpcDogJ+e6v+adoeeahOe7k+adn+err+eCueagt+W8jycsXHJcbiAgICB9KVxyXG4gICAgZ2V0IGxpbmVDYXAgKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lQ2FwO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBsaW5lQ2FwICh2YWx1ZTogTGluZUNhcCkge1xyXG4gICAgICAgIHRoaXMuX2xpbmVDYXAgPSB2YWx1ZTtcclxuICAgICAgICBpZiAoIXRoaXMuaW1wbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmltcGwubGluZUNhcCA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBTdHJva2UgY29sb3IuXHJcbiAgICAgKlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDnur/mrrXpopzoibLjgIJcclxuICAgICAqL1xyXG4gICAgQHByb3BlcnR5KHtcclxuICAgICAgICB0b29sdGlwOiAn56yU6Kem55qE6aKc6ImyJyxcclxuICAgIH0pXHJcbiAgICAvLyBAY29uc3RnZXRcclxuICAgIGdldCBzdHJva2VDb2xvciAoKTogUmVhZG9ubHk8Q29sb3I+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3Ryb2tlQ29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHN0cm9rZUNvbG9yICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbXBsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3N0cm9rZUNvbG9yLnNldCh2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5pbXBsLnN0cm9rZUNvbG9yID0gdGhpcy5fc3Ryb2tlQ29sb3I7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIEZpbGwgY29sb3IuXHJcbiAgICAgKlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDloavlhYXpopzoibLjgIJcclxuICAgICAqL1xyXG4gICAgQHByb3BlcnR5KHtcclxuICAgICAgICB0b29sdGlwOiAn5aGr5YWF57uY55S755qE6aKc6ImyJyxcclxuICAgIH0pXHJcbiAgICAvLyBAY29uc3RnZXRcclxuICAgIGdldCBmaWxsQ29sb3IgKCk6IFJlYWRvbmx5PENvbG9yPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGxDb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgZmlsbENvbG9yICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbXBsKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fZmlsbENvbG9yLnNldCh2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5pbXBsLmZpbGxDb2xvciA9IHRoaXMuX2ZpbGxDb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogU2V0cyB0aGUgbWl0ZXIgbGltaXQgcmF0aW8uXHJcbiAgICAgKlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDorr7nva7mlpzmjqXpnaLpmZDliLbmr5TkvovjgIJcclxuICAgICAqL1xyXG4gICAgQHByb3BlcnR5KHtcclxuICAgICAgICB0b29sdGlwOiAn5pyA5aSn5pac5o6l6ZW/5bqmJyxcclxuICAgIH0pXHJcbiAgICBnZXQgbWl0ZXJMaW1pdCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pdGVyTGltaXQ7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IG1pdGVyTGltaXQgKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fbWl0ZXJMaW1pdCA9IHZhbHVlO1xyXG4gICAgICAgIC8vIHRoaXMuaW1wbC5taXRlckxpbWl0ID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgQHByb3BlcnR5KHtcclxuICAgICAgICBvdmVycmlkZTogdHJ1ZSxcclxuICAgICAgICB2aXNpYmxlOiBmYWxzZSxcclxuICAgIH0pXHJcbiAgICBnZXQgY29sb3IgKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvcjtcclxuICAgIH1cclxuXHJcbiAgICBzZXQgY29sb3IgKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9jb2xvci5zZXQodmFsdWUpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUNvbG9yKCk7XHJcbiAgICAgICAgdGhpcy5tYXJrRm9yVXBkYXRlUmVuZGVyRGF0YSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgTGluZUpvaW4gPSBMaW5lSm9pbjtcclxuICAgIHB1YmxpYyBzdGF0aWMgTGluZUNhcCA9IExpbmVDYXA7XHJcbiAgICBwdWJsaWMgaW1wbDogSW1wbCB8IG51bGwgPSBudWxsO1xyXG4gICAgcHVibGljIG1vZGVsOiBNb2RlbCB8IG51bGwgPSBudWxsO1xyXG4gICAgQHByb3BlcnR5XHJcbiAgICBwcm90ZWN0ZWQgX2xpbmVXaWR0aCA9IDE7XHJcbiAgICBAcHJvcGVydHlcclxuICAgIHByb3RlY3RlZCBfc3Ryb2tlQ29sb3IgPSBDb2xvci5CTEFDSy5jbG9uZSgpO1xyXG4gICAgQHByb3BlcnR5XHJcbiAgICBwcm90ZWN0ZWQgX2xpbmVKb2luID0gTGluZUpvaW4uTUlURVI7XHJcbiAgICBAcHJvcGVydHlcclxuICAgIHByb3RlY3RlZCBfbGluZUNhcCA9IExpbmVDYXAuQlVUVDtcclxuICAgIEBwcm9wZXJ0eVxyXG4gICAgcHJvdGVjdGVkIF9maWxsQ29sb3IgPSBDb2xvci5XSElURS5jbG9uZSgpO1xyXG4gICAgQHByb3BlcnR5XHJcbiAgICBwcm90ZWN0ZWQgX21pdGVyTGltaXQgPSAxMDtcclxuXHJcbiAgICBjb25zdHJ1Y3RvciAoKXtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2luc3RhbmNlTWF0ZXJpYWxUeXBlID0gSW5zdGFuY2VNYXRlcmlhbFR5cGUuQUREQ09MT1I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uUmVzdG9yZSAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmltcGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmx1c2hBc3NlbWJsZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF9fcHJlbG9hZCAoKXtcclxuICAgICAgICBpZiAoc3VwZXIuX19wcmVsb2FkKXtcclxuICAgICAgICAgICAgc3VwZXIuX19wcmVsb2FkKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0aGlzLl9mbHVzaEFzc2VtYmxlcigpO1xyXG4gICAgICAgIHRoaXMuaW1wbCA9IHRoaXMuX2Fzc2VtYmxlciAmJiAodGhpcy5fYXNzZW1ibGVyIGFzIElBc3NlbWJsZXIpLmNyZWF0ZUltcGwhKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkxvYWQgKCkge1xyXG4gICAgICAgIHRoaXMuX3NjZW5lR2V0dGVyID0gZGlyZWN0b3Iucm9vdCEudWkuZ2V0UmVuZGVyU2NlbmVHZXR0ZXIoKTtcclxuICAgICAgICBpZiAoIXRoaXMubW9kZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IGRpcmVjdG9yLnJvb3QhLmNyZWF0ZU1vZGVsKE1vZGVsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uRW5hYmxlICgpIHtcclxuICAgICAgICBzdXBlci5vbkVuYWJsZSgpO1xyXG5cclxuICAgICAgICB0aGlzLl9hY3RpdmF0ZU1hdGVyaWFsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uRGlzYWJsZSAoKXtcclxuICAgICAgICB0aGlzLl9kZXRhY2hGcm9tU2NlbmUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25EZXN0cm95ICgpIHtcclxuICAgICAgICBzdXBlci5vbkRlc3Ryb3koKTtcclxuXHJcbiAgICAgICAgdGhpcy5fc2NlbmVHZXR0ZXIgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLm1vZGVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICBkaXJlY3Rvci5yb290IS5kZXN0cm95TW9kZWwodGhpcy5tb2RlbCk7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmltcGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbXBsLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5pbXBsID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgX2FjdGl2YXRlTWF0ZXJpYWwgKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fbWF0ZXJpYWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlTWF0ZXJpYWwodGhpcy5fbWF0ZXJpYWwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBNb3ZlIHBhdGggc3RhcnQgcG9pbnQgdG8gKHgseSkuXHJcbiAgICAgKlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDnp7vliqjot6/lvoTotbfngrnliLDlnZDmoIcoeCwgeSnjgIJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geCAtIOenu+WKqOWdkOaghyB4IOi9tOOAglxyXG4gICAgICogQHBhcmFtIHkgLSDnp7vliqjlnZDmoIcgeSDovbTjgIJcclxuICAgICAqL1xyXG4gICAgcHVibGljIG1vdmVUbyAoeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW1wbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmltcGwubW92ZVRvKHgsIHkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBBZGRzIGEgc3RyYWlnaHQgbGluZSB0byB0aGUgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAemhcclxuICAgICAqIOe7mOWItuebtOe6v+i3r+W+hOOAglxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB4IC0g57uY5Yi26Lev5b6E5Z2Q5qCHIHgg6L2044CCXHJcbiAgICAgKiBAcGFyYW0geSAtIOe7mOWItui3r+W+hOWdkOaghyB5IOi9tOOAglxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbGluZVRvICh4OiBudW1iZXIsIHk6IG51bWJlcikge1xyXG4gICAgICAgIGlmICghdGhpcy5pbXBsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW1wbC5saW5lVG8oeCwgeSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIEFkZHMgYSBjdWJpYyBCw6l6aWVyIGN1cnZlIHRvIHRoZSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEB6aFxyXG4gICAgICog57uY5Yi25LiJ5qyh6LSd6LWb5bCU5puy57q/6Lev5b6E44CCXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGMxeCAtIOesrOS4gOS4quaOp+WItueCueeahOWdkOaghyB4IOi9tOOAglxyXG4gICAgICogQHBhcmFtIGMxeSAtIOesrOS4gOS4quaOp+WItueCueeahOWdkOaghyB5IOi9tOOAglxyXG4gICAgICogQHBhcmFtIGMyeCAtIOesrOS6jOS4quaOp+WItueCueeahOWdkOaghyB4IOi9tOOAglxyXG4gICAgICogQHBhcmFtIGMyeSAtIOesrOS6jOS4quaOp+WItueCueeahOWdkOaghyB5IOi9tOOAglxyXG4gICAgICogQHBhcmFtIHggLSDmnIDlkI7kuIDkuKrmjqfliLbngrnnmoTlnZDmoIcgeCDovbTjgIJcclxuICAgICAqIEBwYXJhbSB5IC0g5pyA5ZCO5LiA5Liq5o6n5Yi254K555qE5Z2Q5qCHIHkg6L2044CCXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBiZXppZXJDdXJ2ZVRvIChjMXg6IG51bWJlciwgYzF5OiBudW1iZXIsIGMyeDogbnVtYmVyLCBjMnk6IG51bWJlciwgeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW1wbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmltcGwuYmV6aWVyQ3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBBZGRzIGEgcXVhZHJhdGljIELDqXppZXIgY3VydmUgdG8gdGhlIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDnu5jliLbkuozmrKHotJ3otZvlsJTmm7Lnur/ot6/lvoTjgIJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3ggLSDotbflp4vmjqfliLbngrnnmoTlnZDmoIcgeCDovbTjgIJcclxuICAgICAqIEBwYXJhbSBjeSAtIOi1t+Wni+aOp+WItueCueeahOWdkOaghyB5IOi9tOOAglxyXG4gICAgICogQHBhcmFtIHggLSDnu4jngrnmjqfliLbngrnnmoTlnZDmoIcgeCDovbTjgIJcclxuICAgICAqIEBwYXJhbSB5IC0g57uI54K55o6n5Yi254K555qE5Z2Q5qCHIHgg6L2044CCXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBxdWFkcmF0aWNDdXJ2ZVRvIChjeDogbnVtYmVyLCBjeTogbnVtYmVyLCB4OiBudW1iZXIsIHk6IG51bWJlcikge1xyXG4gICAgICAgIGlmICghdGhpcy5pbXBsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW1wbC5xdWFkcmF0aWNDdXJ2ZVRvKGN4LCBjeSwgeCwgeSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIEFkZHMgYW4gYXJjIHRvIHRoZSBwYXRoIHdoaWNoIGlzIGNlbnRlcmVkIGF0IChjeCwgY3kpIHBvc2l0aW9uIHdpdGggcmFkaXVzIHIgc3RhcnRpbmcgYXQgc3RhcnRBbmdsZVxyXG4gICAgICogYW5kIGVuZGluZyBhdCBlbmRBbmdsZSBnb2luZyBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uIGJ5IGNvdW50ZXJjbG9ja3dpc2UgKGRlZmF1bHRpbmcgdG8gZmFsc2UpLlxyXG4gICAgICpcclxuICAgICAqIEB6aFxyXG4gICAgICog57uY5Yi25ZyG5byn6Lev5b6E44CC5ZyG5byn6Lev5b6E55qE5ZyG5b+D5ZyoIChjeCwgY3kpIOS9jee9ru+8jOWNiuW+hOS4uiByIO+8jOagueaNriBjb3VudGVyY2xvY2t3aXNlIO+8iOm7mOiupOS4umZhbHNl77yJ5oyH5a6a55qE5pa55ZCR5LuOIHN0YXJ0QW5nbGUg5byA5aeL57uY5Yi277yM5YiwIGVuZEFuZ2xlIOe7k+adn+OAglxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjeCAtIOS4reW/g+aOp+WItueCueeahOWdkOaghyB4IOi9tOOAglxyXG4gICAgICogQHBhcmFtIGN5IC0g5Lit5b+D5o6n5Yi254K555qE5Z2Q5qCHIHkg6L2044CCXHJcbiAgICAgKiBAcGFyYW0gciAtIOWchuW8p+W8p+W6puOAglxyXG4gICAgICogQHBhcmFtIHN0YXJ0QW5nbGUgLSDlvIDlp4vlvKfluqbvvIzku47mraMgeCDovbTpobrml7bpkojmlrnlkJHmtYvph4/jgIJcclxuICAgICAqIEBwYXJhbSBlbmRBbmdsZSAtIOe7k+adn+W8p+W6pu+8jOS7juatoyB4IOi9tOmhuuaXtumSiOaWueWQkea1i+mHj+OAglxyXG4gICAgICogQHBhcmFtIGNvdW50ZXJjbG9ja3dpc2Ug5aaC5p6c5Li655yf77yM5Zyo5Lik5Liq6KeS5bqm5LmL6Ze06YCG5pe26ZKI57uY5Yi244CC6buY6K6k6aG65pe26ZKI44CCXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhcmMgKGN4OiBudW1iZXIsIGN5OiBudW1iZXIsIHI6IG51bWJlciwgc3RhcnRBbmdsZTogbnVtYmVyLCBlbmRBbmdsZTogbnVtYmVyLCBjb3VudGVyY2xvY2t3aXNlOiBib29sZWFuKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmltcGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbXBsLmFyYyhjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjb3VudGVyY2xvY2t3aXNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogQWRkcyBhbiBlbGxpcHNlIHRvIHRoZSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEB6aFxyXG4gICAgICog57uY5Yi25qSt5ZyG6Lev5b6E44CCXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN4IC0g5Lit5b+D54K555qE5Z2Q5qCHIHgg6L2044CCXHJcbiAgICAgKiBAcGFyYW0gY3kgLSDkuK3lv4PngrnnmoTlnZDmoIcgeSDovbTjgIJcclxuICAgICAqIEBwYXJhbSByeCAtIOakreWchiB4IOi9tOWNiuW+hOOAglxyXG4gICAgICogQHBhcmFtIHJ5IC0g5qSt5ZyGIHkg6L205Y2K5b6E44CCXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBlbGxpcHNlIChjeDogbnVtYmVyLCBjeTogbnVtYmVyLCByeDogbnVtYmVyLCByeTogbnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmltcGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbXBsLmVsbGlwc2UoY3gsIGN5LCByeCwgcnkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBBZGRzIGEgY2lyY2xlIHRvIHRoZSBwYXRoLlxyXG4gICAgICpcclxuICAgICAqIEB6aFxyXG4gICAgICog57uY5Yi25ZyG5b2i6Lev5b6E44CCXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN4IC0g5Lit5b+D54K555qE5Z2Q5qCHIHgg6L2044CCXHJcbiAgICAgKiBAcGFyYW0gY3kgLSDkuK3lv4PngrnnmoTlnZDmoIcgeSDovbTjgIJcclxuICAgICAqIEBwYXJhbSByIC0g5ZyG5Y2K5b6E44CCXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjaXJjbGUgKGN4OiBudW1iZXIsIGN5OiBudW1iZXIsIHI6IG51bWJlcikge1xyXG4gICAgICAgIGlmICghdGhpcy5pbXBsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW1wbC5jaXJjbGUoY3gsIGN5LCByKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogQWRkcyBhIHJlY3RhbmdsZSB0byB0aGUgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAemhcclxuICAgICAqIOe7mOWItuefqeW9oui3r+W+hOOAglxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB4IC0g55+p5b2i6LW35aeL5Z2Q5qCHIHgg6L2044CCXHJcbiAgICAgKiBAcGFyYW0geSAtIOefqeW9oui1t+Wni+WdkOaghyB5IOi9tOOAglxyXG4gICAgICogQHBhcmFtIHcgLSDnn6nlvaLlrr3luqbjgIJcclxuICAgICAqIEBwYXJhbSBoIC0g55+p5b2i6auY5bqm44CCXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZWN0ICh4OiBudW1iZXIsIHk6IG51bWJlciwgdzogbnVtYmVyLCBoOiBudW1iZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW1wbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmltcGwucmVjdCh4LCB5LCB3LCBoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogQWRkcyBhIHJvdW5kIGNvcm5lciByZWN0YW5nbGUgdG8gdGhlIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDnu5jliLblnIbop5Lnn6nlvaLot6/lvoTjgIJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geCAtIOefqeW9oui1t+Wni+WdkOaghyB4IOi9tOOAglxyXG4gICAgICogQHBhcmFtIHkgLSDnn6nlvaLotbflp4vlnZDmoIcgeSDovbTjgIJcclxuICAgICAqIEBwYXJhbSB3IC0g55+p5b2i5a695bqm44CCXHJcbiAgICAgKiBAcGFyYW0gaCAtIOefqeW9oumrmOW6puOAglxyXG4gICAgICogQHBhcmFtIHIgLSDnn6nlvaLlnIbop5LljYrlvoTjgIJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJvdW5kUmVjdCAoeDogbnVtYmVyLCB5OiBudW1iZXIsIHc6IG51bWJlciwgaDogbnVtYmVyLCByOiBudW1iZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW1wbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmltcGwucm91bmRSZWN0KHgsIHksIHcsIGgsIHIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBEcmF3cyBhIGZpbGxlZCByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDnu5jliLbloavlhYXnn6nlvaLjgIJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geCAtIOefqeW9oui1t+Wni+WdkOaghyB4IOi9tOOAglxyXG4gICAgICogQHBhcmFtIHkgLSDnn6nlvaLotbflp4vlnZDmoIcgeSDovbTjgIJcclxuICAgICAqIEBwYXJhbSB3IC0g55+p5b2i5a695bqm44CCXHJcbiAgICAgKiBAcGFyYW0gaCAtIOefqeW9oumrmOW6puOAglxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZmlsbFJlY3QgKHgsIHksIHcsIGgpIHtcclxuICAgICAgICB0aGlzLnJlY3QoeCwgeSwgdywgaCk7XHJcbiAgICAgICAgdGhpcy5maWxsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIEVyYXNpbmcgYW55IHByZXZpb3VzbHkgZHJhd24gY29udGVudC5cclxuICAgICAqXHJcbiAgICAgKiBAemhcclxuICAgICAqIOaTpumZpOS5i+WJjee7mOWItueahOaJgOacieWGheWuueeahOaWueazleOAglxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2xlYXIgKGNsZWFuID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW1wbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmltcGwuY2xlYXIoY2xlYW4pO1xyXG4gICAgICAgIHRoaXMuX2RldGFjaEZyb21TY2VuZSgpO1xyXG4gICAgICAgIGlmKHRoaXMubW9kZWwpe1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVsLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tYXJrRm9yVXBkYXRlUmVuZGVyRGF0YSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBDYXVzZXMgdGhlIHBvaW50IG9mIHRoZSBwZW4gdG8gbW92ZSBiYWNrIHRvIHRoZSBzdGFydCBvZiB0aGUgY3VycmVudCBwYXRoLlxyXG4gICAgICogSXQgdHJpZXMgdG8gYWRkIGEgc3RyYWlnaHQgbGluZSBmcm9tIHRoZSBjdXJyZW50IHBvaW50IHRvIHRoZSBzdGFydC5cclxuICAgICAqXHJcbiAgICAgKiBAemhcclxuICAgICAqIOWwhueslOeCuei/lOWbnuWIsOW9k+WJjei3r+W+hOi1t+Wni+eCueeahOOAguWug+WwneivleS7juW9k+WJjeeCueWIsOi1t+Wni+eCuee7mOWItuS4gOadoeebtOe6v+OAglxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY2xvc2UgKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbXBsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW1wbC5jbG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBTdHJva2VzIHRoZSBjdXJyZW50IG9yIGdpdmVuIHBhdGggd2l0aCB0aGUgY3VycmVudCBzdHJva2Ugc3R5bGUuXHJcbiAgICAgKlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDmoLnmja7lvZPliY3nmoTnlLvnur/moLflvI/vvIznu5jliLblvZPliY3miJblt7Lnu4/lrZjlnKjnmoTot6/lvoTjgIJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0cm9rZSAoKSB7XHJcbiAgICAgICAgKHRoaXMuX2Fzc2VtYmxlciBhcyBJQXNzZW1ibGVyKS5zdHJva2UhKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2F0dGFjaFRvU2NlbmUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogRmlsbHMgdGhlIGN1cnJlbnQgb3IgZ2l2ZW4gcGF0aCB3aXRoIHRoZSBjdXJyZW50IGZpbGwgc3R5bGUuXHJcbiAgICAgKlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDmoLnmja7lvZPliY3nmoTnlLvnur/moLflvI/vvIzloavlhYXlvZPliY3miJblt7Lnu4/lrZjlnKjnmoTot6/lvoTjgIJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGZpbGwgKCkge1xyXG4gICAgICAgICh0aGlzLl9hc3NlbWJsZXIgYXMgSUFzc2VtYmxlcikuZmlsbCEodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fYXR0YWNoVG9TY2VuZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBNYW51YWwgaW5zdGFuY2UgbWF0ZXJpYWwuXHJcbiAgICAgKlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDovoXliqnmnZDotKjlrp7kvovljJbjgILlj6/nlKjkuo7lj6rlj5bmlbDmja7ogIzml6Dlrp7kvZPmg4XlhrXkuIvmuLLmn5Pkvb/nlKjjgILnibnmrormg4XlhrXlj6/lj4LogIPvvJpbW2luc3RhbmNlTWF0ZXJpYWxdXVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaGVscEluc3RhbmNlTWF0ZXJpYWwgKCkge1xyXG4gICAgICAgIGxldCBtYXQ6IE1hdGVyaWFsSW5zdGFuY2UgfCBudWxsID0gbnVsbDtcclxuICAgICAgICBfbWF0SW5zSW5mby5vd25lciA9IG5ldyBSZW5kZXJhYmxlQ29tcG9uZW50KCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NoYXJlZE1hdGVyaWFsKSB7XHJcbiAgICAgICAgICAgIF9tYXRJbnNJbmZvLnBhcmVudCA9IHRoaXMuX3NoYXJlZE1hdGVyaWFsO1xyXG4gICAgICAgICAgICBtYXQgPSBuZXcgTWF0ZXJpYWxJbnN0YW5jZShfbWF0SW5zSW5mbyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX21hdEluc0luZm8ucGFyZW50ID0gYnVpbHRpblJlc01nci5nZXQoJ3VpLWJhc2UtbWF0ZXJpYWwnKTtcclxuICAgICAgICAgICAgbWF0ID0gbmV3IE1hdGVyaWFsSW5zdGFuY2UoX21hdEluc0luZm8pO1xyXG4gICAgICAgICAgICBtYXQucmVjb21waWxlU2hhZGVycyh7IFVTRV9MT0NBTDogdHJ1ZSB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZU1hdGVyaWFsKG1hdCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmltcGwpe1xyXG4gICAgICAgICAgICB0aGlzLl9mbHVzaEFzc2VtYmxlcigpO1xyXG4gICAgICAgICAgICB0aGlzLmltcGwgPSB0aGlzLl9hc3NlbWJsZXIgJiYgKHRoaXMuX2Fzc2VtYmxlciBhcyBJQXNzZW1ibGVyKS5jcmVhdGVJbXBsISh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9yZW5kZXIgKHJlbmRlcjogVUkpIHtcclxuICAgICAgICByZW5kZXIuY29tbWl0TW9kZWwodGhpcywgdGhpcy5tb2RlbCwgdGhpcy5fbWF0ZXJpYWwpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfaW5zdGFuY2VNYXRlcmlhbCAoKXtcclxuICAgICAgICB0aGlzLmhlbHBJbnN0YW5jZU1hdGVyaWFsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9mbHVzaEFzc2VtYmxlciAoKXtcclxuICAgICAgICBjb25zdCBhc3NlbWJsZXIgPSBHcmFwaGljc0NvbXBvbmVudC5Bc3NlbWJsZXIhLmdldEFzc2VtYmxlcih0aGlzKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2Fzc2VtYmxlciAhPT0gYXNzZW1ibGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Fzc2VtYmxlciA9IGFzc2VtYmxlcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9jYW5SZW5kZXIgKCl7XHJcbiAgICAgICAgaWYgKCFzdXBlci5fY2FuUmVuZGVyKCkpe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gISF0aGlzLm1vZGVsICYmIHRoaXMubW9kZWwuaW5pdGVkO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfYXR0YWNoVG9TY2VuZSAoKSB7XHJcbiAgICAgICAgY29uc3Qgc2NlbmUgPSBkaXJlY3Rvci5yb290IS51aS5yZW5kZXJTY2VuZTtcclxuICAgICAgICBpZiAoIXRoaXMubW9kZWwgfHwgdGhpcy5tb2RlbCEuc2NlbmUgPT09IHNjZW5lKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm1vZGVsIS5zY2VuZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZXRhY2hGcm9tU2NlbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2NlbmUuYWRkTW9kZWwodGhpcy5tb2RlbCEpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfZGV0YWNoRnJvbVNjZW5lICgpIHtcclxuICAgICAgICBpZiAodGhpcy5tb2RlbCAmJiB0aGlzLm1vZGVsLnNjZW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2NlbmUucmVtb3ZlTW9kZWwodGhpcy5tb2RlbCk7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWwuc2NlbmUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuY2MuR3JhcGhpY3NDb21wb25lbnQgPSBHcmFwaGljc0NvbXBvbmVudDtcclxuIl19