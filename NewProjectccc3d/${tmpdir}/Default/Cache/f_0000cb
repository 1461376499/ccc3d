(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "../components/component.js", "../data/class-decorator.js", "../event/eventify.js", "../platform/debug.js", "../utils/array.js", "../utils/js-typed.js", "./animation-clip.js", "./animation-state.js", "./cross-fade.js", "../default-constants.js"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("../components/component.js"), require("../data/class-decorator.js"), require("../event/eventify.js"), require("../platform/debug.js"), require("../utils/array.js"), require("../utils/js-typed.js"), require("./animation-clip.js"), require("./animation-state.js"), require("./cross-fade.js"), require("../default-constants.js"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.component, global.classDecorator, global.eventify, global.debug, global.array, global.jsTyped, global.animationClip, global.animationState, global.crossFade, global.defaultConstants);
    global.animationComponent = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _component, _classDecorator, _eventify, _debug, ArrayUtils, _jsTyped, _animationClip, _animationState, _crossFade, _defaultConstants) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.AnimationComponent = void 0;
  ArrayUtils = _interopRequireWildcard(ArrayUtils);

  var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _class, _class2, _descriptor, _descriptor2, _descriptor3, _class3, _temp;

  function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

  /**
   * @en
   * Animation component governs a group of animation states to control playback of the states.
   * For convenient, it stores a group of animation clips.
   * Each of those clips would have an associated animation state uniquely created.
   * Animation component is eventful, it dispatch a serials playback status events.
   * See [[EventType]].
   * @zh
   * 动画组件管理一组动画状态，控制它们的播放。
   * 为了方便，动画组件还存储了一组动画剪辑。
   * 每个剪辑都会独自创建一个关联的动画状态对象。
   * 动画组件具有事件特性，它会派发一系列播放状态相关的事件。
   * 参考 [[EventType]]
   */
  var AnimationComponent = (_dec = (0, _classDecorator.ccclass)('cc.AnimationComponent'), _dec2 = (0, _classDecorator.help)('i18n:cc.AnimationComponent'), _dec3 = (0, _classDecorator.executionOrder)(99), _dec4 = (0, _classDecorator.menu)('Components/Animation'), _dec5 = (0, _classDecorator.property)({
    type: [_animationClip.AnimationClip],
    tooltip: '此动画组件管理的动画剪辑'
  }), _dec6 = (0, _classDecorator.property)({
    type: _animationClip.AnimationClip,
    tooltip: '默认动画剪辑'
  }), _dec7 = (0, _classDecorator.property)({
    tooltip: '是否在动画组件开始运行时自动播放默认动画剪辑'
  }), _dec8 = (0, _classDecorator.property)({
    type: [_animationClip.AnimationClip]
  }), _dec(_class = _dec2(_class = _dec3(_class = (0, _classDecorator.executeInEditMode)(_class = _dec4(_class = (_class2 = (_temp = _class3 = /*#__PURE__*/function (_Eventify) {
    _inherits(AnimationComponent, _Eventify);

    function AnimationComponent() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, AnimationComponent);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(AnimationComponent)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _initializerDefineProperty(_this, "playOnLoad", _descriptor, _assertThisInitialized(_this));

      _this._crossFade = new _crossFade.CrossFade();
      _this._nameToState = (0, _jsTyped.createMap)(true);

      _initializerDefineProperty(_this, "_clips", _descriptor2, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_defaultClip", _descriptor3, _assertThisInitialized(_this));

      _this._hasBeenPlayed = false;
      return _this;
    }

    _createClass(AnimationComponent, [{
      key: "onLoad",
      value: function onLoad() {
        this.clips = this._clips;

        for (var stateName in this._nameToState) {
          var state = this._nameToState[stateName];
          state.initialize(this.node);
        }
      }
    }, {
      key: "start",
      value: function start() {
        if (!_defaultConstants.EDITOR && this.playOnLoad && !this._hasBeenPlayed && this._defaultClip) {
          this.crossFade(this._defaultClip.name, 0);
        }
      }
    }, {
      key: "onEnable",
      value: function onEnable() {
        this._crossFade.resume();
      }
    }, {
      key: "onDisable",
      value: function onDisable() {
        this._crossFade.pause();
      }
    }, {
      key: "onDestroy",
      value: function onDestroy() {
        this._crossFade.stop();

        for (var name in this._nameToState) {
          var state = this._nameToState[name];
          state.destroy();
        }

        this._nameToState = (0, _jsTyped.createMap)(true);
      }
      /**
       * @en
       * Switch to play specified animation state, without fading.
       * @zh
       * 立即切换到指定动画状态。
       * @param name The name of the animation to be played, if absent, the default clip will be played
       */

    }, {
      key: "play",
      value: function play(name) {
        this._hasBeenPlayed = true;

        if (!name) {
          if (!this._defaultClip) {
            return;
          } else {
            name = this._defaultClip.name;
          }
        }

        this.crossFade(name, 0);
      }
      /**
       * @en
       * Smoothly switch to play specified animation state.
       * @zn
       * 平滑地切换到指定动画状态。
       * @param name The name of the animation to switch to
       * @param duration The duration of the cross fade, default value is 0.3s
       */

    }, {
      key: "crossFade",
      value: function crossFade(name) {
        var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.3;
        this._hasBeenPlayed = true;
        var state = this._nameToState[name];

        if (state) {
          this._crossFade.play();

          this._crossFade.crossFade(state, duration);
        }
      }
      /**
       * @en
       * Pause all animation states and all switching.
       * @zh
       * 暂停所有动画状态，并暂停所有切换。
       */

    }, {
      key: "pause",
      value: function pause() {
        this._crossFade.pause();
      }
      /**
       * @en
       * Resume all animation states and all switching.
       * @zh
       * 恢复所有动画状态，并恢复所有切换。
       */

    }, {
      key: "resume",
      value: function resume() {
        this._crossFade.resume();
      }
      /**
       * @en
       * Stop all animation states and all switching.
       * @zh
       * 停止所有动画状态，并停止所有切换。
       */

    }, {
      key: "stop",
      value: function stop() {
        this._crossFade.stop();
      }
      /**
       * @en
       * Get specified animation state.
       * @zh
       * 获取指定的动画状态。
       * @deprecated please use [[getState]]
       */

    }, {
      key: "getAnimationState",
      value: function getAnimationState(name) {
        return this.getState(name);
      }
      /**
       * @en
       * Get specified animation state.
       * @zh
       * 获取指定的动画状态。
       * @param name The name of the animation
       * @returns If no animation found, return null, otherwise the correspond animation state is returned
       */

    }, {
      key: "getState",
      value: function getState(name) {
        var state = this._nameToState[name];

        if (state && !state.curveLoaded) {
          state.initialize(this.node);
        }

        return state || null;
      }
      /**
       * @en
       * Creates a state for specified clip.
       * If there is already a clip with same name, the existing animation state will be stopped and overridden.
       * @zh
       * 使用指定的动画剪辑创建一个动画状态。
       * 若指定名称的动画状态已存在，已存在的动画状态将先被设为停止并被覆盖。
       * @param clip The animation clip
       * @param name The animation state name, if absent, the default clip's name will be used
       * @returns The animation state created
       */

    }, {
      key: "createState",
      value: function createState(clip, name) {
        name = name || clip.name;
        this.removeState(name);
        return this._doCreateState(clip, name);
      }
      /**
       * @en
       * Stops and removes specified clip.
       * @zh
       * 停止并移除指定的动画状态。
       * @param name The name of the animation state
       */

    }, {
      key: "removeState",
      value: function removeState(name) {
        var state = this._nameToState[name];

        if (state) {
          state.allowLastFrameEvent(false);
          state.stop();
          delete this._nameToState[name];
        }
      }
      /**
       * 添加一个动画剪辑到 `this.clips`中并以此剪辑创建动画状态。
       * @deprecated please use [[createState]]
       * @param clip The animation clip
       * @param name The animation state name, if absent, the default clip's name will be used
       * @returns The created animation state
       */

    }, {
      key: "addClip",
      value: function addClip(clip, name) {
        if (!ArrayUtils.contains(this._clips, clip)) {
          this._clips.push(clip);
        }

        return this.createState(clip, name);
      }
      /**
       * @en
       * Remove clip from the animation list. This will remove the clip and any animation states based on it.<br>
       * If there are animation states depend on the clip are playing or clip is defaultClip, it will not delete the clip.<br>
       * But if force is true, then will always remove the clip and any animation states based on it. If clip is defaultClip, defaultClip will be reset to null
       * @zh
       * 从动画列表中移除指定的动画剪辑，<br/>
       * 如果依赖于 clip 的 AnimationState 正在播放或者 clip 是 defaultClip 的话，默认是不会删除 clip 的。<br/>
       * 但是如果 force 参数为 true，则会强制停止该动画，然后移除该动画剪辑和相关的动画。这时候如果 clip 是 defaultClip，defaultClip 将会被重置为 null。<br/>
       * @deprecated please use [[removeState]]
       * @param force - If force is true, then will always remove the clip and any animation states based on it.
       */

    }, {
      key: "removeClip",
      value: function removeClip(clip, force) {
        var removalState;

        for (var name in this._nameToState) {
          var state = this._nameToState[name];
          var stateClip = state.clip;

          if (stateClip === clip) {
            removalState = state;
            break;
          }
        }

        if (clip === this._defaultClip) {
          if (force) {
            this._defaultClip = null;
          } else {
            if (!_defaultConstants.TEST) {
              (0, _debug.warnID)(3902);
            }

            return;
          }
        }

        if (removalState && removalState.isPlaying) {
          if (force) {
            removalState.stop();
          } else {
            if (!_defaultConstants.TEST) {
              (0, _debug.warnID)(3903);
            }

            return;
          }
        }

        this._clips = this._clips.filter(function (item) {
          return item !== clip;
        });

        if (removalState) {
          delete this._nameToState[removalState.name];
        }
      }
      /**
       * @en
       * Register animation event callback.<bg>
       * The event arguments will provide the AnimationState which emit the event.<bg>
       * When play an animation, will auto register the event callback to the AnimationState,<bg>
       * and unregister the event callback from the AnimationState when animation stopped.
       * @zh
       * 注册动画事件回调。<bg>
       * 回调的事件里将会附上发送事件的 AnimationState。<bg>
       * 当播放一个动画时，会自动将事件注册到对应的 AnimationState 上，停止播放时会将事件从这个 AnimationState 上取消注册。
       * @param type The event type to listen to
       * @param callback The callback when event triggered
       * @param target The callee when invoke the callback, could be absent
       * @return The registered callback
       * @example
       * ```typescript
       * onPlay: function (type, state) {
       *     // callback
       * }
       *
       * // register event to all animation
       * animation.on('play', this.onPlay, this);
       * ```
       */

    }, {
      key: "on",
      value: function on(type, callback, thisArg, once) {
        var ret = _get(_getPrototypeOf(AnimationComponent.prototype), "on", this).call(this, type, callback, thisArg, once);

        if (type === _animationState.EventType.LASTFRAME) {
          this._syncAllowLastFrameEvent();
        }

        return ret;
      }
    }, {
      key: "once",
      value: function once(type, callback, thisArg) {
        var ret = _get(_getPrototypeOf(AnimationComponent.prototype), "once", this).call(this, type, callback, thisArg);

        if (type === _animationState.EventType.LASTFRAME) {
          this._syncAllowLastFrameEvent();
        }

        return ret;
      }
      /**
       * @en
       * Unregister animation event callback.
       * @zh
       * 取消注册动画事件回调。
       * @param {String} type The event type to unregister
       * @param {Function} callback The callback to unregister
       * @param {Object} target The callee of the callback, could be absent
       * @example
       * ```typescript
       * // unregister event to all animation
       * animation.off('play', this.onPlay, this);
       * ```
       */

    }, {
      key: "off",
      value: function off(type, callback, thisArg) {
        _get(_getPrototypeOf(AnimationComponent.prototype), "off", this).call(this, type, callback, thisArg);

        if (type === _animationState.EventType.LASTFRAME) {
          this._syncDisallowLastFrameEvent();
        }
      }
    }, {
      key: "_createState",
      value: function _createState(clip, name) {
        return new _animationState.AnimationState(clip, name);
      }
    }, {
      key: "_doCreateState",
      value: function _doCreateState(clip, name) {
        var state = this._createState(clip, name);

        state._setEventTarget(this);

        state.allowLastFrameEvent(this.hasEventListener(_animationState.EventType.LASTFRAME));

        if (this.node) {
          state.initialize(this.node);
        }

        this._nameToState[state.name] = state;
        return state;
      }
    }, {
      key: "_getStateByNameOrDefaultClip",
      value: function _getStateByNameOrDefaultClip(name) {
        if (!name) {
          if (!this._defaultClip) {
            return null;
          } else {
            name = this._defaultClip.name;
          }
        }

        var state = this._nameToState[name];

        if (state) {
          return state;
        } else {
          return null;
        }
      }
    }, {
      key: "_removeStateOfAutomaticClip",
      value: function _removeStateOfAutomaticClip(clip) {
        // tslint:disable-next-line:forin
        for (var name in this._nameToState) {
          var state = this._nameToState[name];

          if (equalClips(clip, state.clip)) {
            state.stop();
            delete this._nameToState[name];
          }
        }
      }
    }, {
      key: "_syncAllowLastFrameEvent",
      value: function _syncAllowLastFrameEvent() {
        if (this.hasEventListener(_animationState.EventType.LASTFRAME)) {
          for (var stateName in this._nameToState) {
            this._nameToState[stateName].allowLastFrameEvent(true);
          }
        }
      }
    }, {
      key: "_syncDisallowLastFrameEvent",
      value: function _syncDisallowLastFrameEvent() {
        if (!this.hasEventListener(_animationState.EventType.LASTFRAME)) {
          for (var stateName in this._nameToState) {
            this._nameToState[stateName].allowLastFrameEvent(false);
          }
        }
      }
    }, {
      key: "clips",

      /**
       * @en
       * Gets or sets clips this component governs.
       * When set, associated animation state of each existing clip will be stopped.
       * If the existing default clip is not in the set of new clips, default clip will be reset to null.
       * @zh
       * 获取或设置此组件管理的剪辑。
       * 设置时，已有剪辑关联的动画状态将被停止；若默认剪辑不在新的动画剪辑中，将被重置为空。
       */
      get: function get() {
        return this._clips;
      },
      set: function set(value) {
        var _this2 = this;

        if (this._crossFade) {
          this._crossFade.clear();
        } // Remove state for old automatic clips.


        var _iterator = _createForOfIteratorHelper(this._clips),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var clip = _step.value;

            if (clip) {
              this._removeStateOfAutomaticClip(clip);
            }
          } // Create state for new clips.

        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        var _iterator2 = _createForOfIteratorHelper(value),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _clip = _step2.value;

            if (_clip) {
              this.createState(_clip);
            }
          } // Default clip should be in the list of automatic clips.

        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        var newDefaultClip = value.find(function (clip) {
          return equalClips(clip, _this2._defaultClip);
        });

        if (newDefaultClip) {
          this._defaultClip = newDefaultClip;
        } else {
          this._defaultClip = null;
        }

        this._clips = value;
      }
      /**
       * @en
       * Gets or sets the default clip.
       * @en
       * 获取或设置默认剪辑。
       * 设置时，若指定的剪辑不在 `this.clips` 中则会被自动添加至 `this.clips`。
       * @see [[playOnLoad]]
       */

    }, {
      key: "defaultClip",
      get: function get() {
        return this._defaultClip;
      },
      set: function set(value) {
        this._defaultClip = value;

        if (!value) {
          return;
        }

        var isBoundedDefaultClip = this._clips.findIndex(function (clip) {
          return equalClips(clip, value);
        }) >= 0;

        if (!isBoundedDefaultClip) {
          this._clips.push(value);

          this.createState(value);
        }
      }
    }]);

    return AnimationComponent;
  }((0, _eventify.Eventify)(_component.Component)), _class3.EventType = _animationState.EventType, _temp), (_applyDecoratedDescriptor(_class2.prototype, "clips", [_dec5], Object.getOwnPropertyDescriptor(_class2.prototype, "clips"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "defaultClip", [_dec6], Object.getOwnPropertyDescriptor(_class2.prototype, "defaultClip"), _class2.prototype), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "playOnLoad", [_dec7], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return false;
    }
  }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_clips", [_dec8], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return [];
    }
  }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "_defaultClip", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return null;
    }
  })), _class2)) || _class) || _class) || _class) || _class) || _class);
  _exports.AnimationComponent = AnimationComponent;

  (function (_AnimationComponent) {})(AnimationComponent || (_exports.AnimationComponent = AnimationComponent = {}));

  cc.AnimationComponent = AnimationComponent;

  function equalClips(clip1, clip2) {
    if (clip1 === clip2) {
      return true;
    }

    return !!clip1 && !!clip2 && (clip1.name === clip2.name || clip1._uuid === clip2._uuid);
  }
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkY6L2plbmtpbnMvd29ya3NwYWNlL0NyZWF0b3JfM0QvZWRpdG9yLTNkL3Jlc291cmNlcy8zZC9lbmdpbmUvY29jb3MvY29yZS9hbmltYXRpb24vYW5pbWF0aW9uLWNvbXBvbmVudC50cyJdLCJuYW1lcyI6WyJBbmltYXRpb25Db21wb25lbnQiLCJ0eXBlIiwiQW5pbWF0aW9uQ2xpcCIsInRvb2x0aXAiLCJleGVjdXRlSW5FZGl0TW9kZSIsIl9jcm9zc0ZhZGUiLCJDcm9zc0ZhZGUiLCJfbmFtZVRvU3RhdGUiLCJfaGFzQmVlblBsYXllZCIsImNsaXBzIiwiX2NsaXBzIiwic3RhdGVOYW1lIiwic3RhdGUiLCJpbml0aWFsaXplIiwibm9kZSIsIkVESVRPUiIsInBsYXlPbkxvYWQiLCJfZGVmYXVsdENsaXAiLCJjcm9zc0ZhZGUiLCJuYW1lIiwicmVzdW1lIiwicGF1c2UiLCJzdG9wIiwiZGVzdHJveSIsImR1cmF0aW9uIiwicGxheSIsImdldFN0YXRlIiwiY3VydmVMb2FkZWQiLCJjbGlwIiwicmVtb3ZlU3RhdGUiLCJfZG9DcmVhdGVTdGF0ZSIsImFsbG93TGFzdEZyYW1lRXZlbnQiLCJBcnJheVV0aWxzIiwiY29udGFpbnMiLCJwdXNoIiwiY3JlYXRlU3RhdGUiLCJmb3JjZSIsInJlbW92YWxTdGF0ZSIsInN0YXRlQ2xpcCIsIlRFU1QiLCJpc1BsYXlpbmciLCJmaWx0ZXIiLCJpdGVtIiwiY2FsbGJhY2siLCJ0aGlzQXJnIiwib25jZSIsInJldCIsIkV2ZW50VHlwZSIsIkxBU1RGUkFNRSIsIl9zeW5jQWxsb3dMYXN0RnJhbWVFdmVudCIsIl9zeW5jRGlzYWxsb3dMYXN0RnJhbWVFdmVudCIsIkFuaW1hdGlvblN0YXRlIiwiX2NyZWF0ZVN0YXRlIiwiX3NldEV2ZW50VGFyZ2V0IiwiaGFzRXZlbnRMaXN0ZW5lciIsImVxdWFsQ2xpcHMiLCJ2YWx1ZSIsImNsZWFyIiwiX3JlbW92ZVN0YXRlT2ZBdXRvbWF0aWNDbGlwIiwibmV3RGVmYXVsdENsaXAiLCJmaW5kIiwiaXNCb3VuZGVkRGVmYXVsdENsaXAiLCJmaW5kSW5kZXgiLCJDb21wb25lbnQiLCJwcm9wZXJ0eSIsImNjIiwiY2xpcDEiLCJjbGlwMiIsIl91dWlkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0NBOzs7Ozs7Ozs7Ozs7OztNQW1CYUEsa0IsV0FMWiw2QkFBUSx1QkFBUixDLFVBQ0EsMEJBQUssNEJBQUwsQyxVQUNBLG9DQUFlLEVBQWYsQyxVQUVBLDBCQUFLLHNCQUFMLEMsVUFXSSw4QkFBUztBQUNOQyxJQUFBQSxJQUFJLEVBQUUsQ0FBQ0MsNEJBQUQsQ0FEQTtBQUVOQyxJQUFBQSxPQUFPLEVBQUU7QUFGSCxHQUFULEMsVUEyQ0EsOEJBQVM7QUFDTkYsSUFBQUEsSUFBSSxFQUFFQyw0QkFEQTtBQUVOQyxJQUFBQSxPQUFPLEVBQUU7QUFGSCxHQUFULEMsVUE4QkEsOEJBQVM7QUFDTkEsSUFBQUEsT0FBTyxFQUFFO0FBREgsR0FBVCxDLFVBU0EsOEJBQVM7QUFBRUYsSUFBQUEsSUFBSSxFQUFFLENBQUNDLDRCQUFEO0FBQVIsR0FBVCxDLGtEQTlGSkUsaUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQTBGYUMsVSxHQUFhLElBQUlDLG9CQUFKLEU7WUFFYkMsWSxHQUErQyx3QkFBVSxJQUFWLEM7Ozs7OztZQVdqREMsYyxHQUFpQixLOzs7Ozs7K0JBRVI7QUFDYixhQUFLQyxLQUFMLEdBQWEsS0FBS0MsTUFBbEI7O0FBQ0EsYUFBSyxJQUFNQyxTQUFYLElBQXdCLEtBQUtKLFlBQTdCLEVBQTJDO0FBQ3ZDLGNBQU1LLEtBQUssR0FBRyxLQUFLTCxZQUFMLENBQWtCSSxTQUFsQixDQUFkO0FBQ0FDLFVBQUFBLEtBQUssQ0FBQ0MsVUFBTixDQUFpQixLQUFLQyxJQUF0QjtBQUNIO0FBQ0o7Ozs4QkFFZTtBQUNaLFlBQUksQ0FBQ0Msd0JBQUQsSUFBWSxLQUFLQyxVQUFMLElBQW1CLENBQUMsS0FBS1IsY0FB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Q0FBQ2hELElBQXJCLElBQTZCK0MsS0FBSyxDQUFDRSxLQUFOLEtBQWdCRCxLQUFLLENBQUNDLEtBQTFFLENBQVA7QUFDSCIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiBDb3B5cmlnaHQgKGMpIDIwMTctMjAxOCBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC5cclxuXHJcbiBodHRwOi8vd3d3LmNvY29zLmNvbVxyXG5cclxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZW5naW5lIHNvdXJjZSBjb2RlICh0aGUgXCJTb2Z0d2FyZVwiKSwgYSBsaW1pdGVkLFxyXG4gIHdvcmxkd2lkZSwgcm95YWx0eS1mcmVlLCBub24tYXNzaWduYWJsZSwgcmV2b2NhYmxlIGFuZCBub24tZXhjbHVzaXZlIGxpY2Vuc2VcclxuIHRvIHVzZSBDb2NvcyBDcmVhdG9yIHNvbGVseSB0byBkZXZlbG9wIGdhbWVzIG9uIHlvdXIgdGFyZ2V0IHBsYXRmb3Jtcy4gWW91IHNoYWxsXHJcbiAgbm90IHVzZSBDb2NvcyBDcmVhdG9yIHNvZnR3YXJlIGZvciBkZXZlbG9waW5nIG90aGVyIHNvZnR3YXJlIG9yIHRvb2xzIHRoYXQnc1xyXG4gIHVzZWQgZm9yIGRldmVsb3BpbmcgZ2FtZXMuIFlvdSBhcmUgbm90IGdyYW50ZWQgdG8gcHVibGlzaCwgZGlzdHJpYnV0ZSxcclxuICBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgQ29jb3MgQ3JlYXRvci5cclxuXHJcbiBUaGUgc29mdHdhcmUgb3IgdG9vbHMgaW4gdGhpcyBMaWNlbnNlIEFncmVlbWVudCBhcmUgbGljZW5zZWQsIG5vdCBzb2xkLlxyXG4gWGlhbWVuIFlhamkgU29mdHdhcmUgQ28uLCBMdGQuIHJlc2VydmVzIGFsbCByaWdodHMgbm90IGV4cHJlc3NseSBncmFudGVkIHRvIHlvdS5cclxuXHJcbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuIFRIRSBTT0ZUV0FSRS5cclxuKi9cclxuXHJcbi8qKlxyXG4gKiBAY2F0ZWdvcnkgYW5pbWF0aW9uXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50cy9jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBjY2NsYXNzLCBleGVjdXRlSW5FZGl0TW9kZSwgZXhlY3V0aW9uT3JkZXIsIGhlbHAsIG1lbnUsIHByb3BlcnR5IH0gZnJvbSAnLi4vZGF0YS9jbGFzcy1kZWNvcmF0b3InO1xyXG5pbXBvcnQgeyBFdmVudGlmeSB9IGZyb20gJy4uL2V2ZW50L2V2ZW50aWZ5JztcclxuaW1wb3J0IHsgd2FybklEIH0gZnJvbSAnLi4vcGxhdGZvcm0vZGVidWcnO1xyXG5pbXBvcnQgKiBhcyBBcnJheVV0aWxzIGZyb20gJy4uL3V0aWxzL2FycmF5JztcclxuaW1wb3J0IHsgY3JlYXRlTWFwIH0gZnJvbSAnLi4vdXRpbHMvanMtdHlwZWQnO1xyXG5pbXBvcnQgeyBBbmltYXRpb25DbGlwIH0gZnJvbSAnLi9hbmltYXRpb24tY2xpcCc7XHJcbmltcG9ydCB7IEFuaW1hdGlvblN0YXRlLCBFdmVudFR5cGUgfSBmcm9tICcuL2FuaW1hdGlvbi1zdGF0ZSc7XHJcbmltcG9ydCB7IENyb3NzRmFkZSB9IGZyb20gJy4vY3Jvc3MtZmFkZSc7XHJcbmltcG9ydCB7IEVESVRPUiwgVEVTVCB9IGZyb20gJ2ludGVybmFsOmNvbnN0YW50cyc7XHJcblxyXG4vKipcclxuICogQGVuXHJcbiAqIEFuaW1hdGlvbiBjb21wb25lbnQgZ292ZXJucyBhIGdyb3VwIG9mIGFuaW1hdGlvbiBzdGF0ZXMgdG8gY29udHJvbCBwbGF5YmFjayBvZiB0aGUgc3RhdGVzLlxyXG4gKiBGb3IgY29udmVuaWVudCwgaXQgc3RvcmVzIGEgZ3JvdXAgb2YgYW5pbWF0aW9uIGNsaXBzLlxyXG4gKiBFYWNoIG9mIHRob3NlIGNsaXBzIHdvdWxkIGhhdmUgYW4gYXNzb2NpYXRlZCBhbmltYXRpb24gc3RhdGUgdW5pcXVlbHkgY3JlYXRlZC5cclxuICogQW5pbWF0aW9uIGNvbXBvbmVudCBpcyBldmVudGZ1bCwgaXQgZGlzcGF0Y2ggYSBzZXJpYWxzIHBsYXliYWNrIHN0YXR1cyBldmVudHMuXHJcbiAqIFNlZSBbW0V2ZW50VHlwZV1dLlxyXG4gKiBAemhcclxuICog5Yqo55S757uE5Lu2566h55CG5LiA57uE5Yqo55S754q25oCB77yM5o6n5Yi25a6D5Lus55qE5pKt5pS+44CCXHJcbiAqIOS4uuS6huaWueS+v++8jOWKqOeUu+e7hOS7tui/mOWtmOWCqOS6huS4gOe7hOWKqOeUu+WJqui+keOAglxyXG4gKiDmr4/kuKrliarovpHpg73kvJrni6zoh6rliJvlu7rkuIDkuKrlhbPogZTnmoTliqjnlLvnirbmgIHlr7nosaHjgIJcclxuICog5Yqo55S757uE5Lu25YW35pyJ5LqL5Lu254m55oCn77yM5a6D5Lya5rS+5Y+R5LiA57O75YiX5pKt5pS+54q25oCB55u45YWz55qE5LqL5Lu244CCXHJcbiAqIOWPguiAgyBbW0V2ZW50VHlwZV1dXHJcbiAqL1xyXG5AY2NjbGFzcygnY2MuQW5pbWF0aW9uQ29tcG9uZW50JylcclxuQGhlbHAoJ2kxOG46Y2MuQW5pbWF0aW9uQ29tcG9uZW50JylcclxuQGV4ZWN1dGlvbk9yZGVyKDk5KVxyXG5AZXhlY3V0ZUluRWRpdE1vZGVcclxuQG1lbnUoJ0NvbXBvbmVudHMvQW5pbWF0aW9uJylcclxuZXhwb3J0IGNsYXNzIEFuaW1hdGlvbkNvbXBvbmVudCBleHRlbmRzIEV2ZW50aWZ5KENvbXBvbmVudCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIEdldHMgb3Igc2V0cyBjbGlwcyB0aGlzIGNvbXBvbmVudCBnb3Zlcm5zLlxyXG4gICAgICogV2hlbiBzZXQsIGFzc29jaWF0ZWQgYW5pbWF0aW9uIHN0YXRlIG9mIGVhY2ggZXhpc3RpbmcgY2xpcCB3aWxsIGJlIHN0b3BwZWQuXHJcbiAgICAgKiBJZiB0aGUgZXhpc3RpbmcgZGVmYXVsdCBjbGlwIGlzIG5vdCBpbiB0aGUgc2V0IG9mIG5ldyBjbGlwcywgZGVmYXVsdCBjbGlwIHdpbGwgYmUgcmVzZXQgdG8gbnVsbC5cclxuICAgICAqIEB6aFxyXG4gICAgICog6I635Y+W5oiW6K6+572u5q2k57uE5Lu2566h55CG55qE5Ymq6L6R44CCXHJcbiAgICAgKiDorr7nva7ml7bvvIzlt7LmnInliarovpHlhbPogZTnmoTliqjnlLvnirbmgIHlsIbooqvlgZzmraLvvJvoi6Xpu5jorqTliarovpHkuI3lnKjmlrDnmoTliqjnlLvliarovpHkuK3vvIzlsIbooqvph43nva7kuLrnqbrjgIJcclxuICAgICAqL1xyXG4gICAgQHByb3BlcnR5KHtcclxuICAgICAgICB0eXBlOiBbQW5pbWF0aW9uQ2xpcF0sXHJcbiAgICAgICAgdG9vbHRpcDogJ+atpOWKqOeUu+e7hOS7tueuoeeQhueahOWKqOeUu+WJqui+kScsXHJcbiAgICB9KVxyXG4gICAgZ2V0IGNsaXBzICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2xpcHM7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IGNsaXBzICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jcm9zc0ZhZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fY3Jvc3NGYWRlLmNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBzdGF0ZSBmb3Igb2xkIGF1dG9tYXRpYyBjbGlwcy5cclxuICAgICAgICBmb3IgKGNvbnN0IGNsaXAgb2YgdGhpcy5fY2xpcHMpIHtcclxuICAgICAgICAgICAgaWYgKGNsaXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN0YXRlT2ZBdXRvbWF0aWNDbGlwKGNsaXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENyZWF0ZSBzdGF0ZSBmb3IgbmV3IGNsaXBzLlxyXG4gICAgICAgIGZvciAoY29uc3QgY2xpcCBvZiB2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAoY2xpcCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVTdGF0ZShjbGlwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEZWZhdWx0IGNsaXAgc2hvdWxkIGJlIGluIHRoZSBsaXN0IG9mIGF1dG9tYXRpYyBjbGlwcy5cclxuICAgICAgICBjb25zdCBuZXdEZWZhdWx0Q2xpcCA9IHZhbHVlLmZpbmQoKGNsaXApID0+IGVxdWFsQ2xpcHMoY2xpcCwgdGhpcy5fZGVmYXVsdENsaXApKTtcclxuICAgICAgICBpZiAobmV3RGVmYXVsdENsaXApIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdENsaXAgPSBuZXdEZWZhdWx0Q2xpcDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9kZWZhdWx0Q2xpcCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9jbGlwcyA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGRlZmF1bHQgY2xpcC5cclxuICAgICAqIEBlblxyXG4gICAgICog6I635Y+W5oiW6K6+572u6buY6K6k5Ymq6L6R44CCXHJcbiAgICAgKiDorr7nva7ml7bvvIzoi6XmjIflrprnmoTliarovpHkuI3lnKggYHRoaXMuY2xpcHNgIOS4reWImeS8muiiq+iHquWKqOa3u+WKoOiHsyBgdGhpcy5jbGlwc2DjgIJcclxuICAgICAqIEBzZWUgW1twbGF5T25Mb2FkXV1cclxuICAgICAqL1xyXG4gICAgQHByb3BlcnR5KHtcclxuICAgICAgICB0eXBlOiBBbmltYXRpb25DbGlwLFxyXG4gICAgICAgIHRvb2x0aXA6ICfpu5jorqTliqjnlLvliarovpEnLFxyXG4gICAgfSlcclxuICAgIGdldCBkZWZhdWx0Q2xpcCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRDbGlwO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBkZWZhdWx0Q2xpcCAodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9kZWZhdWx0Q2xpcCA9IHZhbHVlO1xyXG4gICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpc0JvdW5kZWREZWZhdWx0Q2xpcCA9IHRoaXMuX2NsaXBzLmZpbmRJbmRleCgoY2xpcCkgPT4gZXF1YWxDbGlwcyhjbGlwLCB2YWx1ZSkpID49IDA7XHJcbiAgICAgICAgaWYgKCFpc0JvdW5kZWREZWZhdWx0Q2xpcCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jbGlwcy5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVTdGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgRXZlbnRUeXBlID0gRXZlbnRUeXBlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBkZWZhdWx0IGNsaXAgc2hvdWxkIGdldCBpbnRvIHBsYXlpbmcgd2hlbiB0aGlzIGNvbXBvbmVudHMgc3RhcnRzLlxyXG4gICAgICogTm90ZSwgdGhpcyBmaWVsZCB0YWtlcyBubyBlZmZlY3QgaWYgYGNyb3NzRmFkZSgpYCBvciBgcGxheSgpYCBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcG9uZW50IHN0YXJ0cy5cclxuICAgICAqIEB6aFxyXG4gICAgICog5piv5ZCm5Zyo57uE5Lu25byA5aeL6L+Q6KGM5pe26Ieq5Yqo5pKt5pS+6buY6K6k5Ymq6L6R44CCXHJcbiAgICAgKiDms6jmhI/vvIzoi6XlnKjnu4Tku7blvIDlp4vov5DooYzliY3osIPnlKjkuoYgYGNyb3NzRmFkZWAg5oiWIGBwbGF5KClg77yM5q2k5a2X5q615bCG5LiN5Lya55Sf5pWI44CCXHJcbiAgICAgKi9cclxuICAgIEBwcm9wZXJ0eSh7XHJcbiAgICAgICAgdG9vbHRpcDogJ+aYr+WQpuWcqOWKqOeUu+e7hOS7tuW8gOWni+i/kOihjOaXtuiHquWKqOaSreaUvum7mOiupOWKqOeUu+WJqui+kScsXHJcbiAgICB9KVxyXG4gICAgcHVibGljIHBsYXlPbkxvYWQgPSBmYWxzZTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2Nyb3NzRmFkZSA9IG5ldyBDcm9zc0ZhZGUoKTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX25hbWVUb1N0YXRlOiBSZWNvcmQ8c3RyaW5nLCBBbmltYXRpb25TdGF0ZT4gPSBjcmVhdGVNYXAodHJ1ZSk7XHJcblxyXG4gICAgQHByb3BlcnR5KHsgdHlwZTogW0FuaW1hdGlvbkNsaXBdIH0pXHJcbiAgICBwcm90ZWN0ZWQgX2NsaXBzOiAoQW5pbWF0aW9uQ2xpcCB8IG51bGwpW10gPSBbXTtcclxuXHJcbiAgICBAcHJvcGVydHlcclxuICAgIHByb3RlY3RlZCBfZGVmYXVsdENsaXA6IEFuaW1hdGlvbkNsaXAgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgaWYgYGNyb3NzRmFkZSgpYCBvciBgcGxheSgpYCBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcG9uZW50IHN0YXJ0cy5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfaGFzQmVlblBsYXllZCA9IGZhbHNlO1xyXG5cclxuICAgIHB1YmxpYyBvbkxvYWQgKCkge1xyXG4gICAgICAgIHRoaXMuY2xpcHMgPSB0aGlzLl9jbGlwcztcclxuICAgICAgICBmb3IgKGNvbnN0IHN0YXRlTmFtZSBpbiB0aGlzLl9uYW1lVG9TdGF0ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX25hbWVUb1N0YXRlW3N0YXRlTmFtZV07XHJcbiAgICAgICAgICAgIHN0YXRlLmluaXRpYWxpemUodGhpcy5ub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXJ0ICgpIHtcclxuICAgICAgICBpZiAoIUVESVRPUiAmJiAodGhpcy5wbGF5T25Mb2FkICYmICF0aGlzLl9oYXNCZWVuUGxheWVkKSAmJiB0aGlzLl9kZWZhdWx0Q2xpcCkge1xyXG4gICAgICAgICAgICB0aGlzLmNyb3NzRmFkZSh0aGlzLl9kZWZhdWx0Q2xpcC5uYW1lLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uRW5hYmxlICgpIHtcclxuICAgICAgICB0aGlzLl9jcm9zc0ZhZGUucmVzdW1lKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uRGlzYWJsZSAoKSB7XHJcbiAgICAgICAgdGhpcy5fY3Jvc3NGYWRlLnBhdXNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uRGVzdHJveSAoKSB7XHJcbiAgICAgICAgdGhpcy5fY3Jvc3NGYWRlLnN0b3AoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5fbmFtZVRvU3RhdGUpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9uYW1lVG9TdGF0ZVtuYW1lXTtcclxuICAgICAgICAgICAgc3RhdGUuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9uYW1lVG9TdGF0ZSA9IGNyZWF0ZU1hcCh0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogU3dpdGNoIHRvIHBsYXkgc3BlY2lmaWVkIGFuaW1hdGlvbiBzdGF0ZSwgd2l0aG91dCBmYWRpbmcuXHJcbiAgICAgKiBAemhcclxuICAgICAqIOeri+WNs+WIh+aNouWIsOaMh+WumuWKqOeUu+eKtuaAgeOAglxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBiZSBwbGF5ZWQsIGlmIGFic2VudCwgdGhlIGRlZmF1bHQgY2xpcCB3aWxsIGJlIHBsYXllZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcGxheSAobmFtZT86IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX2hhc0JlZW5QbGF5ZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmICghbmFtZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RlZmF1bHRDbGlwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5fZGVmYXVsdENsaXAubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNyb3NzRmFkZShuYW1lLCAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogU21vb3RobHkgc3dpdGNoIHRvIHBsYXkgc3BlY2lmaWVkIGFuaW1hdGlvbiBzdGF0ZS5cclxuICAgICAqIEB6blxyXG4gICAgICog5bmz5ruR5Zyw5YiH5o2i5Yiw5oyH5a6a5Yqo55S754q25oCB44CCXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHN3aXRjaCB0b1xyXG4gICAgICogQHBhcmFtIGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgY3Jvc3MgZmFkZSwgZGVmYXVsdCB2YWx1ZSBpcyAwLjNzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjcm9zc0ZhZGUgKG5hbWU6IHN0cmluZywgZHVyYXRpb24gPSAwLjMpIHtcclxuICAgICAgICB0aGlzLl9oYXNCZWVuUGxheWVkID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX25hbWVUb1N0YXRlW25hbWVdO1xyXG4gICAgICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jcm9zc0ZhZGUucGxheSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9jcm9zc0ZhZGUuY3Jvc3NGYWRlKHN0YXRlLCBkdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBQYXVzZSBhbGwgYW5pbWF0aW9uIHN0YXRlcyBhbmQgYWxsIHN3aXRjaGluZy5cclxuICAgICAqIEB6aFxyXG4gICAgICog5pqC5YGc5omA5pyJ5Yqo55S754q25oCB77yM5bm25pqC5YGc5omA5pyJ5YiH5o2i44CCXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwYXVzZSAoKSB7XHJcbiAgICAgICAgdGhpcy5fY3Jvc3NGYWRlLnBhdXNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIFJlc3VtZSBhbGwgYW5pbWF0aW9uIHN0YXRlcyBhbmQgYWxsIHN3aXRjaGluZy5cclxuICAgICAqIEB6aFxyXG4gICAgICog5oGi5aSN5omA5pyJ5Yqo55S754q25oCB77yM5bm25oGi5aSN5omA5pyJ5YiH5o2i44CCXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXN1bWUgKCkge1xyXG4gICAgICAgIHRoaXMuX2Nyb3NzRmFkZS5yZXN1bWUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogU3RvcCBhbGwgYW5pbWF0aW9uIHN0YXRlcyBhbmQgYWxsIHN3aXRjaGluZy5cclxuICAgICAqIEB6aFxyXG4gICAgICog5YGc5q2i5omA5pyJ5Yqo55S754q25oCB77yM5bm25YGc5q2i5omA5pyJ5YiH5o2i44CCXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdG9wICgpIHtcclxuICAgICAgICB0aGlzLl9jcm9zc0ZhZGUuc3RvcCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBHZXQgc3BlY2lmaWVkIGFuaW1hdGlvbiBzdGF0ZS5cclxuICAgICAqIEB6aFxyXG4gICAgICog6I635Y+W5oyH5a6a55qE5Yqo55S754q25oCB44CCXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFtbZ2V0U3RhdGVdXVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0QW5pbWF0aW9uU3RhdGUgKG5hbWU6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlKG5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBHZXQgc3BlY2lmaWVkIGFuaW1hdGlvbiBzdGF0ZS5cclxuICAgICAqIEB6aFxyXG4gICAgICog6I635Y+W5oyH5a6a55qE5Yqo55S754q25oCB44CCXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKiBAcmV0dXJucyBJZiBubyBhbmltYXRpb24gZm91bmQsIHJldHVybiBudWxsLCBvdGhlcndpc2UgdGhlIGNvcnJlc3BvbmQgYW5pbWF0aW9uIHN0YXRlIGlzIHJldHVybmVkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRTdGF0ZSAobmFtZTogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9uYW1lVG9TdGF0ZVtuYW1lXTtcclxuICAgICAgICBpZiAoc3RhdGUgJiYgIXN0YXRlLmN1cnZlTG9hZGVkKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmluaXRpYWxpemUodGhpcy5ub2RlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlIHx8IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIENyZWF0ZXMgYSBzdGF0ZSBmb3Igc3BlY2lmaWVkIGNsaXAuXHJcbiAgICAgKiBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgY2xpcCB3aXRoIHNhbWUgbmFtZSwgdGhlIGV4aXN0aW5nIGFuaW1hdGlvbiBzdGF0ZSB3aWxsIGJlIHN0b3BwZWQgYW5kIG92ZXJyaWRkZW4uXHJcbiAgICAgKiBAemhcclxuICAgICAqIOS9v+eUqOaMh+WumueahOWKqOeUu+WJqui+keWIm+W7uuS4gOS4quWKqOeUu+eKtuaAgeOAglxyXG4gICAgICog6Iul5oyH5a6a5ZCN56ew55qE5Yqo55S754q25oCB5bey5a2Y5Zyo77yM5bey5a2Y5Zyo55qE5Yqo55S754q25oCB5bCG5YWI6KKr6K6+5Li65YGc5q2i5bm26KKr6KaG55uW44CCXHJcbiAgICAgKiBAcGFyYW0gY2xpcCBUaGUgYW5pbWF0aW9uIGNsaXBcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBhbmltYXRpb24gc3RhdGUgbmFtZSwgaWYgYWJzZW50LCB0aGUgZGVmYXVsdCBjbGlwJ3MgbmFtZSB3aWxsIGJlIHVzZWRcclxuICAgICAqIEByZXR1cm5zIFRoZSBhbmltYXRpb24gc3RhdGUgY3JlYXRlZFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgY3JlYXRlU3RhdGUgKGNsaXA6IEFuaW1hdGlvbkNsaXAsIG5hbWU/OiBzdHJpbmcpIHtcclxuICAgICAgICBuYW1lID0gbmFtZSB8fCBjbGlwLm5hbWU7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVTdGF0ZShuYW1lKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvQ3JlYXRlU3RhdGUoY2xpcCwgbmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIFN0b3BzIGFuZCByZW1vdmVzIHNwZWNpZmllZCBjbGlwLlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDlgZzmraLlubbnp7vpmaTmjIflrprnmoTliqjnlLvnirbmgIHjgIJcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gc3RhdGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZVN0YXRlIChuYW1lOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX25hbWVUb1N0YXRlW25hbWVdO1xyXG4gICAgICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgICAgICBzdGF0ZS5hbGxvd0xhc3RGcmFtZUV2ZW50KGZhbHNlKTtcclxuICAgICAgICAgICAgc3RhdGUuc3RvcCgpO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbmFtZVRvU3RhdGVbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICog5re75Yqg5LiA5Liq5Yqo55S75Ymq6L6R5YiwIGB0aGlzLmNsaXBzYOS4reW5tuS7peatpOWJqui+keWIm+W7uuWKqOeUu+eKtuaAgeOAglxyXG4gICAgICogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSBbW2NyZWF0ZVN0YXRlXV1cclxuICAgICAqIEBwYXJhbSBjbGlwIFRoZSBhbmltYXRpb24gY2xpcFxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIGFuaW1hdGlvbiBzdGF0ZSBuYW1lLCBpZiBhYnNlbnQsIHRoZSBkZWZhdWx0IGNsaXAncyBuYW1lIHdpbGwgYmUgdXNlZFxyXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgYW5pbWF0aW9uIHN0YXRlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRDbGlwIChjbGlwOiBBbmltYXRpb25DbGlwLCBuYW1lPzogc3RyaW5nKTogQW5pbWF0aW9uU3RhdGUge1xyXG4gICAgICAgIGlmICghQXJyYXlVdGlscy5jb250YWlucyh0aGlzLl9jbGlwcywgY2xpcCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2xpcHMucHVzaChjbGlwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU3RhdGUoY2xpcCwgbmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIFJlbW92ZSBjbGlwIGZyb20gdGhlIGFuaW1hdGlvbiBsaXN0LiBUaGlzIHdpbGwgcmVtb3ZlIHRoZSBjbGlwIGFuZCBhbnkgYW5pbWF0aW9uIHN0YXRlcyBiYXNlZCBvbiBpdC48YnI+XHJcbiAgICAgKiBJZiB0aGVyZSBhcmUgYW5pbWF0aW9uIHN0YXRlcyBkZXBlbmQgb24gdGhlIGNsaXAgYXJlIHBsYXlpbmcgb3IgY2xpcCBpcyBkZWZhdWx0Q2xpcCwgaXQgd2lsbCBub3QgZGVsZXRlIHRoZSBjbGlwLjxicj5cclxuICAgICAqIEJ1dCBpZiBmb3JjZSBpcyB0cnVlLCB0aGVuIHdpbGwgYWx3YXlzIHJlbW92ZSB0aGUgY2xpcCBhbmQgYW55IGFuaW1hdGlvbiBzdGF0ZXMgYmFzZWQgb24gaXQuIElmIGNsaXAgaXMgZGVmYXVsdENsaXAsIGRlZmF1bHRDbGlwIHdpbGwgYmUgcmVzZXQgdG8gbnVsbFxyXG4gICAgICogQHpoXHJcbiAgICAgKiDku47liqjnlLvliJfooajkuK3np7vpmaTmjIflrprnmoTliqjnlLvliarovpHvvIw8YnIvPlxyXG4gICAgICog5aaC5p6c5L6d6LWW5LqOIGNsaXAg55qEIEFuaW1hdGlvblN0YXRlIOato+WcqOaSreaUvuaIluiAhSBjbGlwIOaYryBkZWZhdWx0Q2xpcCDnmoTor53vvIzpu5jorqTmmK/kuI3kvJrliKDpmaQgY2xpcCDnmoTjgII8YnIvPlxyXG4gICAgICog5L2G5piv5aaC5p6cIGZvcmNlIOWPguaVsOS4uiB0cnVl77yM5YiZ5Lya5by65Yi25YGc5q2i6K+l5Yqo55S777yM54S25ZCO56e76Zmk6K+l5Yqo55S75Ymq6L6R5ZKM55u45YWz55qE5Yqo55S744CC6L+Z5pe25YCZ5aaC5p6cIGNsaXAg5pivIGRlZmF1bHRDbGlw77yMZGVmYXVsdENsaXAg5bCG5Lya6KKr6YeN572u5Li6IG51bGzjgII8YnIvPlxyXG4gICAgICogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSBbW3JlbW92ZVN0YXRlXV1cclxuICAgICAqIEBwYXJhbSBmb3JjZSAtIElmIGZvcmNlIGlzIHRydWUsIHRoZW4gd2lsbCBhbHdheXMgcmVtb3ZlIHRoZSBjbGlwIGFuZCBhbnkgYW5pbWF0aW9uIHN0YXRlcyBiYXNlZCBvbiBpdC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZUNsaXAgKGNsaXA6IEFuaW1hdGlvbkNsaXAsIGZvcmNlPzogYm9vbGVhbikge1xyXG4gICAgICAgIGxldCByZW1vdmFsU3RhdGU6IEFuaW1hdGlvblN0YXRlIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLl9uYW1lVG9TdGF0ZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX25hbWVUb1N0YXRlW25hbWVdO1xyXG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNsaXAgPSBzdGF0ZS5jbGlwO1xyXG4gICAgICAgICAgICBpZiAoc3RhdGVDbGlwID09PSBjbGlwKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmFsU3RhdGUgPSBzdGF0ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2xpcCA9PT0gdGhpcy5fZGVmYXVsdENsaXApIHtcclxuICAgICAgICAgICAgaWYgKGZvcmNlKSB7IHRoaXMuX2RlZmF1bHRDbGlwID0gbnVsbDsgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghVEVTVCkgeyB3YXJuSUQoMzkwMik7IH1cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlbW92YWxTdGF0ZSAmJiByZW1vdmFsU3RhdGUuaXNQbGF5aW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChmb3JjZSkgeyByZW1vdmFsU3RhdGUuc3RvcCgpOyB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFURVNUKSB7IHdhcm5JRCgzOTAzKTsgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9jbGlwcyA9IHRoaXMuX2NsaXBzLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAhPT0gY2xpcCk7XHJcblxyXG4gICAgICAgIGlmIChyZW1vdmFsU3RhdGUpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX25hbWVUb1N0YXRlW3JlbW92YWxTdGF0ZS5uYW1lXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIFJlZ2lzdGVyIGFuaW1hdGlvbiBldmVudCBjYWxsYmFjay48Ymc+XHJcbiAgICAgKiBUaGUgZXZlbnQgYXJndW1lbnRzIHdpbGwgcHJvdmlkZSB0aGUgQW5pbWF0aW9uU3RhdGUgd2hpY2ggZW1pdCB0aGUgZXZlbnQuPGJnPlxyXG4gICAgICogV2hlbiBwbGF5IGFuIGFuaW1hdGlvbiwgd2lsbCBhdXRvIHJlZ2lzdGVyIHRoZSBldmVudCBjYWxsYmFjayB0byB0aGUgQW5pbWF0aW9uU3RhdGUsPGJnPlxyXG4gICAgICogYW5kIHVucmVnaXN0ZXIgdGhlIGV2ZW50IGNhbGxiYWNrIGZyb20gdGhlIEFuaW1hdGlvblN0YXRlIHdoZW4gYW5pbWF0aW9uIHN0b3BwZWQuXHJcbiAgICAgKiBAemhcclxuICAgICAqIOazqOWGjOWKqOeUu+S6i+S7tuWbnuiwg+OAgjxiZz5cclxuICAgICAqIOWbnuiwg+eahOS6i+S7tumHjOWwhuS8mumZhOS4iuWPkemAgeS6i+S7tueahCBBbmltYXRpb25TdGF0ZeOAgjxiZz5cclxuICAgICAqIOW9k+aSreaUvuS4gOS4quWKqOeUu+aXtu+8jOS8muiHquWKqOWwhuS6i+S7tuazqOWGjOWIsOWvueW6lOeahCBBbmltYXRpb25TdGF0ZSDkuIrvvIzlgZzmraLmkq3mlL7ml7bkvJrlsIbkuovku7bku47ov5nkuKogQW5pbWF0aW9uU3RhdGUg5LiK5Y+W5raI5rOo5YaM44CCXHJcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gdG9cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgd2hlbiBldmVudCB0cmlnZ2VyZWRcclxuICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIGNhbGxlZSB3aGVuIGludm9rZSB0aGUgY2FsbGJhY2ssIGNvdWxkIGJlIGFic2VudFxyXG4gICAgICogQHJldHVybiBUaGUgcmVnaXN0ZXJlZCBjYWxsYmFja1xyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIG9uUGxheTogZnVuY3Rpb24gKHR5cGUsIHN0YXRlKSB7XHJcbiAgICAgKiAgICAgLy8gY2FsbGJhY2tcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiAvLyByZWdpc3RlciBldmVudCB0byBhbGwgYW5pbWF0aW9uXHJcbiAgICAgKiBhbmltYXRpb24ub24oJ3BsYXknLCB0aGlzLm9uUGxheSwgdGhpcyk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcHVibGljIG9uPFRGdW5jdGlvbiBleHRlbmRzIEZ1bmN0aW9uPiAodHlwZTogRXZlbnRUeXBlLCBjYWxsYmFjazogVEZ1bmN0aW9uLCB0aGlzQXJnPzogYW55LCBvbmNlPzogYm9vbGVhbikge1xyXG4gICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLm9uKHR5cGUsIGNhbGxiYWNrLCB0aGlzQXJnLCBvbmNlKTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gRXZlbnRUeXBlLkxBU1RGUkFNRSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zeW5jQWxsb3dMYXN0RnJhbWVFdmVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbmNlPFRGdW5jdGlvbiBleHRlbmRzIEZ1bmN0aW9uPiAodHlwZTogRXZlbnRUeXBlLCBjYWxsYmFjazogVEZ1bmN0aW9uLCB0aGlzQXJnPzogYW55KSB7XHJcbiAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIub25jZSh0eXBlLCBjYWxsYmFjaywgdGhpc0FyZyk7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IEV2ZW50VHlwZS5MQVNURlJBTUUpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3luY0FsbG93TGFzdEZyYW1lRXZlbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogVW5yZWdpc3RlciBhbmltYXRpb24gZXZlbnQgY2FsbGJhY2suXHJcbiAgICAgKiBAemhcclxuICAgICAqIOWPlua2iOazqOWGjOWKqOeUu+S6i+S7tuWbnuiwg+OAglxyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGV2ZW50IHR5cGUgdG8gdW5yZWdpc3RlclxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIHVucmVnaXN0ZXJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGhlIGNhbGxlZSBvZiB0aGUgY2FsbGJhY2ssIGNvdWxkIGJlIGFic2VudFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIC8vIHVucmVnaXN0ZXIgZXZlbnQgdG8gYWxsIGFuaW1hdGlvblxyXG4gICAgICogYW5pbWF0aW9uLm9mZigncGxheScsIHRoaXMub25QbGF5LCB0aGlzKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgb2ZmICh0eXBlOiBFdmVudFR5cGUsIGNhbGxiYWNrPzogRnVuY3Rpb24sIHRoaXNBcmc/OiBhbnkpIHtcclxuICAgICAgICBzdXBlci5vZmYodHlwZSwgY2FsbGJhY2ssIHRoaXNBcmcpO1xyXG4gICAgICAgIGlmICh0eXBlID09PSBFdmVudFR5cGUuTEFTVEZSQU1FKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N5bmNEaXNhbGxvd0xhc3RGcmFtZUV2ZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfY3JlYXRlU3RhdGUgKGNsaXA6IEFuaW1hdGlvbkNsaXAsIG5hbWU/OiBzdHJpbmcpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvblN0YXRlKGNsaXAsIG5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfZG9DcmVhdGVTdGF0ZSAoY2xpcDogQW5pbWF0aW9uQ2xpcCwgbmFtZTogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9jcmVhdGVTdGF0ZShjbGlwLCBuYW1lKTtcclxuICAgICAgICBzdGF0ZS5fc2V0RXZlbnRUYXJnZXQodGhpcyk7XHJcbiAgICAgICAgc3RhdGUuYWxsb3dMYXN0RnJhbWVFdmVudCh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkxBU1RGUkFNRSkpO1xyXG4gICAgICAgIGlmICh0aGlzLm5vZGUpIHtcclxuICAgICAgICAgICAgc3RhdGUuaW5pdGlhbGl6ZSh0aGlzLm5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9uYW1lVG9TdGF0ZVtzdGF0ZS5uYW1lXSA9IHN0YXRlO1xyXG4gICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9nZXRTdGF0ZUJ5TmFtZU9yRGVmYXVsdENsaXAgKG5hbWU/OiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAoIW5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kZWZhdWx0Q2xpcCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuYW1lID0gdGhpcy5fZGVmYXVsdENsaXAubmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX25hbWVUb1N0YXRlW25hbWVdO1xyXG4gICAgICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3JlbW92ZVN0YXRlT2ZBdXRvbWF0aWNDbGlwIChjbGlwOiBBbmltYXRpb25DbGlwKSB7XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOmZvcmluXHJcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMuX25hbWVUb1N0YXRlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fbmFtZVRvU3RhdGVbbmFtZV07XHJcbiAgICAgICAgICAgIGlmIChlcXVhbENsaXBzKGNsaXAsIHN0YXRlLmNsaXApKSB7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbmFtZVRvU3RhdGVbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfc3luY0FsbG93TGFzdEZyYW1lRXZlbnQgKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkxBU1RGUkFNRSkpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBzdGF0ZU5hbWUgaW4gdGhpcy5fbmFtZVRvU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX25hbWVUb1N0YXRlW3N0YXRlTmFtZV0uYWxsb3dMYXN0RnJhbWVFdmVudCh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9zeW5jRGlzYWxsb3dMYXN0RnJhbWVFdmVudCAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmhhc0V2ZW50TGlzdGVuZXIoRXZlbnRUeXBlLkxBU1RGUkFNRSkpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBzdGF0ZU5hbWUgaW4gdGhpcy5fbmFtZVRvU3RhdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX25hbWVUb1N0YXRlW3N0YXRlTmFtZV0uYWxsb3dMYXN0RnJhbWVFdmVudChmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBuYW1lc3BhY2UgQW5pbWF0aW9uQ29tcG9uZW50IHtcclxuICAgIGV4cG9ydCB0eXBlIEV2ZW50VHlwZSA9IEVudW1BbGlhczx0eXBlb2YgRXZlbnRUeXBlPjtcclxufVxyXG5cclxuY2MuQW5pbWF0aW9uQ29tcG9uZW50ID0gQW5pbWF0aW9uQ29tcG9uZW50O1xyXG5cclxuZnVuY3Rpb24gZXF1YWxDbGlwcyAoY2xpcDE6IEFuaW1hdGlvbkNsaXAgfCBudWxsLCBjbGlwMjogQW5pbWF0aW9uQ2xpcCB8IG51bGwpIHtcclxuICAgIGlmIChjbGlwMSA9PT0gY2xpcDIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiAhIWNsaXAxICYmICEhY2xpcDIgJiYgKGNsaXAxLm5hbWUgPT09IGNsaXAyLm5hbWUgfHwgY2xpcDEuX3V1aWQgPT09IGNsaXAyLl91dWlkKTtcclxufVxyXG4iXX0=