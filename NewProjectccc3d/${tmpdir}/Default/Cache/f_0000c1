(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "../data/class-decorator.js", "../math/index.js", "../platform/event-manager/event-enum.js", "../platform/event-manager/event-manager.js", "./base-node.js", "./layers.js", "./node-enum.js", "./node-ui-properties.js"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("../data/class-decorator.js"), require("../math/index.js"), require("../platform/event-manager/event-enum.js"), require("../platform/event-manager/event-manager.js"), require("./base-node.js"), require("./layers.js"), require("./node-enum.js"), require("./node-ui-properties.js"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.classDecorator, global.index, global.eventEnum, global.eventManager, global.baseNode, global.layers, global.nodeEnum, global.nodeUiProperties);
    global.node = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _classDecorator, _index, _eventEnum, _eventManager, _baseNode, _layers, _nodeEnum, _nodeUiProperties) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.Node = void 0;

  var _dec, _dec2, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _class3, _temp;

  function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

  function _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }

  var v3_a = new _index.Vec3();
  var q_a = new _index.Quat();
  var q_b = new _index.Quat();
  var array_a = new Array(10);
  var qt_1 = new _index.Quat();
  var m3_1 = new _index.Mat3();
  var m3_scaling = new _index.Mat3();
  var m4_1 = new _index.Mat4();
  var bookOfChange = new Map();
  /**
   * @zh
   * 场景树中的基本节点，基本特性有：
   * * 具有层级关系
   * * 持有各类组件
   * * 维护空间变换（坐标、旋转、缩放）信息
   */

  /**
   * !#en
   * Class of all entities in Cocos Creator scenes.
   * Basic functionalities include:
   * * Hierarchy management with parent and children
   * * Components management
   * * Coordinate system with position, scale, rotation in 3d space
   * !#zh
   * Cocos Creator 场景中的所有节点类。
   * 基本特性有：
   * * 具有层级关系
   * * 持有各类组件
   * * 维护 3D 空间左边变换（坐标、旋转、缩放）信息
   */

  var Node = (_dec = (0, _classDecorator.ccclass)('cc.Node'), _dec2 = (0, _classDecorator.property)({
    type: _index.Vec3
  }), _dec(_class = (_class2 = (_temp = _class3 = /*#__PURE__*/function (_BaseNode) {
    _inherits(Node, _BaseNode);

    function Node() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, Node);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Node)).call.apply(_getPrototypeOf2, [this].concat(args)));
      _this._uiProps = new _nodeUiProperties.NodeUIProperties(_assertThisInitialized(_this));
      _this._static = false;
      _this._pos = new _index.Vec3();
      _this._rot = new _index.Quat();
      _this._scale = new _index.Vec3(1, 1, 1);
      _this._mat = new _index.Mat4();

      _initializerDefineProperty(_this, "_lpos", _descriptor, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_lrot", _descriptor2, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_lscale", _descriptor3, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_layer", _descriptor4, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_euler", _descriptor5, _assertThisInitialized(_this));

      _this._dirtyFlags = _nodeEnum.TransformBit.NONE;
      _this._eulerDirty = false;
      return _this;
    }

    _createClass(Node, [{
      key: "setParent",
      // ===============================
      // hierarchy
      // ===============================

      /**
       * @en Set parent of the node.
       * @zh 设置该节点的父节点。
       * @param value Parent node
       * @param keepWorldTransform Whether keep node's current world transform unchanged after this operation
       */
      value: function setParent(value) {
        var keepWorldTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (keepWorldTransform) {
          this.updateWorldTransform();
        }

        _get(_getPrototypeOf(Node.prototype), "setParent", this).call(this, value, keepWorldTransform);
      }
    }, {
      key: "_onSetParent",
      value: function _onSetParent(oldParent, keepWorldTransform) {
        _get(_getPrototypeOf(Node.prototype), "_onSetParent", this).call(this, oldParent, keepWorldTransform);

        if (keepWorldTransform) {
          var parent = this._parent;

          if (parent) {
            parent.updateWorldTransform();

            _index.Mat4.multiply(m4_1, _index.Mat4.invert(m4_1, parent._mat), this._mat);

            _index.Mat4.toRTS(m4_1, this._lrot, this._lpos, this._lscale);
          } else {
            _index.Vec3.copy(this._lpos, this._pos);

            _index.Quat.copy(this._lrot, this._rot);

            _index.Vec3.copy(this._lscale, this._scale);
          }

          this._eulerDirty = true;
        }

        this.invalidateChildren(_nodeEnum.TransformBit.TRS);
      }
    }, {
      key: "_onBatchCreated",
      value: function _onBatchCreated() {
        _get(_getPrototypeOf(Node.prototype), "_onBatchCreated", this).call(this);

        bookOfChange.set(this._id, _nodeEnum.TransformBit.TRS);
        this._dirtyFlags = _nodeEnum.TransformBit.TRS;
        var len = this._children.length;

        for (var i = 0; i < len; ++i) {
          this._children[i]._onBatchCreated();
        }
      }
    }, {
      key: "_onBatchRestored",
      value: function _onBatchRestored() {
        this._onBatchCreated();
      }
    }, {
      key: "_onBeforeSerialize",
      value: function _onBeforeSerialize() {
        // tslint:disable-next-line: no-unused-expression
        this.eulerAngles; // make sure we save the correct eulerAngles
      } // ===============================
      // transform helper, convenient but not the most efficient
      // ===============================

      /**
       * @en Perform a translation on the node
       * @zh 移动节点
       * @param trans The increment on position
       * @param ns The operation coordinate space
       */

    }, {
      key: "translate",
      value: function translate(trans, ns) {
        var space = ns || _nodeEnum.NodeSpace.LOCAL;

        if (space === _nodeEnum.NodeSpace.LOCAL) {
          _index.Vec3.transformQuat(v3_a, trans, this._lrot);

          this._lpos.x += v3_a.x;
          this._lpos.y += v3_a.y;
          this._lpos.z += v3_a.z;
        } else if (space === _nodeEnum.NodeSpace.WORLD) {
          if (this._parent) {
            _index.Quat.invert(q_a, this._parent.worldRotation);

            _index.Vec3.transformQuat(v3_a, trans, q_a);

            var _scale = this.worldScale;
            this._lpos.x += v3_a.x / _scale.x;
            this._lpos.y += v3_a.y / _scale.y;
            this._lpos.z += v3_a.z / _scale.z;
          } else {
            this._lpos.x += trans.x;
            this._lpos.y += trans.y;
            this._lpos.z += trans.z;
          }
        }

        this.invalidateChildren(_nodeEnum.TransformBit.POSITION);

        if (this._eventMask & _baseNode.TRANSFORM_ON) {
          this.emit(_eventEnum.SystemEventType.TRANSFORM_CHANGED, _nodeEnum.TransformBit.POSITION);
        }
      }
      /**
       * @en Perform a rotation on the node
       * @zh 旋转节点
       * @param trans The increment on position
       * @param ns The operation coordinate space
       */

    }, {
      key: "rotate",
      value: function rotate(rot, ns) {
        var space = ns || _nodeEnum.NodeSpace.LOCAL;

        _index.Quat.normalize(q_a, rot);

        if (space === _nodeEnum.NodeSpace.LOCAL) {
          _index.Quat.multiply(this._lrot, this._lrot, q_a);
        } else if (space === _nodeEnum.NodeSpace.WORLD) {
          var worldRot = this.worldRotation;

          _index.Quat.multiply(q_b, q_a, worldRot);

          _index.Quat.invert(q_a, worldRot);

          _index.Quat.multiply(q_b, q_a, q_b);

          _index.Quat.multiply(this._lrot, this._lrot, q_b);
        }

        this._eulerDirty = true;
        this.invalidateChildren(_nodeEnum.TransformBit.ROTATION);

        if (this._eventMask & _baseNode.TRANSFORM_ON) {
          this.emit(_eventEnum.SystemEventType.TRANSFORM_CHANGED, _nodeEnum.TransformBit.ROTATION);
        }
      }
      /**
       * @en Set the orientation of the node to face the target position, the node is facing minus z direction by default
       * @zh 设置当前节点旋转为面向目标位置，默认前方为 -z 方向
       * @param pos Target position
       * @param up Up direction
       */

    }, {
      key: "lookAt",
      value: function lookAt(pos, up) {
        this.getWorldPosition(v3_a);

        _index.Vec3.subtract(v3_a, v3_a, pos);

        _index.Vec3.normalize(v3_a, v3_a);

        _index.Quat.fromViewUp(q_a, v3_a, up);

        this.setWorldRotation(q_a);
      } // ===============================
      // transform maintainer
      // ===============================

      /**
       * @en Invalidate the world transform information
       * for this node and all its children recursively
       * @zh 递归标记节点世界变换为 dirty
       * @param dirtyBit The dirty bits to setup to children, can be composed with multiple dirty bits
       */

    }, {
      key: "invalidateChildren",
      value: function invalidateChildren(dirtyBit) {
        if ((this._dirtyFlags & this.hasChangedFlags & dirtyBit) === dirtyBit) {
          return;
        }

        this._dirtyFlags |= dirtyBit;
        bookOfChange.set(this._id, this.hasChangedFlags | dirtyBit);
        dirtyBit |= _nodeEnum.TransformBit.POSITION;
        var len = this._children.length;

        for (var i = 0; i < len; ++i) {
          var child = this._children[i];

          if (child.isValid) {
            child.invalidateChildren(dirtyBit);
          }
        }
      }
      /**
       * @en Update the world transform information if outdated
       * @zh 更新节点的世界变换信息
       */

    }, {
      key: "updateWorldTransform",
      value: function updateWorldTransform() {
        if (!this._dirtyFlags) {
          return;
        }

        var cur = this;
        var i = 0;

        while (cur && cur._dirtyFlags) {
          // top level node
          array_a[i++] = cur;
          cur = cur._parent;
        }

        var child;
        var dirtyBits = 0;

        while (i) {
          child = array_a[--i];
          dirtyBits |= child._dirtyFlags;

          if (cur) {
            if (dirtyBits & _nodeEnum.TransformBit.POSITION) {
              _index.Vec3.transformMat4(child._pos, child._lpos, cur._mat);

              child._mat.m12 = child._pos.x;
              child._mat.m13 = child._pos.y;
              child._mat.m14 = child._pos.z;
            }

            if (dirtyBits & _nodeEnum.TransformBit.RS) {
              _index.Mat4.fromRTS(child._mat, child._lrot, child._lpos, child._lscale);

              _index.Mat4.multiply(child._mat, cur._mat, child._mat);

              if (dirtyBits & _nodeEnum.TransformBit.ROTATION) {
                _index.Quat.multiply(child._rot, cur._rot, child._lrot);
              }

              _index.Mat3.fromQuat(m3_1, _index.Quat.conjugate(qt_1, child._rot));

              _index.Mat3.multiplyMat4(m3_1, m3_1, child._mat);

              child._scale.x = m3_1.m00;
              child._scale.y = m3_1.m04;
              child._scale.z = m3_1.m08;
            }
          } else {
            if (dirtyBits & _nodeEnum.TransformBit.POSITION) {
              _index.Vec3.copy(child._pos, child._lpos);

              child._mat.m12 = child._pos.x;
              child._mat.m13 = child._pos.y;
              child._mat.m14 = child._pos.z;
            }

            if (dirtyBits & _nodeEnum.TransformBit.RS) {
              if (dirtyBits & _nodeEnum.TransformBit.ROTATION) {
                _index.Quat.copy(child._rot, child._lrot);
              }

              if (dirtyBits & _nodeEnum.TransformBit.SCALE) {
                _index.Vec3.copy(child._scale, child._lscale);
              }

              _index.Mat4.fromRTS(child._mat, child._rot, child._pos, child._scale);
            }
          }

          child._dirtyFlags = _nodeEnum.TransformBit.NONE;
          cur = child;
        }
      } // ===============================
      // transform
      // ===============================

      /**
       * @en Set position in local coordinate system
       * @zh 设置本地坐标
       * @param position Target position
       */

    }, {
      key: "setPosition",
      value: function setPosition(val, y, z) {
        if (y === undefined || z === undefined) {
          _index.Vec3.copy(this._lpos, val);
        } else {
          _index.Vec3.set(this._lpos, val, y, z);
        }

        this.invalidateChildren(_nodeEnum.TransformBit.POSITION);

        if (this._eventMask & _baseNode.TRANSFORM_ON) {
          this.emit(_eventEnum.SystemEventType.TRANSFORM_CHANGED, _nodeEnum.TransformBit.POSITION);
        }
      }
      /**
       * @en Get position in local coordinate system, please try to pass `out` vector and reuse it to avoid garbage.
       * @zh 获取本地坐标，注意，尽可能传递复用的 [[Vec3]] 以避免产生垃圾。
       * @param out Set the result to out vector
       * @return If `out` given, the return value equals to `out`, otherwise a new vector will be generated and return
       */

    }, {
      key: "getPosition",
      value: function getPosition(out) {
        if (out) {
          return _index.Vec3.set(out, this._lpos.x, this._lpos.y, this._lpos.z);
        } else {
          return _index.Vec3.copy(new _index.Vec3(), this._lpos);
        }
      }
      /**
       * @en Set rotation in local coordinate system with a quaternion representing the rotation
       * @zh 用四元数设置本地旋转
       * @param rotation Rotation in quaternion
       */

    }, {
      key: "setRotation",
      value: function setRotation(val, y, z, w) {
        if (y === undefined || z === undefined || w === undefined) {
          _index.Quat.copy(this._lrot, val);
        } else {
          _index.Quat.set(this._lrot, val, y, z, w);
        }

        this._eulerDirty = true;
        this.invalidateChildren(_nodeEnum.TransformBit.ROTATION);

        if (this._eventMask & _baseNode.TRANSFORM_ON) {
          this.emit(_eventEnum.SystemEventType.TRANSFORM_CHANGED, _nodeEnum.TransformBit.ROTATION);
        }
      }
      /**
       * @en Set rotation in local coordinate system with euler angles
       * @zh 用欧拉角设置本地旋转
       * @param x X axis rotation
       * @param y Y axis rotation
       * @param z Z axis rotation
       */

    }, {
      key: "setRotationFromEuler",
      value: function setRotationFromEuler(x, y, z) {
        _index.Vec3.set(this._euler, x, y, z);

        _index.Quat.fromEuler(this._lrot, x, y, z);

        this._eulerDirty = false;
        this.invalidateChildren(_nodeEnum.TransformBit.ROTATION);

        if (this._eventMask & _baseNode.TRANSFORM_ON) {
          this.emit(_eventEnum.SystemEventType.TRANSFORM_CHANGED, _nodeEnum.TransformBit.ROTATION);
        }
      }
      /**
       * @en Get rotation as quaternion in local coordinate system, please try to pass `out` quaternion and reuse it to avoid garbage.
       * @zh 获取本地旋转，注意，尽可能传递复用的 [[Quat]] 以避免产生垃圾。
       * @param out Set the result to out quaternion
       * @return If `out` given, the return value equals to `out`, otherwise a new quaternion will be generated and return
       */

    }, {
      key: "getRotation",
      value: function getRotation(out) {
        if (out) {
          return _index.Quat.set(out, this._lrot.x, this._lrot.y, this._lrot.z, this._lrot.w);
        } else {
          return _index.Quat.copy(new _index.Quat(), this._lrot);
        }
      }
      /**
       * @en Set scale in local coordinate system
       * @zh 设置本地缩放
       * @param scale Target scale
       */

    }, {
      key: "setScale",
      value: function setScale(val, y, z) {
        if (y === undefined || z === undefined) {
          _index.Vec3.copy(this._lscale, val);
        } else {
          _index.Vec3.set(this._lscale, val, y, z);
        }

        this.invalidateChildren(_nodeEnum.TransformBit.SCALE);

        if (this._eventMask & _baseNode.TRANSFORM_ON) {
          this.emit(_eventEnum.SystemEventType.TRANSFORM_CHANGED, _nodeEnum.TransformBit.SCALE);
        }
      }
      /**
       * @en Get scale in local coordinate system, please try to pass `out` vector and reuse it to avoid garbage.
       * @zh 获取本地缩放，注意，尽可能传递复用的 [[Vec3]] 以避免产生垃圾。
       * @param out Set the result to out vector
       * @return If `out` given, the return value equals to `out`, otherwise a new vector will be generated and return
       */

    }, {
      key: "getScale",
      value: function getScale(out) {
        if (out) {
          return _index.Vec3.set(out, this._lscale.x, this._lscale.y, this._lscale.z);
        } else {
          return _index.Vec3.copy(new _index.Vec3(), this._lscale);
        }
      }
      /**
       * @en Inversely transform a point from world coordinate system to local coordinate system.
       * @zh 逆向变换一个空间点，一般用于将世界坐标转换到本地坐标系中。
       * @param out The result point in local coordinate system will be stored in this vector
       * @param p A position in world coordinate system
       */

    }, {
      key: "inverseTransformPoint",
      value: function inverseTransformPoint(out, p) {
        _index.Vec3.copy(out, p);

        var cur = this;
        var i = 0;

        while (cur._parent) {
          array_a[i++] = cur;
          cur = cur._parent;
        }

        while (i >= 0) {
          _index.Vec3.transformInverseRTS(out, out, cur._lrot, cur._lpos, cur._lscale);

          cur = array_a[--i];
        }

        return out;
      }
      /**
       * @en Set position in world coordinate system
       * @zh 设置世界坐标
       * @param position Target position
       */

    }, {
      key: "setWorldPosition",
      value: function setWorldPosition(val, y, z) {
        if (y === undefined || z === undefined) {
          _index.Vec3.copy(this._pos, val);
        } else {
          _index.Vec3.set(this._pos, val, y, z);
        }

        var parent = this._parent;
        var local = this._lpos;

        if (parent) {
          // TODO: benchmark these approaches

          /* */
          parent.updateWorldTransform();

          _index.Vec3.transformMat4(local, this._pos, _index.Mat4.invert(m4_1, parent._mat));
          /* *
          parent.inverseTransformPoint(local, this._pos);
          /* */

        } else {
          _index.Vec3.copy(local, this._pos);
        }

        this.invalidateChildren(_nodeEnum.TransformBit.POSITION);

        if (this._eventMask & _baseNode.TRANSFORM_ON) {
          this.emit(_eventEnum.SystemEventType.TRANSFORM_CHANGED, _nodeEnum.TransformBit.POSITION);
        }
      }
      /**
       * @en Get position in world coordinate system, please try to pass `out` vector and reuse it to avoid garbage.
       * @zh 获取世界坐标，注意，尽可能传递复用的 [[Vec3]] 以避免产生垃圾。
       * @param out Set the result to out vector
       * @return If `out` given, the return value equals to `out`, otherwise a new vector will be generated and return
       */

    }, {
      key: "getWorldPosition",
      value: function getWorldPosition(out) {
        this.updateWorldTransform();

        if (out) {
          return _index.Vec3.copy(out, this._pos);
        } else {
          return _index.Vec3.copy(new _index.Vec3(), this._pos);
        }
      }
      /**
       * @en Set rotation in world coordinate system with a quaternion representing the rotation
       * @zh 用四元数设置世界坐标系下的旋转
       * @param rotation Rotation in quaternion
       */

    }, {
      key: "setWorldRotation",
      value: function setWorldRotation(val, y, z, w) {
        if (y === undefined || z === undefined || w === undefined) {
          _index.Quat.copy(this._rot, val);
        } else {
          _index.Quat.set(this._rot, val, y, z, w);
        }

        if (this._parent) {
          this._parent.updateWorldTransform();

          _index.Quat.multiply(this._lrot, _index.Quat.conjugate(this._lrot, this._parent._rot), this._rot);
        } else {
          _index.Quat.copy(this._lrot, this._rot);
        }

        this._eulerDirty = true;
        this.invalidateChildren(_nodeEnum.TransformBit.ROTATION);

        if (this._eventMask & _baseNode.TRANSFORM_ON) {
          this.emit(_eventEnum.SystemEventType.TRANSFORM_CHANGED, _nodeEnum.TransformBit.ROTATION);
        }
      }
      /**
       * @en Set rotation in world coordinate system with euler angles
       * @zh 用欧拉角设置世界坐标系下的旋转
       * @param x X axis rotation
       * @param y Y axis rotation
       * @param z Z axis rotation
       */

    }, {
      key: "setWorldRotationFromEuler",
      value: function setWorldRotationFromEuler(x, y, z) {
        _index.Quat.fromEuler(this._rot, x, y, z);

        if (this._parent) {
          this._parent.updateWorldTransform();

          _index.Quat.multiply(this._lrot, _index.Quat.conjugate(this._lrot, this._parent._rot), this._rot);
        } else {
          _index.Quat.copy(this._lrot, this._rot);
        }

        this._eulerDirty = true;
        this.invalidateChildren(_nodeEnum.TransformBit.ROTATION);

        if (this._eventMask & _baseNode.TRANSFORM_ON) {
          this.emit(_eventEnum.SystemEventType.TRANSFORM_CHANGED, _nodeEnum.TransformBit.ROTATION);
        }
      }
      /**
       * @en Get rotation as quaternion in world coordinate system, please try to pass `out` quaternion and reuse it to avoid garbage.
       * @zh 获取世界坐标系下的旋转，注意，尽可能传递复用的 [[Quat]] 以避免产生垃圾。
       * @param out Set the result to out quaternion
       * @return If `out` given, the return value equals to `out`, otherwise a new quaternion will be generated and return
       */

    }, {
      key: "getWorldRotation",
      value: function getWorldRotation(out) {
        this.updateWorldTransform();

        if (out) {
          return _index.Quat.copy(out, this._rot);
        } else {
          return _index.Quat.copy(new _index.Quat(), this._rot);
        }
      }
      /**
       * @en Set scale in world coordinate system
       * @zh 设置世界坐标系下的缩放
       * @param scale Target scale
       */

    }, {
      key: "setWorldScale",
      value: function setWorldScale(val, y, z) {
        if (y === undefined || z === undefined) {
          _index.Vec3.copy(this._scale, val);
        } else {
          _index.Vec3.set(this._scale, val, y, z);
        }

        var parent = this._parent;

        if (parent) {
          parent.updateWorldTransform();

          _index.Mat3.fromQuat(m3_1, _index.Quat.conjugate(qt_1, parent._rot));

          _index.Mat3.multiplyMat4(m3_1, m3_1, parent._mat);

          m3_scaling.m00 = this._scale.x;
          m3_scaling.m04 = this._scale.y;
          m3_scaling.m08 = this._scale.z;

          _index.Mat3.multiply(m3_1, m3_scaling, _index.Mat3.invert(m3_1, m3_1));

          this._lscale.x = _index.Vec3.set(v3_a, m3_1.m00, m3_1.m01, m3_1.m02).length();
          this._lscale.y = _index.Vec3.set(v3_a, m3_1.m03, m3_1.m04, m3_1.m05).length();
          this._lscale.z = _index.Vec3.set(v3_a, m3_1.m06, m3_1.m07, m3_1.m08).length();
        } else {
          _index.Vec3.copy(this._lscale, this._scale);
        }

        this.invalidateChildren(_nodeEnum.TransformBit.SCALE);

        if (this._eventMask & _baseNode.TRANSFORM_ON) {
          this.emit(_eventEnum.SystemEventType.TRANSFORM_CHANGED, _nodeEnum.TransformBit.SCALE);
        }
      }
      /**
       * @en Get scale in world coordinate system, please try to pass `out` vector and reuse it to avoid garbage.
       * @zh 获取世界缩放，注意，尽可能传递复用的 [[Vec3]] 以避免产生垃圾。
       * @param out Set the result to out vector
       * @return If `out` given, the return value equals to `out`, otherwise a new vector will be generated and return
       */

    }, {
      key: "getWorldScale",
      value: function getWorldScale(out) {
        this.updateWorldTransform();

        if (out) {
          return _index.Vec3.copy(out, this._scale);
        } else {
          return _index.Vec3.copy(new _index.Vec3(), this._scale);
        }
      }
      /**
       * @en Get a world transform matrix
       * @zh 获取世界变换矩阵
       * @param out Set the result to out matrix
       * @return If `out` given, the return value equals to `out`, otherwise a new matrix will be generated and return
       */

    }, {
      key: "getWorldMatrix",
      value: function getWorldMatrix(out) {
        this.updateWorldTransform();

        if (!out) {
          out = new _index.Mat4();
        }

        return _index.Mat4.copy(out, this._mat);
      }
      /**
       * @en Get a world transform matrix with only rotation and scale
       * @zh 获取只包含旋转和缩放的世界变换矩阵
       * @param out Set the result to out matrix
       * @return If `out` given, the return value equals to `out`, otherwise a new matrix will be generated and return
       */

    }, {
      key: "getWorldRS",
      value: function getWorldRS(out) {
        this.updateWorldTransform();

        if (!out) {
          out = new _index.Mat4();
        }

        _index.Mat4.copy(out, this._mat);

        out.m12 = 0;
        out.m13 = 0;
        out.m14 = 0;
        return out;
      }
      /**
       * @en Get a world transform matrix with only rotation and translation
       * @zh 获取只包含旋转和位移的世界变换矩阵
       * @param out Set the result to out matrix
       * @return If `out` given, the return value equals to `out`, otherwise a new matrix will be generated and return
       */

    }, {
      key: "getWorldRT",
      value: function getWorldRT(out) {
        this.updateWorldTransform();

        if (!out) {
          out = new _index.Mat4();
        }

        return _index.Mat4.fromRT(out, this._rot, this._pos);
      }
      /**
       * @en Set local transformation with rotation, position and scale separately.
       * @zh 一次性设置所有局部变换（平移、旋转、缩放）信息
       * @param rot The rotation
       * @param pos The position
       * @param scale The scale
       */

    }, {
      key: "setRTS",
      value: function setRTS(rot, pos, scale) {
        var dirtyBit = 0;

        if (rot) {
          dirtyBit |= _nodeEnum.TransformBit.ROTATION;

          if (rot.w !== undefined) {
            _index.Quat.copy(this._lrot, rot);

            this._eulerDirty = true;
          } else {
            _index.Vec3.copy(this._euler, rot);

            _index.Quat.fromEuler(this._lrot, rot.x, rot.y, rot.z);

            this._eulerDirty = false;
          }
        }

        if (pos) {
          _index.Vec3.copy(this._lpos, pos);

          dirtyBit |= _nodeEnum.TransformBit.POSITION;
        }

        if (scale) {
          _index.Vec3.copy(this._lscale, scale);

          dirtyBit |= _nodeEnum.TransformBit.SCALE;
        }

        if (dirtyBit) {
          this.invalidateChildren(dirtyBit);

          if (this._eventMask & _baseNode.TRANSFORM_ON) {
            this.emit(_eventEnum.SystemEventType.TRANSFORM_CHANGED, dirtyBit);
          }
        }
      } // ===============================
      // for backward-compatibility
      // ===============================

    }, {
      key: "getAnchorPoint",
      value: function getAnchorPoint(out) {
        if (!out) {
          out = new _index.Vec2();
        }

        out.set(this._uiProps.uiTransformComp.anchorPoint);
        return out;
      }
    }, {
      key: "setAnchorPoint",
      value: function setAnchorPoint(point, y) {
        this._uiProps.uiTransformComp.setAnchorPoint(point, y);
      }
    }, {
      key: "getContentSize",
      value: function getContentSize(out) {
        if (!out) {
          out = new _index.Size();
        }

        out.set(this._uiProps.uiTransformComp.contentSize);
        return out;
      }
    }, {
      key: "setContentSize",
      value: function setContentSize(size, height) {
        this._uiProps.uiTransformComp.setContentSize(size, height);
      }
      /**
       * @en Pause all system events which is dispatched by [[SystemEvent]]
       * @zh 暂停所有 [[SystemEvent]] 派发的系统事件
       * @param recursive Whether pause system events recursively for the child node tree
       */

    }, {
      key: "pauseSystemEvents",
      value: function pauseSystemEvents(recursive) {
        // @ts-ignore
        _eventManager.eventManager.pauseTarget(this, recursive);
      }
      /**
       * @en Resume all paused system events which is dispatched by [[SystemEvent]]
       * @zh 恢复所有 [[SystemEvent]] 派发的系统事件
       * @param recursive Whether resume system events recursively for the child node tree
       */

    }, {
      key: "resumeSystemEvents",
      value: function resumeSystemEvents(recursive) {
        // @ts-ignore
        _eventManager.eventManager.resumeTarget(this, recursive);
      }
    }, {
      key: "_onPostActivated",
      value: function _onPostActivated(active) {
        if (active) {
          _eventManager.eventManager.resumeTarget(this);

          this.eventProcessor.reattach();
        } else {
          // deactivate
          _eventManager.eventManager.pauseTarget(this);
        }
      }
    }, {
      key: "position",

      /**
       * @en Position in local coordinate system
       * @zh 本地坐标系下的坐标
       */
      // @constget
      get: function get() {
        return this._lpos;
      },
      set: function set(val) {
        this.setPosition(val);
      }
      /**
       * @en Position in world coordinate system
       * @zh 世界坐标系下的坐标
       */
      // @constget

    }, {
      key: "worldPosition",
      get: function get() {
        this.updateWorldTransform();
        return this._pos;
      },
      set: function set(val) {
        this.setWorldPosition(val);
      }
      /**
       * @en Rotation in local coordinate system, represented by a quaternion
       * @zh 本地坐标系下的旋转，用四元数表示
       */
      // @constget

    }, {
      key: "rotation",
      get: function get() {
        return this._lrot;
      },
      set: function set(val) {
        this.setRotation(val);
      }
      /**
       * @en Rotation in local coordinate system, represented by euler angles
       * @zh 本地坐标系下的旋转，用欧拉角表示
       */

    }, {
      key: "eulerAngles",
      set: function set(val) {
        this.setRotationFromEuler(val.x, val.y, val.z);
      },
      get: function get() {
        if (this._eulerDirty) {
          _index.Quat.toEuler(this._euler, this._lrot);

          this._eulerDirty = false;
        }

        return this._euler;
      }
      /**
       * @en Rotation in world coordinate system, represented by a quaternion
       * @zh 世界坐标系下的旋转，用四元数表示
       */
      // @constget

    }, {
      key: "worldRotation",
      get: function get() {
        this.updateWorldTransform();
        return this._rot;
      },
      set: function set(val) {
        this.setWorldRotation(val);
      }
      /**
       * @en Scale in local coordinate system
       * @zh 本地坐标系下的缩放
       */
      // @constget

    }, {
      key: "scale",
      get: function get() {
        return this._lscale;
      },
      set: function set(val) {
        this.setScale(val);
      }
      /**
       * @en Scale in world coordinate system
       * @zh 世界坐标系下的缩放
       */
      // @constget

    }, {
      key: "worldScale",
      get: function get() {
        this.updateWorldTransform();
        return this._scale;
      },
      set: function set(val) {
        this.setWorldScale(val);
      }
      /**
       * @en Local transformation matrix
       * @zh 本地坐标系变换矩阵
       */

    }, {
      key: "matrix",
      set: function set(val) {
        _index.Mat4.toRTS(val, this._lrot, this._lpos, this._lscale);

        this.invalidateChildren(_nodeEnum.TransformBit.TRS);
        this._eulerDirty = true;

        if (this._eventMask & _baseNode.TRANSFORM_ON) {
          this.emit(_eventEnum.SystemEventType.TRANSFORM_CHANGED, _nodeEnum.TransformBit.TRS);
        }
      }
      /**
       * @en World transformation matrix
       * @zh 世界坐标系变换矩阵
       */
      // @constget

    }, {
      key: "worldMatrix",
      get: function get() {
        this.updateWorldTransform();
        return this._mat;
      }
      /**
       * @en The vector representing forward direction in local coordinate system, it's the minus z direction by default
       * @zh 当前节点面向的前方方向，默认前方为 -z 方向
       */

    }, {
      key: "forward",
      get: function get() {
        return _index.Vec3.transformQuat(new _index.Vec3(), _index.Vec3.FORWARD, this.worldRotation);
      },
      set: function set(dir) {
        var len = dir.length();

        _index.Vec3.multiplyScalar(v3_a, dir, -1 / len);

        _index.Quat.fromViewUp(q_a, v3_a);

        this.setWorldRotation(q_a);
      }
      /**
       * @en Layer of the current Node, it affects raycast, physics etc, refer to [[Layers]]
       * @zh 节点所属层，主要影响射线检测、物理碰撞等，参考 [[Layers]]
       */

    }, {
      key: "layer",
      set: function set(l) {
        this._layer = l;
      },
      get: function get() {
        return this._layer;
      }
      /**
       * @en Whether the node's transformation have changed during the current frame.
       * @zh 这个节点的空间变换信息在当前帧内是否有变过？
       */

    }, {
      key: "hasChangedFlags",
      get: function get() {
        return bookOfChange.get(this._id) || 0;
      },
      set: function set(val) {
        bookOfChange.set(this._id, val);
      } // ===============================
      // for backward-compatibility
      // ===============================

    }, {
      key: "width",
      get: function get() {
        return this._uiProps.uiTransformComp.width;
      },
      set: function set(value) {
        this._uiProps.uiTransformComp.width = value;
      }
    }, {
      key: "height",
      get: function get() {
        return this._uiProps.uiTransformComp.height;
      },
      set: function set(value) {
        this._uiProps.uiTransformComp.height = value;
      }
    }, {
      key: "anchorX",
      get: function get() {
        return this._uiProps.uiTransformComp.anchorX;
      },
      set: function set(value) {
        this._uiProps.uiTransformComp.anchorX = value;
      }
    }, {
      key: "anchorY",
      get: function get() {
        return this._uiProps.uiTransformComp.anchorY;
      },
      set: function set(value) {
        this._uiProps.uiTransformComp.anchorY = value;
      }
    }], [{
      key: "isNode",

      /**
       * @en Determine whether the given object is a normal Node. Will return false if [[Scene]] given.
       * @zh 指定对象是否是普通的节点？如果传入 [[Scene]] 会返回 false。
       */
      value: function isNode(obj) {
        return obj instanceof Node && (obj.constructor === Node || !(obj instanceof cc.Scene));
      } // UI 部分的脏数据

    }]);

    return Node;
  }(_baseNode.BaseNode), _class3.bookOfChange = bookOfChange, _class3.EventType = _eventEnum.SystemEventType, _class3.NodeSpace = _nodeEnum.NodeSpace, _class3.TransformDirtyBit = _nodeEnum.TransformBit, _class3.TransformBit = _nodeEnum.TransformBit, _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "_lpos", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return new _index.Vec3();
    }
  }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_lrot", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return new _index.Quat();
    }
  }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "_lscale", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return new _index.Vec3(1, 1, 1);
    }
  }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "_layer", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return _layers.Layers.Enum.DEFAULT;
    }
  }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "_euler", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return new _index.Vec3();
    }
  }), _applyDecoratedDescriptor(_class2.prototype, "eulerAngles", [_dec2], Object.getOwnPropertyDescriptor(_class2.prototype, "eulerAngles"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "layer", [_classDecorator.property], Object.getOwnPropertyDescriptor(_class2.prototype, "layer"), _class2.prototype)), _class2)) || _class);
  _exports.Node = Node;
  cc.Node = Node;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkY6L2plbmtpbnMvd29ya3NwYWNlL0NyZWF0b3JfM0QvZWRpdG9yLTNkL3Jlc291cmNlcy8zZC9lbmdpbmUvY29jb3MvY29yZS9zY2VuZS1ncmFwaC9ub2RlLnRzIl0sIm5hbWVzIjpbInYzX2EiLCJWZWMzIiwicV9hIiwiUXVhdCIsInFfYiIsImFycmF5X2EiLCJBcnJheSIsInF0XzEiLCJtM18xIiwiTWF0MyIsIm0zX3NjYWxpbmciLCJtNF8xIiwiTWF0NCIsImJvb2tPZkNoYW5nZSIsIk1hcCIsIk5vZGUiLCJ0eXBlIiwiX3VpUHJvcHMiLCJOb2RlVUlQcm9wZXJ0aWVzIiwiX3N0YXRpYyIsIl9wb3MiLCJfcm90IiwiX3NjYWxlIiwiX21hdCIsIl9kaXJ0eUZsYWdzIiwiVHJhbnNmb3JtQml0IiwiTk9ORSIsIl9ldWxlckRpcnR5IiwidmFsdWUiLCJrZWVwV29ybGRUcmFuc2Zvcm0iLCJ1cGRhdGVXb3JsZFRyYW5zZm9ybSIsIm9sZFBhcmVudCIsInBhcmVudCIsIl9wYXJlbnQiLCJtdWx0aXBseSIsImludmVydCIsInRvUlRTIiwiX2xyb3QiLCJfbHBvcyIsIl9sc2NhbGUiLCJjb3B5IiwiaW52YWxpZGF0ZUNoaWxkcmVuIiwiVFJTIiwic2V0IiwiX2lkIiwibGVuIiwiX2NoaWxkcmVuIiwibGVuZ3RoIiwiaSIsIl9vbkJhdGNoQ3JlYXRlZCIsImV1bGVyQW5nbGVzIiwidHJhbnMiLCJucyIsInNwYWNlIiwiTm9kZVNwYWNlIiwiTE9DQUwiLCJ0cmFuc2Zvcm1RdWF0IiwieCIsInkiLCJ6IiwiV09STEQiLCJ3b3JsZFJvdGF0aW9uIiwic2NhbGUiLCJ3b3JsZFNjYWxlIiwiUE9TSVRJT04iLCJfZXZlbnRNYXNrIiwiVFJBTlNGT1JNX09OIiwiZW1pdCIsIlN5c3RlbUV2ZW50VHlwZSIsIlRSQU5TRk9STV9DSEFOR0VEIiwicm90Iiwibm9ybWFsaXplIiwid29ybGRSb3QiLCJST1RBVElPTiIsInBvcyIsInVwIiwiZ2V0V29ybGRQb3NpdGlvbiIsInN1YnRyYWN0IiwiZnJvbVZpZXdVcCIsInNldFdvcmxkUm90YXRpb24iLCJkaXJ0eUJpdCIsImhhc0NoYW5nZWRGbGFncyIsImNoaWxkIiwiaXNWYWxpZCIsImN1ciIsImRpcnR5Qml0cyIsInRyYW5zZm9ybU1hdDQiLCJtMTIiLCJtMTMiLCJtMTQiLCJSUyIsImZyb21SVFMiLCJmcm9tUXVhdCIsImNvbmp1Z2F0ZSIsIm11bHRpcGx5TWF0NCIsIm0wMCIsIm0wNCIsIm0wOCIsIlNDQUxFIiwidmFsIiwidW5kZWZpbmVkIiwib3V0IiwidyIsIl9ldWxlciIsImZyb21FdWxlciIsInAiLCJ0cmFuc2Zvcm1JbnZlcnNlUlRTIiwibG9jYWwiLCJtMDEiLCJtMDIiLCJtMDMiLCJtMDUiLCJtMDYiLCJtMDciLCJmcm9tUlQiLCJWZWMyIiwidWlUcmFuc2Zvcm1Db21wIiwiYW5jaG9yUG9pbnQiLCJwb2ludCIsInNldEFuY2hvclBvaW50IiwiU2l6ZSIsImNvbnRlbnRTaXplIiwic2l6ZSIsImhlaWdodCIsInNldENvbnRlbnRTaXplIiwicmVjdXJzaXZlIiwiZXZlbnRNYW5hZ2VyIiwicGF1c2VUYXJnZXQiLCJyZXN1bWVUYXJnZXQiLCJhY3RpdmUiLCJldmVudFByb2Nlc3NvciIsInJlYXR0YWNoIiwic2V0UG9zaXRpb24iLCJzZXRXb3JsZFBvc2l0aW9uIiwic2V0Um90YXRpb24iLCJzZXRSb3RhdGlvbkZyb21FdWxlciIsInRvRXVsZXIiLCJzZXRTY2FsZSIsInNldFdvcmxkU2NhbGUiLCJGT1JXQVJEIiwiZGlyIiwibXVsdGlwbHlTY2FsYXIiLCJsIiwiX2xheWVyIiwiZ2V0Iiwid2lkdGgiLCJhbmNob3JYIiwiYW5jaG9yWSIsIm9iaiIsImNvbnN0cnVjdG9yIiwiY2MiLCJTY2VuZSIsIkJhc2VOb2RlIiwiRXZlbnRUeXBlIiwiVHJhbnNmb3JtRGlydHlCaXQiLCJwcm9wZXJ0eSIsIkxheWVycyIsIkVudW0iLCJERUZBVUxUIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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QWVBLHNCLGdGQXFCNUJrSSx3Qjs7Ozs7YUFDaUIsSUFBSTFKLFdBQUosRTs7NEVBQ2pCMEosd0I7Ozs7O2FBQ2lCLElBQUl4SixXQUFKLEU7OzhFQUNqQndKLHdCOzs7OzthQUNtQixJQUFJMUosV0FBSixDQUFTLENBQVQsRUFBWSxDQUFaLEVBQWUsQ0FBZixDOzs2RUFDbkIwSix3Qjs7Ozs7YUFDa0JDLGVBQU9DLElBQVAsQ0FBWUMsTzs7NkVBRzlCSCx3Qjs7Ozs7YUFDa0IsSUFBSTFKLFdBQUosRTs7eU5BeUlsQjBKLHdCOztBQTB2QkxMLEVBQUFBLEVBQUUsQ0FBQ3ZJLElBQUgsR0FBVUEsSUFBViIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiBDb3B5cmlnaHQgKGMpIDIwMTctMjAxOSBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC5cclxuXHJcbiBodHRwOi8vd3d3LmNvY29zLmNvbVxyXG5cclxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZW5naW5lIHNvdXJjZSBjb2RlICh0aGUgXCJTb2Z0d2FyZVwiKSwgYSBsaW1pdGVkLFxyXG4gIHdvcmxkd2lkZSwgcm95YWx0eS1mcmVlLCBub24tYXNzaWduYWJsZSwgcmV2b2NhYmxlIGFuZCBub24tZXhjbHVzaXZlIGxpY2Vuc2VcclxuIHRvIHVzZSBDb2NvcyBDcmVhdG9yIHNvbGVseSB0byBkZXZlbG9wIGdhbWVzIG9uIHlvdXIgdGFyZ2V0IHBsYXRmb3Jtcy4gWW91IHNoYWxsXHJcbiAgbm90IHVzZSBDb2NvcyBDcmVhdG9yIHNvZnR3YXJlIGZvciBkZXZlbG9waW5nIG90aGVyIHNvZnR3YXJlIG9yIHRvb2xzIHRoYXQnc1xyXG4gIHVzZWQgZm9yIGRldmVsb3BpbmcgZ2FtZXMuIFlvdSBhcmUgbm90IGdyYW50ZWQgdG8gcHVibGlzaCwgZGlzdHJpYnV0ZSxcclxuICBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgQ29jb3MgQ3JlYXRvci5cclxuXHJcbiBUaGUgc29mdHdhcmUgb3IgdG9vbHMgaW4gdGhpcyBMaWNlbnNlIEFncmVlbWVudCBhcmUgbGljZW5zZWQsIG5vdCBzb2xkLlxyXG4gWGlhbWVuIFlhamkgU29mdHdhcmUgQ28uLCBMdGQuIHJlc2VydmVzIGFsbCByaWdodHMgbm90IGV4cHJlc3NseSBncmFudGVkIHRvIHlvdS5cclxuXHJcbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXHJcbiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcclxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxyXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxyXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcclxuIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cclxuIFRIRSBTT0ZUV0FSRS5cclxuKi9cclxuXHJcbi8qKlxyXG4gKiBAY2F0ZWdvcnkgc2NlbmUtZ3JhcGhcclxuICovXHJcblxyXG5pbXBvcnQgeyBjY2NsYXNzLCBwcm9wZXJ0eSB9IGZyb20gJy4uL2RhdGEvY2xhc3MtZGVjb3JhdG9yJztcclxuaW1wb3J0IHsgTWF0MywgTWF0NCwgUXVhdCwgU2l6ZSwgVmVjMiwgVmVjMyB9IGZyb20gJy4uL21hdGgnO1xyXG5pbXBvcnQgeyBTeXN0ZW1FdmVudFR5cGUgfSBmcm9tICcuLi9wbGF0Zm9ybS9ldmVudC1tYW5hZ2VyL2V2ZW50LWVudW0nO1xyXG5pbXBvcnQgeyBldmVudE1hbmFnZXIgfSBmcm9tICcuLi9wbGF0Zm9ybS9ldmVudC1tYW5hZ2VyL2V2ZW50LW1hbmFnZXInO1xyXG5pbXBvcnQgeyBCYXNlTm9kZSwgVFJBTlNGT1JNX09OIH0gZnJvbSAnLi9iYXNlLW5vZGUnO1xyXG5pbXBvcnQgeyBMYXllcnMgfSBmcm9tICcuL2xheWVycyc7XHJcbmltcG9ydCB7IE5vZGVTcGFjZSwgVHJhbnNmb3JtQml0IH0gZnJvbSAnLi9ub2RlLWVudW0nO1xyXG5pbXBvcnQgeyBOb2RlVUlQcm9wZXJ0aWVzIH0gZnJvbSAnLi9ub2RlLXVpLXByb3BlcnRpZXMnO1xyXG5cclxuY29uc3QgdjNfYSA9IG5ldyBWZWMzKCk7XHJcbmNvbnN0IHFfYSA9IG5ldyBRdWF0KCk7XHJcbmNvbnN0IHFfYiA9IG5ldyBRdWF0KCk7XHJcbmNvbnN0IGFycmF5X2EgPSBuZXcgQXJyYXkoMTApO1xyXG5jb25zdCBxdF8xID0gbmV3IFF1YXQoKTtcclxuY29uc3QgbTNfMSA9IG5ldyBNYXQzKCk7XHJcbmNvbnN0IG0zX3NjYWxpbmcgPSBuZXcgTWF0MygpO1xyXG5jb25zdCBtNF8xID0gbmV3IE1hdDQoKTtcclxuY29uc3QgYm9va09mQ2hhbmdlID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcclxuXHJcbi8qKlxyXG4gKiBAemhcclxuICog5Zy65pmv5qCR5Lit55qE5Z+65pys6IqC54K577yM5Z+65pys54m55oCn5pyJ77yaXHJcbiAqICog5YW35pyJ5bGC57qn5YWz57O7XHJcbiAqICog5oyB5pyJ5ZCE57G757uE5Lu2XHJcbiAqICog57u05oqk56m66Ze05Y+Y5o2i77yI5Z2Q5qCH44CB5peL6L2s44CB57yp5pS+77yJ5L+h5oGvXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqICEjZW5cclxuICogQ2xhc3Mgb2YgYWxsIGVudGl0aWVzIGluIENvY29zIENyZWF0b3Igc2NlbmVzLlxyXG4gKiBCYXNpYyBmdW5jdGlvbmFsaXRpZXMgaW5jbHVkZTpcclxuICogKiBIaWVyYXJjaHkgbWFuYWdlbWVudCB3aXRoIHBhcmVudCBhbmQgY2hpbGRyZW5cclxuICogKiBDb21wb25lbnRzIG1hbmFnZW1lbnRcclxuICogKiBDb29yZGluYXRlIHN5c3RlbSB3aXRoIHBvc2l0aW9uLCBzY2FsZSwgcm90YXRpb24gaW4gM2Qgc3BhY2VcclxuICogISN6aFxyXG4gKiBDb2NvcyBDcmVhdG9yIOWcuuaZr+S4reeahOaJgOacieiKgueCueexu+OAglxyXG4gKiDln7rmnKznibnmgKfmnInvvJpcclxuICogKiDlhbfmnInlsYLnuqflhbPns7tcclxuICogKiDmjIHmnInlkITnsbvnu4Tku7ZcclxuICogKiDnu7TmiqQgM0Qg56m66Ze05bem6L655Y+Y5o2i77yI5Z2Q5qCH44CB5peL6L2s44CB57yp5pS+77yJ5L+h5oGvXHJcbiAqL1xyXG5AY2NjbGFzcygnY2MuTm9kZScpXHJcbmV4cG9ydCBjbGFzcyBOb2RlIGV4dGVuZHMgQmFzZU5vZGUge1xyXG4gICAgcHVibGljIHN0YXRpYyBib29rT2ZDaGFuZ2UgPSBib29rT2ZDaGFuZ2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gRXZlbnQgdHlwZXMgZW1pdHRlZCBieSBOb2RlXHJcbiAgICAgKiBAemgg6IqC54K55Y+v6IO95Y+R5Ye655qE5LqL5Lu257G75Z6LXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgRXZlbnRUeXBlID0gU3lzdGVtRXZlbnRUeXBlO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gQ29vcmRpbmF0ZXMgc3BhY2VcclxuICAgICAqIEB6aCDnqbrpl7Tlj5jmjaLmk43kvZznmoTlnZDmoIfns7tcclxuICAgICAqL1xyXG4gICAgcHVibGljIHN0YXRpYyBOb2RlU3BhY2UgPSBOb2RlU3BhY2U7XHJcbiAgICAvKipcclxuICAgICAqIEBlbiBCaXQgbWFza3MgZm9yIE5vZGUgdHJhbnNmb3JtYXRpb24gcGFydHNcclxuICAgICAqIEB6aCDoioLngrnlj5jmjaLmm7TmlrDnmoTlhbfkvZPpg6jliIZcclxuICAgICAqIEBkZXByZWNhdGVkIHBsZWFzZSB1c2UgW1tOb2RlLlRyYW5zZm9ybUJpdF1dXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzdGF0aWMgVHJhbnNmb3JtRGlydHlCaXQgPSBUcmFuc2Zvcm1CaXQ7XHJcbiAgICAvKipcclxuICAgICAqIEBlbiBCaXQgbWFza3MgZm9yIE5vZGUgdHJhbnNmb3JtYXRpb24gcGFydHMsIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB3aGljaCBwYXJ0IGNoYW5nZWQgaW4gW1tTeXN0ZW1FdmVudFR5cGUuVFJBTlNGT1JNX0NIQU5HRURdXSBldmVudFxyXG4gICAgICogQHpoIOiKgueCueWPmOaNouabtOaWsOeahOWFt+S9k+mDqOWIhu+8jOWPr+eUqOS6juWIpOaWrSBbW1N5c3RlbUV2ZW50VHlwZS5UUkFOU0ZPUk1fQ0hBTkdFRF1dIOS6i+S7tueahOWFt+S9k+exu+Wei1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFRyYW5zZm9ybUJpdCA9IFRyYW5zZm9ybUJpdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBEZXRlcm1pbmUgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgbm9ybWFsIE5vZGUuIFdpbGwgcmV0dXJuIGZhbHNlIGlmIFtbU2NlbmVdXSBnaXZlbi5cclxuICAgICAqIEB6aCDmjIflrprlr7nosaHmmK/lkKbmmK/mma7pgJrnmoToioLngrnvvJ/lpoLmnpzkvKDlhaUgW1tTY2VuZV1dIOS8mui/lOWbniBmYWxzZeOAglxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGlzTm9kZSAob2JqOiBvYmplY3QgfCBudWxsKTogb2JqIGlzIE5vZGUge1xyXG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBOb2RlICYmIChvYmouY29uc3RydWN0b3IgPT09IE5vZGUgfHwgIShvYmogaW5zdGFuY2VvZiBjYy5TY2VuZSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVJIOmDqOWIhueahOiEj+aVsOaNrlxyXG4gICAgcHVibGljIF91aVByb3BzID0gbmV3IE5vZGVVSVByb3BlcnRpZXModGhpcyk7XHJcbiAgICBwdWJsaWMgX3N0YXRpYyA9IGZhbHNlO1xyXG5cclxuICAgIC8vIHdvcmxkIHRyYW5zZm9ybSwgZG9uJ3QgYWNjZXNzIHRoaXMgZGlyZWN0bHlcclxuICAgIHByb3RlY3RlZCBfcG9zID0gbmV3IFZlYzMoKTtcclxuICAgIHByb3RlY3RlZCBfcm90ID0gbmV3IFF1YXQoKTtcclxuICAgIHByb3RlY3RlZCBfc2NhbGUgPSBuZXcgVmVjMygxLCAxLCAxKTtcclxuICAgIHByb3RlY3RlZCBfbWF0ID0gbmV3IE1hdDQoKTtcclxuXHJcbiAgICAvLyBsb2NhbCB0cmFuc2Zvcm1cclxuICAgIEBwcm9wZXJ0eVxyXG4gICAgcHJvdGVjdGVkIF9scG9zID0gbmV3IFZlYzMoKTtcclxuICAgIEBwcm9wZXJ0eVxyXG4gICAgcHJvdGVjdGVkIF9scm90ID0gbmV3IFF1YXQoKTtcclxuICAgIEBwcm9wZXJ0eVxyXG4gICAgcHJvdGVjdGVkIF9sc2NhbGUgPSBuZXcgVmVjMygxLCAxLCAxKTtcclxuICAgIEBwcm9wZXJ0eVxyXG4gICAgcHJvdGVjdGVkIF9sYXllciA9IExheWVycy5FbnVtLkRFRkFVTFQ7IC8vIHRoZSBsYXllciB0aGlzIG5vZGUgYmVsb25ncyB0b1xyXG5cclxuICAgIC8vIGxvY2FsIHJvdGF0aW9uIGluIGV1bGVyIGFuZ2xlcywgbWFpbnRhaW5lZCBoZXJlIHNvIHRoYXQgcm90YXRpb24gYW5nbGVzIGNvdWxkIGJlIGdyZWF0ZXIgdGhhbiAzNjAgZGVncmVlLlxyXG4gICAgQHByb3BlcnR5XHJcbiAgICBwcm90ZWN0ZWQgX2V1bGVyID0gbmV3IFZlYzMoKTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2RpcnR5RmxhZ3MgPSBUcmFuc2Zvcm1CaXQuTk9ORTsgLy8gZG9lcyB0aGUgd29ybGQgdHJhbnNmb3JtIG5lZWQgdG8gdXBkYXRlP1xyXG4gICAgcHJvdGVjdGVkIF9ldWxlckRpcnR5ID0gZmFsc2U7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gUG9zaXRpb24gaW4gbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW1cclxuICAgICAqIEB6aCDmnKzlnLDlnZDmoIfns7vkuIvnmoTlnZDmoIdcclxuICAgICAqL1xyXG4gICAgLy8gQGNvbnN0Z2V0XHJcbiAgICBwdWJsaWMgZ2V0IHBvc2l0aW9uICgpOiBSZWFkb25seTxWZWMzPiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xwb3M7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHBvc2l0aW9uICh2YWw6IFJlYWRvbmx5PFZlYzM+KSB7XHJcbiAgICAgICAgdGhpcy5zZXRQb3NpdGlvbih2YWwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFBvc2l0aW9uIGluIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtXHJcbiAgICAgKiBAemgg5LiW55WM5Z2Q5qCH57O75LiL55qE5Z2Q5qCHXHJcbiAgICAgKi9cclxuICAgIC8vIEBjb25zdGdldFxyXG4gICAgcHVibGljIGdldCB3b3JsZFBvc2l0aW9uICgpOiBSZWFkb25seTxWZWMzPiB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVXb3JsZFRyYW5zZm9ybSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb3M7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHdvcmxkUG9zaXRpb24gKHZhbDogUmVhZG9ubHk8VmVjMz4pIHtcclxuICAgICAgICB0aGlzLnNldFdvcmxkUG9zaXRpb24odmFsKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBSb3RhdGlvbiBpbiBsb2NhbCBjb29yZGluYXRlIHN5c3RlbSwgcmVwcmVzZW50ZWQgYnkgYSBxdWF0ZXJuaW9uXHJcbiAgICAgKiBAemgg5pys5Zyw5Z2Q5qCH57O75LiL55qE5peL6L2s77yM55So5Zub5YWD5pWw6KGo56S6XHJcbiAgICAgKi9cclxuICAgIC8vIEBjb25zdGdldFxyXG4gICAgcHVibGljIGdldCByb3RhdGlvbiAoKTogUmVhZG9ubHk8UXVhdD4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9scm90O1xyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCByb3RhdGlvbiAodmFsOiBSZWFkb25seTxRdWF0Pikge1xyXG4gICAgICAgIHRoaXMuc2V0Um90YXRpb24odmFsKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBSb3RhdGlvbiBpbiBsb2NhbCBjb29yZGluYXRlIHN5c3RlbSwgcmVwcmVzZW50ZWQgYnkgZXVsZXIgYW5nbGVzXHJcbiAgICAgKiBAemgg5pys5Zyw5Z2Q5qCH57O75LiL55qE5peL6L2s77yM55So5qyn5ouJ6KeS6KGo56S6XHJcbiAgICAgKi9cclxuICAgIEBwcm9wZXJ0eSh7IHR5cGU6IFZlYzMgfSlcclxuICAgIHNldCBldWxlckFuZ2xlcyAodmFsOiBSZWFkb25seTxWZWMzPikge1xyXG4gICAgICAgIHRoaXMuc2V0Um90YXRpb25Gcm9tRXVsZXIodmFsLngsIHZhbC55LCB2YWwueik7XHJcbiAgICB9XHJcbiAgICBnZXQgZXVsZXJBbmdsZXMgKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9ldWxlckRpcnR5KSB7XHJcbiAgICAgICAgICAgIFF1YXQudG9FdWxlcih0aGlzLl9ldWxlciwgdGhpcy5fbHJvdCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2V1bGVyRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V1bGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFJvdGF0aW9uIGluIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtLCByZXByZXNlbnRlZCBieSBhIHF1YXRlcm5pb25cclxuICAgICAqIEB6aCDkuJbnlYzlnZDmoIfns7vkuIvnmoTml4vovazvvIznlKjlm5vlhYPmlbDooajnpLpcclxuICAgICAqL1xyXG4gICAgLy8gQGNvbnN0Z2V0XHJcbiAgICBwdWJsaWMgZ2V0IHdvcmxkUm90YXRpb24gKCk6IFJlYWRvbmx5PFF1YXQ+IHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVdvcmxkVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdDtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgd29ybGRSb3RhdGlvbiAodmFsOiBSZWFkb25seTxRdWF0Pikge1xyXG4gICAgICAgIHRoaXMuc2V0V29ybGRSb3RhdGlvbih2YWwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFNjYWxlIGluIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtXHJcbiAgICAgKiBAemgg5pys5Zyw5Z2Q5qCH57O75LiL55qE57yp5pS+XHJcbiAgICAgKi9cclxuICAgIC8vIEBjb25zdGdldFxyXG4gICAgcHVibGljIGdldCBzY2FsZSAoKTogUmVhZG9ubHk8VmVjMz4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sc2NhbGU7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IHNjYWxlICh2YWw6IFJlYWRvbmx5PFZlYzM+KSB7XHJcbiAgICAgICAgdGhpcy5zZXRTY2FsZSh2YWwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFNjYWxlIGluIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtXHJcbiAgICAgKiBAemgg5LiW55WM5Z2Q5qCH57O75LiL55qE57yp5pS+XHJcbiAgICAgKi9cclxuICAgIC8vIEBjb25zdGdldFxyXG4gICAgcHVibGljIGdldCB3b3JsZFNjYWxlICgpOiBSZWFkb25seTxWZWMzPiB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVXb3JsZFRyYW5zZm9ybSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgd29ybGRTY2FsZSAodmFsOiBSZWFkb25seTxWZWMzPikge1xyXG4gICAgICAgIHRoaXMuc2V0V29ybGRTY2FsZSh2YWwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIExvY2FsIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxyXG4gICAgICogQHpoIOacrOWcsOWdkOagh+ezu+WPmOaNouefqemYtVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0IG1hdHJpeCAodmFsOiBSZWFkb25seTxNYXQ0Pikge1xyXG4gICAgICAgIE1hdDQudG9SVFModmFsLCB0aGlzLl9scm90LCB0aGlzLl9scG9zLCB0aGlzLl9sc2NhbGUpO1xyXG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUNoaWxkcmVuKFRyYW5zZm9ybUJpdC5UUlMpO1xyXG4gICAgICAgIHRoaXMuX2V1bGVyRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLl9ldmVudE1hc2sgJiBUUkFOU0ZPUk1fT04pIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KFN5c3RlbUV2ZW50VHlwZS5UUkFOU0ZPUk1fQ0hBTkdFRCwgVHJhbnNmb3JtQml0LlRSUyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFdvcmxkIHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxyXG4gICAgICogQHpoIOS4lueVjOWdkOagh+ezu+WPmOaNouefqemYtVxyXG4gICAgICovXHJcbiAgICAvLyBAY29uc3RnZXRcclxuICAgIHB1YmxpYyBnZXQgd29ybGRNYXRyaXggKCk6IFJlYWRvbmx5PE1hdDQ+IHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVdvcmxkVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBUaGUgdmVjdG9yIHJlcHJlc2VudGluZyBmb3J3YXJkIGRpcmVjdGlvbiBpbiBsb2NhbCBjb29yZGluYXRlIHN5c3RlbSwgaXQncyB0aGUgbWludXMgeiBkaXJlY3Rpb24gYnkgZGVmYXVsdFxyXG4gICAgICogQHpoIOW9k+WJjeiKgueCuemdouWQkeeahOWJjeaWueaWueWQke+8jOm7mOiupOWJjeaWueS4uiAteiDmlrnlkJFcclxuICAgICAqL1xyXG4gICAgZ2V0IGZvcndhcmQgKCk6IFZlYzMge1xyXG4gICAgICAgIHJldHVybiBWZWMzLnRyYW5zZm9ybVF1YXQobmV3IFZlYzMoKSwgVmVjMy5GT1JXQVJELCB0aGlzLndvcmxkUm90YXRpb24pO1xyXG4gICAgfVxyXG4gICAgc2V0IGZvcndhcmQgKGRpcjogVmVjMykge1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IGRpci5sZW5ndGgoKTtcclxuICAgICAgICBWZWMzLm11bHRpcGx5U2NhbGFyKHYzX2EsIGRpciwgLTEgLyBsZW4pO1xyXG4gICAgICAgIFF1YXQuZnJvbVZpZXdVcChxX2EsIHYzX2EpO1xyXG4gICAgICAgIHRoaXMuc2V0V29ybGRSb3RhdGlvbihxX2EpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIExheWVyIG9mIHRoZSBjdXJyZW50IE5vZGUsIGl0IGFmZmVjdHMgcmF5Y2FzdCwgcGh5c2ljcyBldGMsIHJlZmVyIHRvIFtbTGF5ZXJzXV1cclxuICAgICAqIEB6aCDoioLngrnmiYDlsZ7lsYLvvIzkuLvopoHlvbHlk43lsITnur/mo4DmtYvjgIHniannkIbnorDmkp7nrYnvvIzlj4LogIMgW1tMYXllcnNdXVxyXG4gICAgICovXHJcbiAgICBAcHJvcGVydHlcclxuICAgIHNldCBsYXllciAobCkge1xyXG4gICAgICAgIHRoaXMuX2xheWVyID0gbDtcclxuICAgIH1cclxuICAgIGdldCBsYXllciAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFdoZXRoZXIgdGhlIG5vZGUncyB0cmFuc2Zvcm1hdGlvbiBoYXZlIGNoYW5nZWQgZHVyaW5nIHRoZSBjdXJyZW50IGZyYW1lLlxyXG4gICAgICogQHpoIOi/meS4quiKgueCueeahOepuumXtOWPmOaNouS/oeaBr+WcqOW9k+WJjeW4p+WGheaYr+WQpuacieWPmOi/h++8n1xyXG4gICAgICovXHJcbiAgICBnZXQgaGFzQ2hhbmdlZEZsYWdzICgpIHtcclxuICAgICAgICByZXR1cm4gYm9va09mQ2hhbmdlLmdldCh0aGlzLl9pZCkgfHwgMDtcclxuICAgIH1cclxuICAgIHNldCBoYXNDaGFuZ2VkRmxhZ3MgKHZhbDogbnVtYmVyKSB7XHJcbiAgICAgICAgYm9va09mQ2hhbmdlLnNldCh0aGlzLl9pZCwgdmFsKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIGdldCB3aWR0aCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VpUHJvcHMudWlUcmFuc2Zvcm1Db21wIS53aWR0aDtcclxuICAgIH1cclxuICAgIHNldCB3aWR0aCAodmFsdWU6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuX3VpUHJvcHMudWlUcmFuc2Zvcm1Db21wIS53aWR0aCA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBoZWlnaHQgKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91aVByb3BzLnVpVHJhbnNmb3JtQ29tcCEuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgc2V0IGhlaWdodCAodmFsdWU6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuX3VpUHJvcHMudWlUcmFuc2Zvcm1Db21wIS5oZWlnaHQgPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgYW5jaG9yWCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VpUHJvcHMudWlUcmFuc2Zvcm1Db21wIS5hbmNob3JYO1xyXG4gICAgfVxyXG4gICAgc2V0IGFuY2hvclggKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fdWlQcm9wcy51aVRyYW5zZm9ybUNvbXAhLmFuY2hvclggPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBnZXQgYW5jaG9yWSAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VpUHJvcHMudWlUcmFuc2Zvcm1Db21wIS5hbmNob3JZO1xyXG4gICAgfVxyXG4gICAgc2V0IGFuY2hvclkgKHZhbHVlOiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl91aVByb3BzLnVpVHJhbnNmb3JtQ29tcCEuYW5jaG9yWSA9IHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIGhpZXJhcmNoeVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFNldCBwYXJlbnQgb2YgdGhlIG5vZGUuXHJcbiAgICAgKiBAemgg6K6+572u6K+l6IqC54K555qE54i26IqC54K544CCXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgUGFyZW50IG5vZGVcclxuICAgICAqIEBwYXJhbSBrZWVwV29ybGRUcmFuc2Zvcm0gV2hldGhlciBrZWVwIG5vZGUncyBjdXJyZW50IHdvcmxkIHRyYW5zZm9ybSB1bmNoYW5nZWQgYWZ0ZXIgdGhpcyBvcGVyYXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFBhcmVudCAodmFsdWU6IHRoaXMgfCBudWxsLCBrZWVwV29ybGRUcmFuc2Zvcm06IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgICAgIGlmIChrZWVwV29ybGRUcmFuc2Zvcm0pIHsgdGhpcy51cGRhdGVXb3JsZFRyYW5zZm9ybSgpOyB9XHJcbiAgICAgICAgc3VwZXIuc2V0UGFyZW50KHZhbHVlLCBrZWVwV29ybGRUcmFuc2Zvcm0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBfb25TZXRQYXJlbnQgKG9sZFBhcmVudDogdGhpcyB8IG51bGwsIGtlZXBXb3JsZFRyYW5zZm9ybTogYm9vbGVhbikge1xyXG4gICAgICAgIHN1cGVyLl9vblNldFBhcmVudChvbGRQYXJlbnQsIGtlZXBXb3JsZFRyYW5zZm9ybSk7XHJcbiAgICAgICAgaWYgKGtlZXBXb3JsZFRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XHJcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVXb3JsZFRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgTWF0NC5tdWx0aXBseShtNF8xLCBNYXQ0LmludmVydChtNF8xLCBwYXJlbnQuX21hdCksIHRoaXMuX21hdCk7XHJcbiAgICAgICAgICAgICAgICBNYXQ0LnRvUlRTKG00XzEsIHRoaXMuX2xyb3QsIHRoaXMuX2xwb3MsIHRoaXMuX2xzY2FsZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBWZWMzLmNvcHkodGhpcy5fbHBvcywgdGhpcy5fcG9zKTtcclxuICAgICAgICAgICAgICAgIFF1YXQuY29weSh0aGlzLl9scm90LCB0aGlzLl9yb3QpO1xyXG4gICAgICAgICAgICAgICAgVmVjMy5jb3B5KHRoaXMuX2xzY2FsZSwgdGhpcy5fc2NhbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2V1bGVyRGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlQ2hpbGRyZW4oVHJhbnNmb3JtQml0LlRSUyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF9vbkJhdGNoQ3JlYXRlZCAoKSB7XHJcbiAgICAgICAgc3VwZXIuX29uQmF0Y2hDcmVhdGVkKCk7XHJcbiAgICAgICAgYm9va09mQ2hhbmdlLnNldCh0aGlzLl9pZCwgVHJhbnNmb3JtQml0LlRSUyk7XHJcbiAgICAgICAgdGhpcy5fZGlydHlGbGFncyA9IFRyYW5zZm9ybUJpdC5UUlM7XHJcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW5baV0uX29uQmF0Y2hDcmVhdGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBfb25CYXRjaFJlc3RvcmVkICgpIHtcclxuICAgICAgICB0aGlzLl9vbkJhdGNoQ3JlYXRlZCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBfb25CZWZvcmVTZXJpYWxpemUgKCkge1xyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tdW51c2VkLWV4cHJlc3Npb25cclxuICAgICAgICB0aGlzLmV1bGVyQW5nbGVzOyAvLyBtYWtlIHN1cmUgd2Ugc2F2ZSB0aGUgY29ycmVjdCBldWxlckFuZ2xlc1xyXG4gICAgfVxyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIHRyYW5zZm9ybSBoZWxwZXIsIGNvbnZlbmllbnQgYnV0IG5vdCB0aGUgbW9zdCBlZmZpY2llbnRcclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBQZXJmb3JtIGEgdHJhbnNsYXRpb24gb24gdGhlIG5vZGVcclxuICAgICAqIEB6aCDnp7vliqjoioLngrlcclxuICAgICAqIEBwYXJhbSB0cmFucyBUaGUgaW5jcmVtZW50IG9uIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gbnMgVGhlIG9wZXJhdGlvbiBjb29yZGluYXRlIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0cmFuc2xhdGUgKHRyYW5zOiBWZWMzLCBucz86IE5vZGVTcGFjZSk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHNwYWNlID0gbnMgfHwgTm9kZVNwYWNlLkxPQ0FMO1xyXG4gICAgICAgIGlmIChzcGFjZSA9PT0gTm9kZVNwYWNlLkxPQ0FMKSB7XHJcbiAgICAgICAgICAgIFZlYzMudHJhbnNmb3JtUXVhdCh2M19hLCB0cmFucywgdGhpcy5fbHJvdCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xwb3MueCArPSB2M19hLng7XHJcbiAgICAgICAgICAgIHRoaXMuX2xwb3MueSArPSB2M19hLnk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xwb3MueiArPSB2M19hLno7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzcGFjZSA9PT0gTm9kZVNwYWNlLldPUkxEKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIFF1YXQuaW52ZXJ0KHFfYSwgdGhpcy5fcGFyZW50LndvcmxkUm90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgVmVjMy50cmFuc2Zvcm1RdWF0KHYzX2EsIHRyYW5zLCBxX2EpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLndvcmxkU2NhbGU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9scG9zLnggKz0gdjNfYS54IC8gc2NhbGUueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xwb3MueSArPSB2M19hLnkgLyBzY2FsZS55O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbHBvcy56ICs9IHYzX2EueiAvIHNjYWxlLno7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9scG9zLnggKz0gdHJhbnMueDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xwb3MueSArPSB0cmFucy55O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbHBvcy56ICs9IHRyYW5zLno7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUNoaWxkcmVuKFRyYW5zZm9ybUJpdC5QT1NJVElPTik7XHJcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50TWFzayAmIFRSQU5TRk9STV9PTikge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoU3lzdGVtRXZlbnRUeXBlLlRSQU5TRk9STV9DSEFOR0VELCBUcmFuc2Zvcm1CaXQuUE9TSVRJT04pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBQZXJmb3JtIGEgcm90YXRpb24gb24gdGhlIG5vZGVcclxuICAgICAqIEB6aCDml4vovazoioLngrlcclxuICAgICAqIEBwYXJhbSB0cmFucyBUaGUgaW5jcmVtZW50IG9uIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gbnMgVGhlIG9wZXJhdGlvbiBjb29yZGluYXRlIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByb3RhdGUgKHJvdDogUXVhdCwgbnM/OiBOb2RlU3BhY2UpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBzcGFjZSA9IG5zIHx8IE5vZGVTcGFjZS5MT0NBTDtcclxuICAgICAgICBRdWF0Lm5vcm1hbGl6ZShxX2EsIHJvdCk7XHJcblxyXG4gICAgICAgIGlmIChzcGFjZSA9PT0gTm9kZVNwYWNlLkxPQ0FMKSB7XHJcbiAgICAgICAgICAgIFF1YXQubXVsdGlwbHkodGhpcy5fbHJvdCwgdGhpcy5fbHJvdCwgcV9hKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHNwYWNlID09PSBOb2RlU3BhY2UuV09STEQpIHtcclxuICAgICAgICAgICAgY29uc3Qgd29ybGRSb3QgPSB0aGlzLndvcmxkUm90YXRpb247XHJcbiAgICAgICAgICAgIFF1YXQubXVsdGlwbHkocV9iLCBxX2EsIHdvcmxkUm90KTtcclxuICAgICAgICAgICAgUXVhdC5pbnZlcnQocV9hLCB3b3JsZFJvdCk7XHJcbiAgICAgICAgICAgIFF1YXQubXVsdGlwbHkocV9iLCBxX2EsIHFfYik7XHJcbiAgICAgICAgICAgIFF1YXQubXVsdGlwbHkodGhpcy5fbHJvdCwgdGhpcy5fbHJvdCwgcV9iKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZXVsZXJEaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUNoaWxkcmVuKFRyYW5zZm9ybUJpdC5ST1RBVElPTik7XHJcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50TWFzayAmIFRSQU5TRk9STV9PTikge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoU3lzdGVtRXZlbnRUeXBlLlRSQU5TRk9STV9DSEFOR0VELCBUcmFuc2Zvcm1CaXQuUk9UQVRJT04pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBTZXQgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBub2RlIHRvIGZhY2UgdGhlIHRhcmdldCBwb3NpdGlvbiwgdGhlIG5vZGUgaXMgZmFjaW5nIG1pbnVzIHogZGlyZWN0aW9uIGJ5IGRlZmF1bHRcclxuICAgICAqIEB6aCDorr7nva7lvZPliY3oioLngrnml4vovazkuLrpnaLlkJHnm67moIfkvY3nva7vvIzpu5jorqTliY3mlrnkuLogLXog5pa55ZCRXHJcbiAgICAgKiBAcGFyYW0gcG9zIFRhcmdldCBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHVwIFVwIGRpcmVjdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbG9va0F0IChwb3M6IFZlYzMsIHVwPzogVmVjMyk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZ2V0V29ybGRQb3NpdGlvbih2M19hKTtcclxuICAgICAgICBWZWMzLnN1YnRyYWN0KHYzX2EsIHYzX2EsIHBvcyk7XHJcbiAgICAgICAgVmVjMy5ub3JtYWxpemUodjNfYSwgdjNfYSk7XHJcbiAgICAgICAgUXVhdC5mcm9tVmlld1VwKHFfYSwgdjNfYSwgdXApO1xyXG4gICAgICAgIHRoaXMuc2V0V29ybGRSb3RhdGlvbihxX2EpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgIC8vIHRyYW5zZm9ybSBtYWludGFpbmVyXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gSW52YWxpZGF0ZSB0aGUgd29ybGQgdHJhbnNmb3JtIGluZm9ybWF0aW9uXHJcbiAgICAgKiBmb3IgdGhpcyBub2RlIGFuZCBhbGwgaXRzIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5XHJcbiAgICAgKiBAemgg6YCS5b2S5qCH6K6w6IqC54K55LiW55WM5Y+Y5o2i5Li6IGRpcnR5XHJcbiAgICAgKiBAcGFyYW0gZGlydHlCaXQgVGhlIGRpcnR5IGJpdHMgdG8gc2V0dXAgdG8gY2hpbGRyZW4sIGNhbiBiZSBjb21wb3NlZCB3aXRoIG11bHRpcGxlIGRpcnR5IGJpdHNcclxuICAgICAqL1xyXG4gICAgcHVibGljIGludmFsaWRhdGVDaGlsZHJlbiAoZGlydHlCaXQ6IFRyYW5zZm9ybUJpdCkge1xyXG4gICAgICAgIGlmICgodGhpcy5fZGlydHlGbGFncyAmIHRoaXMuaGFzQ2hhbmdlZEZsYWdzICYgZGlydHlCaXQpID09PSBkaXJ0eUJpdCkgeyByZXR1cm47IH1cclxuICAgICAgICB0aGlzLl9kaXJ0eUZsYWdzIHw9IGRpcnR5Qml0O1xyXG4gICAgICAgIGJvb2tPZkNoYW5nZS5zZXQodGhpcy5faWQsIHRoaXMuaGFzQ2hhbmdlZEZsYWdzIHwgZGlydHlCaXQpO1xyXG4gICAgICAgIGRpcnR5Qml0IHw9IFRyYW5zZm9ybUJpdC5QT1NJVElPTjtcclxuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQuaXNWYWxpZCkgeyBjaGlsZC5pbnZhbGlkYXRlQ2hpbGRyZW4oZGlydHlCaXQpOyB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFVwZGF0ZSB0aGUgd29ybGQgdHJhbnNmb3JtIGluZm9ybWF0aW9uIGlmIG91dGRhdGVkXHJcbiAgICAgKiBAemgg5pu05paw6IqC54K555qE5LiW55WM5Y+Y5o2i5L+h5oGvXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1cGRhdGVXb3JsZFRyYW5zZm9ybSAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kaXJ0eUZsYWdzKSB7IHJldHVybjsgfVxyXG4gICAgICAgIGxldCBjdXI6IHRoaXMgfCBudWxsID0gdGhpcztcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGN1ciAmJiBjdXIuX2RpcnR5RmxhZ3MpIHtcclxuICAgICAgICAgICAgLy8gdG9wIGxldmVsIG5vZGVcclxuICAgICAgICAgICAgYXJyYXlfYVtpKytdID0gY3VyO1xyXG4gICAgICAgICAgICBjdXIgPSBjdXIuX3BhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNoaWxkOiB0aGlzOyBsZXQgZGlydHlCaXRzID0gMDtcclxuICAgICAgICB3aGlsZSAoaSkge1xyXG4gICAgICAgICAgICBjaGlsZCA9IGFycmF5X2FbLS1pXTtcclxuICAgICAgICAgICAgZGlydHlCaXRzIHw9IGNoaWxkLl9kaXJ0eUZsYWdzO1xyXG4gICAgICAgICAgICBpZiAoY3VyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlydHlCaXRzICYgVHJhbnNmb3JtQml0LlBPU0lUSU9OKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVmVjMy50cmFuc2Zvcm1NYXQ0KGNoaWxkLl9wb3MsIGNoaWxkLl9scG9zLCBjdXIuX21hdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuX21hdC5tMTIgPSBjaGlsZC5fcG9zLng7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuX21hdC5tMTMgPSBjaGlsZC5fcG9zLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuX21hdC5tMTQgPSBjaGlsZC5fcG9zLno7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlydHlCaXRzICYgVHJhbnNmb3JtQml0LlJTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTWF0NC5mcm9tUlRTKGNoaWxkLl9tYXQsIGNoaWxkLl9scm90LCBjaGlsZC5fbHBvcywgY2hpbGQuX2xzY2FsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgTWF0NC5tdWx0aXBseShjaGlsZC5fbWF0LCBjdXIuX21hdCwgY2hpbGQuX21hdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcnR5Qml0cyAmIFRyYW5zZm9ybUJpdC5ST1RBVElPTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBRdWF0Lm11bHRpcGx5KGNoaWxkLl9yb3QsIGN1ci5fcm90LCBjaGlsZC5fbHJvdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIE1hdDMuZnJvbVF1YXQobTNfMSwgUXVhdC5jb25qdWdhdGUocXRfMSwgY2hpbGQuX3JvdCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIE1hdDMubXVsdGlwbHlNYXQ0KG0zXzEsIG0zXzEsIGNoaWxkLl9tYXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLl9zY2FsZS54ID0gbTNfMS5tMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuX3NjYWxlLnkgPSBtM18xLm0wNDtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5fc2NhbGUueiA9IG0zXzEubTA4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpcnR5Qml0cyAmIFRyYW5zZm9ybUJpdC5QT1NJVElPTikge1xyXG4gICAgICAgICAgICAgICAgICAgIFZlYzMuY29weShjaGlsZC5fcG9zLCBjaGlsZC5fbHBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuX21hdC5tMTIgPSBjaGlsZC5fcG9zLng7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuX21hdC5tMTMgPSBjaGlsZC5fcG9zLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuX21hdC5tMTQgPSBjaGlsZC5fcG9zLno7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlydHlCaXRzICYgVHJhbnNmb3JtQml0LlJTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcnR5Qml0cyAmIFRyYW5zZm9ybUJpdC5ST1RBVElPTikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBRdWF0LmNvcHkoY2hpbGQuX3JvdCwgY2hpbGQuX2xyb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlydHlCaXRzICYgVHJhbnNmb3JtQml0LlNDQUxFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFZlYzMuY29weShjaGlsZC5fc2NhbGUsIGNoaWxkLl9sc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBNYXQ0LmZyb21SVFMoY2hpbGQuX21hdCwgY2hpbGQuX3JvdCwgY2hpbGQuX3BvcywgY2hpbGQuX3NjYWxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGlsZC5fZGlydHlGbGFncyA9IFRyYW5zZm9ybUJpdC5OT05FO1xyXG4gICAgICAgICAgICBjdXIgPSBjaGlsZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gICAgLy8gdHJhbnNmb3JtXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gU2V0IHBvc2l0aW9uIGluIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtXHJcbiAgICAgKiBAemgg6K6+572u5pys5Zyw5Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGFyZ2V0IHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRQb3NpdGlvbiAocG9zaXRpb246IFZlYzMpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFNldCBwb3NpdGlvbiBpbiBsb2NhbCBjb29yZGluYXRlIHN5c3RlbVxyXG4gICAgICogQHpoIOiuvue9ruacrOWcsOWdkOagh1xyXG4gICAgICogQHBhcmFtIHggWCBheGlzIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0geSBZIGF4aXMgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB6IFogYXhpcyBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0UG9zaXRpb24gKHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIpOiB2b2lkO1xyXG5cclxuICAgIHB1YmxpYyBzZXRQb3NpdGlvbiAodmFsOiBWZWMzIHwgbnVtYmVyLCB5PzogbnVtYmVyLCB6PzogbnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCB8fCB6ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgVmVjMy5jb3B5KHRoaXMuX2xwb3MsIHZhbCBhcyBWZWMzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBWZWMzLnNldCh0aGlzLl9scG9zLCB2YWwgYXMgbnVtYmVyLCB5LCB6KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUNoaWxkcmVuKFRyYW5zZm9ybUJpdC5QT1NJVElPTik7XHJcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50TWFzayAmIFRSQU5TRk9STV9PTikge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoU3lzdGVtRXZlbnRUeXBlLlRSQU5TRk9STV9DSEFOR0VELCBUcmFuc2Zvcm1CaXQuUE9TSVRJT04pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBHZXQgcG9zaXRpb24gaW4gbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW0sIHBsZWFzZSB0cnkgdG8gcGFzcyBgb3V0YCB2ZWN0b3IgYW5kIHJldXNlIGl0IHRvIGF2b2lkIGdhcmJhZ2UuXHJcbiAgICAgKiBAemgg6I635Y+W5pys5Zyw5Z2Q5qCH77yM5rOo5oSP77yM5bC95Y+v6IO95Lyg6YCS5aSN55So55qEIFtbVmVjM11dIOS7pemBv+WFjeS6p+eUn+Weg+WcvuOAglxyXG4gICAgICogQHBhcmFtIG91dCBTZXQgdGhlIHJlc3VsdCB0byBvdXQgdmVjdG9yXHJcbiAgICAgKiBAcmV0dXJuIElmIGBvdXRgIGdpdmVuLCB0aGUgcmV0dXJuIHZhbHVlIGVxdWFscyB0byBgb3V0YCwgb3RoZXJ3aXNlIGEgbmV3IHZlY3RvciB3aWxsIGJlIGdlbmVyYXRlZCBhbmQgcmV0dXJuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRQb3NpdGlvbiAob3V0PzogVmVjMyk6IFZlYzMge1xyXG4gICAgICAgIGlmIChvdXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFZlYzMuc2V0KG91dCwgdGhpcy5fbHBvcy54LCB0aGlzLl9scG9zLnksIHRoaXMuX2xwb3Mueik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFZlYzMuY29weShuZXcgVmVjMygpLCB0aGlzLl9scG9zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gU2V0IHJvdGF0aW9uIGluIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtIHdpdGggYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb25cclxuICAgICAqIEB6aCDnlKjlm5vlhYPmlbDorr7nva7mnKzlnLDml4vovaxcclxuICAgICAqIEBwYXJhbSByb3RhdGlvbiBSb3RhdGlvbiBpbiBxdWF0ZXJuaW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRSb3RhdGlvbiAocm90YXRpb246IFF1YXQpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFNldCByb3RhdGlvbiBpbiBsb2NhbCBjb29yZGluYXRlIHN5c3RlbSB3aXRoIGEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJvdGF0aW9uXHJcbiAgICAgKiBAemgg55So5Zub5YWD5pWw6K6+572u5pys5Zyw5peL6L2sXHJcbiAgICAgKiBAcGFyYW0geCBYIHZhbHVlIGluIHF1YXRlcm5pb25cclxuICAgICAqIEBwYXJhbSB5IFkgdmFsdWUgaW4gcXVhdGVybmlvblxyXG4gICAgICogQHBhcmFtIHogWiB2YWx1ZSBpbiBxdWF0ZXJuaW9uXHJcbiAgICAgKiBAcGFyYW0gdyBXIHZhbHVlIGluIHF1YXRlcm5pb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFJvdGF0aW9uICh4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyLCB3OiBudW1iZXIpOiB2b2lkO1xyXG5cclxuICAgIHB1YmxpYyBzZXRSb3RhdGlvbiAodmFsOiBRdWF0IHwgbnVtYmVyLCB5PzogbnVtYmVyLCB6PzogbnVtYmVyLCB3PzogbnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCB8fCB6ID09PSB1bmRlZmluZWQgfHwgdyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIFF1YXQuY29weSh0aGlzLl9scm90LCB2YWwgYXMgUXVhdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgUXVhdC5zZXQodGhpcy5fbHJvdCwgdmFsIGFzIG51bWJlciwgeSwgeiwgdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2V1bGVyRGlydHkgPSB0cnVlO1xyXG5cclxuICAgICAgICB0aGlzLmludmFsaWRhdGVDaGlsZHJlbihUcmFuc2Zvcm1CaXQuUk9UQVRJT04pO1xyXG4gICAgICAgIGlmICh0aGlzLl9ldmVudE1hc2sgJiBUUkFOU0ZPUk1fT04pIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KFN5c3RlbUV2ZW50VHlwZS5UUkFOU0ZPUk1fQ0hBTkdFRCwgVHJhbnNmb3JtQml0LlJPVEFUSU9OKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gU2V0IHJvdGF0aW9uIGluIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtIHdpdGggZXVsZXIgYW5nbGVzXHJcbiAgICAgKiBAemgg55So5qyn5ouJ6KeS6K6+572u5pys5Zyw5peL6L2sXHJcbiAgICAgKiBAcGFyYW0geCBYIGF4aXMgcm90YXRpb25cclxuICAgICAqIEBwYXJhbSB5IFkgYXhpcyByb3RhdGlvblxyXG4gICAgICogQHBhcmFtIHogWiBheGlzIHJvdGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRSb3RhdGlvbkZyb21FdWxlciAoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlcik6IHZvaWQge1xyXG4gICAgICAgIFZlYzMuc2V0KHRoaXMuX2V1bGVyLCB4LCB5LCB6KTtcclxuICAgICAgICBRdWF0LmZyb21FdWxlcih0aGlzLl9scm90LCB4LCB5LCB6KTtcclxuICAgICAgICB0aGlzLl9ldWxlckRpcnR5ID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUNoaWxkcmVuKFRyYW5zZm9ybUJpdC5ST1RBVElPTik7XHJcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50TWFzayAmIFRSQU5TRk9STV9PTikge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoU3lzdGVtRXZlbnRUeXBlLlRSQU5TRk9STV9DSEFOR0VELCBUcmFuc2Zvcm1CaXQuUk9UQVRJT04pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBHZXQgcm90YXRpb24gYXMgcXVhdGVybmlvbiBpbiBsb2NhbCBjb29yZGluYXRlIHN5c3RlbSwgcGxlYXNlIHRyeSB0byBwYXNzIGBvdXRgIHF1YXRlcm5pb24gYW5kIHJldXNlIGl0IHRvIGF2b2lkIGdhcmJhZ2UuXHJcbiAgICAgKiBAemgg6I635Y+W5pys5Zyw5peL6L2s77yM5rOo5oSP77yM5bC95Y+v6IO95Lyg6YCS5aSN55So55qEIFtbUXVhdF1dIOS7pemBv+WFjeS6p+eUn+Weg+WcvuOAglxyXG4gICAgICogQHBhcmFtIG91dCBTZXQgdGhlIHJlc3VsdCB0byBvdXQgcXVhdGVybmlvblxyXG4gICAgICogQHJldHVybiBJZiBgb3V0YCBnaXZlbiwgdGhlIHJldHVybiB2YWx1ZSBlcXVhbHMgdG8gYG91dGAsIG90aGVyd2lzZSBhIG5ldyBxdWF0ZXJuaW9uIHdpbGwgYmUgZ2VuZXJhdGVkIGFuZCByZXR1cm5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFJvdGF0aW9uIChvdXQ/OiBRdWF0KTogUXVhdCB7XHJcbiAgICAgICAgaWYgKG91dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUXVhdC5zZXQob3V0LCB0aGlzLl9scm90LngsIHRoaXMuX2xyb3QueSwgdGhpcy5fbHJvdC56LCB0aGlzLl9scm90LncpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBRdWF0LmNvcHkobmV3IFF1YXQoKSwgdGhpcy5fbHJvdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFNldCBzY2FsZSBpbiBsb2NhbCBjb29yZGluYXRlIHN5c3RlbVxyXG4gICAgICogQHpoIOiuvue9ruacrOWcsOe8qeaUvlxyXG4gICAgICogQHBhcmFtIHNjYWxlIFRhcmdldCBzY2FsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U2NhbGUgKHNjYWxlOiBWZWMzKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBTZXQgc2NhbGUgaW4gbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW1cclxuICAgICAqIEB6aCDorr7nva7mnKzlnLDnvKnmlL5cclxuICAgICAqIEBwYXJhbSB4IFggYXhpcyBzY2FsZVxyXG4gICAgICogQHBhcmFtIHkgWSBheGlzIHNjYWxlXHJcbiAgICAgKiBAcGFyYW0geiBaIGF4aXMgc2NhbGVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFNjYWxlICh4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgICBwdWJsaWMgc2V0U2NhbGUgKHZhbDogVmVjMyB8IG51bWJlciwgeT86IG51bWJlciwgej86IG51bWJlcikge1xyXG4gICAgICAgIGlmICh5ID09PSB1bmRlZmluZWQgfHwgeiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIFZlYzMuY29weSh0aGlzLl9sc2NhbGUsIHZhbCBhcyBWZWMzKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBWZWMzLnNldCh0aGlzLl9sc2NhbGUsIHZhbCBhcyBudW1iZXIsIHksIHopO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlQ2hpbGRyZW4oVHJhbnNmb3JtQml0LlNDQUxFKTtcclxuICAgICAgICBpZiAodGhpcy5fZXZlbnRNYXNrICYgVFJBTlNGT1JNX09OKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdChTeXN0ZW1FdmVudFR5cGUuVFJBTlNGT1JNX0NIQU5HRUQsIFRyYW5zZm9ybUJpdC5TQ0FMRSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIEdldCBzY2FsZSBpbiBsb2NhbCBjb29yZGluYXRlIHN5c3RlbSwgcGxlYXNlIHRyeSB0byBwYXNzIGBvdXRgIHZlY3RvciBhbmQgcmV1c2UgaXQgdG8gYXZvaWQgZ2FyYmFnZS5cclxuICAgICAqIEB6aCDojrflj5bmnKzlnLDnvKnmlL7vvIzms6jmhI/vvIzlsL3lj6/og73kvKDpgJLlpI3nlKjnmoQgW1tWZWMzXV0g5Lul6YG/5YWN5Lqn55Sf5Z6D5Zy+44CCXHJcbiAgICAgKiBAcGFyYW0gb3V0IFNldCB0aGUgcmVzdWx0IHRvIG91dCB2ZWN0b3JcclxuICAgICAqIEByZXR1cm4gSWYgYG91dGAgZ2l2ZW4sIHRoZSByZXR1cm4gdmFsdWUgZXF1YWxzIHRvIGBvdXRgLCBvdGhlcndpc2UgYSBuZXcgdmVjdG9yIHdpbGwgYmUgZ2VuZXJhdGVkIGFuZCByZXR1cm5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFNjYWxlIChvdXQ/OiBWZWMzKTogVmVjMyB7XHJcbiAgICAgICAgaWYgKG91dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gVmVjMy5zZXQob3V0LCB0aGlzLl9sc2NhbGUueCwgdGhpcy5fbHNjYWxlLnksIHRoaXMuX2xzY2FsZS56KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gVmVjMy5jb3B5KG5ldyBWZWMzKCksIHRoaXMuX2xzY2FsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIEludmVyc2VseSB0cmFuc2Zvcm0gYSBwb2ludCBmcm9tIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtIHRvIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtLlxyXG4gICAgICogQHpoIOmAhuWQkeWPmOaNouS4gOS4quepuumXtOeCue+8jOS4gOiIrOeUqOS6juWwhuS4lueVjOWdkOagh+i9rOaNouWIsOacrOWcsOWdkOagh+ezu+S4reOAglxyXG4gICAgICogQHBhcmFtIG91dCBUaGUgcmVzdWx0IHBvaW50IGluIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtIHdpbGwgYmUgc3RvcmVkIGluIHRoaXMgdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0gcCBBIHBvc2l0aW9uIGluIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbnZlcnNlVHJhbnNmb3JtUG9pbnQgKG91dDogVmVjMywgcDogVmVjMykge1xyXG4gICAgICAgIFZlYzMuY29weShvdXQsIHApO1xyXG4gICAgICAgIGxldCBjdXIgPSB0aGlzOyBsZXQgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGN1ci5fcGFyZW50KSB7XHJcbiAgICAgICAgICAgIGFycmF5X2FbaSsrXSA9IGN1cjtcclxuICAgICAgICAgICAgY3VyID0gY3VyLl9wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChpID49IDApIHtcclxuICAgICAgICAgICAgVmVjMy50cmFuc2Zvcm1JbnZlcnNlUlRTKG91dCwgb3V0LCBjdXIuX2xyb3QsIGN1ci5fbHBvcywgY3VyLl9sc2NhbGUpO1xyXG4gICAgICAgICAgICBjdXIgPSBhcnJheV9hWy0taV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gU2V0IHBvc2l0aW9uIGluIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtXHJcbiAgICAgKiBAemgg6K6+572u5LiW55WM5Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGFyZ2V0IHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRXb3JsZFBvc2l0aW9uIChwb3NpdGlvbjogVmVjMyk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gU2V0IHBvc2l0aW9uIGluIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtXHJcbiAgICAgKiBAemgg6K6+572u5LiW55WM5Z2Q5qCHXHJcbiAgICAgKiBAcGFyYW0geCBYIGF4aXMgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB5IFkgYXhpcyBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHogWiBheGlzIHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRXb3JsZFBvc2l0aW9uICh4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgICBwdWJsaWMgc2V0V29ybGRQb3NpdGlvbiAodmFsOiBWZWMzIHwgbnVtYmVyLCB5PzogbnVtYmVyLCB6PzogbnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCB8fCB6ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgVmVjMy5jb3B5KHRoaXMuX3BvcywgdmFsIGFzIFZlYzMpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIFZlYzMuc2V0KHRoaXMuX3BvcywgdmFsIGFzIG51bWJlciwgeSwgeik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3BhcmVudDtcclxuICAgICAgICBjb25zdCBsb2NhbCA9IHRoaXMuX2xwb3M7XHJcbiAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBiZW5jaG1hcmsgdGhlc2UgYXBwcm9hY2hlc1xyXG4gICAgICAgICAgICAvKiAqL1xyXG4gICAgICAgICAgICBwYXJlbnQudXBkYXRlV29ybGRUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgVmVjMy50cmFuc2Zvcm1NYXQ0KGxvY2FsLCB0aGlzLl9wb3MsIE1hdDQuaW52ZXJ0KG00XzEsIHBhcmVudC5fbWF0KSk7XHJcbiAgICAgICAgICAgIC8qICpcclxuICAgICAgICAgICAgcGFyZW50LmludmVyc2VUcmFuc2Zvcm1Qb2ludChsb2NhbCwgdGhpcy5fcG9zKTtcclxuICAgICAgICAgICAgLyogKi9cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBWZWMzLmNvcHkobG9jYWwsIHRoaXMuX3Bvcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmludmFsaWRhdGVDaGlsZHJlbihUcmFuc2Zvcm1CaXQuUE9TSVRJT04pO1xyXG4gICAgICAgIGlmICh0aGlzLl9ldmVudE1hc2sgJiBUUkFOU0ZPUk1fT04pIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KFN5c3RlbUV2ZW50VHlwZS5UUkFOU0ZPUk1fQ0hBTkdFRCwgVHJhbnNmb3JtQml0LlBPU0lUSU9OKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gR2V0IHBvc2l0aW9uIGluIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtLCBwbGVhc2UgdHJ5IHRvIHBhc3MgYG91dGAgdmVjdG9yIGFuZCByZXVzZSBpdCB0byBhdm9pZCBnYXJiYWdlLlxyXG4gICAgICogQHpoIOiOt+WPluS4lueVjOWdkOagh++8jOazqOaEj++8jOWwveWPr+iDveS8oOmAkuWkjeeUqOeahCBbW1ZlYzNdXSDku6Xpgb/lhY3kuqfnlJ/lnoPlnL7jgIJcclxuICAgICAqIEBwYXJhbSBvdXQgU2V0IHRoZSByZXN1bHQgdG8gb3V0IHZlY3RvclxyXG4gICAgICogQHJldHVybiBJZiBgb3V0YCBnaXZlbiwgdGhlIHJldHVybiB2YWx1ZSBlcXVhbHMgdG8gYG91dGAsIG90aGVyd2lzZSBhIG5ldyB2ZWN0b3Igd2lsbCBiZSBnZW5lcmF0ZWQgYW5kIHJldHVyblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0V29ybGRQb3NpdGlvbiAob3V0PzogVmVjMyk6IFZlYzMge1xyXG4gICAgICAgIHRoaXMudXBkYXRlV29ybGRUcmFuc2Zvcm0oKTtcclxuICAgICAgICBpZiAob3V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBWZWMzLmNvcHkob3V0LCB0aGlzLl9wb3MpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBWZWMzLmNvcHkobmV3IFZlYzMoKSwgdGhpcy5fcG9zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gU2V0IHJvdGF0aW9uIGluIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtIHdpdGggYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb25cclxuICAgICAqIEB6aCDnlKjlm5vlhYPmlbDorr7nva7kuJbnlYzlnZDmoIfns7vkuIvnmoTml4vovaxcclxuICAgICAqIEBwYXJhbSByb3RhdGlvbiBSb3RhdGlvbiBpbiBxdWF0ZXJuaW9uXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRXb3JsZFJvdGF0aW9uIChyb3RhdGlvbjogUXVhdCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gU2V0IHJvdGF0aW9uIGluIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtIHdpdGggYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb25cclxuICAgICAqIEB6aCDnlKjlm5vlhYPmlbDorr7nva7kuJbnlYzlnZDmoIfns7vkuIvnmoTml4vovaxcclxuICAgICAqIEBwYXJhbSB4IFggdmFsdWUgaW4gcXVhdGVybmlvblxyXG4gICAgICogQHBhcmFtIHkgWSB2YWx1ZSBpbiBxdWF0ZXJuaW9uXHJcbiAgICAgKiBAcGFyYW0geiBaIHZhbHVlIGluIHF1YXRlcm5pb25cclxuICAgICAqIEBwYXJhbSB3IFcgdmFsdWUgaW4gcXVhdGVybmlvblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0V29ybGRSb3RhdGlvbiAoeDogbnVtYmVyLCB5OiBudW1iZXIsIHo6IG51bWJlciwgdzogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgICBwdWJsaWMgc2V0V29ybGRSb3RhdGlvbiAodmFsOiBRdWF0IHwgbnVtYmVyLCB5PzogbnVtYmVyLCB6PzogbnVtYmVyLCB3PzogbnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCB8fCB6ID09PSB1bmRlZmluZWQgfHwgdyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIFF1YXQuY29weSh0aGlzLl9yb3QsIHZhbCBhcyBRdWF0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBRdWF0LnNldCh0aGlzLl9yb3QsIHZhbCBhcyBudW1iZXIsIHksIHosIHcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC51cGRhdGVXb3JsZFRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICBRdWF0Lm11bHRpcGx5KHRoaXMuX2xyb3QsIFF1YXQuY29uanVnYXRlKHRoaXMuX2xyb3QsIHRoaXMuX3BhcmVudC5fcm90KSwgdGhpcy5fcm90KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBRdWF0LmNvcHkodGhpcy5fbHJvdCwgdGhpcy5fcm90KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZXVsZXJEaXJ0eSA9IHRydWU7XHJcblxyXG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUNoaWxkcmVuKFRyYW5zZm9ybUJpdC5ST1RBVElPTik7XHJcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50TWFzayAmIFRSQU5TRk9STV9PTikge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoU3lzdGVtRXZlbnRUeXBlLlRSQU5TRk9STV9DSEFOR0VELCBUcmFuc2Zvcm1CaXQuUk9UQVRJT04pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBTZXQgcm90YXRpb24gaW4gd29ybGQgY29vcmRpbmF0ZSBzeXN0ZW0gd2l0aCBldWxlciBhbmdsZXNcclxuICAgICAqIEB6aCDnlKjmrKfmi4nop5Lorr7nva7kuJbnlYzlnZDmoIfns7vkuIvnmoTml4vovaxcclxuICAgICAqIEBwYXJhbSB4IFggYXhpcyByb3RhdGlvblxyXG4gICAgICogQHBhcmFtIHkgWSBheGlzIHJvdGF0aW9uXHJcbiAgICAgKiBAcGFyYW0geiBaIGF4aXMgcm90YXRpb25cclxuICAgICAqL1xyXG4gICAgcHVibGljIHNldFdvcmxkUm90YXRpb25Gcm9tRXVsZXIgKHg6IG51bWJlciwgeTogbnVtYmVyLCB6OiBudW1iZXIpOiB2b2lkIHtcclxuICAgICAgICBRdWF0LmZyb21FdWxlcih0aGlzLl9yb3QsIHgsIHksIHopO1xyXG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGFyZW50LnVwZGF0ZVdvcmxkVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIFF1YXQubXVsdGlwbHkodGhpcy5fbHJvdCwgUXVhdC5jb25qdWdhdGUodGhpcy5fbHJvdCwgdGhpcy5fcGFyZW50Ll9yb3QpLCB0aGlzLl9yb3QpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIFF1YXQuY29weSh0aGlzLl9scm90LCB0aGlzLl9yb3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9ldWxlckRpcnR5ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlQ2hpbGRyZW4oVHJhbnNmb3JtQml0LlJPVEFUSU9OKTtcclxuICAgICAgICBpZiAodGhpcy5fZXZlbnRNYXNrICYgVFJBTlNGT1JNX09OKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdChTeXN0ZW1FdmVudFR5cGUuVFJBTlNGT1JNX0NIQU5HRUQsIFRyYW5zZm9ybUJpdC5ST1RBVElPTik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIEdldCByb3RhdGlvbiBhcyBxdWF0ZXJuaW9uIGluIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtLCBwbGVhc2UgdHJ5IHRvIHBhc3MgYG91dGAgcXVhdGVybmlvbiBhbmQgcmV1c2UgaXQgdG8gYXZvaWQgZ2FyYmFnZS5cclxuICAgICAqIEB6aCDojrflj5bkuJbnlYzlnZDmoIfns7vkuIvnmoTml4vovazvvIzms6jmhI/vvIzlsL3lj6/og73kvKDpgJLlpI3nlKjnmoQgW1tRdWF0XV0g5Lul6YG/5YWN5Lqn55Sf5Z6D5Zy+44CCXHJcbiAgICAgKiBAcGFyYW0gb3V0IFNldCB0aGUgcmVzdWx0IHRvIG91dCBxdWF0ZXJuaW9uXHJcbiAgICAgKiBAcmV0dXJuIElmIGBvdXRgIGdpdmVuLCB0aGUgcmV0dXJuIHZhbHVlIGVxdWFscyB0byBgb3V0YCwgb3RoZXJ3aXNlIGEgbmV3IHF1YXRlcm5pb24gd2lsbCBiZSBnZW5lcmF0ZWQgYW5kIHJldHVyblxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0V29ybGRSb3RhdGlvbiAob3V0PzogUXVhdCk6IFF1YXQge1xyXG4gICAgICAgIHRoaXMudXBkYXRlV29ybGRUcmFuc2Zvcm0oKTtcclxuICAgICAgICBpZiAob3V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBRdWF0LmNvcHkob3V0LCB0aGlzLl9yb3QpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBRdWF0LmNvcHkobmV3IFF1YXQoKSwgdGhpcy5fcm90KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gU2V0IHNjYWxlIGluIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtXHJcbiAgICAgKiBAemgg6K6+572u5LiW55WM5Z2Q5qCH57O75LiL55qE57yp5pS+XHJcbiAgICAgKiBAcGFyYW0gc2NhbGUgVGFyZ2V0IHNjYWxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRXb3JsZFNjYWxlIChzY2FsZTogVmVjMyk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gU2V0IHNjYWxlIGluIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtXHJcbiAgICAgKiBAemgg6K6+572u5LiW55WM5Z2Q5qCH57O75LiL55qE57yp5pS+XHJcbiAgICAgKiBAcGFyYW0geCBYIGF4aXMgc2NhbGVcclxuICAgICAqIEBwYXJhbSB5IFkgYXhpcyBzY2FsZVxyXG4gICAgICogQHBhcmFtIHogWiBheGlzIHNjYWxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRXb3JsZFNjYWxlICh4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgICBwdWJsaWMgc2V0V29ybGRTY2FsZSAodmFsOiBWZWMzIHwgbnVtYmVyLCB5PzogbnVtYmVyLCB6PzogbnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCB8fCB6ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgVmVjMy5jb3B5KHRoaXMuX3NjYWxlLCB2YWwgYXMgVmVjMyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgVmVjMy5zZXQodGhpcy5fc2NhbGUsIHZhbCBhcyBudW1iZXIsIHksIHopO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XHJcbiAgICAgICAgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICBwYXJlbnQudXBkYXRlV29ybGRUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgTWF0My5mcm9tUXVhdChtM18xLCBRdWF0LmNvbmp1Z2F0ZShxdF8xLCBwYXJlbnQuX3JvdCkpO1xyXG4gICAgICAgICAgICBNYXQzLm11bHRpcGx5TWF0NChtM18xLCBtM18xLCBwYXJlbnQuX21hdCk7XHJcbiAgICAgICAgICAgIG0zX3NjYWxpbmcubTAwID0gdGhpcy5fc2NhbGUueDtcclxuICAgICAgICAgICAgbTNfc2NhbGluZy5tMDQgPSB0aGlzLl9zY2FsZS55O1xyXG4gICAgICAgICAgICBtM19zY2FsaW5nLm0wOCA9IHRoaXMuX3NjYWxlLno7XHJcbiAgICAgICAgICAgIE1hdDMubXVsdGlwbHkobTNfMSwgbTNfc2NhbGluZywgTWF0My5pbnZlcnQobTNfMSwgbTNfMSkpO1xyXG4gICAgICAgICAgICB0aGlzLl9sc2NhbGUueCA9IFZlYzMuc2V0KHYzX2EsIG0zXzEubTAwLCBtM18xLm0wMSwgbTNfMS5tMDIpLmxlbmd0aCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9sc2NhbGUueSA9IFZlYzMuc2V0KHYzX2EsIG0zXzEubTAzLCBtM18xLm0wNCwgbTNfMS5tMDUpLmxlbmd0aCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9sc2NhbGUueiA9IFZlYzMuc2V0KHYzX2EsIG0zXzEubTA2LCBtM18xLm0wNywgbTNfMS5tMDgpLmxlbmd0aCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIFZlYzMuY29weSh0aGlzLl9sc2NhbGUsIHRoaXMuX3NjYWxlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZUNoaWxkcmVuKFRyYW5zZm9ybUJpdC5TQ0FMRSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2V2ZW50TWFzayAmIFRSQU5TRk9STV9PTikge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoU3lzdGVtRXZlbnRUeXBlLlRSQU5TRk9STV9DSEFOR0VELCBUcmFuc2Zvcm1CaXQuU0NBTEUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBHZXQgc2NhbGUgaW4gd29ybGQgY29vcmRpbmF0ZSBzeXN0ZW0sIHBsZWFzZSB0cnkgdG8gcGFzcyBgb3V0YCB2ZWN0b3IgYW5kIHJldXNlIGl0IHRvIGF2b2lkIGdhcmJhZ2UuXHJcbiAgICAgKiBAemgg6I635Y+W5LiW55WM57yp5pS+77yM5rOo5oSP77yM5bC95Y+v6IO95Lyg6YCS5aSN55So55qEIFtbVmVjM11dIOS7pemBv+WFjeS6p+eUn+Weg+WcvuOAglxyXG4gICAgICogQHBhcmFtIG91dCBTZXQgdGhlIHJlc3VsdCB0byBvdXQgdmVjdG9yXHJcbiAgICAgKiBAcmV0dXJuIElmIGBvdXRgIGdpdmVuLCB0aGUgcmV0dXJuIHZhbHVlIGVxdWFscyB0byBgb3V0YCwgb3RoZXJ3aXNlIGEgbmV3IHZlY3RvciB3aWxsIGJlIGdlbmVyYXRlZCBhbmQgcmV0dXJuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRXb3JsZFNjYWxlIChvdXQ/OiBWZWMzKTogVmVjMyB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVXb3JsZFRyYW5zZm9ybSgpO1xyXG4gICAgICAgIGlmIChvdXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFZlYzMuY29weShvdXQsIHRoaXMuX3NjYWxlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gVmVjMy5jb3B5KG5ldyBWZWMzKCksIHRoaXMuX3NjYWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gR2V0IGEgd29ybGQgdHJhbnNmb3JtIG1hdHJpeFxyXG4gICAgICogQHpoIOiOt+WPluS4lueVjOWPmOaNouefqemYtVxyXG4gICAgICogQHBhcmFtIG91dCBTZXQgdGhlIHJlc3VsdCB0byBvdXQgbWF0cml4XHJcbiAgICAgKiBAcmV0dXJuIElmIGBvdXRgIGdpdmVuLCB0aGUgcmV0dXJuIHZhbHVlIGVxdWFscyB0byBgb3V0YCwgb3RoZXJ3aXNlIGEgbmV3IG1hdHJpeCB3aWxsIGJlIGdlbmVyYXRlZCBhbmQgcmV0dXJuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRXb3JsZE1hdHJpeCAob3V0PzogTWF0NCk6IE1hdDQge1xyXG4gICAgICAgIHRoaXMudXBkYXRlV29ybGRUcmFuc2Zvcm0oKTtcclxuICAgICAgICBpZiAoIW91dCkgeyBvdXQgPSBuZXcgTWF0NCgpOyB9XHJcbiAgICAgICAgcmV0dXJuIE1hdDQuY29weShvdXQsIHRoaXMuX21hdCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gR2V0IGEgd29ybGQgdHJhbnNmb3JtIG1hdHJpeCB3aXRoIG9ubHkgcm90YXRpb24gYW5kIHNjYWxlXHJcbiAgICAgKiBAemgg6I635Y+W5Y+q5YyF5ZCr5peL6L2s5ZKM57yp5pS+55qE5LiW55WM5Y+Y5o2i55+p6Zi1XHJcbiAgICAgKiBAcGFyYW0gb3V0IFNldCB0aGUgcmVzdWx0IHRvIG91dCBtYXRyaXhcclxuICAgICAqIEByZXR1cm4gSWYgYG91dGAgZ2l2ZW4sIHRoZSByZXR1cm4gdmFsdWUgZXF1YWxzIHRvIGBvdXRgLCBvdGhlcndpc2UgYSBuZXcgbWF0cml4IHdpbGwgYmUgZ2VuZXJhdGVkIGFuZCByZXR1cm5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFdvcmxkUlMgKG91dD86IE1hdDQpOiBNYXQ0IHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVdvcmxkVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgaWYgKCFvdXQpIHsgb3V0ID0gbmV3IE1hdDQoKTsgfVxyXG4gICAgICAgIE1hdDQuY29weShvdXQsIHRoaXMuX21hdCk7XHJcbiAgICAgICAgb3V0Lm0xMiA9IDA7IG91dC5tMTMgPSAwOyBvdXQubTE0ID0gMDtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIEdldCBhIHdvcmxkIHRyYW5zZm9ybSBtYXRyaXggd2l0aCBvbmx5IHJvdGF0aW9uIGFuZCB0cmFuc2xhdGlvblxyXG4gICAgICogQHpoIOiOt+WPluWPquWMheWQq+aXi+i9rOWSjOS9jeenu+eahOS4lueVjOWPmOaNouefqemYtVxyXG4gICAgICogQHBhcmFtIG91dCBTZXQgdGhlIHJlc3VsdCB0byBvdXQgbWF0cml4XHJcbiAgICAgKiBAcmV0dXJuIElmIGBvdXRgIGdpdmVuLCB0aGUgcmV0dXJuIHZhbHVlIGVxdWFscyB0byBgb3V0YCwgb3RoZXJ3aXNlIGEgbmV3IG1hdHJpeCB3aWxsIGJlIGdlbmVyYXRlZCBhbmQgcmV0dXJuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRXb3JsZFJUIChvdXQ/OiBNYXQ0KTogTWF0NCB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVXb3JsZFRyYW5zZm9ybSgpO1xyXG4gICAgICAgIGlmICghb3V0KSB7IG91dCA9IG5ldyBNYXQ0KCk7IH1cclxuICAgICAgICByZXR1cm4gTWF0NC5mcm9tUlQob3V0LCB0aGlzLl9yb3QsIHRoaXMuX3Bvcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gU2V0IGxvY2FsIHRyYW5zZm9ybWF0aW9uIHdpdGggcm90YXRpb24sIHBvc2l0aW9uIGFuZCBzY2FsZSBzZXBhcmF0ZWx5LlxyXG4gICAgICogQHpoIOS4gOasoeaAp+iuvue9ruaJgOacieWxgOmDqOWPmOaNou+8iOW5s+enu+OAgeaXi+i9rOOAgee8qeaUvu+8ieS/oeaBr1xyXG4gICAgICogQHBhcmFtIHJvdCBUaGUgcm90YXRpb25cclxuICAgICAqIEBwYXJhbSBwb3MgVGhlIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0gc2NhbGUgVGhlIHNjYWxlXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRSVFMgKHJvdD86IFF1YXQgfCBWZWMzLCBwb3M/OiBWZWMzLCBzY2FsZT86IFZlYzMpIHtcclxuICAgICAgICBsZXQgZGlydHlCaXQ6IFRyYW5zZm9ybUJpdCA9IDA7XHJcbiAgICAgICAgaWYgKHJvdCkge1xyXG4gICAgICAgICAgICBkaXJ0eUJpdCB8PSBUcmFuc2Zvcm1CaXQuUk9UQVRJT047XHJcbiAgICAgICAgICAgIGlmICgocm90IGFzIFF1YXQpLncgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgUXVhdC5jb3B5KHRoaXMuX2xyb3QsIHJvdCBhcyBRdWF0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2V1bGVyRGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgVmVjMy5jb3B5KHRoaXMuX2V1bGVyLCByb3QpO1xyXG4gICAgICAgICAgICAgICAgUXVhdC5mcm9tRXVsZXIodGhpcy5fbHJvdCwgcm90LngsIHJvdC55LCByb3Queik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ldWxlckRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBvcykge1xyXG4gICAgICAgICAgICBWZWMzLmNvcHkodGhpcy5fbHBvcywgcG9zKTtcclxuICAgICAgICAgICAgZGlydHlCaXQgfD0gVHJhbnNmb3JtQml0LlBPU0lUSU9OO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2NhbGUpIHtcclxuICAgICAgICAgICAgVmVjMy5jb3B5KHRoaXMuX2xzY2FsZSwgc2NhbGUpO1xyXG4gICAgICAgICAgICBkaXJ0eUJpdCB8PSBUcmFuc2Zvcm1CaXQuU0NBTEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXJ0eUJpdCkge1xyXG4gICAgICAgICAgICB0aGlzLmludmFsaWRhdGVDaGlsZHJlbihkaXJ0eUJpdCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudE1hc2sgJiBUUkFOU0ZPUk1fT04pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChTeXN0ZW1FdmVudFR5cGUuVFJBTlNGT1JNX0NIQU5HRUQsIGRpcnR5Qml0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgICAvLyBmb3IgYmFja3dhcmQtY29tcGF0aWJpbGl0eVxyXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICAgIHB1YmxpYyBnZXRBbmNob3JQb2ludCAob3V0PzogVmVjMik6IFZlYzIge1xyXG4gICAgICAgIGlmICghb3V0KSB7XHJcbiAgICAgICAgICAgIG91dCA9IG5ldyBWZWMyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dC5zZXQodGhpcy5fdWlQcm9wcy51aVRyYW5zZm9ybUNvbXAhLmFuY2hvclBvaW50KTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzZXRBbmNob3JQb2ludCAocG9pbnQ6IFZlYzIgfCBudW1iZXIsIHk/OiBudW1iZXIpIHtcclxuICAgICAgICB0aGlzLl91aVByb3BzLnVpVHJhbnNmb3JtQ29tcCEuc2V0QW5jaG9yUG9pbnQocG9pbnQsIHkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRDb250ZW50U2l6ZSAob3V0PzogU2l6ZSk6IFNpemUge1xyXG4gICAgICAgIGlmICghb3V0KSB7XHJcbiAgICAgICAgICAgIG91dCA9IG5ldyBTaXplKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvdXQuc2V0KHRoaXMuX3VpUHJvcHMudWlUcmFuc2Zvcm1Db21wIS5jb250ZW50U2l6ZSk7XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc2V0Q29udGVudFNpemUgKHNpemU6IFNpemUgfCBudW1iZXIsIGhlaWdodD86IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuX3VpUHJvcHMudWlUcmFuc2Zvcm1Db21wIS5zZXRDb250ZW50U2l6ZShzaXplLCBoZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gUGF1c2UgYWxsIHN5c3RlbSBldmVudHMgd2hpY2ggaXMgZGlzcGF0Y2hlZCBieSBbW1N5c3RlbUV2ZW50XV1cclxuICAgICAqIEB6aCDmmoLlgZzmiYDmnIkgW1tTeXN0ZW1FdmVudF1dIOa0vuWPkeeahOezu+e7n+S6i+S7tlxyXG4gICAgICogQHBhcmFtIHJlY3Vyc2l2ZSBXaGV0aGVyIHBhdXNlIHN5c3RlbSBldmVudHMgcmVjdXJzaXZlbHkgZm9yIHRoZSBjaGlsZCBub2RlIHRyZWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBhdXNlU3lzdGVtRXZlbnRzIChyZWN1cnNpdmU6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyLnBhdXNlVGFyZ2V0KHRoaXMsIHJlY3Vyc2l2ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gUmVzdW1lIGFsbCBwYXVzZWQgc3lzdGVtIGV2ZW50cyB3aGljaCBpcyBkaXNwYXRjaGVkIGJ5IFtbU3lzdGVtRXZlbnRdXVxyXG4gICAgICogQHpoIOaBouWkjeaJgOaciSBbW1N5c3RlbUV2ZW50XV0g5rS+5Y+R55qE57O757uf5LqL5Lu2XHJcbiAgICAgKiBAcGFyYW0gcmVjdXJzaXZlIFdoZXRoZXIgcmVzdW1lIHN5c3RlbSBldmVudHMgcmVjdXJzaXZlbHkgZm9yIHRoZSBjaGlsZCBub2RlIHRyZWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlc3VtZVN5c3RlbUV2ZW50cyAocmVjdXJzaXZlOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIGV2ZW50TWFuYWdlci5yZXN1bWVUYXJnZXQodGhpcywgcmVjdXJzaXZlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgX29uUG9zdEFjdGl2YXRlZCAoYWN0aXZlKSB7XHJcbiAgICAgICAgaWYgKGFjdGl2ZSkge1xyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIucmVzdW1lVGFyZ2V0KHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50UHJvY2Vzc29yLnJlYXR0YWNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBkZWFjdGl2YXRlXHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci5wYXVzZVRhcmdldCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5jYy5Ob2RlID0gTm9kZTtcclxuIl19