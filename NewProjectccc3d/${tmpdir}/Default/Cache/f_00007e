(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "../data/class-decorator.js", "../utils/murmurhash2_gc.js", "../3d/builtin/init.js", "../gfx/define.js", "../gfx/texture-view.js", "../renderer/core/pass.js", "../renderer/core/sampler-lib.js", "./asset.js", "./effect-asset.js", "./sprite-frame.js", "./texture-base.js"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("../data/class-decorator.js"), require("../utils/murmurhash2_gc.js"), require("../3d/builtin/init.js"), require("../gfx/define.js"), require("../gfx/texture-view.js"), require("../renderer/core/pass.js"), require("../renderer/core/sampler-lib.js"), require("./asset.js"), require("./effect-asset.js"), require("./sprite-frame.js"), require("./texture-base.js"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.classDecorator, global.murmurhash2_gc, global.init, global.define, global.textureView, global.pass, global.samplerLib, global.asset, global.effectAsset, global.spriteFrame, global.textureBase);
    global.material = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _classDecorator, _murmurhash2_gc, _init, _define, _textureView, _pass2, _samplerLib, _asset, _effectAsset, _spriteFrame, _textureBase) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.Material = void 0;

  var _dec, _dec2, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _temp;

  function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

  function _createForOfIteratorHelper(o) { if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

  function _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }

  /**
   * @en
   * The material asset, specifies in details how a model is drawn on screen.
   * @zh
   * 材质资源类，包含模型绘制方式的全部细节描述。
   */
  var Material = (_dec = (0, _classDecorator.ccclass)('cc.Material'), _dec2 = (0, _classDecorator.property)(_effectAsset.EffectAsset), _dec(_class = (_class2 = (_temp = /*#__PURE__*/function (_Asset) {
    _inherits(Material, _Asset);

    _createClass(Material, [{
      key: "effectAsset",

      /**
       * @en The current [[EffectAsset]].
       * @zh 当前使用的 [[EffectAsset]] 资源。
       */
      get: function get() {
        return this._effectAsset;
      }
      /**
       * @en Name of the current [[EffectAsset]].
       * @zh 当前使用的 [[EffectAsset]] 资源名。
       */

    }, {
      key: "effectName",
      get: function get() {
        return this._effectAsset ? this._effectAsset.name : '';
      }
      /**
       * @en The current technique index.
       * @zh 当前的 technique 索引。
       */

    }, {
      key: "technique",
      get: function get() {
        return this._techIdx;
      }
      /**
       * @en The passes defined in this material.
       * @zh 当前正在使用的 pass 数组。
       */

    }, {
      key: "passes",
      get: function get() {
        return this._passes;
      }
      /**
       * @en The hash value of this material.
       * @zh 材质的 hash。
       */

    }, {
      key: "hash",
      get: function get() {
        return this._hash;
      }
    }, {
      key: "parent",
      get: function get() {
        return null;
      }
    }, {
      key: "owner",
      get: function get() {
        return null;
      }
    }], [{
      key: "getHash",
      value: function getHash(material) {
        var str = '';

        var _iterator = _createForOfIteratorHelper(material.passes),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var pass = _step.value;
            str += pass.hash;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return (0, _murmurhash2_gc.murmurhash2_32_gc)(str, 666);
      }
    }]);

    function Material() {
      var _this;

      _classCallCheck(this, Material);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Material).call(this));

      _initializerDefineProperty(_this, "_effectAsset", _descriptor, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_techIdx", _descriptor2, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_defines", _descriptor3, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_states", _descriptor4, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_props", _descriptor5, _assertThisInitialized(_this));

      _this._passes = [];
      _this._hash = 0;
      _this.loaded = false;
      return _this;
    }
    /**
     * @en Initialize this material with the given information.
     * @zh 根据所给信息初始化这个材质，初始化正常结束后材质即可立即用于渲染。
     * @param info Material description info.
     */


    _createClass(Material, [{
      key: "initialize",
      value: function initialize(info) {
        if (!this._defines) {
          this._defines = [];
        }

        if (!this._states) {
          this._states = [];
        }

        if (!this._props) {
          this._props = [];
        }

        if (info.technique !== undefined) {
          this._techIdx = info.technique;
        }

        if (info.effectAsset) {
          this._effectAsset = info.effectAsset;
        } else if (info.effectName) {
          this._effectAsset = _effectAsset.EffectAsset.get(info.effectName);
        }

        if (info.defines) {
          this._prepareInfo(info.defines, this._defines);
        }

        if (info.states) {
          this._prepareInfo(info.states, this._states);
        }

        this._update();
      }
    }, {
      key: "reset",
      value: function reset(info) {
        // consistency with other assets
        this.initialize(info);
      }
      /**
       * @en
       * Destroy the material definitively.<br>
       * Cannot re-initialize after destroy.<br>
       * For re-initialize purposes, call [[Material.initialize]] directly.
       * @zh
       * 彻底销毁材质，注意销毁后无法重新初始化。<br>
       * 如需重新初始化材质，不必先调用 destroy。
       */

    }, {
      key: "destroy",
      value: function destroy() {
        this._doDestroy();

        return _get(_getPrototypeOf(Material.prototype), "destroy", this).call(this);
      }
      /**
       * @en Recompile the shader with the specified macro overrides. Allowed only on material instances.
       * @zh 使用指定预处理宏重新编译当前 pass（数组）中的 shader。只允许对材质实例执行。
       * @param overrides The shader macro override values.
       * @param passIdx The pass to apply to. Will apply to all passes if not specified.
       */

    }, {
      key: "recompileShaders",
      value: function recompileShaders(overrides, passIdx) {
        console.warn('Shaders in material asset \'' + this.name + '\' cannot be modified at runtime, please instantiate the material first.');
      }
      /**
       * @en Override the passes with the specified pipeline states. Allowed only on material instances.
       * @zh 使用指定管线状态重载当前的 pass（数组）。只允许对材质实例执行。
       * @param overrides The pipeline state override values.
       * @param passIdx The pass to apply to. Will apply to all passes if not specified.
       */

    }, {
      key: "overridePipelineStates",
      value: function overridePipelineStates(overrides, passIdx) {
        console.warn('Pipeline states in material asset \'' + this.name + '\' cannot be modified at runtime, please instantiate the material first.');
      }
      /**
       * @en Callback function after material is loaded in [[Loader]]. Initialize the resources automatically.
       * @zh 通过 [[Loader]] 加载完成时的回调，将自动初始化材质资源。
       */

    }, {
      key: "onLoaded",
      value: function onLoaded() {
        this._update();

        this.loaded = true;
        this.emit('load');
      }
      /**
       * @en Reset all the uniforms to the default value specified in [[EffectAsset]].
       * @zh 重置材质的所有 uniform 参数数据为 [[EffectAsset]] 中的默认初始值。
       * @param clearPasses Will the rendering data be cleared too?
       */

    }, {
      key: "resetUniforms",
      value: function resetUniforms() {
        var clearPasses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this._props.length = this._passes.length;

        for (var i = 0; i < this._props.length; i++) {
          this._props[i] = {};
        }

        if (!clearPasses) {
          return;
        }

        var _iterator2 = _createForOfIteratorHelper(this._passes),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var pass = _step2.value;
            pass.resetUBOs();
            pass.resetTextures();
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      /**
       * @en
       * Convenient property setter provided for quick material setup.<br>
       * [[Pass.setUniform]] should be used instead if you need to do per-frame uniform update.
       * @zh
       * 设置材质 uniform 参数的统一入口。<br>
       * 注意如果需要每帧更新 uniform，建议使用 [[Pass.setUniform]] 以获得更好的性能。
       * @param name The target uniform name.
       * @param val The target value.
       * @param passIdx The pass to apply to. Will apply to all passes if not specified.
       */

    }, {
      key: "setProperty",
      value: function setProperty(name, val, passIdx) {
        var success = false;

        if (passIdx === undefined) {
          // try set property for all applicable passes
          var passes = this._passes;
          var len = passes.length;

          for (var i = 0; i < len; i++) {
            var pass = passes[i];

            if (this._uploadProperty(pass, name, val)) {
              this._props[i][name] = val;
              success = true;
            }
          }
        } else {
          if (passIdx >= this._passes.length) {
            console.warn("illegal pass index: ".concat(passIdx, "."));
            return;
          }

          var _pass = this._passes[passIdx];

          if (this._uploadProperty(_pass, name, val)) {
            this._props[passIdx][name] = val;
            success = true;
          }
        }

        if (!success) {
          console.warn("illegal property name: ".concat(name, "."));
          return;
        }
      }
      /**
       * @en
       * Get the specified uniform value for this material.<br>
       * Note that only uniforms set through [[Material.setProperty]] can be acquired here.<br>
       * For the complete rendering data, use [[Pass.getUniform]] instead.
       * @zh
       * 获取当前材质的指定 uniform 参数的值。<br>
       * 注意只有通过 [[Material.setProperty]] 函数设置的参数才能从此函数取出，<br>
       * 如需取出完整的渲染数据，请使用 [[Pass.getUniform]]。
       * @param name The property or uniform name.
       * @param passIdx The target pass index. If not specified, return the first found value in all passes.
       */

    }, {
      key: "getProperty",
      value: function getProperty(name, passIdx) {
        if (passIdx === undefined) {
          // try get property in all possible passes
          var propsArray = this._props;
          var len = propsArray.length;

          for (var i = 0; i < len; i++) {
            var props = propsArray[i];

            for (var p in props) {
              if (p === name) {
                return props[p];
              }
            }
          }
        } else {
          if (passIdx >= this._props.length) {
            console.warn("illegal pass index: ".concat(passIdx, "."));
            return null;
          }

          var _props = this._props[passIdx];

          for (var _p in _props) {
            if (_p === name) {
              return _props[_p];
            }
          }
        }

        return null;
      }
      /**
       * @en Copy the target material.
       * @zh 复制目标材质到当前实例。
       * @param mat The material to be copied.
       */

    }, {
      key: "copy",
      value: function copy(mat) {
        this._techIdx = mat._techIdx;
        this._props.length = mat._props.length;

        for (var i = 0; i < mat._props.length; i++) {
          this._props[i] = Object.assign({}, mat._props[i]);
        }

        this._defines.length = mat._defines.length;

        for (var _i = 0; _i < mat._defines.length; _i++) {
          this._defines[_i] = Object.assign({}, mat._defines[_i]);
        }

        this._states.length = mat._states.length;

        for (var _i2 = 0; _i2 < mat._states.length; _i2++) {
          this._states[_i2] = Object.assign({}, mat._states[_i2]);
        }

        this._effectAsset = mat._effectAsset;

        this._update();
      }
    }, {
      key: "_prepareInfo",
      value: function _prepareInfo(patch, cur) {
        if (!Array.isArray(patch)) {
          // fill all the passes if not specified
          var len = this._effectAsset ? this._effectAsset.techniques[this._techIdx].passes.length : 1;
          patch = Array(len).fill(patch);
        }

        for (var i = 0; i < patch.length; ++i) {
          Object.assign(cur[i] || (cur[i] = {}), patch[i]);
        }
      }
    }, {
      key: "_createPasses",
      value: function _createPasses() {
        var tech = this._effectAsset.techniques[this._techIdx || 0];

        if (!tech) {
          return [];
        }

        var passNum = tech.passes.length;
        var passes = [];

        for (var k = 0; k < passNum; ++k) {
          var passInfo = tech.passes[k];
          var defs = passInfo.defines = this._defines.length > k ? this._defines[k] : {};

          if (passInfo["switch"] && !defs[passInfo["switch"]]) {
            continue;
          }

          passInfo.stateOverrides = this._states.length > k ? this._states[k] : {};
          passInfo.idxInTech = k;
          var pass = new _pass2.Pass(cc.director.root.device);
          pass.initialize(passInfo);
          passes.push(pass);
        }

        return passes;
      }
    }, {
      key: "_update",
      value: function _update() {
        var _this2 = this;

        var keepProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        if (this._effectAsset) {
          if (this._passes && this._passes.length) {
            var _iterator3 = _createForOfIteratorHelper(this._passes),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var pass = _step3.value;
                pass.destroy();
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }

          this._passes = this._createPasses(); // handle property values

          var totalPasses = this._effectAsset.techniques[this._techIdx].passes.length;
          this._props.length = totalPasses;

          if (keepProps) {
            this._passes.forEach(function (pass, i) {
              var props = _this2._props[pass.idxInTech];

              if (!props) {
                props = _this2._props[i] = {};
              }

              for (var p in props) {
                _this2._uploadProperty(pass, p, props[p]);
              }
            });
          } else {
            for (var i = 0; i < this._props.length; i++) {
              this._props[i] = {};
            }
          }
        } else {
          // ugly yellow indicating missing effect
          var missing = _init.builtinResMgr.get('missing-effect-material');

          if (missing) {
            this._passes = missing._passes.slice();
          }
        }

        this._hash = Material.getHash(this);
      }
    }, {
      key: "_uploadProperty",
      value: function _uploadProperty(pass, name, val) {
        var handle = pass.getHandle(name);

        if (handle === undefined) {
          return false;
        }

        var bindingType = _pass2.Pass.getBindingTypeFromHandle(handle);

        if (bindingType === _define.GFXBindingType.UNIFORM_BUFFER) {
          if (Array.isArray(val)) {
            pass.setUniformArray(handle, val);
          } else if (val !== null) {
            pass.setUniform(handle, val);
          } else {
            pass.resetUniform(name);
          }
        } else if (bindingType === _define.GFXBindingType.SAMPLER) {
          var binding = _pass2.Pass.getBindingFromHandle(handle);

          if (val instanceof _textureView.GFXTextureView) {
            pass.bindTextureView(binding, val);
          } else if (val instanceof _textureBase.TextureBase || val instanceof _spriteFrame.SpriteFrame) {
            var textureView = val.getGFXTextureView();

            if (!textureView || !textureView.texture.width || !textureView.texture.height) {
              // console.warn(`material '${this._uuid}' received incomplete texture asset '${val._uuid}'`);
              return false;
            }

            pass.bindTextureView(binding, textureView);

            if (val instanceof _textureBase.TextureBase) {
              pass.bindSampler(binding, _samplerLib.samplerLib.getSampler(cc.director.root.device, val.getSamplerHash()));
            }
          } else if (!val) {
            pass.resetTexture(name);
          }
        }

        return true;
      }
    }, {
      key: "_doDestroy",
      value: function _doDestroy() {
        if (this._passes && this._passes.length) {
          var _iterator4 = _createForOfIteratorHelper(this._passes),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var pass = _step4.value;
              pass.destroy();
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
        }

        this._effectAsset = null;
        this._passes.length = 0;
        this._props.length = 0;
        this._defines.length = 0;
        this._states.length = 0;
      }
    }]);

    return Material;
  }(_asset.Asset), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "_effectAsset", [_dec2], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return null;
    }
  }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_techIdx", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return 0;
    }
  }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "_defines", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return [];
    }
  }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "_states", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return [];
    }
  }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "_props", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return [];
    }
  })), _class2)) || _class);
  _exports.Material = Material;
  cc.Material = Material;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkY6L2plbmtpbnMvd29ya3NwYWNlL0NyZWF0b3JfM0QvZWRpdG9yLTNkL3Jlc291cmNlcy8zZC9lbmdpbmUvY29jb3MvY29yZS9hc3NldHMvbWF0ZXJpYWwudHMiXSwibmFtZXMiOlsiTWF0ZXJpYWwiLCJFZmZlY3RBc3NldCIsIl9lZmZlY3RBc3NldCIsIm5hbWUiLCJfdGVjaElkeCIsIl9wYXNzZXMiLCJfaGFzaCIsIm1hdGVyaWFsIiwic3RyIiwicGFzc2VzIiwicGFzcyIsImhhc2giLCJsb2FkZWQiLCJpbmZvIiwiX2RlZmluZXMiLCJfc3RhdGVzIiwiX3Byb3BzIiwidGVjaG5pcXVlIiwidW5kZWZpbmVkIiwiZWZmZWN0QXNzZXQiLCJlZmZlY3ROYW1lIiwiZ2V0IiwiZGVmaW5lcyIsIl9wcmVwYXJlSW5mbyIsInN0YXRlcyIsIl91cGRhdGUiLCJpbml0aWFsaXplIiwiX2RvRGVzdHJveSIsIm92ZXJyaWRlcyIsInBhc3NJZHgiLCJjb25zb2xlIiwid2FybiIsImVtaXQiLCJjbGVhclBhc3NlcyIsImxlbmd0aCIsImkiLCJyZXNldFVCT3MiLCJyZXNldFRleHR1cmVzIiwidmFsIiwic3VjY2VzcyIsImxlbiIsIl91cGxvYWRQcm9wZXJ0eSIsInByb3BzQXJyYXkiLCJwcm9wcyIsInAiLCJtYXQiLCJPYmplY3QiLCJhc3NpZ24iLCJwYXRjaCIsImN1ciIsIkFycmF5IiwiaXNBcnJheSIsInRlY2huaXF1ZXMiLCJmaWxsIiwidGVjaCIsInBhc3NOdW0iLCJrIiwicGFzc0luZm8iLCJkZWZzIiwic3RhdGVPdmVycmlkZXMiLCJpZHhJblRlY2giLCJQYXNzIiwiY2MiLCJkaXJlY3RvciIsInJvb3QiLCJkZXZpY2UiLCJwdXNoIiwia2VlcFByb3BzIiwiZGVzdHJveSIsIl9jcmVhdGVQYXNzZXMiLCJ0b3RhbFBhc3NlcyIsImZvckVhY2giLCJtaXNzaW5nIiwiYnVpbHRpblJlc01nciIsInNsaWNlIiwiZ2V0SGFzaCIsImhhbmRsZSIsImdldEhhbmRsZSIsImJpbmRpbmdUeXBlIiwiZ2V0QmluZGluZ1R5cGVGcm9tSGFuZGxlIiwiR0ZYQmluZGluZ1R5cGUiLCJVTklGT1JNX0JVRkZFUiIsInNldFVuaWZvcm1BcnJheSIsInNldFVuaWZvcm0iLCJyZXNldFVuaWZvcm0iLCJTQU1QTEVSIiwiYmluZGluZyIsImdldEJpbmRpbmdGcm9tSGFuZGxlIiwiR0ZYVGV4dHVyZVZpZXciLCJiaW5kVGV4dHVyZVZpZXciLCJUZXh0dXJlQmFzZSIsIlNwcml0ZUZyYW1lIiwidGV4dHVyZVZpZXciLCJnZXRHRlhUZXh0dXJlVmlldyIsInRleHR1cmUiLCJ3aWR0aCIsImhlaWdodCIsImJpbmRTYW1wbGVyIiwic2FtcGxlckxpYiIsImdldFNhbXBsZXIiLCJnZXRTYW1wbGVySGFzaCIsInJlc2V0VGV4dHVyZSIsIkFzc2V0IiwicHJvcGVydHkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkZBOzs7Ozs7TUFPYUEsUSxXQURaLDZCQUFRLGFBQVIsQyxVQVdJLDhCQUFTQyx3QkFBVCxDOzs7Ozs7QUFjRDs7OzswQkFJbUI7QUFDZixlQUFPLEtBQUtDLFlBQVo7QUFDSDtBQUVEOzs7Ozs7OzBCQUlrQjtBQUNkLGVBQU8sS0FBS0EsWUFBTCxHQUFvQixLQUFLQSxZQUFMLENBQWtCQyxJQUF0QyxHQUE2QyxFQUFwRDtBQUNIO0FBRUQ7Ozs7Ozs7MEJBSWlCO0FBQ2IsZUFBTyxLQUFLQyxRQUFaO0FBQ0g7QUFFRDs7Ozs7OzswQkFJYztBQUNWLGVBQU8sS0FBS0MsT0FBWjtBQUNIO0FBRUQ7Ozs7Ozs7MEJBSVk7QUFDUixlQUFPLEtBQUtDLEtBQVo7QUFDSDs7OzBCQUU4QjtBQUMzQixlQUFPLElBQVA7QUFDSDs7OzBCQUV3QztBQUNyQyxlQUFPLElBQVA7QUFDSDs7OzhCQXBFc0JDLFEsRUFBb0I7QUFDdkMsWUFBSUMsR0FBRyxHQUFHLEVBQVY7O0FBRHVDLG1EQUVwQkQsUUFBUSxDQUFDRSxNQUZXO0FBQUE7O0FBQUE7QUFFdkMsOERBQW9DO0FBQUEsZ0JBQXpCQyxJQUF5QjtBQUNoQ0YsWUFBQUEsR0FBRyxJQUFJRSxJQUFJLENBQUNDLElBQVo7QUFDSDtBQUpzQztBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUt2QyxlQUFPLHVDQUFrQkgsR0FBbEIsRUFBdUIsR0FBdkIsQ0FBUDtBQUNIOzs7QUFnRUQsd0JBQWU7QUFBQTs7QUFBQTs7QUFDWDs7QUFEVzs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQTs7QUFBQSxZQW5ETEgsT0FtREssR0FuRGEsRUFtRGI7QUFBQSxZQWxETEMsS0FrREssR0FsREcsQ0FrREg7QUFFWCxZQUFLTSxNQUFMLEdBQWMsS0FBZDtBQUZXO0FBR2Q7QUFFRDs7Ozs7Ozs7O2lDQUttQkMsSSxFQUFxQjtBQUNwQyxZQUFJLENBQUMsS0FBS0MsUUFBVixFQUFvQjtBQUFFLGVBQUtBLFFBQUwsR0FBZ0IsRUFBaEI7QUFBcUI7O0FBQzNDLFlBQUksQ0FBQyxLQUFLQyxPQUFWLEVBQW1CO0FBQUUsZUFBS0EsT0FBTCxHQUFlLEVBQWY7QUFBb0I7O0FBQ3pDLFlBQUksQ0FBQyxLQUFLQyxNQUFWLEVBQWtCO0FBQUUsZUFBS0EsTUFBTCxHQUFjLEVBQWQ7QUFBbUI7O0FBQ3ZDLFlBQUlILElBQUksQ0FBQ0ksU0FBTCxLQUFtQkMsU0FBdkIsRUFBa0M7QUFBRSxlQUFLZCxRQUFMLEdBQWdCUyxJQUFJLENBQUNJLFNBQXJCO0FBQWlDOztBQUNyRSxZQUFJSixJQUFJLENBQUNNLFdBQVQsRUFBc0I7QUFBRSxlQUFLakIsWUFBTCxHQUFvQlcsSUFBSSxDQUFDTSxXQUF6QjtBQUF1QyxTQUEvRCxNQUNLLElBQUlOLElBQUksQ0FBQ08sVUFBVCxFQUFxQjtBQUFFLGVBQUtsQixZQUFMLEdBQW9CRCx5QkFBWW9CLEdBQVosQ0FBZ0JSLElBQUksQ0FBQ08sVUFBckIsQ0FBcEI7QUFBdUQ7O0FBQ25GLFlBQUlQLElBQUksQ0FBQ1MsT0FBVCxFQUFrQjtBQUFFLGVBQUtDLFlBQUwsQ0FBa0JWLElBQUksQ0FBQ1MsT0FBdkIsRUFBZ0MsS0FBS1IsUUFBckM7QUFBaUQ7O0FBQ3JFLFlBQUlELElBQUksQ0FBQ1csTUFBVCxFQUFpQjtBQUFFLGVBQUtELFlBQUwsQ0FBa0JWLElBQUksQ0FBQ1csTUFBdkIsRUFBK0IsS0FBS1QsT0FBcEM7QUFBK0M7O0FBQ2xFLGFBQUtVLE9BQUw7QUFDSDs7OzRCQUNhWixJLEVBQXFCO0FBQUU7QUFDakMsYUFBS2EsVUFBTCxDQUFnQmIsSUFBaEI7QUFDSDtBQUVEOzs7Ozs7Ozs7Ozs7Z0NBU2tCO0FBQ2QsYUFBS2MsVUFBTDs7QUFDQTtBQUNIO0FBRUQ7Ozs7Ozs7Ozt1Q0FNeUJDLFMsRUFBdUJDLE8sRUFBa0I7QUFDOURDLFFBQUFBLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLGlDQUFpQyxLQUFLNUIsSUFBdEMsR0FBNkMsMEVBQTFEO0FBQ0g7QUFFRDs7Ozs7Ozs7OzZDQU0rQnlCLFMsRUFBMEJDLE8sRUFBa0I7QUFDdkVDLFFBQUFBLE9BQU8sQ0FBQ0MsSUFBUixDQUFhLHlDQUF5QyxLQUFLNUIsSUFBOUMsR0FBcUQsMEVBQWxFO0FBQ0g7QUFFRDs7Ozs7OztpQ0FJbUI7QUFDZixhQUFLc0IsT0FBTDs7QUFDQSxhQUFLYixNQUFMLEdBQWMsSUFBZDtBQUNBLGFBQUtvQixJQUFMLENBQVUsTUFBVjtBQUNIO0FBRUQ7Ozs7Ozs7O3NDQUswQztBQUFBLFlBQXBCQyxXQUFvQix1RUFBTixJQUFNO0FBQ3RDLGFBQUtqQixNQUFMLENBQVlrQixNQUFaLEdBQXFCLEtBQUs3QixPQUFMLENBQWE2QixNQUFsQzs7QUFDQSxhQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS25CLE1BQUwsQ0FBWWtCLE1BQWhDLEVBQXdDQyxDQUFDLEVBQXpDLEVBQTZDO0FBQUUsZUFBS25CLE1BQUwsQ0FBWW1CLENBQVosSUFBaUIsRUFBakI7QUFBc0I7O0FBQ3JFLFlBQUksQ0FBQ0YsV0FBTCxFQUFrQjtBQUFFO0FBQVM7O0FBSFMsb0RBSW5CLEtBQUs1QixPQUpjO0FBQUE7O0FBQUE7QUFJdEMsaUVBQWlDO0FBQUEsZ0JBQXRCSyxJQUFzQjtBQUM3QkEsWUFBQUEsSUFBSSxDQUFDMEIsU0FBTDtBQUNBMUIsWUFBQUEsSUFBSSxDQUFDMkIsYUFBTDtBQUNIO0FBUHFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRekM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7a0NBV29CbEMsSSxFQUFjbUMsRyxFQUFvRFQsTyxFQUFrQjtBQUNwRyxZQUFJVSxPQUFPLEdBQUcsS0FBZDs7QUFDQSxZQUFJVixPQUFPLEtBQUtYLFNBQWhCLEVBQTJCO0FBQUU7QUFDekIsY0FBTVQsTUFBTSxHQUFHLEtBQUtKLE9BQXBCO0FBQ0EsY0FBTW1DLEdBQUcsR0FBRy9CLE1BQU0sQ0FBQ3lCLE1BQW5COztBQUNBLGVBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0ssR0FBcEIsRUFBeUJMLENBQUMsRUFBMUIsRUFBOEI7QUFDMUIsZ0JBQU16QixJQUFJLEdBQUdELE1BQU0sQ0FBQzBCLENBQUQsQ0FBbkI7O0FBQ0EsZ0JBQUksS0FBS00sZUFBTCxDQUFxQi9CLElBQXJCLEVBQTJCUCxJQUEzQixFQUFpQ21DLEdBQWpDLENBQUosRUFBMkM7QUFDdkMsbUJBQUt0QixNQUFMLENBQVltQixDQUFaLEVBQWVoQyxJQUFmLElBQXVCbUMsR0FBdkI7QUFDQUMsY0FBQUEsT0FBTyxHQUFHLElBQVY7QUFDSDtBQUNKO0FBQ0osU0FWRCxNQVVPO0FBQ0gsY0FBSVYsT0FBTyxJQUFJLEtBQUt4QixPQUFMLENBQWE2QixNQUE1QixFQUFvQztBQUFFSixZQUFBQSxPQUFPLENBQUNDLElBQVIsK0JBQW9DRixPQUFwQztBQUFpRDtBQUFTOztBQUNoRyxjQUFNbkIsS0FBSSxHQUFHLEtBQUtMLE9BQUwsQ0FBYXdCLE9BQWIsQ0FBYjs7QUFDQSxjQUFJLEtBQUtZLGVBQUwsQ0FBcUIvQixLQUFyQixFQUEyQlAsSUFBM0IsRUFBaUNtQyxHQUFqQyxDQUFKLEVBQTJDO0FBQ3ZDLGlCQUFLdEIsTUFBTCxDQUFZYSxPQUFaLEVBQXFCMUIsSUFBckIsSUFBNkJtQyxHQUE3QjtBQUNBQyxZQUFBQSxPQUFPLEdBQUcsSUFBVjtBQUNIO0FBQ0o7O0FBQ0QsWUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFDVlQsVUFBQUEsT0FBTyxDQUFDQyxJQUFSLGtDQUF1QzVCLElBQXZDO0FBQ0E7QUFDSDtBQUNKO0FBRUQ7Ozs7Ozs7Ozs7Ozs7OztrQ0FZb0JBLEksRUFBYzBCLE8sRUFBa0I7QUFDaEQsWUFBSUEsT0FBTyxLQUFLWCxTQUFoQixFQUEyQjtBQUFFO0FBQ3pCLGNBQU13QixVQUFVLEdBQUcsS0FBSzFCLE1BQXhCO0FBQ0EsY0FBTXdCLEdBQUcsR0FBR0UsVUFBVSxDQUFDUixNQUF2Qjs7QUFDQSxlQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdLLEdBQXBCLEVBQXlCTCxDQUFDLEVBQTFCLEVBQThCO0FBQzFCLGdCQUFNUSxLQUFLLEdBQUdELFVBQVUsQ0FBQ1AsQ0FBRCxDQUF4Qjs7QUFDQSxpQkFBSyxJQUFNUyxDQUFYLElBQWdCRCxLQUFoQixFQUF1QjtBQUNuQixrQkFBSUMsQ0FBQyxLQUFLekMsSUFBVixFQUFnQjtBQUFFLHVCQUFPd0MsS0FBSyxDQUFDQyxDQUFELENBQVo7QUFBa0I7QUFDdkM7QUFDSjtBQUNKLFNBVEQsTUFTTztBQUNILGNBQUlmLE9BQU8sSUFBSSxLQUFLYixNQUFMLENBQVlrQixNQUEzQixFQUFtQztBQUFFSixZQUFBQSxPQUFPLENBQUNDLElBQVIsK0JBQW9DRixPQUFwQztBQUFpRCxtQkFBTyxJQUFQO0FBQWM7O0FBQ3BHLGNBQU1jLE1BQUssR0FBRyxLQUFLM0IsTUFBTCxDQUFZYSxPQUFaLENBQWQ7O0FBQ0EsZUFBSyxJQUFNZSxFQUFYLElBQWdCRCxNQUFoQixFQUF1QjtBQUNuQixnQkFBSUMsRUFBQyxLQUFLekMsSUFBVixFQUFnQjtBQUFFLHFCQUFPd0MsTUFBSyxDQUFDQyxFQUFELENBQVo7QUFBa0I7QUFDdkM7QUFDSjs7QUFDRCxlQUFPLElBQVA7QUFDSDtBQUVEOzs7Ozs7OzsyQkFLYUMsRyxFQUFlO0FBQ3hCLGFBQUt6QyxRQUFMLEdBQWdCeUMsR0FBRyxDQUFDekMsUUFBcEI7QUFDQSxhQUFLWSxNQUFMLENBQVlrQixNQUFaLEdBQXFCVyxHQUFHLENBQUM3QixNQUFKLENBQVdrQixNQUFoQzs7QUFDQSxhQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdVLEdBQUcsQ0FBQzdCLE1BQUosQ0FBV2tCLE1BQS9CLEVBQXVDQyxDQUFDLEVBQXhDLEVBQTRDO0FBQ3hDLGVBQUtuQixNQUFMLENBQVltQixDQUFaLElBQWlCVyxNQUFNLENBQUNDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCRixHQUFHLENBQUM3QixNQUFKLENBQVdtQixDQUFYLENBQWxCLENBQWpCO0FBQ0g7O0FBQ0QsYUFBS3JCLFFBQUwsQ0FBY29CLE1BQWQsR0FBdUJXLEdBQUcsQ0FBQy9CLFFBQUosQ0FBYW9CLE1BQXBDOztBQUNBLGFBQUssSUFBSUMsRUFBQyxHQUFHLENBQWIsRUFBZ0JBLEVBQUMsR0FBR1UsR0FBRyxDQUFDL0IsUUFBSixDQUFhb0IsTUFBakMsRUFBeUNDLEVBQUMsRUFBMUMsRUFBOEM7QUFDMUMsZUFBS3JCLFFBQUwsQ0FBY3FCLEVBQWQsSUFBbUJXLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JGLEdBQUcsQ0FBQy9CLFFBQUosQ0FBYXFCLEVBQWIsQ0FBbEIsQ0FBbkI7QUFDSDs7QUFDRCxhQUFLcEIsT0FBTCxDQUFhbUIsTUFBYixHQUFzQlcsR0FBRyxDQUFDOUIsT0FBSixDQUFZbUIsTUFBbEM7O0FBQ0EsYUFBSyxJQUFJQyxHQUFDLEdBQUcsQ0FBYixFQUFnQkEsR0FBQyxHQUFHVSxHQUFHLENBQUM5QixPQUFKLENBQVltQixNQUFoQyxFQUF3Q0MsR0FBQyxFQUF6QyxFQUE2QztBQUN6QyxlQUFLcEIsT0FBTCxDQUFhb0IsR0FBYixJQUFrQlcsTUFBTSxDQUFDQyxNQUFQLENBQWMsRUFBZCxFQUFrQkYsR0FBRyxDQUFDOUIsT0FBSixDQUFZb0IsR0FBWixDQUFsQixDQUFsQjtBQUNIOztBQUNELGFBQUtqQyxZQUFMLEdBQW9CMkMsR0FBRyxDQUFDM0MsWUFBeEI7O0FBQ0EsYUFBS3VCLE9BQUw7QUFDSDs7O21DQUV1QnVCLEssRUFBMEJDLEcsRUFBZTtBQUM3RCxZQUFJLENBQUNDLEtBQUssQ0FBQ0MsT0FBTixDQUFjSCxLQUFkLENBQUwsRUFBMkI7QUFBRTtBQUN6QixjQUFNUixHQUFHLEdBQUcsS0FBS3RDLFlBQUwsR0FBb0IsS0FBS0EsWUFBTCxDQUFrQmtELFVBQWxCLENBQTZCLEtBQUtoRCxRQUFsQyxFQUE0Q0ssTUFBNUMsQ0FBbUR5QixNQUF2RSxHQUFnRixDQUE1RjtBQUNBYyxVQUFBQSxLQUFLLEdBQUdFLEtBQUssQ0FBQ1YsR0FBRCxDQUFMLENBQVdhLElBQVgsQ0FBZ0JMLEtBQWhCLENBQVI7QUFDSDs7QUFDRCxhQUFLLElBQUliLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUlhLEtBQUQsQ0FBb0JkLE1BQXhDLEVBQWdELEVBQUVDLENBQWxELEVBQXFEO0FBQ2pEVyxVQUFBQSxNQUFNLENBQUNDLE1BQVAsQ0FBY0UsR0FBRyxDQUFDZCxDQUFELENBQUgsS0FBV2MsR0FBRyxDQUFDZCxDQUFELENBQUgsR0FBUyxFQUFwQixDQUFkLEVBQXVDYSxLQUFLLENBQUNiLENBQUQsQ0FBNUM7QUFDSDtBQUNKOzs7c0NBRTBCO0FBQ3ZCLFlBQU1tQixJQUFJLEdBQUcsS0FBS3BELFlBQUwsQ0FBbUJrRCxVQUFuQixDQUE4QixLQUFLaEQsUUFBTCxJQUFpQixDQUEvQyxDQUFiOztBQUNBLFlBQUksQ0FBQ2tELElBQUwsRUFBVztBQUFFLGlCQUFPLEVBQVA7QUFBWTs7QUFDekIsWUFBTUMsT0FBTyxHQUFHRCxJQUFJLENBQUM3QyxNQUFMLENBQVl5QixNQUE1QjtBQUNBLFlBQU16QixNQUFjLEdBQUcsRUFBdkI7O0FBQ0EsYUFBSyxJQUFJK0MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0QsT0FBcEIsRUFBNkIsRUFBRUMsQ0FBL0IsRUFBa0M7QUFDOUIsY0FBTUMsUUFBUSxHQUFHSCxJQUFJLENBQUM3QyxNQUFMLENBQVkrQyxDQUFaLENBQWpCO0FBQ0EsY0FBTUUsSUFBSSxHQUFHRCxRQUFRLENBQUNuQyxPQUFULEdBQW1CLEtBQUtSLFFBQUwsQ0FBY29CLE1BQWQsR0FBdUJzQixDQUF2QixHQUEyQixLQUFLMUMsUUFBTCxDQUFjMEMsQ0FBZCxDQUEzQixHQUE4QyxFQUE5RTs7QUFDQSxjQUFJQyxRQUFRLFVBQVIsSUFBbUIsQ0FBQ0MsSUFBSSxDQUFDRCxRQUFRLFVBQVQsQ0FBNUIsRUFBK0M7QUFBRTtBQUFXOztBQUM1REEsVUFBQUEsUUFBUSxDQUFDRSxjQUFULEdBQTBCLEtBQUs1QyxPQUFMLENBQWFtQixNQUFiLEdBQXNCc0IsQ0FBdEIsR0FBMEIsS0FBS3pDLE9BQUwsQ0FBYXlDLENBQWIsQ0FBMUIsR0FBNEMsRUFBdEU7QUFDQUMsVUFBQUEsUUFBUSxDQUFDRyxTQUFULEdBQXFCSixDQUFyQjtBQUNBLGNBQU05QyxJQUFJLEdBQUcsSUFBSW1ELFdBQUosQ0FBU0MsRUFBRSxDQUFDQyxRQUFILENBQVlDLElBQVosQ0FBaUJDLE1BQTFCLENBQWI7QUFDQXZELFVBQUFBLElBQUksQ0FBQ2dCLFVBQUwsQ0FBZ0IrQixRQUFoQjtBQUNBaEQsVUFBQUEsTUFBTSxDQUFDeUQsSUFBUCxDQUFZeEQsSUFBWjtBQUNIOztBQUNELGVBQU9ELE1BQVA7QUFDSDs7O2dDQUU2QztBQUFBOztBQUFBLFlBQTNCMEQsU0FBMkIsdUVBQU4sSUFBTTs7QUFDMUMsWUFBSSxLQUFLakUsWUFBVCxFQUF1QjtBQUNuQixjQUFJLEtBQUtHLE9BQUwsSUFBZ0IsS0FBS0EsT0FBTCxDQUFhNkIsTUFBakMsRUFBeUM7QUFBQSx3REFDbEIsS0FBSzdCLE9BRGE7QUFBQTs7QUFBQTtBQUNyQyxxRUFBaUM7QUFBQSxvQkFBdEJLLElBQXNCO0FBQzdCQSxnQkFBQUEsSUFBSSxDQUFDMEQsT0FBTDtBQUNIO0FBSG9DO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJeEM7O0FBQ0QsZUFBSy9ELE9BQUwsR0FBZSxLQUFLZ0UsYUFBTCxFQUFmLENBTm1CLENBT25COztBQUNBLGNBQU1DLFdBQVcsR0FBRyxLQUFLcEUsWUFBTCxDQUFrQmtELFVBQWxCLENBQTZCLEtBQUtoRCxRQUFsQyxFQUE0Q0ssTUFBNUMsQ0FBbUR5QixNQUF2RTtBQUNBLGVBQUtsQixNQUFMLENBQVlrQixNQUFaLEdBQXFCb0MsV0FBckI7O0FBQ0EsY0FBSUgsU0FBSixFQUFlO0FBQ1gsaUJBQUs5RCxPQUFMLENBQWFrRSxPQUFiLENBQXFCLFVBQUM3RCxJQUFELEVBQU95QixDQUFQLEVBQWE7QUFDOUIsa0JBQUlRLEtBQUssR0FBRyxNQUFJLENBQUMzQixNQUFMLENBQVlOLElBQUksQ0FBQ2tELFNBQWpCLENBQVo7O0FBQ0Esa0JBQUksQ0FBQ2pCLEtBQUwsRUFBWTtBQUFFQSxnQkFBQUEsS0FBSyxHQUFHLE1BQUksQ0FBQzNCLE1BQUwsQ0FBWW1CLENBQVosSUFBaUIsRUFBekI7QUFBOEI7O0FBQzVDLG1CQUFLLElBQU1TLENBQVgsSUFBZ0JELEtBQWhCLEVBQXVCO0FBQ25CLGdCQUFBLE1BQUksQ0FBQ0YsZUFBTCxDQUFxQi9CLElBQXJCLEVBQTJCa0MsQ0FBM0IsRUFBOEJELEtBQUssQ0FBQ0MsQ0FBRCxDQUFuQztBQUNIO0FBQ0osYUFORDtBQU9ILFdBUkQsTUFRTztBQUNILGlCQUFLLElBQUlULENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS25CLE1BQUwsQ0FBWWtCLE1BQWhDLEVBQXdDQyxDQUFDLEVBQXpDLEVBQTZDO0FBQUUsbUJBQUtuQixNQUFMLENBQVltQixDQUFaLElBQWlCLEVBQWpCO0FBQXNCO0FBQ3hFO0FBQ0osU0FyQkQsTUFxQk87QUFBRTtBQUNMLGNBQU1xQyxPQUFPLEdBQUdDLG9CQUFjcEQsR0FBZCxDQUE0Qix5QkFBNUIsQ0FBaEI7O0FBQ0EsY0FBSW1ELE9BQUosRUFBYTtBQUFFLGlCQUFLbkUsT0FBTCxHQUFlbUUsT0FBTyxDQUFDbkUsT0FBUixDQUFnQnFFLEtBQWhCLEVBQWY7QUFBeUM7QUFDM0Q7O0FBQ0QsYUFBS3BFLEtBQUwsR0FBYU4sUUFBUSxDQUFDMkUsT0FBVCxDQUFpQixJQUFqQixDQUFiO0FBQ0g7OztzQ0FFMEJqRSxJLEVBQVlQLEksRUFBY21DLEcsRUFBb0Q7QUFDckcsWUFBTXNDLE1BQU0sR0FBR2xFLElBQUksQ0FBQ21FLFNBQUwsQ0FBZTFFLElBQWYsQ0FBZjs7QUFDQSxZQUFJeUUsTUFBTSxLQUFLMUQsU0FBZixFQUEwQjtBQUFFLGlCQUFPLEtBQVA7QUFBZTs7QUFDM0MsWUFBTTRELFdBQVcsR0FBR2pCLFlBQUtrQix3QkFBTCxDQUE4QkgsTUFBOUIsQ0FBcEI7O0FBQ0EsWUFBSUUsV0FBVyxLQUFLRSx1QkFBZUMsY0FBbkMsRUFBbUQ7QUFDL0MsY0FBSS9CLEtBQUssQ0FBQ0MsT0FBTixDQUFjYixHQUFkLENBQUosRUFBd0I7QUFDcEI1QixZQUFBQSxJQUFJLENBQUN3RSxlQUFMLENBQXFCTixNQUFyQixFQUE2QnRDLEdBQTdCO0FBQ0gsV0FGRCxNQUVPLElBQUlBLEdBQUcsS0FBSyxJQUFaLEVBQWtCO0FBQ3JCNUIsWUFBQUEsSUFBSSxDQUFDeUUsVUFBTCxDQUFnQlAsTUFBaEIsRUFBd0J0QyxHQUF4QjtBQUNILFdBRk0sTUFFQTtBQUNINUIsWUFBQUEsSUFBSSxDQUFDMEUsWUFBTCxDQUFrQmpGLElBQWxCO0FBQ0g7QUFDSixTQVJELE1BUU8sSUFBSTJFLFdBQVcsS0FBS0UsdUJBQWVLLE9BQW5DLEVBQTRDO0FBQy9DLGNBQU1DLE9BQU8sR0FBR3pCLFlBQUswQixvQkFBTCxDQUEwQlgsTUFBMUIsQ0FBaEI7O0FBQ0EsY0FBSXRDLEdBQUcsWUFBWWtELDJCQUFuQixFQUFtQztBQUMvQjlFLFlBQUFBLElBQUksQ0FBQytFLGVBQUwsQ0FBcUJILE9BQXJCLEVBQThCaEQsR0FBOUI7QUFDSCxXQUZELE1BRU8sSUFBSUEsR0FBRyxZQUFZb0Qsd0JBQWYsSUFBOEJwRCxHQUFHLFlBQVlxRCx3QkFBakQsRUFBOEQ7QUFDakUsZ0JBQU1DLFdBQWtDLEdBQUd0RCxHQUFHLENBQUN1RCxpQkFBSixFQUEzQzs7QUFDQSxnQkFBSSxDQUFDRCxXQUFELElBQWdCLENBQUNBLFdBQVcsQ0FBQ0UsT0FBWixDQUFvQkMsS0FBckMsSUFBOEMsQ0FBQ0gsV0FBVyxDQUFDRSxPQUFaLENBQW9CRSxNQUF2RSxFQUErRTtBQUMzRTtBQUNBLHFCQUFPLEtBQVA7QUFDSDs7QUFDRHRGLFlBQUFBLElBQUksQ0FBQytFLGVBQUwsQ0FBcUJILE9BQXJCLEVBQThCTSxXQUE5Qjs7QUFDQSxnQkFBSXRELEdBQUcsWUFBWW9ELHdCQUFuQixFQUFnQztBQUM1QmhGLGNBQUFBLElBQUksQ0FBQ3VGLFdBQUwsQ0FBaUJYLE9BQWpCLEVBQTBCWSx1QkFBV0MsVUFBWCxDQUFzQnJDLEVBQUUsQ0FBQ0MsUUFBSCxDQUFZQyxJQUFaLENBQWlCQyxNQUF2QyxFQUErQzNCLEdBQUcsQ0FBQzhELGNBQUosRUFBL0MsQ0FBMUI7QUFDSDtBQUNKLFdBVk0sTUFVQSxJQUFJLENBQUM5RCxHQUFMLEVBQVU7QUFDYjVCLFlBQUFBLElBQUksQ0FBQzJGLFlBQUwsQ0FBa0JsRyxJQUFsQjtBQUNIO0FBQ0o7O0FBQ0QsZUFBTyxJQUFQO0FBQ0g7OzttQ0FFdUI7QUFDcEIsWUFBSSxLQUFLRSxPQUFMLElBQWdCLEtBQUtBLE9BQUwsQ0FBYTZCLE1BQWpDLEVBQXlDO0FBQUEsc0RBQ2xCLEtBQUs3QixPQURhO0FBQUE7O0FBQUE7QUFDckMsbUVBQWlDO0FBQUEsa0JBQXRCSyxJQUFzQjtBQUM3QkEsY0FBQUEsSUFBSSxDQUFDMEQsT0FBTDtBQUNIO0FBSG9DO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFJeEM7O0FBQ0QsYUFBS2xFLFlBQUwsR0FBb0IsSUFBcEI7QUFDQSxhQUFLRyxPQUFMLENBQWE2QixNQUFiLEdBQXNCLENBQXRCO0FBQ0EsYUFBS2xCLE1BQUwsQ0FBWWtCLE1BQVosR0FBcUIsQ0FBckI7QUFDQSxhQUFLcEIsUUFBTCxDQUFjb0IsTUFBZCxHQUF1QixDQUF2QjtBQUNBLGFBQUtuQixPQUFMLENBQWFtQixNQUFiLEdBQXNCLENBQXRCO0FBQ0g7Ozs7SUE3VnlCb0UsWTs7Ozs7YUFXbUIsSTs7K0VBQzVDQyx3Qjs7Ozs7YUFDb0IsQzs7K0VBQ3BCQSx3Qjs7Ozs7YUFDa0MsRTs7OEVBQ2xDQSx3Qjs7Ozs7YUFDb0MsRTs7NkVBQ3BDQSx3Qjs7Ozs7YUFDbUYsRTs7OztBQTZVeEZ6QyxFQUFBQSxFQUFFLENBQUM5RCxRQUFILEdBQWNBLFFBQWQiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gQ29weXJpZ2h0IChjKSAyMDE3LTIwMTggWGlhbWVuIFlhamkgU29mdHdhcmUgQ28uLCBMdGQuXHJcblxyXG4gaHR0cDovL3d3dy5jb2Nvcy5jb21cclxuXHJcbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGVuZ2luZSBzb3VyY2UgY29kZSAodGhlIFwiU29mdHdhcmVcIiksIGEgbGltaXRlZCxcclxuICB3b3JsZHdpZGUsIHJveWFsdHktZnJlZSwgbm9uLWFzc2lnbmFibGUsIHJldm9jYWJsZSBhbmQgbm9uLWV4Y2x1c2l2ZSBsaWNlbnNlXHJcbiB0byB1c2UgQ29jb3MgQ3JlYXRvciBzb2xlbHkgdG8gZGV2ZWxvcCBnYW1lcyBvbiB5b3VyIHRhcmdldCBwbGF0Zm9ybXMuIFlvdSBzaGFsbFxyXG4gIG5vdCB1c2UgQ29jb3MgQ3JlYXRvciBzb2Z0d2FyZSBmb3IgZGV2ZWxvcGluZyBvdGhlciBzb2Z0d2FyZSBvciB0b29scyB0aGF0J3NcclxuICB1c2VkIGZvciBkZXZlbG9waW5nIGdhbWVzLiBZb3UgYXJlIG5vdCBncmFudGVkIHRvIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsXHJcbiAgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIENvY29zIENyZWF0b3IuXHJcblxyXG4gVGhlIHNvZnR3YXJlIG9yIHRvb2xzIGluIHRoaXMgTGljZW5zZSBBZ3JlZW1lbnQgYXJlIGxpY2Vuc2VkLCBub3Qgc29sZC5cclxuIFhpYW1lbiBZYWppIFNvZnR3YXJlIENvLiwgTHRkLiByZXNlcnZlcyBhbGwgcmlnaHRzIG5vdCBleHByZXNzbHkgZ3JhbnRlZCB0byB5b3UuXHJcblxyXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiBUSEUgU09GVFdBUkUuXHJcbiovXHJcblxyXG4vKipcclxuICog5p2Q6LSo57O757uf55qE55u45YWz5YaF5a65XHJcbiAqIEBjYXRlZ29yeSBtYXRlcmlhbFxyXG4gKi9cclxuXHJcbmltcG9ydCB7IGNjY2xhc3MsIHByb3BlcnR5IH0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2NsYXNzLWRlY29yYXRvcic7XHJcbmltcG9ydCB7IG11cm11cmhhc2gyXzMyX2djIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscy9tdXJtdXJoYXNoMl9nYyc7XHJcbmltcG9ydCB7IGJ1aWx0aW5SZXNNZ3IgfSBmcm9tICcuLi8zZC9idWlsdGluL2luaXQnO1xyXG5pbXBvcnQgeyBSZW5kZXJhYmxlQ29tcG9uZW50IH0gZnJvbSAnLi4vM2QvZnJhbWV3b3JrL3JlbmRlcmFibGUtY29tcG9uZW50JztcclxuaW1wb3J0IHsgR0ZYQmluZGluZ1R5cGUgfSBmcm9tICcuLi9nZngvZGVmaW5lJztcclxuaW1wb3J0IHsgR0ZYVGV4dHVyZVZpZXcgfSBmcm9tICcuLi9nZngvdGV4dHVyZS12aWV3JztcclxuaW1wb3J0IHsgSURlZmluZU1hcCwgTWF0ZXJpYWxQcm9wZXJ0eSB9IGZyb20gJy4uL3JlbmRlcmVyJztcclxuaW1wb3J0IHsgSVBhc3NJbmZvRnVsbCwgUGFzcywgUGFzc092ZXJyaWRlcyB9IGZyb20gJy4uL3JlbmRlcmVyL2NvcmUvcGFzcyc7XHJcbmltcG9ydCB7IHNhbXBsZXJMaWIgfSBmcm9tICcuLi9yZW5kZXJlci9jb3JlL3NhbXBsZXItbGliJztcclxuaW1wb3J0IHsgQXNzZXQgfSBmcm9tICcuL2Fzc2V0JztcclxuaW1wb3J0IHsgRWZmZWN0QXNzZXQgfSBmcm9tICcuL2VmZmVjdC1hc3NldCc7XHJcbmltcG9ydCB7IFNwcml0ZUZyYW1lIH0gZnJvbSAnLi9zcHJpdGUtZnJhbWUnO1xyXG5pbXBvcnQgeyBUZXh0dXJlQmFzZSB9IGZyb20gJy4vdGV4dHVyZS1iYXNlJztcclxuXHJcbi8qKlxyXG4gKiBAZW5cclxuICogVGhlIGJhc2ljIGluZm9zIGZvciBtYXRlcmlhbCBpbml0aWFsaXphdGlvbi5cclxuICogQHpoXHJcbiAqIOeUqOadpeWIneWni+WMluadkOi0qOeahOWfuuacrOS/oeaBr+OAglxyXG4gKi9cclxuaW50ZXJmYWNlIElNYXRlcmlhbEluZm8ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIFRoZSBFZmZlY3RBc3NldCB0byB1c2UuIE11c3QgcHJvdmlkZSBpZiBgZWZmZWN0TmFtZWAgaXMgbm90IHNwZWNpZmllZC5cclxuICAgICAqIEB6aFxyXG4gICAgICog6L+Z5Liq5p2Q6LSo5bCG5L2/55So55qEIEVmZmVjdEFzc2V077yM55u05o6l5o+Q5L6b6LWE5rqQ5byV55So77yM5ZKMIGBlZmZlY3ROYW1lYCDoh7PlsJHopoHmjIflrprkuIDkuKrjgIJcclxuICAgICAqL1xyXG4gICAgZWZmZWN0QXNzZXQ/OiBFZmZlY3RBc3NldCB8IG51bGw7XHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIEVmZmVjdEFzc2V0IHRvIHVzZS4gTXVzdCBwcm92aWRlIGlmIGBlZmZlY3RBc3NldGAgaXMgbm90IHNwZWNpZmllZC5cclxuICAgICAqIEB6aFxyXG4gICAgICog6L+Z5Liq5p2Q6LSo5bCG5L2/55So55qEIEVmZmVjdEFzc2V077yM6YCa6L+HIGVmZmVjdCDlkI3mjIflrprvvIzlkowgYGVmZmVjdEFzc2V0YCDoh7PlsJHopoHmjIflrprkuIDkuKrjgIJcclxuICAgICAqL1xyXG4gICAgZWZmZWN0TmFtZT86IHN0cmluZztcclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIHRlY2huaXF1ZSB0byB1c2UuXHJcbiAgICAgKiBAemhcclxuICAgICAqIOi/meS4quadkOi0qOWwhuS9v+eUqOesrOWHoOS4qiB0ZWNobmlxdWXvvIzpu5jorqTkuLogMOOAglxyXG4gICAgICovXHJcbiAgICB0ZWNobmlxdWU/OiBudW1iZXI7XHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogVGhlIHNoYWRlciBtYWNybyBkZWZpbml0aW9ucy4gRGVmYXVsdCB0byAwIG9yIHRoZSBzcGVjaWZpZWQgdmFsdWUgaW4gW1tFZmZlY3RBc3NldF1dLlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDov5nkuKrmnZDotKjlrprkuYnnmoTpooTlpITnkIblro/vvIzpu5jorqTlhajkuLogMO+8jOaIliBbW0VmZmVjdEFzc2V0XV0g5Lit55qE5oyH5a6a5YC844CCXHJcbiAgICAgKi9cclxuICAgIGRlZmluZXM/OiBJRGVmaW5lTWFwIHwgSURlZmluZU1hcFtdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIFRoZSBvdmVycmlkZSB2YWx1ZXMgb24gdG9wIG9mIHRoZSBwaXBlbGluZSBzdGF0ZXMgc3BlY2lmaWVkIGluIFtbRWZmZWN0QXNzZXRdXS5cclxuICAgICAqIEB6aFxyXG4gICAgICog6L+Z5Liq5p2Q6LSo55qE6Ieq5a6a5LmJ566h57q/54q25oCB77yM5bCG6KaG55uWIGVmZmVjdCDkuK3nmoTlsZ7mgKfjgII8YnI+XHJcbiAgICAgKiDms6jmhI/lnKjlj6/og73nmoTmg4XlhrXkuIvor7flsL3ph4/lsJHnmoToh6rlrprkuYnnrqHnur/nirbmgIHvvIzku6Xlh4/lsI/lr7nmuLLmn5PmlYjnjofnmoTlvbHlk43jgIJcclxuICAgICAqL1xyXG4gICAgc3RhdGVzPzogUGFzc092ZXJyaWRlcyB8IFBhc3NPdmVycmlkZXNbXTtcclxufVxyXG5cclxudHlwZSBNYXRlcmlhbFByb3BlcnR5RnVsbCA9IE1hdGVyaWFsUHJvcGVydHkgfCBUZXh0dXJlQmFzZSB8IFNwcml0ZUZyYW1lIHwgR0ZYVGV4dHVyZVZpZXcgfCBudWxsO1xyXG5cclxuLyoqXHJcbiAqIEBlblxyXG4gKiBUaGUgbWF0ZXJpYWwgYXNzZXQsIHNwZWNpZmllcyBpbiBkZXRhaWxzIGhvdyBhIG1vZGVsIGlzIGRyYXduIG9uIHNjcmVlbi5cclxuICogQHpoXHJcbiAqIOadkOi0qOi1hOa6kOexu++8jOWMheWQq+aooeWei+e7mOWItuaWueW8j+eahOWFqOmDqOe7huiKguaPj+i/sOOAglxyXG4gKi9cclxuQGNjY2xhc3MoJ2NjLk1hdGVyaWFsJylcclxuZXhwb3J0IGNsYXNzIE1hdGVyaWFsIGV4dGVuZHMgQXNzZXQge1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0SGFzaCAobWF0ZXJpYWw6IE1hdGVyaWFsKSB7XHJcbiAgICAgICAgbGV0IHN0ciA9ICcnO1xyXG4gICAgICAgIGZvciAoY29uc3QgcGFzcyBvZiBtYXRlcmlhbC5wYXNzZXMpIHtcclxuICAgICAgICAgICAgc3RyICs9IHBhc3MuaGFzaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG11cm11cmhhc2gyXzMyX2djKHN0ciwgNjY2KTtcclxuICAgIH1cclxuXHJcbiAgICBAcHJvcGVydHkoRWZmZWN0QXNzZXQpXHJcbiAgICBwcm90ZWN0ZWQgX2VmZmVjdEFzc2V0OiBFZmZlY3RBc3NldCB8IG51bGwgPSBudWxsO1xyXG4gICAgQHByb3BlcnR5XHJcbiAgICBwcm90ZWN0ZWQgX3RlY2hJZHggPSAwO1xyXG4gICAgQHByb3BlcnR5XHJcbiAgICBwcm90ZWN0ZWQgX2RlZmluZXM6IElEZWZpbmVNYXBbXSA9IFtdO1xyXG4gICAgQHByb3BlcnR5XHJcbiAgICBwcm90ZWN0ZWQgX3N0YXRlczogUGFzc092ZXJyaWRlc1tdID0gW107XHJcbiAgICBAcHJvcGVydHlcclxuICAgIHByb3RlY3RlZCBfcHJvcHM6IFJlY29yZDxzdHJpbmcsIE1hdGVyaWFsUHJvcGVydHlGdWxsIHwgTWF0ZXJpYWxQcm9wZXJ0eUZ1bGxbXT5bXSA9IFtdO1xyXG5cclxuICAgIHByb3RlY3RlZCBfcGFzc2VzOiBQYXNzW10gPSBbXTtcclxuICAgIHByb3RlY3RlZCBfaGFzaCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gVGhlIGN1cnJlbnQgW1tFZmZlY3RBc3NldF1dLlxyXG4gICAgICogQHpoIOW9k+WJjeS9v+eUqOeahCBbW0VmZmVjdEFzc2V0XV0g6LWE5rqQ44CCXHJcbiAgICAgKi9cclxuICAgIGdldCBlZmZlY3RBc3NldCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VmZmVjdEFzc2V0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIE5hbWUgb2YgdGhlIGN1cnJlbnQgW1tFZmZlY3RBc3NldF1dLlxyXG4gICAgICogQHpoIOW9k+WJjeS9v+eUqOeahCBbW0VmZmVjdEFzc2V0XV0g6LWE5rqQ5ZCN44CCXHJcbiAgICAgKi9cclxuICAgIGdldCBlZmZlY3ROYW1lICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZWZmZWN0QXNzZXQgPyB0aGlzLl9lZmZlY3RBc3NldC5uYW1lIDogJyc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gVGhlIGN1cnJlbnQgdGVjaG5pcXVlIGluZGV4LlxyXG4gICAgICogQHpoIOW9k+WJjeeahCB0ZWNobmlxdWUg57Si5byV44CCXHJcbiAgICAgKi9cclxuICAgIGdldCB0ZWNobmlxdWUgKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZWNoSWR4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFRoZSBwYXNzZXMgZGVmaW5lZCBpbiB0aGlzIG1hdGVyaWFsLlxyXG4gICAgICogQHpoIOW9k+WJjeato+WcqOS9v+eUqOeahCBwYXNzIOaVsOe7hOOAglxyXG4gICAgICovXHJcbiAgICBnZXQgcGFzc2VzICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFzc2VzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFRoZSBoYXNoIHZhbHVlIG9mIHRoaXMgbWF0ZXJpYWwuXHJcbiAgICAgKiBAemgg5p2Q6LSo55qEIGhhc2jjgIJcclxuICAgICAqL1xyXG4gICAgZ2V0IGhhc2ggKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNoO1xyXG4gICAgfVxyXG5cclxuICAgIGdldCBwYXJlbnQgKCk6IE1hdGVyaWFsIHwgbnVsbCB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IG93bmVyICgpOiBSZW5kZXJhYmxlQ29tcG9uZW50IHwgbnVsbCB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0b3IgKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBJbml0aWFsaXplIHRoaXMgbWF0ZXJpYWwgd2l0aCB0aGUgZ2l2ZW4gaW5mb3JtYXRpb24uXHJcbiAgICAgKiBAemgg5qC55o2u5omA57uZ5L+h5oGv5Yid5aeL5YyW6L+Z5Liq5p2Q6LSo77yM5Yid5aeL5YyW5q2j5bi457uT5p2f5ZCO5p2Q6LSo5Y2z5Y+v56uL5Y2z55So5LqO5riy5p+T44CCXHJcbiAgICAgKiBAcGFyYW0gaW5mbyBNYXRlcmlhbCBkZXNjcmlwdGlvbiBpbmZvLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgaW5pdGlhbGl6ZSAoaW5mbzogSU1hdGVyaWFsSW5mbykge1xyXG4gICAgICAgIGlmICghdGhpcy5fZGVmaW5lcykgeyB0aGlzLl9kZWZpbmVzID0gW107IH1cclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXRlcykgeyB0aGlzLl9zdGF0ZXMgPSBbXTsgfVxyXG4gICAgICAgIGlmICghdGhpcy5fcHJvcHMpIHsgdGhpcy5fcHJvcHMgPSBbXTsgfVxyXG4gICAgICAgIGlmIChpbmZvLnRlY2huaXF1ZSAhPT0gdW5kZWZpbmVkKSB7IHRoaXMuX3RlY2hJZHggPSBpbmZvLnRlY2huaXF1ZTsgfVxyXG4gICAgICAgIGlmIChpbmZvLmVmZmVjdEFzc2V0KSB7IHRoaXMuX2VmZmVjdEFzc2V0ID0gaW5mby5lZmZlY3RBc3NldDsgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluZm8uZWZmZWN0TmFtZSkgeyB0aGlzLl9lZmZlY3RBc3NldCA9IEVmZmVjdEFzc2V0LmdldChpbmZvLmVmZmVjdE5hbWUpOyB9XHJcbiAgICAgICAgaWYgKGluZm8uZGVmaW5lcykgeyB0aGlzLl9wcmVwYXJlSW5mbyhpbmZvLmRlZmluZXMsIHRoaXMuX2RlZmluZXMpOyB9XHJcbiAgICAgICAgaWYgKGluZm8uc3RhdGVzKSB7IHRoaXMuX3ByZXBhcmVJbmZvKGluZm8uc3RhdGVzLCB0aGlzLl9zdGF0ZXMpOyB9XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgcmVzZXQgKGluZm86IElNYXRlcmlhbEluZm8pIHsgLy8gY29uc2lzdGVuY3kgd2l0aCBvdGhlciBhc3NldHNcclxuICAgICAgICB0aGlzLmluaXRpYWxpemUoaW5mbyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIERlc3Ryb3kgdGhlIG1hdGVyaWFsIGRlZmluaXRpdmVseS48YnI+XHJcbiAgICAgKiBDYW5ub3QgcmUtaW5pdGlhbGl6ZSBhZnRlciBkZXN0cm95Ljxicj5cclxuICAgICAqIEZvciByZS1pbml0aWFsaXplIHB1cnBvc2VzLCBjYWxsIFtbTWF0ZXJpYWwuaW5pdGlhbGl6ZV1dIGRpcmVjdGx5LlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDlvbvlupXplIDmr4HmnZDotKjvvIzms6jmhI/plIDmr4HlkI7ml6Dms5Xph43mlrDliJ3lp4vljJbjgII8YnI+XHJcbiAgICAgKiDlpoLpnIDph43mlrDliJ3lp4vljJbmnZDotKjvvIzkuI3lv4XlhYjosIPnlKggZGVzdHJveeOAglxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGVzdHJveSAoKSB7XHJcbiAgICAgICAgdGhpcy5fZG9EZXN0cm95KCk7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBSZWNvbXBpbGUgdGhlIHNoYWRlciB3aXRoIHRoZSBzcGVjaWZpZWQgbWFjcm8gb3ZlcnJpZGVzLiBBbGxvd2VkIG9ubHkgb24gbWF0ZXJpYWwgaW5zdGFuY2VzLlxyXG4gICAgICogQHpoIOS9v+eUqOaMh+WumumihOWkhOeQhuWuj+mHjeaWsOe8luivkeW9k+WJjSBwYXNz77yI5pWw57uE77yJ5Lit55qEIHNoYWRlcuOAguWPquWFgeiuuOWvueadkOi0qOWunuS+i+aJp+ihjOOAglxyXG4gICAgICogQHBhcmFtIG92ZXJyaWRlcyBUaGUgc2hhZGVyIG1hY3JvIG92ZXJyaWRlIHZhbHVlcy5cclxuICAgICAqIEBwYXJhbSBwYXNzSWR4IFRoZSBwYXNzIHRvIGFwcGx5IHRvLiBXaWxsIGFwcGx5IHRvIGFsbCBwYXNzZXMgaWYgbm90IHNwZWNpZmllZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlY29tcGlsZVNoYWRlcnMgKG92ZXJyaWRlczogSURlZmluZU1hcCwgcGFzc0lkeD86IG51bWJlcikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignU2hhZGVycyBpbiBtYXRlcmlhbCBhc3NldCBcXCcnICsgdGhpcy5uYW1lICsgJ1xcJyBjYW5ub3QgYmUgbW9kaWZpZWQgYXQgcnVudGltZSwgcGxlYXNlIGluc3RhbnRpYXRlIHRoZSBtYXRlcmlhbCBmaXJzdC4nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBPdmVycmlkZSB0aGUgcGFzc2VzIHdpdGggdGhlIHNwZWNpZmllZCBwaXBlbGluZSBzdGF0ZXMuIEFsbG93ZWQgb25seSBvbiBtYXRlcmlhbCBpbnN0YW5jZXMuXHJcbiAgICAgKiBAemgg5L2/55So5oyH5a6a566h57q/54q25oCB6YeN6L295b2T5YmN55qEIHBhc3PvvIjmlbDnu4TvvInjgILlj6rlhYHorrjlr7nmnZDotKjlrp7kvovmiafooYzjgIJcclxuICAgICAqIEBwYXJhbSBvdmVycmlkZXMgVGhlIHBpcGVsaW5lIHN0YXRlIG92ZXJyaWRlIHZhbHVlcy5cclxuICAgICAqIEBwYXJhbSBwYXNzSWR4IFRoZSBwYXNzIHRvIGFwcGx5IHRvLiBXaWxsIGFwcGx5IHRvIGFsbCBwYXNzZXMgaWYgbm90IHNwZWNpZmllZC5cclxuICAgICAqL1xyXG4gICAgcHVibGljIG92ZXJyaWRlUGlwZWxpbmVTdGF0ZXMgKG92ZXJyaWRlczogUGFzc092ZXJyaWRlcywgcGFzc0lkeD86IG51bWJlcikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignUGlwZWxpbmUgc3RhdGVzIGluIG1hdGVyaWFsIGFzc2V0IFxcJycgKyB0aGlzLm5hbWUgKyAnXFwnIGNhbm5vdCBiZSBtb2RpZmllZCBhdCBydW50aW1lLCBwbGVhc2UgaW5zdGFudGlhdGUgdGhlIG1hdGVyaWFsIGZpcnN0LicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIENhbGxiYWNrIGZ1bmN0aW9uIGFmdGVyIG1hdGVyaWFsIGlzIGxvYWRlZCBpbiBbW0xvYWRlcl1dLiBJbml0aWFsaXplIHRoZSByZXNvdXJjZXMgYXV0b21hdGljYWxseS5cclxuICAgICAqIEB6aCDpgJrov4cgW1tMb2FkZXJdXSDliqDovb3lrozmiJDml7bnmoTlm57osIPvvIzlsIboh6rliqjliJ3lp4vljJbmnZDotKjotYTmupDjgIJcclxuICAgICAqL1xyXG4gICAgcHVibGljIG9uTG9hZGVkICgpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcclxuICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdsb2FkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gUmVzZXQgYWxsIHRoZSB1bmlmb3JtcyB0byB0aGUgZGVmYXVsdCB2YWx1ZSBzcGVjaWZpZWQgaW4gW1tFZmZlY3RBc3NldF1dLlxyXG4gICAgICogQHpoIOmHjee9ruadkOi0qOeahOaJgOaciSB1bmlmb3JtIOWPguaVsOaVsOaNruS4uiBbW0VmZmVjdEFzc2V0XV0g5Lit55qE6buY6K6k5Yid5aeL5YC844CCXHJcbiAgICAgKiBAcGFyYW0gY2xlYXJQYXNzZXMgV2lsbCB0aGUgcmVuZGVyaW5nIGRhdGEgYmUgY2xlYXJlZCB0b28/XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXNldFVuaWZvcm1zIChjbGVhclBhc3NlcyA9IHRydWUpIHtcclxuICAgICAgICB0aGlzLl9wcm9wcy5sZW5ndGggPSB0aGlzLl9wYXNzZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcHJvcHMubGVuZ3RoOyBpKyspIHsgdGhpcy5fcHJvcHNbaV0gPSB7fTsgfVxyXG4gICAgICAgIGlmICghY2xlYXJQYXNzZXMpIHsgcmV0dXJuOyB9XHJcbiAgICAgICAgZm9yIChjb25zdCBwYXNzIG9mIHRoaXMuX3Bhc3Nlcykge1xyXG4gICAgICAgICAgICBwYXNzLnJlc2V0VUJPcygpO1xyXG4gICAgICAgICAgICBwYXNzLnJlc2V0VGV4dHVyZXMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIENvbnZlbmllbnQgcHJvcGVydHkgc2V0dGVyIHByb3ZpZGVkIGZvciBxdWljayBtYXRlcmlhbCBzZXR1cC48YnI+XHJcbiAgICAgKiBbW1Bhc3Muc2V0VW5pZm9ybV1dIHNob3VsZCBiZSB1c2VkIGluc3RlYWQgaWYgeW91IG5lZWQgdG8gZG8gcGVyLWZyYW1lIHVuaWZvcm0gdXBkYXRlLlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDorr7nva7mnZDotKggdW5pZm9ybSDlj4LmlbDnmoTnu5/kuIDlhaXlj6PjgII8YnI+XHJcbiAgICAgKiDms6jmhI/lpoLmnpzpnIDopoHmr4/luKfmm7TmlrAgdW5pZm9ybe+8jOW7uuiuruS9v+eUqCBbW1Bhc3Muc2V0VW5pZm9ybV1dIOS7peiOt+W+l+abtOWlveeahOaAp+iDveOAglxyXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIHRhcmdldCB1bmlmb3JtIG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gdmFsIFRoZSB0YXJnZXQgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gcGFzc0lkeCBUaGUgcGFzcyB0byBhcHBseSB0by4gV2lsbCBhcHBseSB0byBhbGwgcGFzc2VzIGlmIG5vdCBzcGVjaWZpZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzZXRQcm9wZXJ0eSAobmFtZTogc3RyaW5nLCB2YWw6IE1hdGVyaWFsUHJvcGVydHlGdWxsIHwgTWF0ZXJpYWxQcm9wZXJ0eUZ1bGxbXSwgcGFzc0lkeD86IG51bWJlcikge1xyXG4gICAgICAgIGxldCBzdWNjZXNzID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHBhc3NJZHggPT09IHVuZGVmaW5lZCkgeyAvLyB0cnkgc2V0IHByb3BlcnR5IGZvciBhbGwgYXBwbGljYWJsZSBwYXNzZXNcclxuICAgICAgICAgICAgY29uc3QgcGFzc2VzID0gdGhpcy5fcGFzc2VzO1xyXG4gICAgICAgICAgICBjb25zdCBsZW4gPSBwYXNzZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwYXNzID0gcGFzc2VzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3VwbG9hZFByb3BlcnR5KHBhc3MsIG5hbWUsIHZhbCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wc1tpXVtuYW1lXSA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwYXNzSWR4ID49IHRoaXMuX3Bhc3Nlcy5sZW5ndGgpIHsgY29uc29sZS53YXJuKGBpbGxlZ2FsIHBhc3MgaW5kZXg6ICR7cGFzc0lkeH0uYCk7IHJldHVybjsgfVxyXG4gICAgICAgICAgICBjb25zdCBwYXNzID0gdGhpcy5fcGFzc2VzW3Bhc3NJZHhdO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdXBsb2FkUHJvcGVydHkocGFzcywgbmFtZSwgdmFsKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvcHNbcGFzc0lkeF1bbmFtZV0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBpbGxlZ2FsIHByb3BlcnR5IG5hbWU6ICR7bmFtZX0uYCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIEdldCB0aGUgc3BlY2lmaWVkIHVuaWZvcm0gdmFsdWUgZm9yIHRoaXMgbWF0ZXJpYWwuPGJyPlxyXG4gICAgICogTm90ZSB0aGF0IG9ubHkgdW5pZm9ybXMgc2V0IHRocm91Z2ggW1tNYXRlcmlhbC5zZXRQcm9wZXJ0eV1dIGNhbiBiZSBhY3F1aXJlZCBoZXJlLjxicj5cclxuICAgICAqIEZvciB0aGUgY29tcGxldGUgcmVuZGVyaW5nIGRhdGEsIHVzZSBbW1Bhc3MuZ2V0VW5pZm9ybV1dIGluc3RlYWQuXHJcbiAgICAgKiBAemhcclxuICAgICAqIOiOt+WPluW9k+WJjeadkOi0qOeahOaMh+WumiB1bmlmb3JtIOWPguaVsOeahOWAvOOAgjxicj5cclxuICAgICAqIOazqOaEj+WPquaciemAmui/hyBbW01hdGVyaWFsLnNldFByb3BlcnR5XV0g5Ye95pWw6K6+572u55qE5Y+C5pWw5omN6IO95LuO5q2k5Ye95pWw5Y+W5Ye677yMPGJyPlxyXG4gICAgICog5aaC6ZyA5Y+W5Ye65a6M5pW055qE5riy5p+T5pWw5o2u77yM6K+35L2/55SoIFtbUGFzcy5nZXRVbmlmb3JtXV3jgIJcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBwcm9wZXJ0eSBvciB1bmlmb3JtIG5hbWUuXHJcbiAgICAgKiBAcGFyYW0gcGFzc0lkeCBUaGUgdGFyZ2V0IHBhc3MgaW5kZXguIElmIG5vdCBzcGVjaWZpZWQsIHJldHVybiB0aGUgZmlyc3QgZm91bmQgdmFsdWUgaW4gYWxsIHBhc3Nlcy5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFByb3BlcnR5IChuYW1lOiBzdHJpbmcsIHBhc3NJZHg/OiBudW1iZXIpIHtcclxuICAgICAgICBpZiAocGFzc0lkeCA9PT0gdW5kZWZpbmVkKSB7IC8vIHRyeSBnZXQgcHJvcGVydHkgaW4gYWxsIHBvc3NpYmxlIHBhc3Nlc1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wc0FycmF5ID0gdGhpcy5fcHJvcHM7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHByb3BzQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IHByb3BzQXJyYXlbaV07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocCA9PT0gbmFtZSkgeyByZXR1cm4gcHJvcHNbcF07IH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChwYXNzSWR4ID49IHRoaXMuX3Byb3BzLmxlbmd0aCkgeyBjb25zb2xlLndhcm4oYGlsbGVnYWwgcGFzcyBpbmRleDogJHtwYXNzSWR4fS5gKTsgcmV0dXJuIG51bGw7IH1cclxuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLl9wcm9wc1twYXNzSWR4XTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwIGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gbmFtZSkgeyByZXR1cm4gcHJvcHNbcF07IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBDb3B5IHRoZSB0YXJnZXQgbWF0ZXJpYWwuXHJcbiAgICAgKiBAemgg5aSN5Yi255uu5qCH5p2Q6LSo5Yiw5b2T5YmN5a6e5L6L44CCXHJcbiAgICAgKiBAcGFyYW0gbWF0IFRoZSBtYXRlcmlhbCB0byBiZSBjb3BpZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBjb3B5IChtYXQ6IE1hdGVyaWFsKSB7XHJcbiAgICAgICAgdGhpcy5fdGVjaElkeCA9IG1hdC5fdGVjaElkeDtcclxuICAgICAgICB0aGlzLl9wcm9wcy5sZW5ndGggPSBtYXQuX3Byb3BzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdC5fcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fcHJvcHNbaV0gPSBPYmplY3QuYXNzaWduKHt9LCBtYXQuX3Byb3BzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGVmaW5lcy5sZW5ndGggPSBtYXQuX2RlZmluZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Ll9kZWZpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlZmluZXNbaV0gPSBPYmplY3QuYXNzaWduKHt9LCBtYXQuX2RlZmluZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zdGF0ZXMubGVuZ3RoID0gbWF0Ll9zdGF0ZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Ll9zdGF0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhdGVzW2ldID0gT2JqZWN0LmFzc2lnbih7fSwgbWF0Ll9zdGF0ZXNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9lZmZlY3RBc3NldCA9IG1hdC5fZWZmZWN0QXNzZXQ7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9wcmVwYXJlSW5mbyAocGF0Y2g6IG9iamVjdCB8IG9iamVjdFtdLCBjdXI6IG9iamVjdFtdKSB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhdGNoKSkgeyAvLyBmaWxsIGFsbCB0aGUgcGFzc2VzIGlmIG5vdCBzcGVjaWZpZWRcclxuICAgICAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fZWZmZWN0QXNzZXQgPyB0aGlzLl9lZmZlY3RBc3NldC50ZWNobmlxdWVzW3RoaXMuX3RlY2hJZHhdLnBhc3Nlcy5sZW5ndGggOiAxO1xyXG4gICAgICAgICAgICBwYXRjaCA9IEFycmF5KGxlbikuZmlsbChwYXRjaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKHBhdGNoIGFzIG9iamVjdFtdKS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKGN1cltpXSB8fCAoY3VyW2ldID0ge30pLCBwYXRjaFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfY3JlYXRlUGFzc2VzICgpIHtcclxuICAgICAgICBjb25zdCB0ZWNoID0gdGhpcy5fZWZmZWN0QXNzZXQhLnRlY2huaXF1ZXNbdGhpcy5fdGVjaElkeCB8fCAwXTtcclxuICAgICAgICBpZiAoIXRlY2gpIHsgcmV0dXJuIFtdOyB9XHJcbiAgICAgICAgY29uc3QgcGFzc051bSA9IHRlY2gucGFzc2VzLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBwYXNzZXM6IFBhc3NbXSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcGFzc051bTsgKytrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhc3NJbmZvID0gdGVjaC5wYXNzZXNba10gYXMgSVBhc3NJbmZvRnVsbDtcclxuICAgICAgICAgICAgY29uc3QgZGVmcyA9IHBhc3NJbmZvLmRlZmluZXMgPSB0aGlzLl9kZWZpbmVzLmxlbmd0aCA+IGsgPyB0aGlzLl9kZWZpbmVzW2tdIDoge307XHJcbiAgICAgICAgICAgIGlmIChwYXNzSW5mby5zd2l0Y2ggJiYgIWRlZnNbcGFzc0luZm8uc3dpdGNoXSkgeyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICBwYXNzSW5mby5zdGF0ZU92ZXJyaWRlcyA9IHRoaXMuX3N0YXRlcy5sZW5ndGggPiBrID8gdGhpcy5fc3RhdGVzW2tdIDoge307XHJcbiAgICAgICAgICAgIHBhc3NJbmZvLmlkeEluVGVjaCA9IGs7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhc3MgPSBuZXcgUGFzcyhjYy5kaXJlY3Rvci5yb290LmRldmljZSk7XHJcbiAgICAgICAgICAgIHBhc3MuaW5pdGlhbGl6ZShwYXNzSW5mbyk7XHJcbiAgICAgICAgICAgIHBhc3Nlcy5wdXNoKHBhc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFzc2VzO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfdXBkYXRlIChrZWVwUHJvcHM6IGJvb2xlYW4gPSB0cnVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2VmZmVjdEFzc2V0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXNzZXMgJiYgdGhpcy5fcGFzc2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXNzIG9mIHRoaXMuX3Bhc3Nlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhc3MuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Bhc3NlcyA9IHRoaXMuX2NyZWF0ZVBhc3NlcygpO1xyXG4gICAgICAgICAgICAvLyBoYW5kbGUgcHJvcGVydHkgdmFsdWVzXHJcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsUGFzc2VzID0gdGhpcy5fZWZmZWN0QXNzZXQudGVjaG5pcXVlc1t0aGlzLl90ZWNoSWR4XS5wYXNzZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9wcy5sZW5ndGggPSB0b3RhbFBhc3NlcztcclxuICAgICAgICAgICAgaWYgKGtlZXBQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFzc2VzLmZvckVhY2goKHBhc3MsIGkpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcHJvcHMgPSB0aGlzLl9wcm9wc1twYXNzLmlkeEluVGVjaF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wcykgeyBwcm9wcyA9IHRoaXMuX3Byb3BzW2ldID0ge307IH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBsb2FkUHJvcGVydHkocGFzcywgcCwgcHJvcHNbcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wcm9wcy5sZW5ndGg7IGkrKykgeyB0aGlzLl9wcm9wc1tpXSA9IHt9OyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgeyAvLyB1Z2x5IHllbGxvdyBpbmRpY2F0aW5nIG1pc3NpbmcgZWZmZWN0XHJcbiAgICAgICAgICAgIGNvbnN0IG1pc3NpbmcgPSBidWlsdGluUmVzTWdyLmdldDxNYXRlcmlhbD4oJ21pc3NpbmctZWZmZWN0LW1hdGVyaWFsJyk7XHJcbiAgICAgICAgICAgIGlmIChtaXNzaW5nKSB7IHRoaXMuX3Bhc3NlcyA9IG1pc3NpbmcuX3Bhc3Nlcy5zbGljZSgpOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2hhc2ggPSBNYXRlcmlhbC5nZXRIYXNoKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfdXBsb2FkUHJvcGVydHkgKHBhc3M6IFBhc3MsIG5hbWU6IHN0cmluZywgdmFsOiBNYXRlcmlhbFByb3BlcnR5RnVsbCB8IE1hdGVyaWFsUHJvcGVydHlGdWxsW10pIHtcclxuICAgICAgICBjb25zdCBoYW5kbGUgPSBwYXNzLmdldEhhbmRsZShuYW1lKTtcclxuICAgICAgICBpZiAoaGFuZGxlID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbiAgICAgICAgY29uc3QgYmluZGluZ1R5cGUgPSBQYXNzLmdldEJpbmRpbmdUeXBlRnJvbUhhbmRsZShoYW5kbGUpO1xyXG4gICAgICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gR0ZYQmluZGluZ1R5cGUuVU5JRk9STV9CVUZGRVIpIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xyXG4gICAgICAgICAgICAgICAgcGFzcy5zZXRVbmlmb3JtQXJyYXkoaGFuZGxlLCB2YWwgYXMgTWF0ZXJpYWxQcm9wZXJ0eVtdKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHBhc3Muc2V0VW5pZm9ybShoYW5kbGUsIHZhbCBhcyBNYXRlcmlhbFByb3BlcnR5KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhc3MucmVzZXRVbmlmb3JtKG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSA9PT0gR0ZYQmluZGluZ1R5cGUuU0FNUExFUikge1xyXG4gICAgICAgICAgICBjb25zdCBiaW5kaW5nID0gUGFzcy5nZXRCaW5kaW5nRnJvbUhhbmRsZShoYW5kbGUpO1xyXG4gICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgR0ZYVGV4dHVyZVZpZXcpIHtcclxuICAgICAgICAgICAgICAgIHBhc3MuYmluZFRleHR1cmVWaWV3KGJpbmRpbmcsIHZhbCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgVGV4dHVyZUJhc2UgfHwgdmFsIGluc3RhbmNlb2YgU3ByaXRlRnJhbWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmVWaWV3OiBHRlhUZXh0dXJlVmlldyB8IG51bGwgPSB2YWwuZ2V0R0ZYVGV4dHVyZVZpZXcoKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGV4dHVyZVZpZXcgfHwgIXRleHR1cmVWaWV3LnRleHR1cmUud2lkdGggfHwgIXRleHR1cmVWaWV3LnRleHR1cmUuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKGBtYXRlcmlhbCAnJHt0aGlzLl91dWlkfScgcmVjZWl2ZWQgaW5jb21wbGV0ZSB0ZXh0dXJlIGFzc2V0ICcke3ZhbC5fdXVpZH0nYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFzcy5iaW5kVGV4dHVyZVZpZXcoYmluZGluZywgdGV4dHVyZVZpZXcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFRleHR1cmVCYXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFzcy5iaW5kU2FtcGxlcihiaW5kaW5nLCBzYW1wbGVyTGliLmdldFNhbXBsZXIoY2MuZGlyZWN0b3Iucm9vdC5kZXZpY2UsIHZhbC5nZXRTYW1wbGVySGFzaCgpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXZhbCkge1xyXG4gICAgICAgICAgICAgICAgcGFzcy5yZXNldFRleHR1cmUobmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9kb0Rlc3Ryb3kgKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wYXNzZXMgJiYgdGhpcy5fcGFzc2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhc3Mgb2YgdGhpcy5fcGFzc2VzKSB7XHJcbiAgICAgICAgICAgICAgICBwYXNzLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9lZmZlY3RBc3NldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fcGFzc2VzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fcHJvcHMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl9kZWZpbmVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fc3RhdGVzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbn1cclxuXHJcbmNjLk1hdGVyaWFsID0gTWF0ZXJpYWw7XHJcbiJdfQ==