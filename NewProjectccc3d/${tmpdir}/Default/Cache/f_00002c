(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "../assets/scripts.js", "../data/class-decorator.js", "../data/object.js", "../utils/id-generator.js", "../utils/js.js", "../data/utils/requiring-frame.js", "../default-constants.js"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("../assets/scripts.js"), require("../data/class-decorator.js"), require("../data/object.js"), require("../utils/id-generator.js"), require("../utils/js.js"), require("../data/utils/requiring-frame.js"), require("../default-constants.js"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.scripts, global.classDecorator, global.object, global.idGenerator, global.js, global.requiringFrame, global.defaultConstants);
    global.component = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _scripts, _classDecorator, _object, _idGenerator, _js, RF, _defaultConstants) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.Component = void 0;
  _idGenerator = _interopRequireDefault(_idGenerator);
  RF = _interopRequireWildcard(RF);

  var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _class, _class2, _descriptor, _descriptor2, _class3, _temp;

  function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

  var idGenerator = new _idGenerator.default('Comp'); // @ts-ignore

  var IsOnEnableCalled = _object.CCObject.Flags.IsOnEnableCalled; // @ts-ignore

  var IsOnLoadCalled = _object.CCObject.Flags.IsOnLoadCalled;
  var NullNode = null;
  /**
   * @en
   * Base class for everything attached to Node(Entity).<br/>
   * <br/>
   * NOTE: Not allowed to use construction parameters for Component's subclasses,
   *       because Component is created by the engine.
   * @zh
   * 所有附加到节点的基类。<br/>
   * <br/>
   * 注意：不允许使用组件的子类构造参数，因为组件是由引擎创建的。
   *
   * @class Component
   * @extends Object
   */

  var Component = (_dec = (0, _classDecorator.ccclass)('cc.Component'), _dec2 = (0, _classDecorator.property)({
    visible: false
  }), _dec3 = (0, _classDecorator.property)({
    visible: false
  }), _dec4 = (0, _classDecorator.property)({
    displayName: 'Script',
    type: _scripts.Script,
    tooltip: _defaultConstants.DEV ? 'i18n:INSPECTOR.component.script' : undefined
  }), _dec5 = (0, _classDecorator.property)({
    visible: false
  }), _dec6 = (0, _classDecorator.property)({
    visible: false
  }), _dec7 = (0, _classDecorator.property)({
    visible: false
  }), _dec(_class = (_class2 = (_temp = _class3 = /*#__PURE__*/function (_CCObject) {
    _inherits(Component, _CCObject);

    function Component() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, Component);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Component)).call.apply(_getPrototypeOf2, [this].concat(args)));

      _initializerDefineProperty(_this, "node", _descriptor, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_enabled", _descriptor2, _assertThisInitialized(_this));

      _this._sceneGetter = null;
      _this._id = idGenerator.getNewId();
      return _this;
    }

    _createClass(Component, [{
      key: "_getRenderScene",
      // private __scriptUuid = '';
      value: function _getRenderScene() {
        if (this._sceneGetter) {
          return this._sceneGetter();
        } else {
          return this.node.scene._renderScene;
        }
      } // PUBLIC

      /**
       * @en Adds a component class to the node. You can also add component to node by passing in the name of the script.
       * @zh 向节点添加一个指定类型的组件类，你还可以通过传入脚本的名称来添加组件。
       * @example
       * ```typescript
       * var sprite = node.addComponent(cc.SpriteComponent);
       * ```
       */

    }, {
      key: "addComponent",
      value: function addComponent(typeOrClassName) {
        return this.node.addComponent(typeOrClassName);
      }
      /**
       * @en
       * Returns the component of supplied type if the node has one attached, null if it doesn't.<br/>
       * You can also get component in the node by passing in the name of the script.
       * @zh
       * 获取节点上指定类型的组件，如果节点有附加指定类型的组件，则返回，如果没有则为空。<br/>
       * 传入参数也可以是脚本的名称。
       * @example
       * ```typescript
       * // get sprite component.
       * var sprite = node.getComponent(cc.SpriteComponent);
       * ```
       */

    }, {
      key: "getComponent",
      value: function getComponent(typeOrClassName) {
        return this.node.getComponent(typeOrClassName);
      }
      /**
       * @en Returns all components of supplied type in the node.
       * @zh 返回节点上指定类型的所有组件。
       * @example
       * ```typescript
       * var sprites = node.getComponents(cc.SpriteComponent);
       * ```
       */

    }, {
      key: "getComponents",
      value: function getComponents(typeOrClassName) {
        return this.node.getComponents(typeOrClassName);
      }
      /**
       * @en Returns the component of supplied type in any of its children using depth first search.
       * @zh 递归查找所有子节点中第一个匹配指定类型的组件。
       * @example
       * ```typescript
       * var sprite = node.getComponentInChildren(cc.SpriteComponent);
       * ```
       */

    }, {
      key: "getComponentInChildren",
      value: function getComponentInChildren(typeOrClassName) {
        return this.node.getComponentInChildren(typeOrClassName);
      }
      /**
       * @en Returns all components of supplied type in self or any of its children.
       * @zh 递归查找自身或所有子节点中指定类型的组件。
       * @example
       * ```typescript
       * var sprites = node.getComponentsInChildren(cc.SpriteComponent);
       * ```
       */

    }, {
      key: "getComponentsInChildren",
      value: function getComponentsInChildren(typeOrClassName) {
        return this.node.getComponentsInChildren(typeOrClassName);
      } // OVERRIDE

    }, {
      key: "destroy",
      value: function destroy() {
        if (_defaultConstants.EDITOR) {
          // @ts-ignore
          var depend = this.node._getDependComponent(this);

          if (depend) {
            return cc.errorID(3626, (0, _js.getClassName)(this), (0, _js.getClassName)(depend));
          }
        }

        if (_get(_getPrototypeOf(Component.prototype), "destroy", this).call(this)) {
          if (this._enabled && this.node.activeInHierarchy) {
            cc.director._compScheduler.disableComp(this);
          }
        }
      }
    }, {
      key: "_onPreDestroy",
      value: function _onPreDestroy() {
        // Schedules
        this.unscheduleAllCallbacks(); //

        if (_defaultConstants.EDITOR && !_defaultConstants.TEST) {
          // @ts-ignore
          _Scene.AssetsWatcher.stop(this);
        } // onDestroy


        cc.director._nodeActivator.destroyComp(this); // do remove component


        this.node._removeComponent(this);
      }
    }, {
      key: "_instantiate",
      value: function _instantiate(cloned) {
        if (!cloned) {
          cloned = cc.instantiate._clone(this, this);
        }

        cloned.node = null;
        return cloned;
      } // Scheduler

      /**
       * @en
       * Schedules a custom selector.<br/>
       * If the selector is already scheduled, then the interval parameter will be updated without scheduling it again.
       * @zh
       * 调度一个自定义的回调函数。<br/>
       * 如果回调函数已调度，那么将不会重复调度它，只会更新时间间隔参数。
       * @method schedule
       * @param {function} callback 回调函数。
       * @param {Number} interval  时间间隔，0 表示每帧都重复。
       * @param {Number} repeat    将被重复执行（repeat+ 1）次，您可以使用 cc.macro.REPEAT_FOREVER 进行无限次循环。
       * @param {Number} delay     第一次执行前等待的时间（延时执行）。
       * @example
       * ```typescript
       * var timeCallback = function (dt) {
       *   cc.log("time: " + dt);
       * }
       * this.schedule(timeCallback, 1);
       * ```
       */

    }, {
      key: "schedule",
      value: function schedule(callback) {
        var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var repeat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : cc.macro.REPEAT_FOREVER;
        var delay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        cc.assertID(callback, 1619);
        cc.assertID(interval >= 0, 1620);
        interval = interval || 0;
        repeat = isNaN(repeat) ? cc.macro.REPEAT_FOREVER : repeat;
        delay = delay || 0;
        var scheduler = cc.director.getScheduler(); // should not use enabledInHierarchy to judge whether paused,
        // because enabledInHierarchy is assigned after onEnable.
        // Actually, if not yet scheduled, resumeTarget/pauseTarget has no effect on component,
        // therefore there is no way to guarantee the paused state other than isTargetPaused.

        var paused = scheduler.isTargetPaused(this);
        scheduler.schedule(callback, this, interval, repeat, delay, paused);
      }
      /**
       * @en Schedules a callback function that runs only once, with a delay of 0 or larger.
       * @zh 调度一个只运行一次的回调函数，可以指定 0 让回调函数在下一帧立即执行或者在一定的延时之后执行。
       * @method scheduleOnce
       * @see [[schedule]]
       * @param {function} callback  回调函数。
       * @param {Number} delay  第一次执行前等待的时间（延时执行）。
       * @example
       * ```typescript
       * var timeCallback = function (dt) {
       *   cc.log("time: " + dt);
       * }
       * this.scheduleOnce(timeCallback, 2);
       * ```
       */

    }, {
      key: "scheduleOnce",
      value: function scheduleOnce(callback) {
        var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.schedule(callback, 0, 0, delay);
      }
      /**
       * @en Unschedules a custom callback function.
       * @zh 取消调度一个自定义的回调函数。
       * @param {function} callback_fn  回调函数。
       * @example
       * ```typescript
       * this.unschedule(_callback);
       * ```
       */

    }, {
      key: "unschedule",
      value: function unschedule(callback_fn) {
        if (!callback_fn) {
          return;
        }

        cc.director.getScheduler().unschedule(callback_fn, this);
      }
      /**
       * @en
       * unschedule all scheduled callback functions: custom callback functions, and the 'update' callback function.<br/>
       * Actions are not affected by this method.
       * @zh 取消调度所有已调度的回调函数：定制的回调函数以及 'update' 回调函数。动作不受此方法影响。
       * @method unscheduleAllCallbacks
       * @example
       * ```typescript
       * this.unscheduleAllCallbacks();
       * ```
       */

    }, {
      key: "unscheduleAllCallbacks",
      value: function unscheduleAllCallbacks() {
        cc.director.getScheduler().unscheduleAllForTarget(this);
      } // LIFECYCLE METHODS
      // Fireball provides lifecycle methods that you can specify to hook into this process.
      // We provide Pre methods, which are called right before something happens, and Post methods which are called right after something happens.

      /**
       * @en Update is called every frame, if the Component is enabled.<br/>
       * This is a lifecycle method. It may not be implemented in the super class.<br/>
       * You can only call its super class method inside it. It should not be called manually elsewhere.
       * @zh 如果该组件启用，则每帧调用 update。<br/>
       * 该方法为生命周期方法，父类未必会有实现。并且你只能在该方法内部调用父类的实现，不可在其它地方直接调用该方法。
       * @param dt - the delta time in seconds it took to complete the last frame
       */

    }, {
      key: "name",
      get: function get() {
        if (this._name) {
          return this._name;
        }

        var className = (0, _js.getClassName)(this);
        var trimLeft = className.lastIndexOf('.');

        if (trimLeft >= 0) {
          className = className.slice(trimLeft + 1);
        }

        return this.node.name + '<' + className + '>';
      },
      set: function set(value) {
        this._name = value;
      }
      /**
       * @en The uuid for editor.
       * @zh 组件的 uuid，用于编辑器。
       * @property uuid
       * @type {String}
       * @readOnly
       * @example
       * ```typescript
       * cc.log(comp.uuid);
       * ```
       */

    }, {
      key: "uuid",
      get: function get() {
        return this._id;
      }
    }, {
      key: "__scriptAsset",
      get: function get() {
        return null;
      }
      /**
       * @en indicates whether this component is enabled or not.
       * @zh 表示该组件自身是否启用。
       * @property enabled
       * @type {Boolean}
       * @default true
       * @example
       * ```typescript
       * comp.enabled = true;
       * cc.log(comp.enabled);
       * ```
       */

    }, {
      key: "enabled",
      get: function get() {
        return this._enabled;
      },
      set: function set(value) {
        if (this._enabled !== value) {
          this._enabled = value;

          if (this.node.activeInHierarchy) {
            var compScheduler = cc.director._compScheduler;

            if (value) {
              compScheduler.enableComp(this);
            } else {
              compScheduler.disableComp(this);
            }
          }
        }
      }
      /**
       * @en indicates whether this component is enabled and its node is also active in the hierarchy.
       * @zh 表示该组件是否被启用并且所在的节点也处于激活状态。
       * @property enabledInHierarchy
       * @type {Boolean}
       * @readOnly
       * @example
       * ```typescript
       * cc.log(comp.enabledInHierarchy);
       * ```
       */

    }, {
      key: "enabledInHierarchy",
      get: function get() {
        return this._enabled && this.node && this.node.activeInHierarchy;
      }
      /**
       * @en Returns a value which used to indicate the onLoad get called or not.
       * @zh 返回一个值用来判断 onLoad 是否被调用过，不等于 0 时调用过，等于 0 时未调用。
       * @property _isOnLoadCalled
       * @type {Number}
       * @readOnly
       * @example
       * ```typescript
       * cc.log(this._isOnLoadCalled > 0);
       * ```
       */

    }, {
      key: "_isOnLoadCalled",
      get: function get() {
        return this._objFlags & IsOnLoadCalled;
      }
    }]);

    return Component;
  }(_object.CCObject), _class3.system = null, _temp), (_applyDecoratedDescriptor(_class2.prototype, "name", [_dec2], Object.getOwnPropertyDescriptor(_class2.prototype, "name"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "uuid", [_dec3], Object.getOwnPropertyDescriptor(_class2.prototype, "uuid"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "__scriptAsset", [_dec4], Object.getOwnPropertyDescriptor(_class2.prototype, "__scriptAsset"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "enabled", [_dec5], Object.getOwnPropertyDescriptor(_class2.prototype, "enabled"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "enabledInHierarchy", [_dec6], Object.getOwnPropertyDescriptor(_class2.prototype, "enabledInHierarchy"), _class2.prototype), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "node", [_dec7], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return NullNode;
    }
  }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_enabled", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return true;
    }
  })), _class2)) || _class);
  _exports.Component = Component;
  var proto = Component.prototype; // @ts-ignore

  proto.update = null; // @ts-ignore

  proto.lateUpdate = null; // @ts-ignore

  proto.__preload = null; // @ts-ignore

  proto.onLoad = null; // @ts-ignore

  proto.start = null; // @ts-ignore

  proto.onEnable = null; // @ts-ignore

  proto.onDisable = null; // @ts-ignore

  proto.onDestroy = null; // @ts-ignore

  proto.onFocusInEditor = null; // @ts-ignore

  proto.onLostFocusInEditor = null; // @ts-ignore

  proto.resetInEditor = null; // @ts-ignore

  proto._getLocalBounds = null; // @ts-ignore

  proto.onRestore = null; // @ts-ignore

  Component._requireComponent = null; // @ts-ignore

  Component._executionOrder = 0;

  if (_defaultConstants.EDITOR || _defaultConstants.TEST) {
    // INHERITABLE STATIC MEMBERS
    // @ts-ignore
    Component._executeInEditMode = false; // @ts-ignore

    Component._playOnFocus = false; // @ts-ignore

    Component._disallowMultiple = null; // @ts-ignore

    Component._help = ''; // NON-INHERITED STATIC MEMBERS
    // (TypeScript 2.3 will still inherit them, so always check hasOwnProperty before using)

    (0, _js.value)(Component, '_inspector', '', true);
    (0, _js.value)(Component, '_icon', '', true); // COMPONENT HELPERS
    // TODO Keep temporarily, compatible with old version

    cc._componentMenuItems = [];
  } // we make this non-enumerable, to prevent inherited by sub classes.


  (0, _js.value)(Component, '_registerEditorProps', function (cls, props) {
    var reqComp = props.requireComponent;

    if (reqComp) {
      cls._requireComponent = reqComp;
    }

    var order = props.executionOrder;

    if (order && typeof order === 'number') {
      cls._executionOrder = order;
    }

    if (_defaultConstants.EDITOR || _defaultConstants.TEST) {
      var name = (0, _js.getClassName)(cls);

      for (var key in props) {
        var val = props[key];

        switch (key) {
          case 'executeInEditMode':
            cls._executeInEditMode = !!val;
            break;

          case 'playOnFocus':
            if (val) {
              var willExecuteInEditMode = 'executeInEditMode' in props ? props.executeInEditMode : cls._executeInEditMode;

              if (willExecuteInEditMode) {
                cls._playOnFocus = true;
              } else {
                cc.warnID(3601, name);
              }
            }

            break;

          case 'inspector':
            (0, _js.value)(cls, '_inspector', val, true);
            break;

          case 'icon':
            (0, _js.value)(cls, '_icon', val, true);
            break;

          case 'menu':
            var frame = RF.peek();
            var menu = val;

            if (frame) {
              menu = 'i18n:menu.custom_script/' + menu;
            }

            _defaultConstants.EDITOR && EditorExtends.Component.addMenu(cls, menu, props.menuPriority);
            break;

          case 'disallowMultiple':
            cls._disallowMultiple = cls;
            break;

          case 'requireComponent':
          case 'executionOrder':
            // skip here
            break;

          case 'help':
            cls._help = val;
            break;

          default:
            cc.warnID(3602, key, name);
            break;
        }
      }
    }
  });
  cc.Component = Component;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkY6L2plbmtpbnMvd29ya3NwYWNlL0NyZWF0b3JfM0QvZWRpdG9yLTNkL3Jlc291cmNlcy8zZC9lbmdpbmUvY29jb3MvY29yZS9jb21wb25lbnRzL2NvbXBvbmVudC50cyJdLCJuYW1lcyI6WyJpZEdlbmVyYXRvciIsIklER2VuZXJhdG9yIiwiSXNPbkVuYWJsZUNhbGxlZCIsIkNDT2JqZWN0IiwiRmxhZ3MiLCJJc09uTG9hZENhbGxlZCIsIk51bGxOb2RlIiwiQ29tcG9uZW50IiwidmlzaWJsZSIsImRpc3BsYXlOYW1lIiwidHlwZSIsIlNjcmlwdCIsInRvb2x0aXAiLCJERVYiLCJ1bmRlZmluZWQiLCJfc2NlbmVHZXR0ZXIiLCJfaWQiLCJnZXROZXdJZCIsIm5vZGUiLCJzY2VuZSIsIl9yZW5kZXJTY2VuZSIsInR5cGVPckNsYXNzTmFtZSIsImFkZENvbXBvbmVudCIsImdldENvbXBvbmVudCIsImdldENvbXBvbmVudHMiLCJnZXRDb21wb25lbnRJbkNoaWxkcmVuIiwiZ2V0Q29tcG9uZW50c0luQ2hpbGRyZW4iLCJFRElUT1IiLCJkZXBlbmQiLCJfZ2V0RGVwZW5kQ29tcG9uZW50IiwiY2MiLCJlcnJvcklEIiwiX2VuYWJsZWQiLCJhY3RpdmVJbkhpZXJhcmNoeSIsImRpcmVjdG9yIiwiX2NvbXBTY2hlZHVsZXIiLCJkaXNhYmxlQ29tcCIsInVuc2NoZWR1bGVBbGxDYWxsYmFja3MiLCJURVNUIiwiX1NjZW5lIiwiQXNzZXRzV2F0Y2hlciIsInN0b3AiLCJfbm9kZUFjdGl2YXRvciIsImRlc3Ryb3lDb21wIiwiX3JlbW92ZUNvbXBvbmVudCIsImNsb25lZCIsImluc3RhbnRpYXRlIiwiX2Nsb25lIiwiY2FsbGJhY2siLCJpbnRlcnZhbCIsInJlcGVhdCIsIm1hY3JvIiwiUkVQRUFUX0ZPUkVWRVIiLCJkZWxheSIsImFzc2VydElEIiwiaXNOYU4iLCJzY2hlZHVsZXIiLCJnZXRTY2hlZHVsZXIiLCJwYXVzZWQiLCJpc1RhcmdldFBhdXNlZCIsInNjaGVkdWxlIiwiY2FsbGJhY2tfZm4iLCJ1bnNjaGVkdWxlIiwidW5zY2hlZHVsZUFsbEZvclRhcmdldCIsIl9uYW1lIiwiY2xhc3NOYW1lIiwidHJpbUxlZnQiLCJsYXN0SW5kZXhPZiIsInNsaWNlIiwibmFtZSIsInZhbHVlIiwiY29tcFNjaGVkdWxlciIsImVuYWJsZUNvbXAiLCJfb2JqRmxhZ3MiLCJzeXN0ZW0iLCJwcm9wZXJ0eSIsInByb3RvIiwicHJvdG90eXBlIiwidXBkYXRlIiwibGF0ZVVwZGF0ZSIsIl9fcHJlbG9hZCIsIm9uTG9hZCIsInN0YXJ0Iiwib25FbmFibGUiLCJvbkRpc2FibGUiLCJvbkRlc3Ryb3kiLCJvbkZvY3VzSW5FZGl0b3IiLCJvbkxvc3RGb2N1c0luRWRpdG9yIiwicmVzZXRJbkVkaXRvciIsIl9nZXRMb2NhbEJvdW5kcyIsIm9uUmVzdG9yZSIsIl9yZXF1aXJlQ29tcG9uZW50IiwiX2V4ZWN1dGlvbk9yZGVyIiwiX2V4ZWN1dGVJbkVkaXRNb2RlIiwiX3BsYXlPbkZvY3VzIiwiX2Rpc2FsbG93TXVsdGlwbGUiLCJfaGVscCIsIl9jb21wb25lbnRNZW51SXRlbXMiLCJjbHMiLCJwcm9wcyIsInJlcUNvbXAiLCJyZXF1aXJlQ29tcG9uZW50Iiwib3JkZXIiLCJleGVjdXRpb25PcmRlciIsImtleSIsInZhbCIsIndpbGxFeGVjdXRlSW5FZGl0TW9kZSIsImV4ZWN1dGVJbkVkaXRNb2RlIiwid2FybklEIiwiZnJhbWUiLCJSRiIsInBlZWsiLCJtZW51IiwiRWRpdG9yRXh0ZW5kcyIsImFkZE1lbnUiLCJtZW51UHJpb3JpdHkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQ0EsTUFBTUEsV0FBVyxHQUFHLElBQUlDLG9CQUFKLENBQWdCLE1BQWhCLENBQXBCLEMsQ0FDQTs7QUFDQSxNQUFNQyxnQkFBZ0IsR0FBR0MsaUJBQVNDLEtBQVQsQ0FBZUYsZ0JBQXhDLEMsQ0FDQTs7QUFDQSxNQUFN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QUF5Qk8sR0FBekIsRUFBOEIsSUFBOUI7QUFDQTs7QUFFSixlQUFLLE1BQUw7QUFDSSwyQkFBTVAsR0FBTixFQUFXLE9BQVgsRUFBb0JPLEdBQXBCLEVBQXlCLElBQXpCO0FBQ0E7O0FBRUosZUFBSyxNQUFMO0FBQ0ksZ0JBQU1JLEtBQUssR0FBR0MsRUFBRSxDQUFDQyxJQUFILEVBQWQ7QUFDQSxnQkFBSUMsSUFBSSxHQUFHUCxHQUFYOztBQUNBLGdCQUFJSSxLQUFKLEVBQVc7QUFDUEcsY0FBQUEsSUFBSSxHQUFHLDZCQUE2QkEsSUFBcEM7QUFDSDs7QUFFRHJGLHdDQUFVc0YsYUFBYSxDQUFDMUcsU0FBZCxDQUF3QjJHLE9BQXhCLENBQWdDaEIsR0FBaEMsRUFBcUNjLElBQXJDLEVBQTJDYixLQUFLLENBQUNnQixZQUFqRCxDQUFWO0FBQ0E7O0FBRUosZUFBSyxrQkFBTDtBQUNJakIsWUFBQUEsR0FBRyxDQUFDSCxpQkFBSixHQUF3QkcsR0FBeEI7QUFDQTs7QUFFSixlQUFLLGtCQUFMO0FBQ0EsZUFBSyxnQkFBTDtBQUNJO0FBQ0E7O0FBRUosZUFBSyxNQUFMO0FBQ0lBLFlBQUFBLEdBQUcsQ0FBQ0YsS0FBSixHQUFZUyxHQUFaO0FBQ0E7O0FBRUo7QUFDSTNFLFlBQUFBLEVBQUUsQ0FBQzhFLE1BQUgsQ0FBVSxJQUFWLEVBQWdCSixHQUFoQixFQUFxQm5DLElBQXJCO0FBQ0E7QUFsRFI7QUFvREg7QUFDSjtBQUNKLEdBbkVEO0FBcUVBdkMsRUFBQUEsRUFBRSxDQUFDdkIsU0FBSCxHQUFlQSxTQUFmIiwic291cmNlc0NvbnRlbnQiOlsiLypcclxuIENvcHlyaWdodCAoYykgMjAxMy0yMDE2IENodWtvbmcgVGVjaG5vbG9naWVzIEluYy5cclxuIENvcHlyaWdodCAoYykgMjAxNy0yMDE4IFhpYW1lbiBZYWppIFNvZnR3YXJlIENvLiwgTHRkLlxyXG5cclxuIGh0dHA6Ly93d3cuY29jb3MuY29tXHJcblxyXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBlbmdpbmUgc291cmNlIGNvZGUgKHRoZSBcIlNvZnR3YXJlXCIpLCBhIGxpbWl0ZWQsXHJcbiAgd29ybGR3aWRlLCByb3lhbHR5LWZyZWUsIG5vbi1hc3NpZ25hYmxlLCByZXZvY2FibGUgYW5kIG5vbi1leGNsdXNpdmUgbGljZW5zZVxyXG4gdG8gdXNlIENvY29zIENyZWF0b3Igc29sZWx5IHRvIGRldmVsb3AgZ2FtZXMgb24geW91ciB0YXJnZXQgcGxhdGZvcm1zLiBZb3Ugc2hhbGxcclxuICBub3QgdXNlIENvY29zIENyZWF0b3Igc29mdHdhcmUgZm9yIGRldmVsb3Bpbmcgb3RoZXIgc29mdHdhcmUgb3IgdG9vbHMgdGhhdCdzXHJcbiAgdXNlZCBmb3IgZGV2ZWxvcGluZyBnYW1lcy4gWW91IGFyZSBub3QgZ3JhbnRlZCB0byBwdWJsaXNoLCBkaXN0cmlidXRlLFxyXG4gIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiBDb2NvcyBDcmVhdG9yLlxyXG5cclxuIFRoZSBzb2Z0d2FyZSBvciB0b29scyBpbiB0aGlzIExpY2Vuc2UgQWdyZWVtZW50IGFyZSBsaWNlbnNlZCwgbm90IHNvbGQuXHJcbiBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC4gcmVzZXJ2ZXMgYWxsIHJpZ2h0cyBub3QgZXhwcmVzc2x5IGdyYW50ZWQgdG8geW91LlxyXG5cclxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gVEhFIFNPRlRXQVJFLlxyXG4qL1xyXG5cclxuLy8gdHNsaW50OmRpc2FibGVcclxuXHJcbi8qKlxyXG4gKiBAY2F0ZWdvcnkgY29tcG9uZW50XHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgU2NyaXB0IH0gZnJvbSAnLi4vYXNzZXRzL3NjcmlwdHMnO1xyXG5pbXBvcnQgeyBjY2NsYXNzLCBwcm9wZXJ0eSB9IGZyb20gJy4uL2RhdGEvY2xhc3MtZGVjb3JhdG9yJztcclxuaW1wb3J0IHsgQ0NPYmplY3QgfSBmcm9tICcuLi9kYXRhL29iamVjdCc7XHJcbmltcG9ydCBJREdlbmVyYXRvciBmcm9tICcuLi91dGlscy9pZC1nZW5lcmF0b3InO1xyXG5pbXBvcnQgeyBnZXRDbGFzc05hbWUsIHZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvanMnO1xyXG5pbXBvcnQgeyBSZW5kZXJTY2VuZSB9IGZyb20gJy4uL3JlbmRlcmVyL3NjZW5lL3JlbmRlci1zY2VuZSc7XHJcbmltcG9ydCB7IFJlY3QgfSBmcm9tICcuLi9tYXRoJztcclxuaW1wb3J0ICogYXMgUkYgZnJvbSAnLi4vZGF0YS91dGlscy9yZXF1aXJpbmctZnJhbWUnO1xyXG5pbXBvcnQgeyBOb2RlIH0gZnJvbSAnLi4vc2NlbmUtZ3JhcGgnO1xyXG5pbXBvcnQgeyBFRElUT1IsIFRFU1QsIERFViB9IGZyb20gJ2ludGVybmFsOmNvbnN0YW50cyc7XHJcblxyXG5jb25zdCBpZEdlbmVyYXRvciA9IG5ldyBJREdlbmVyYXRvcignQ29tcCcpO1xyXG4vLyBAdHMtaWdub3JlXHJcbmNvbnN0IElzT25FbmFibGVDYWxsZWQgPSBDQ09iamVjdC5GbGFncy5Jc09uRW5hYmxlQ2FsbGVkO1xyXG4vLyBAdHMtaWdub3JlXHJcbmNvbnN0IElzT25Mb2FkQ2FsbGVkID0gQ0NPYmplY3QuRmxhZ3MuSXNPbkxvYWRDYWxsZWQ7XHJcblxyXG5jb25zdCBOdWxsTm9kZSA9IG51bGwgYXMgdW5rbm93biBhcyBOb2RlO1xyXG5cclxuLyoqXHJcbiAqIEBlblxyXG4gKiBCYXNlIGNsYXNzIGZvciBldmVyeXRoaW5nIGF0dGFjaGVkIHRvIE5vZGUoRW50aXR5KS48YnIvPlxyXG4gKiA8YnIvPlxyXG4gKiBOT1RFOiBOb3QgYWxsb3dlZCB0byB1c2UgY29uc3RydWN0aW9uIHBhcmFtZXRlcnMgZm9yIENvbXBvbmVudCdzIHN1YmNsYXNzZXMsXHJcbiAqICAgICAgIGJlY2F1c2UgQ29tcG9uZW50IGlzIGNyZWF0ZWQgYnkgdGhlIGVuZ2luZS5cclxuICogQHpoXHJcbiAqIOaJgOaciemZhOWKoOWIsOiKgueCueeahOWfuuexu+OAgjxici8+XHJcbiAqIDxici8+XHJcbiAqIOazqOaEj++8muS4jeWFgeiuuOS9v+eUqOe7hOS7tueahOWtkOexu+aehOmAoOWPguaVsO+8jOWboOS4uue7hOS7tuaYr+eUseW8leaTjuWIm+W7uueahOOAglxyXG4gKlxyXG4gKiBAY2xhc3MgQ29tcG9uZW50XHJcbiAqIEBleHRlbmRzIE9iamVjdFxyXG4gKi9cclxuQGNjY2xhc3MoJ2NjLkNvbXBvbmVudCcpXHJcbmNsYXNzIENvbXBvbmVudCBleHRlbmRzIENDT2JqZWN0IHtcclxuXHJcbiAgICBAcHJvcGVydHkoe1xyXG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxyXG4gICAgfSlcclxuICAgIGdldCBuYW1lICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fbmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNsYXNzTmFtZSA9IGdldENsYXNzTmFtZSh0aGlzKTtcclxuICAgICAgICBjb25zdCB0cmltTGVmdCA9IGNsYXNzTmFtZS5sYXN0SW5kZXhPZignLicpO1xyXG4gICAgICAgIGlmICh0cmltTGVmdCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5zbGljZSh0cmltTGVmdCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLm5hbWUgKyAnPCcgKyBjbGFzc05hbWUgKyAnPic7XHJcbiAgICB9XHJcbiAgICBzZXQgbmFtZSAodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9uYW1lID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gVGhlIHV1aWQgZm9yIGVkaXRvci5cclxuICAgICAqIEB6aCDnu4Tku7bnmoQgdXVpZO+8jOeUqOS6jue8lui+keWZqOOAglxyXG4gICAgICogQHByb3BlcnR5IHV1aWRcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjYy5sb2coY29tcC51dWlkKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBAcHJvcGVydHkoe1xyXG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxyXG4gICAgfSlcclxuICAgIGdldCB1dWlkICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XHJcbiAgICB9XHJcblxyXG4gICAgQHByb3BlcnR5KHtcclxuICAgICAgICBkaXNwbGF5TmFtZTogJ1NjcmlwdCcsXHJcbiAgICAgICAgdHlwZTogU2NyaXB0LFxyXG4gICAgICAgIHRvb2x0aXA6IERFViA/ICdpMThuOklOU1BFQ1RPUi5jb21wb25lbnQuc2NyaXB0JyA6IHVuZGVmaW5lZCxcclxuICAgIH0pXHJcbiAgICBnZXQgX19zY3JpcHRBc3NldCAoKSB7IHJldHVybiBudWxsOyB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBjb21wb25lbnQgaXMgZW5hYmxlZCBvciBub3QuXHJcbiAgICAgKiBAemgg6KGo56S66K+l57uE5Lu26Ieq6Lqr5piv5ZCm5ZCv55So44CCXHJcbiAgICAgKiBAcHJvcGVydHkgZW5hYmxlZFxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29tcC5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAqIGNjLmxvZyhjb21wLmVuYWJsZWQpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIEBwcm9wZXJ0eSh7XHJcbiAgICAgICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICB9KVxyXG4gICAgZ2V0IGVuYWJsZWQgKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xyXG4gICAgfVxyXG4gICAgc2V0IGVuYWJsZWQgKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2VuYWJsZWQgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZWQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubm9kZS5hY3RpdmVJbkhpZXJhcmNoeSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcFNjaGVkdWxlciA9IGNjLmRpcmVjdG9yLl9jb21wU2NoZWR1bGVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcFNjaGVkdWxlci5lbmFibGVDb21wKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcFNjaGVkdWxlci5kaXNhYmxlQ29tcCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGNvbXBvbmVudCBpcyBlbmFibGVkIGFuZCBpdHMgbm9kZSBpcyBhbHNvIGFjdGl2ZSBpbiB0aGUgaGllcmFyY2h5LlxyXG4gICAgICogQHpoIOihqOekuuivpee7hOS7tuaYr+WQpuiiq+WQr+eUqOW5tuS4lOaJgOWcqOeahOiKgueCueS5n+WkhOS6jua/gOa0u+eKtuaAgeOAglxyXG4gICAgICogQHByb3BlcnR5IGVuYWJsZWRJbkhpZXJhcmNoeVxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiBjYy5sb2coY29tcC5lbmFibGVkSW5IaWVyYXJjaHkpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIEBwcm9wZXJ0eSh7XHJcbiAgICAgICAgdmlzaWJsZTogZmFsc2UsXHJcbiAgICB9KVxyXG4gICAgZ2V0IGVuYWJsZWRJbkhpZXJhcmNoeSAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQgJiYgdGhpcy5ub2RlICYmIHRoaXMubm9kZS5hY3RpdmVJbkhpZXJhcmNoeTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBSZXR1cm5zIGEgdmFsdWUgd2hpY2ggdXNlZCB0byBpbmRpY2F0ZSB0aGUgb25Mb2FkIGdldCBjYWxsZWQgb3Igbm90LlxyXG4gICAgICogQHpoIOi/lOWbnuS4gOS4quWAvOeUqOadpeWIpOaWrSBvbkxvYWQg5piv5ZCm6KKr6LCD55So6L+H77yM5LiN562J5LqOIDAg5pe26LCD55So6L+H77yM562J5LqOIDAg5pe25pyq6LCD55So44CCXHJcbiAgICAgKiBAcHJvcGVydHkgX2lzT25Mb2FkQ2FsbGVkXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQHJlYWRPbmx5XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2MubG9nKHRoaXMuX2lzT25Mb2FkQ2FsbGVkID4gMCk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgZ2V0IF9pc09uTG9hZENhbGxlZCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29iakZsYWdzICYgSXNPbkxvYWRDYWxsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBzeXN0ZW0gPSBudWxsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gVGhlIG5vZGUgdGhpcyBjb21wb25lbnQgaXMgYXR0YWNoZWQgdG8uIEEgY29tcG9uZW50IGlzIGFsd2F5cyBhdHRhY2hlZCB0byBhIG5vZGUuXHJcbiAgICAgKiBAemgg6K+l57uE5Lu26KKr6ZmE5Yqg5Yiw55qE6IqC54K544CC57uE5Lu25oC75Lya6ZmE5Yqg5Yiw5LiA5Liq6IqC54K544CCXHJcbiAgICAgKiBAcHJvcGVydHkgbm9kZVxyXG4gICAgICogQHR5cGUge05vZGV9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY2MubG9nKGNvbXAubm9kZSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgQHByb3BlcnR5KHtcclxuICAgICAgICB2aXNpYmxlOiBmYWxzZSxcclxuICAgIH0pXHJcbiAgICBwdWJsaWMgbm9kZTogTm9kZSA9IE51bGxOb2RlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByb3BlcnR5IF9lbmFibGVkXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIEBwcm9wZXJ0eVxyXG4gICAgcHVibGljIF9lbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICBwdWJsaWMgX3NjZW5lR2V0dGVyOiBudWxsIHwgKCgpID0+IFJlbmRlclNjZW5lKSA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgaW50ZXJuYWwgdXNhZ2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBfaWQ6IHN0cmluZyA9IGlkR2VuZXJhdG9yLmdldE5ld0lkKCk7XHJcblxyXG4gICAgLy8gcHJpdmF0ZSBfX3NjcmlwdFV1aWQgPSAnJztcclxuXHJcbiAgICBwdWJsaWMgX2dldFJlbmRlclNjZW5lICgpOiBSZW5kZXJTY2VuZSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NjZW5lR2V0dGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zY2VuZUdldHRlcigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuc2NlbmUhLl9yZW5kZXJTY2VuZSE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFBVQkxJQ1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIEFkZHMgYSBjb21wb25lbnQgY2xhc3MgdG8gdGhlIG5vZGUuIFlvdSBjYW4gYWxzbyBhZGQgY29tcG9uZW50IHRvIG5vZGUgYnkgcGFzc2luZyBpbiB0aGUgbmFtZSBvZiB0aGUgc2NyaXB0LlxyXG4gICAgICogQHpoIOWQkeiKgueCuea3u+WKoOS4gOS4quaMh+Wumuexu+Wei+eahOe7hOS7tuexu++8jOS9oOi/mOWPr+S7pemAmui/h+S8oOWFpeiEmuacrOeahOWQjeensOadpea3u+WKoOe7hOS7tuOAglxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIHZhciBzcHJpdGUgPSBub2RlLmFkZENvbXBvbmVudChjYy5TcHJpdGVDb21wb25lbnQpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRDb21wb25lbnQ8VCBleHRlbmRzIENvbXBvbmVudD4gKGNsYXNzQ29uc3RydWN0b3I6IENvbnN0cnVjdG9yPFQ+KTogVCB8IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gQWRkcyBhIGNvbXBvbmVudCBjbGFzcyB0byB0aGUgbm9kZS4gWW91IGNhbiBhbHNvIGFkZCBjb21wb25lbnQgdG8gbm9kZSBieSBwYXNzaW5nIGluIHRoZSBuYW1lIG9mIHRoZSBzY3JpcHQuXHJcbiAgICAgKiBAemgg5ZCR6IqC54K55re75Yqg5LiA5Liq5oyH5a6a57G75Z6L55qE57uE5Lu257G777yM5L2g6L+Y5Y+v5Lul6YCa6L+H5Lyg5YWl6ISa5pys55qE5ZCN56ew5p2l5re75Yqg57uE5Lu244CCXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogdmFyIHRlc3QgPSBub2RlLmFkZENvbXBvbmVudChcIlRlc3RcIik7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGFkZENvbXBvbmVudCAoY2xhc3NOYW1lOiBzdHJpbmcpOiBDb21wb25lbnQgfCBudWxsO1xyXG5cclxuICAgIHB1YmxpYyBhZGRDb21wb25lbnQgKHR5cGVPckNsYXNzTmFtZTogYW55KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5hZGRDb21wb25lbnQodHlwZU9yQ2xhc3NOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogUmV0dXJucyB0aGUgY29tcG9uZW50IG9mIHN1cHBsaWVkIHR5cGUgaWYgdGhlIG5vZGUgaGFzIG9uZSBhdHRhY2hlZCwgbnVsbCBpZiBpdCBkb2Vzbid0Ljxici8+XHJcbiAgICAgKiBZb3UgY2FuIGFsc28gZ2V0IGNvbXBvbmVudCBpbiB0aGUgbm9kZSBieSBwYXNzaW5nIGluIHRoZSBuYW1lIG9mIHRoZSBzY3JpcHQuXHJcbiAgICAgKiBAemhcclxuICAgICAqIOiOt+WPluiKgueCueS4iuaMh+Wumuexu+Wei+eahOe7hOS7tu+8jOWmguaenOiKgueCueaciemZhOWKoOaMh+Wumuexu+Wei+eahOe7hOS7tu+8jOWImei/lOWbnu+8jOWmguaenOayoeacieWImeS4uuepuuOAgjxici8+XHJcbiAgICAgKiDkvKDlhaXlj4LmlbDkuZ/lj6/ku6XmmK/ohJrmnKznmoTlkI3np7DjgIJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiAvLyBnZXQgc3ByaXRlIGNvbXBvbmVudC5cclxuICAgICAqIHZhciBzcHJpdGUgPSBub2RlLmdldENvbXBvbmVudChjYy5TcHJpdGVDb21wb25lbnQpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDb21wb25lbnQ8VCBleHRlbmRzIENvbXBvbmVudD4gKGNsYXNzQ29uc3RydWN0b3I6IENvbnN0cnVjdG9yPFQ+KTogVCB8IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIFJldHVybnMgdGhlIGNvbXBvbmVudCBvZiBzdXBwbGllZCB0eXBlIGlmIHRoZSBub2RlIGhhcyBvbmUgYXR0YWNoZWQsIG51bGwgaWYgaXQgZG9lc24ndC48YnIvPlxyXG4gICAgICogWW91IGNhbiBhbHNvIGdldCBjb21wb25lbnQgaW4gdGhlIG5vZGUgYnkgcGFzc2luZyBpbiB0aGUgbmFtZSBvZiB0aGUgc2NyaXB0LlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDojrflj5boioLngrnkuIrmjIflrprnsbvlnovnmoTnu4Tku7bvvIzlpoLmnpzoioLngrnmnInpmYTliqDmjIflrprnsbvlnovnmoTnu4Tku7bvvIzliJnov5Tlm57vvIzlpoLmnpzmsqHmnInliJnkuLrnqbrjgII8YnIvPlxyXG4gICAgICog5Lyg5YWl5Y+C5pWw5Lmf5Y+v5Lul5piv6ISa5pys55qE5ZCN56ew44CCXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogLy8gZ2V0IGN1c3RvbSB0ZXN0IGNhbHNzLlxyXG4gICAgICogdmFyIHRlc3QgPSBub2RlLmdldENvbXBvbmVudChcIlRlc3RcIik7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvbXBvbmVudCAoY2xhc3NOYW1lOiBzdHJpbmcpOiBDb21wb25lbnQgfCBudWxsO1xyXG5cclxuICAgIHB1YmxpYyBnZXRDb21wb25lbnQgKHR5cGVPckNsYXNzTmFtZTogYW55KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRDb21wb25lbnQodHlwZU9yQ2xhc3NOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBSZXR1cm5zIGFsbCBjb21wb25lbnRzIG9mIHN1cHBsaWVkIHR5cGUgaW4gdGhlIG5vZGUuXHJcbiAgICAgKiBAemgg6L+U5Zue6IqC54K55LiK5oyH5a6a57G75Z6L55qE5omA5pyJ57uE5Lu244CCXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogdmFyIHNwcml0ZXMgPSBub2RlLmdldENvbXBvbmVudHMoY2MuU3ByaXRlQ29tcG9uZW50KTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q29tcG9uZW50czxUIGV4dGVuZHMgQ29tcG9uZW50PiAoY2xhc3NDb25zdHJ1Y3RvcjogQ29uc3RydWN0b3I8VD4pOiBUW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gUmV0dXJucyBhbGwgY29tcG9uZW50cyBvZiBzdXBwbGllZCB0eXBlIGluIHRoZSBub2RlLlxyXG4gICAgICogQHpoIOi/lOWbnuiKgueCueS4iuaMh+Wumuexu+Wei+eahOaJgOaciee7hOS7tuOAglxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIHZhciB0ZXN0cyA9IG5vZGUuZ2V0Q29tcG9uZW50cyhcIlRlc3RcIik7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvbXBvbmVudHMgKGNsYXNzTmFtZTogc3RyaW5nKTogQ29tcG9uZW50W107XHJcblxyXG4gICAgcHVibGljIGdldENvbXBvbmVudHM8VCBleHRlbmRzIENvbXBvbmVudD4gKHR5cGVPckNsYXNzTmFtZTogYW55KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRDb21wb25lbnRzKHR5cGVPckNsYXNzTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gUmV0dXJucyB0aGUgY29tcG9uZW50IG9mIHN1cHBsaWVkIHR5cGUgaW4gYW55IG9mIGl0cyBjaGlsZHJlbiB1c2luZyBkZXB0aCBmaXJzdCBzZWFyY2guXHJcbiAgICAgKiBAemgg6YCS5b2S5p+l5om+5omA5pyJ5a2Q6IqC54K55Lit56ys5LiA5Liq5Yy56YWN5oyH5a6a57G75Z6L55qE57uE5Lu244CCXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogdmFyIHNwcml0ZSA9IG5vZGUuZ2V0Q29tcG9uZW50SW5DaGlsZHJlbihjYy5TcHJpdGVDb21wb25lbnQpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDb21wb25lbnRJbkNoaWxkcmVuPFQgZXh0ZW5kcyBDb21wb25lbnQ+IChjbGFzc0NvbnN0cnVjdG9yOiBDb25zdHJ1Y3RvcjxUPik6IFQgfCBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFJldHVybnMgdGhlIGNvbXBvbmVudCBvZiBzdXBwbGllZCB0eXBlIGluIGFueSBvZiBpdHMgY2hpbGRyZW4gdXNpbmcgZGVwdGggZmlyc3Qgc2VhcmNoLlxyXG4gICAgICogQHpoIOmAkuW9kuafpeaJvuaJgOacieWtkOiKgueCueS4reesrOS4gOS4quWMuemFjeaMh+Wumuexu+Wei+eahOe7hOS7tuOAglxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIHZhciBUZXN0ID0gbm9kZS5nZXRDb21wb25lbnRJbkNoaWxkcmVuKFwiVGVzdFwiKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q29tcG9uZW50SW5DaGlsZHJlbiAoY2xhc3NOYW1lOiBzdHJpbmcpOiBDb21wb25lbnQgfCBudWxsO1xyXG5cclxuICAgIHB1YmxpYyBnZXRDb21wb25lbnRJbkNoaWxkcmVuICh0eXBlT3JDbGFzc05hbWU6IGFueSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0Q29tcG9uZW50SW5DaGlsZHJlbih0eXBlT3JDbGFzc05hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFJldHVybnMgYWxsIGNvbXBvbmVudHMgb2Ygc3VwcGxpZWQgdHlwZSBpbiBzZWxmIG9yIGFueSBvZiBpdHMgY2hpbGRyZW4uXHJcbiAgICAgKiBAemgg6YCS5b2S5p+l5om+6Ieq6Lqr5oiW5omA5pyJ5a2Q6IqC54K55Lit5oyH5a6a57G75Z6L55qE57uE5Lu244CCXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogdmFyIHNwcml0ZXMgPSBub2RlLmdldENvbXBvbmVudHNJbkNoaWxkcmVuKGNjLlNwcml0ZUNvbXBvbmVudCk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvbXBvbmVudHNJbkNoaWxkcmVuPFQgZXh0ZW5kcyBDb21wb25lbnQ+IChjbGFzc0NvbnN0cnVjdG9yOiBDb25zdHJ1Y3RvcjxUPik6IFRbXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBSZXR1cm5zIGFsbCBjb21wb25lbnRzIG9mIHN1cHBsaWVkIHR5cGUgaW4gc2VsZiBvciBhbnkgb2YgaXRzIGNoaWxkcmVuLlxyXG4gICAgICogQHpoIOmAkuW9kuafpeaJvuiHqui6q+aIluaJgOacieWtkOiKgueCueS4reaMh+Wumuexu+Wei+eahOe7hOS7tuOAglxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIHZhciB0ZXN0cyA9IG5vZGUuZ2V0Q29tcG9uZW50c0luQ2hpbGRyZW4oXCJUZXN0XCIpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDb21wb25lbnRzSW5DaGlsZHJlbiAoY2xhc3NOYW1lOiBzdHJpbmcpOiBDb21wb25lbnRbXTtcclxuXHJcbiAgICBwdWJsaWMgZ2V0Q29tcG9uZW50c0luQ2hpbGRyZW4gKHR5cGVPckNsYXNzTmFtZTogYW55KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5nZXRDb21wb25lbnRzSW5DaGlsZHJlbih0eXBlT3JDbGFzc05hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE9WRVJSSURFXHJcblxyXG4gICAgcHVibGljIGRlc3Ryb3kgKCkge1xyXG4gICAgICAgIGlmIChFRElUT1IpIHtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBjb25zdCBkZXBlbmQgPSB0aGlzLm5vZGUuX2dldERlcGVuZENvbXBvbmVudCh0aGlzKTtcclxuICAgICAgICAgICAgaWYgKGRlcGVuZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNjLmVycm9ySUQoMzYyNixcclxuICAgICAgICAgICAgICAgICAgICBnZXRDbGFzc05hbWUodGhpcyksIGdldENsYXNzTmFtZShkZXBlbmQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3VwZXIuZGVzdHJveSgpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVkICYmIHRoaXMubm9kZS5hY3RpdmVJbkhpZXJhcmNoeSkge1xyXG4gICAgICAgICAgICAgICAgY2MuZGlyZWN0b3IuX2NvbXBTY2hlZHVsZXIuZGlzYWJsZUNvbXAodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIF9vblByZURlc3Ryb3kgKCkge1xyXG4gICAgICAgIC8vIFNjaGVkdWxlc1xyXG4gICAgICAgIHRoaXMudW5zY2hlZHVsZUFsbENhbGxiYWNrcygpO1xyXG5cclxuICAgICAgICAvL1xyXG4gICAgICAgIGlmIChFRElUT1IgJiYgIVRFU1QpIHtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgICAgICBfU2NlbmUuQXNzZXRzV2F0Y2hlci5zdG9wKHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gb25EZXN0cm95XHJcbiAgICAgICAgY2MuZGlyZWN0b3IuX25vZGVBY3RpdmF0b3IuZGVzdHJveUNvbXAodGhpcyk7XHJcblxyXG4gICAgICAgIC8vIGRvIHJlbW92ZSBjb21wb25lbnRcclxuICAgICAgICB0aGlzLm5vZGUuX3JlbW92ZUNvbXBvbmVudCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgX2luc3RhbnRpYXRlIChjbG9uZWQpIHtcclxuICAgICAgICBpZiAoIWNsb25lZCkge1xyXG4gICAgICAgICAgICBjbG9uZWQgPSBjYy5pbnN0YW50aWF0ZS5fY2xvbmUodGhpcywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsb25lZC5ub2RlID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gY2xvbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNjaGVkdWxlclxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBTY2hlZHVsZXMgYSBjdXN0b20gc2VsZWN0b3IuPGJyLz5cclxuICAgICAqIElmIHRoZSBzZWxlY3RvciBpcyBhbHJlYWR5IHNjaGVkdWxlZCwgdGhlbiB0aGUgaW50ZXJ2YWwgcGFyYW1ldGVyIHdpbGwgYmUgdXBkYXRlZCB3aXRob3V0IHNjaGVkdWxpbmcgaXQgYWdhaW4uXHJcbiAgICAgKiBAemhcclxuICAgICAqIOiwg+W6puS4gOS4quiHquWumuS5ieeahOWbnuiwg+WHveaVsOOAgjxici8+XHJcbiAgICAgKiDlpoLmnpzlm57osIPlh73mlbDlt7LosIPluqbvvIzpgqPkuYjlsIbkuI3kvJrph43lpI3osIPluqblroPvvIzlj6rkvJrmm7TmlrDml7bpl7Tpl7TpmpTlj4LmlbDjgIJcclxuICAgICAqIEBtZXRob2Qgc2NoZWR1bGVcclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIOWbnuiwg+WHveaVsOOAglxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGludGVydmFsICDml7bpl7Tpl7TpmpTvvIwwIOihqOekuuavj+W4p+mDvemHjeWkjeOAglxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlcGVhdCAgICDlsIbooqvph43lpI3miafooYzvvIhyZXBlYXQrIDHvvInmrKHvvIzmgqjlj6/ku6Xkvb/nlKggY2MubWFjcm8uUkVQRUFUX0ZPUkVWRVIg6L+b6KGM5peg6ZmQ5qyh5b6q546v44CCXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsYXkgICAgIOesrOS4gOasoeaJp+ihjOWJjeetieW+heeahOaXtumXtO+8iOW7tuaXtuaJp+ihjO+8ieOAglxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIHZhciB0aW1lQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZHQpIHtcclxuICAgICAqICAgY2MubG9nKFwidGltZTogXCIgKyBkdCk7XHJcbiAgICAgKiB9XHJcbiAgICAgKiB0aGlzLnNjaGVkdWxlKHRpbWVDYWxsYmFjaywgMSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHNjaGVkdWxlIChjYWxsYmFjaywgaW50ZXJ2YWw6IG51bWJlciA9IDAsIHJlcGVhdDogbnVtYmVyID0gY2MubWFjcm8uUkVQRUFUX0ZPUkVWRVIsIGRlbGF5OiBudW1iZXIgPSAwKSB7XHJcbiAgICAgICAgY2MuYXNzZXJ0SUQoY2FsbGJhY2ssIDE2MTkpO1xyXG4gICAgICAgIGNjLmFzc2VydElEKGludGVydmFsID49IDAsIDE2MjApO1xyXG5cclxuICAgICAgICBpbnRlcnZhbCA9IGludGVydmFsIHx8IDA7XHJcbiAgICAgICAgcmVwZWF0ID0gaXNOYU4ocmVwZWF0KSA/IGNjLm1hY3JvLlJFUEVBVF9GT1JFVkVSIDogcmVwZWF0O1xyXG4gICAgICAgIGRlbGF5ID0gZGVsYXkgfHwgMDtcclxuXHJcbiAgICAgICAgY29uc3Qgc2NoZWR1bGVyID0gY2MuZGlyZWN0b3IuZ2V0U2NoZWR1bGVyKCk7XHJcblxyXG4gICAgICAgIC8vIHNob3VsZCBub3QgdXNlIGVuYWJsZWRJbkhpZXJhcmNoeSB0byBqdWRnZSB3aGV0aGVyIHBhdXNlZCxcclxuICAgICAgICAvLyBiZWNhdXNlIGVuYWJsZWRJbkhpZXJhcmNoeSBpcyBhc3NpZ25lZCBhZnRlciBvbkVuYWJsZS5cclxuICAgICAgICAvLyBBY3R1YWxseSwgaWYgbm90IHlldCBzY2hlZHVsZWQsIHJlc3VtZVRhcmdldC9wYXVzZVRhcmdldCBoYXMgbm8gZWZmZWN0IG9uIGNvbXBvbmVudCxcclxuICAgICAgICAvLyB0aGVyZWZvcmUgdGhlcmUgaXMgbm8gd2F5IHRvIGd1YXJhbnRlZSB0aGUgcGF1c2VkIHN0YXRlIG90aGVyIHRoYW4gaXNUYXJnZXRQYXVzZWQuXHJcbiAgICAgICAgY29uc3QgcGF1c2VkID0gc2NoZWR1bGVyLmlzVGFyZ2V0UGF1c2VkKHRoaXMpO1xyXG5cclxuICAgICAgICBzY2hlZHVsZXIuc2NoZWR1bGUoY2FsbGJhY2ssIHRoaXMsIGludGVydmFsLCByZXBlYXQsIGRlbGF5LCBwYXVzZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFNjaGVkdWxlcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgcnVucyBvbmx5IG9uY2UsIHdpdGggYSBkZWxheSBvZiAwIG9yIGxhcmdlci5cclxuICAgICAqIEB6aCDosIPluqbkuIDkuKrlj6rov5DooYzkuIDmrKHnmoTlm57osIPlh73mlbDvvIzlj6/ku6XmjIflrpogMCDorqnlm57osIPlh73mlbDlnKjkuIvkuIDluKfnq4vljbPmiafooYzmiJbogIXlnKjkuIDlrprnmoTlu7bml7bkuYvlkI7miafooYzjgIJcclxuICAgICAqIEBtZXRob2Qgc2NoZWR1bGVPbmNlXHJcbiAgICAgKiBAc2VlIFtbc2NoZWR1bGVdXVxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgIOWbnuiwg+WHveaVsOOAglxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5ICDnrKzkuIDmrKHmiafooYzliY3nrYnlvoXnmoTml7bpl7TvvIjlu7bml7bmiafooYzvvInjgIJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiB2YXIgdGltZUNhbGxiYWNrID0gZnVuY3Rpb24gKGR0KSB7XHJcbiAgICAgKiAgIGNjLmxvZyhcInRpbWU6IFwiICsgZHQpO1xyXG4gICAgICogfVxyXG4gICAgICogdGhpcy5zY2hlZHVsZU9uY2UodGltZUNhbGxiYWNrLCAyKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2NoZWR1bGVPbmNlIChjYWxsYmFjaywgZGVsYXk6IG51bWJlciA9IDApIHtcclxuICAgICAgICB0aGlzLnNjaGVkdWxlKGNhbGxiYWNrLCAwLCAwLCBkZWxheSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gVW5zY2hlZHVsZXMgYSBjdXN0b20gY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgKiBAemgg5Y+W5raI6LCD5bqm5LiA5Liq6Ieq5a6a5LmJ55qE5Zue6LCD5Ye95pWw44CCXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja19mbiAg5Zue6LCD5Ye95pWw44CCXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogdGhpcy51bnNjaGVkdWxlKF9jYWxsYmFjayk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVuc2NoZWR1bGUgKGNhbGxiYWNrX2ZuKSB7XHJcbiAgICAgICAgaWYgKCFjYWxsYmFja19mbikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYy5kaXJlY3Rvci5nZXRTY2hlZHVsZXIoKS51bnNjaGVkdWxlKGNhbGxiYWNrX2ZuLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogdW5zY2hlZHVsZSBhbGwgc2NoZWR1bGVkIGNhbGxiYWNrIGZ1bmN0aW9uczogY3VzdG9tIGNhbGxiYWNrIGZ1bmN0aW9ucywgYW5kIHRoZSAndXBkYXRlJyBjYWxsYmFjayBmdW5jdGlvbi48YnIvPlxyXG4gICAgICogQWN0aW9ucyBhcmUgbm90IGFmZmVjdGVkIGJ5IHRoaXMgbWV0aG9kLlxyXG4gICAgICogQHpoIOWPlua2iOiwg+W6puaJgOacieW3suiwg+W6pueahOWbnuiwg+WHveaVsO+8muWumuWItueahOWbnuiwg+WHveaVsOS7peWPiiAndXBkYXRlJyDlm57osIPlh73mlbDjgILliqjkvZzkuI3lj5fmraTmlrnms5XlvbHlk43jgIJcclxuICAgICAqIEBtZXRob2QgdW5zY2hlZHVsZUFsbENhbGxiYWNrc1xyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIHRoaXMudW5zY2hlZHVsZUFsbENhbGxiYWNrcygpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1bnNjaGVkdWxlQWxsQ2FsbGJhY2tzICgpIHtcclxuICAgICAgICBjYy5kaXJlY3Rvci5nZXRTY2hlZHVsZXIoKS51bnNjaGVkdWxlQWxsRm9yVGFyZ2V0KHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExJRkVDWUNMRSBNRVRIT0RTXHJcblxyXG4gICAgLy8gRmlyZWJhbGwgcHJvdmlkZXMgbGlmZWN5Y2xlIG1ldGhvZHMgdGhhdCB5b3UgY2FuIHNwZWNpZnkgdG8gaG9vayBpbnRvIHRoaXMgcHJvY2Vzcy5cclxuICAgIC8vIFdlIHByb3ZpZGUgUHJlIG1ldGhvZHMsIHdoaWNoIGFyZSBjYWxsZWQgcmlnaHQgYmVmb3JlIHNvbWV0aGluZyBoYXBwZW5zLCBhbmQgUG9zdCBtZXRob2RzIHdoaWNoIGFyZSBjYWxsZWQgcmlnaHQgYWZ0ZXIgc29tZXRoaW5nIGhhcHBlbnMuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gVXBkYXRlIGlzIGNhbGxlZCBldmVyeSBmcmFtZSwgaWYgdGhlIENvbXBvbmVudCBpcyBlbmFibGVkLjxici8+XHJcbiAgICAgKiBUaGlzIGlzIGEgbGlmZWN5Y2xlIG1ldGhvZC4gSXQgbWF5IG5vdCBiZSBpbXBsZW1lbnRlZCBpbiB0aGUgc3VwZXIgY2xhc3MuPGJyLz5cclxuICAgICAqIFlvdSBjYW4gb25seSBjYWxsIGl0cyBzdXBlciBjbGFzcyBtZXRob2QgaW5zaWRlIGl0LiBJdCBzaG91bGQgbm90IGJlIGNhbGxlZCBtYW51YWxseSBlbHNld2hlcmUuXHJcbiAgICAgKiBAemgg5aaC5p6c6K+l57uE5Lu25ZCv55So77yM5YiZ5q+P5bin6LCD55SoIHVwZGF0ZeOAgjxici8+XHJcbiAgICAgKiDor6Xmlrnms5XkuLrnlJ/lkb3lkajmnJ/mlrnms5XvvIzniLbnsbvmnKrlv4XkvJrmnInlrp7njrDjgILlubbkuJTkvaDlj6rog73lnKjor6Xmlrnms5XlhoXpg6josIPnlKjniLbnsbvnmoTlrp7njrDvvIzkuI3lj6/lnKjlhbblroPlnLDmlrnnm7TmjqXosIPnlKjor6Xmlrnms5XjgIJcclxuICAgICAqIEBwYXJhbSBkdCAtIHRoZSBkZWx0YSB0aW1lIGluIHNlY29uZHMgaXQgdG9vayB0byBjb21wbGV0ZSB0aGUgbGFzdCBmcmFtZVxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgdXBkYXRlPyAoZHQ6IG51bWJlcik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gTGF0ZVVwZGF0ZSBpcyBjYWxsZWQgZXZlcnkgZnJhbWUsIGlmIHRoZSBDb21wb25lbnQgaXMgZW5hYmxlZC48YnIvPlxyXG4gICAgICogVGhpcyBpcyBhIGxpZmVjeWNsZSBtZXRob2QuIEl0IG1heSBub3QgYmUgaW1wbGVtZW50ZWQgaW4gdGhlIHN1cGVyIGNsYXNzLjxici8+XHJcbiAgICAgKiBZb3UgY2FuIG9ubHkgY2FsbCBpdHMgc3VwZXIgY2xhc3MgbWV0aG9kIGluc2lkZSBpdC4gSXQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgbWFudWFsbHkgZWxzZXdoZXJlLlxyXG4gICAgICogQHpoIOWmguaenOivpee7hOS7tuWQr+eUqO+8jOWImeavj+W4p+iwg+eUqCBMYXRlVXBkYXRl44CCPGJyLz5cclxuICAgICAqIOivpeaWueazleS4uueUn+WRveWRqOacn+aWueazle+8jOeItuexu+acquW/heS8muacieWunueOsOOAguW5tuS4lOS9oOWPquiDveWcqOivpeaWueazleWGhemDqOiwg+eUqOeItuexu+eahOWunueOsO+8jOS4jeWPr+WcqOWFtuWug+WcsOaWueebtOaOpeiwg+eUqOivpeaWueazleOAglxyXG4gICAgICogQHBhcmFtIGR0IC0gdGhlIGRlbHRhIHRpbWUgaW4gc2Vjb25kcyBpdCB0b29rIHRvIGNvbXBsZXRlIHRoZSBsYXN0IGZyYW1lXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBsYXRlVXBkYXRlPyAoZHQ6IG51bWJlcik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gYF9fcHJlbG9hZGAgaXMgY2FsbGVkIGJlZm9yZSBldmVyeSBvbkxvYWQuPGJyLz5cclxuICAgICAqIEl0IGlzIHVzZWQgdG8gaW5pdGlhbGl6ZSB0aGUgYnVpbHRpbiBjb21wb25lbnRzIGludGVybmFsbHksPGJyLz5cclxuICAgICAqIHRvIGF2b2lkIGNoZWNraW5nIHdoZXRoZXIgb25Mb2FkIGlzIGNhbGxlZCBiZWZvcmUgZXZlcnkgcHVibGljIG1ldGhvZCBjYWxscy48YnIvPlxyXG4gICAgICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHJlbW92ZWQgaWYgc2NyaXB0IHByaW9yaXR5IGlzIHN1cHBvcnRlZC5cclxuICAgICAqIEB6aCBgX19wcmVsb2FkYCDlnKjmr4/mrKFvbkxvYWTkuYvliY3osIPnlKjjgII8YnIvPlxyXG4gICAgICog5a6D55So5LqO5Zyo5YaF6YOo5Yid5aeL5YyW5YaF572u57uE5Lu277yMPGJyLz5cclxuICAgICAqIOS7pemBv+WFjeWcqOavj+asoeWFrOacieaWueazleiwg+eUqOS5i+WJjeajgOafpeaYr+WQpuiwg+eUqOS6hm9uTG9hZOOAgjxici8+XHJcbiAgICAgKiDlpoLmnpzmlK/mjIHohJrmnKzkvJjlhYjnuqfvvIzliJnlupTliKDpmaTmraTmlrnms5XjgIJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBfX3ByZWxvYWQ/ICgpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBXaGVuIGF0dGFjaGluZyB0byBhbiBhY3RpdmUgbm9kZSBvciBpdHMgbm9kZSBmaXJzdCBhY3RpdmF0ZWQuPGJyLz5cclxuICAgICAqIG9uTG9hZCBpcyBhbHdheXMgY2FsbGVkIGJlZm9yZSBhbnkgc3RhcnQgZnVuY3Rpb25zLCB0aGlzIGFsbG93cyB5b3UgdG8gb3JkZXIgaW5pdGlhbGl6YXRpb24gb2Ygc2NyaXB0cy48YnIvPlxyXG4gICAgICogVGhpcyBpcyBhIGxpZmVjeWNsZSBtZXRob2QuIEl0IG1heSBub3QgYmUgaW1wbGVtZW50ZWQgaW4gdGhlIHN1cGVyIGNsYXNzLjxici8+XHJcbiAgICAgKiBZb3UgY2FuIG9ubHkgY2FsbCBpdHMgc3VwZXIgY2xhc3MgbWV0aG9kIGluc2lkZSBpdC4gSXQgc2hvdWxkIG5vdCBiZSBjYWxsZWQgbWFudWFsbHkgZWxzZXdoZXJlLlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDlvZPpmYTliqDliLDkuIDkuKrmv4DmtLvnmoToioLngrnkuIrmiJbogIXlhbboioLngrnnrKzkuIDmrKHmv4DmtLvml7blgJnosIPnlKjjgIJvbkxvYWQg5oC75piv5Lya5Zyo5Lu75L2VIHN0YXJ0IOaWueazleiwg+eUqOWJjeaJp+ihjO+8jOi/meiDveeUqOS6juWuieaOkuiEmuacrOeahOWIneWni+WMlumhuuW6j+OAgjxici8+XHJcbiAgICAgKiDor6Xmlrnms5XkuLrnlJ/lkb3lkajmnJ/mlrnms5XvvIzniLbnsbvmnKrlv4XkvJrmnInlrp7njrDjgILlubbkuJTkvaDlj6rog73lnKjor6Xmlrnms5XlhoXpg6josIPnlKjniLbnsbvnmoTlrp7njrDvvIzkuI3lj6/lnKjlhbblroPlnLDmlrnnm7TmjqXosIPnlKjor6Xmlrnms5XjgIJcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIG9uTG9hZD8gKCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIENhbGxlZCBiZWZvcmUgYWxsIHNjcmlwdHMnIHVwZGF0ZSBpZiB0aGUgQ29tcG9uZW50IGlzIGVuYWJsZWQgdGhlIGZpcnN0IHRpbWUuPGJyLz5cclxuICAgICAqIFVzdWFsbHkgdXNlZCB0byBpbml0aWFsaXplIHNvbWUgbG9naWMgd2hpY2ggbmVlZCB0byBiZSBjYWxsZWQgYWZ0ZXIgYWxsIGNvbXBvbmVudHMnIGBvbmxvYWRgIG1ldGhvZHMgY2FsbGVkLjxici8+XHJcbiAgICAgKiBUaGlzIGlzIGEgbGlmZWN5Y2xlIG1ldGhvZC4gSXQgbWF5IG5vdCBiZSBpbXBsZW1lbnRlZCBpbiB0aGUgc3VwZXIgY2xhc3MuPGJyLz5cclxuICAgICAqIFlvdSBjYW4gb25seSBjYWxsIGl0cyBzdXBlciBjbGFzcyBtZXRob2QgaW5zaWRlIGl0LiBJdCBzaG91bGQgbm90IGJlIGNhbGxlZCBtYW51YWxseSBlbHNld2hlcmUuXHJcbiAgICAgKiBAemhcclxuICAgICAqIOWmguaenOivpee7hOS7tuesrOS4gOasoeWQr+eUqO+8jOWImeWcqOaJgOaciee7hOS7tueahCB1cGRhdGUg5LmL5YmN6LCD55So44CC6YCa5bi455So5LqO6ZyA6KaB5Zyo5omA5pyJ57uE5Lu255qEIG9uTG9hZCDliJ3lp4vljJblrozmr5XlkI7miafooYznmoTpgLvovpHjgII8YnIvPlxyXG4gICAgICog6K+l5pa55rOV5Li655Sf5ZG95ZGo5pyf5pa55rOV77yM54i257G75pyq5b+F5Lya5pyJ5a6e546w44CC5bm25LiU5L2g5Y+q6IO95Zyo6K+l5pa55rOV5YaF6YOo6LCD55So54i257G755qE5a6e546w77yM5LiN5Y+v5Zyo5YW25a6D5Zyw5pa555u05o6l6LCD55So6K+l5pa55rOV44CCXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBzdGFydD8gKCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gQ2FsbGVkIHdoZW4gdGhpcyBjb21wb25lbnQgYmVjb21lcyBlbmFibGVkIGFuZCBpdHMgbm9kZSBpcyBhY3RpdmUuPGJyLz5cclxuICAgICAqIFRoaXMgaXMgYSBsaWZlY3ljbGUgbWV0aG9kLiBJdCBtYXkgbm90IGJlIGltcGxlbWVudGVkIGluIHRoZSBzdXBlciBjbGFzcy5cclxuICAgICAqIFlvdSBjYW4gb25seSBjYWxsIGl0cyBzdXBlciBjbGFzcyBtZXRob2QgaW5zaWRlIGl0LiBJdCBzaG91bGQgbm90IGJlIGNhbGxlZCBtYW51YWxseSBlbHNld2hlcmUuXHJcbiAgICAgKiBAemgg5b2T6K+l57uE5Lu26KKr5ZCv55So77yM5bm25LiU5a6D55qE6IqC54K55Lmf5r+A5rS75pe244CCPGJyLz5cclxuICAgICAqIOivpeaWueazleS4uueUn+WRveWRqOacn+aWueazle+8jOeItuexu+acquW/heS8muacieWunueOsOOAguW5tuS4lOS9oOWPquiDveWcqOivpeaWueazleWGhemDqOiwg+eUqOeItuexu+eahOWunueOsO+8jOS4jeWPr+WcqOWFtuWug+WcsOaWueebtOaOpeiwg+eUqOivpeaWueazleOAglxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgb25FbmFibGU/ICgpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIENhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IGJlY29tZXMgZGlzYWJsZWQgb3IgaXRzIG5vZGUgYmVjb21lcyBpbmFjdGl2ZS48YnIvPlxyXG4gICAgICogVGhpcyBpcyBhIGxpZmVjeWNsZSBtZXRob2QuIEl0IG1heSBub3QgYmUgaW1wbGVtZW50ZWQgaW4gdGhlIHN1cGVyIGNsYXNzLlxyXG4gICAgICogWW91IGNhbiBvbmx5IGNhbGwgaXRzIHN1cGVyIGNsYXNzIG1ldGhvZCBpbnNpZGUgaXQuIEl0IHNob3VsZCBub3QgYmUgY2FsbGVkIG1hbnVhbGx5IGVsc2V3aGVyZS5cclxuICAgICAqIEB6aCDlvZPor6Xnu4Tku7booqvnpoHnlKjmiJboioLngrnlj5jkuLrml6DmlYjml7bosIPnlKjjgII8YnIvPlxyXG4gICAgICog6K+l5pa55rOV5Li655Sf5ZG95ZGo5pyf5pa55rOV77yM54i257G75pyq5b+F5Lya5pyJ5a6e546w44CC5bm25LiU5L2g5Y+q6IO95Zyo6K+l5pa55rOV5YaF6YOo6LCD55So54i257G755qE5a6e546w77yM5LiN5Y+v5Zyo5YW25a6D5Zyw5pa555u05o6l6LCD55So6K+l5pa55rOV44CCXHJcbiAgICAgKi9cclxuICAgIHByb3RlY3RlZCBvbkRpc2FibGU/ICgpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIENhbGxlZCB3aGVuIHRoaXMgY29tcG9uZW50IHdpbGwgYmUgZGVzdHJveWVkLjxici8+XHJcbiAgICAgKiBUaGlzIGlzIGEgbGlmZWN5Y2xlIG1ldGhvZC4gSXQgbWF5IG5vdCBiZSBpbXBsZW1lbnRlZCBpbiB0aGUgc3VwZXIgY2xhc3MuPGJyLz5cclxuICAgICAqIFlvdSBjYW4gb25seSBjYWxsIGl0cyBzdXBlciBjbGFzcyBtZXRob2QgaW5zaWRlIGl0LiBJdCBzaG91bGQgbm90IGJlIGNhbGxlZCBtYW51YWxseSBlbHNld2hlcmUuXHJcbiAgICAgKiBAemgg5b2T6K+l57uE5Lu26KKr6ZSA5q+B5pe26LCD55SoPGJyLz5cclxuICAgICAqIOivpeaWueazleS4uueUn+WRveWRqOacn+aWueazle+8jOeItuexu+acquW/heS8muacieWunueOsOOAguW5tuS4lOS9oOWPquiDveWcqOivpeaWueazleWGhemDqOiwg+eUqOeItuexu+eahOWunueOsO+8jOS4jeWPr+WcqOWFtuWug+WcsOaWueebtOaOpeiwg+eUqOivpeaWueazleOAglxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgb25EZXN0cm95PyAoKTogdm9pZDtcclxuXHJcbiAgICBwdWJsaWMgb25Gb2N1c0luRWRpdG9yPyAoKTogdm9pZDtcclxuXHJcbiAgICBwdWJsaWMgb25Mb3N0Rm9jdXNJbkVkaXRvcj8gKCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gQ2FsbGVkIHRvIGluaXRpYWxpemUgdGhlIGNvbXBvbmVudCBvciBub2Rl4oCZcyBwcm9wZXJ0aWVzIHdoZW4gYWRkaW5nIHRoZSBjb21wb25lbnQgdGhlIGZpcnN0IHRpbWUgb3Igd2hlbiB0aGUgUmVzZXQgY29tbWFuZCBpcyB1c2VkLlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBpbiBlZGl0b3IuPGJyLz5cclxuICAgICAqIEB6aCDnlKjmnaXliJ3lp4vljJbnu4Tku7bmiJboioLngrnnmoTkuIDkupvlsZ7mgKfvvIzlvZPor6Xnu4Tku7booqvnrKzkuIDmrKHmt7vliqDliLDoioLngrnkuIrmiJbnlKjmiLfngrnlh7vkuoblroPnmoQgUmVzZXQg6I+c5Y2V5pe26LCD55So44CC6L+Z5Liq5Zue6LCD5Y+q5Lya5Zyo57yW6L6R5Zmo5LiL6LCD55So44CCXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXNldEluRWRpdG9yPyAoKTogdm9pZDtcclxuXHJcbiAgICAvLyBWSVJUVUFMXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIElmIHRoZSBjb21wb25lbnQncyBib3VuZGluZyBib3ggaXMgZGlmZmVyZW50IGZyb20gdGhlIG5vZGUncywgeW91IGNhbiBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gc3VwcGx5XHJcbiAgICAgKiBhIGN1c3RvbSBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IChBQUJCKSwgc28gdGhlIGVkaXRvcidzIHNjZW5lIHZpZXcgY2FuIHBlcmZvcm0gaGl0IHRlc3QgcHJvcGVybHkuXHJcbiAgICAgKiBAemhcclxuICAgICAqIOWmguaenOe7hOS7tueahOWMheWbtOebkuS4juiKgueCueS4jeWQjO+8jOaCqOWPr+S7peWunueOsOivpeaWueazleS7peaPkOS+m+iHquWumuS5ieeahOi9tOWQkeWvuem9kOeahOWMheWbtOebku+8iEFBQkLvvInvvIxcclxuICAgICAqIOS7peS+v+e8lui+keWZqOeahOWcuuaZr+inhuWbvuWPr+S7peato+ehruWcsOaJp+ihjOeCuemAiea1i+ivleOAglxyXG4gICAgICogQHBhcmFtIG91dF9yZWN0IC0g5o+Q5L6b5YyF5Zu055uS55qEIFJlY3RcclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIF9nZXRMb2NhbEJvdW5kcz8gKG91dF9yZWN0OiBSZWN0KTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogb25SZXN0b3JlIGlzIGNhbGxlZCBhZnRlciB0aGUgdXNlciBjbGlja3MgdGhlIFJlc2V0IGl0ZW0gaW4gdGhlIEluc3BlY3RvcidzIGNvbnRleHQgbWVudSBvciBwZXJmb3Jtc1xyXG4gICAgICogYW4gdW5kbyBvcGVyYXRpb24gb24gdGhpcyBjb21wb25lbnQuPGJyLz5cclxuICAgICAqIDxici8+XHJcbiAgICAgKiBJZiB0aGUgY29tcG9uZW50IGNvbnRhaW5zIHRoZSBcImludGVybmFsIHN0YXRlXCIsIHNob3J0IGZvciBcInRlbXBvcmFyeSBtZW1iZXIgdmFyaWFibGVzIHdoaWNoIG5vdCBpbmNsdWRlZDxici8+XHJcbiAgICAgKiBpbiBpdHMgQ0NDbGFzcyBwcm9wZXJ0aWVzXCIsIHRoZW4geW91IG1heSBuZWVkIHRvIGltcGxlbWVudCB0aGlzIGZ1bmN0aW9uLjxici8+XHJcbiAgICAgKiA8YnIvPlxyXG4gICAgICogVGhlIGVkaXRvciB3aWxsIGNhbGwgdGhlIGdldHNldCBhY2Nlc3NvcnMgb2YgeW91ciBjb21wb25lbnQgdG8gcmVjb3JkL3Jlc3RvcmUgdGhlIGNvbXBvbmVudCdzIHN0YXRlPGJyLz5cclxuICAgICAqIGZvciB1bmRvL3JlZG8gb3BlcmF0aW9uLiBIb3dldmVyLCBpbiBleHRyZW1lIGNhc2VzLCBpdCBtYXkgbm90IHdvcmtzIHdlbGwuIFRoZW4geW91IHNob3VsZCBpbXBsZW1lbnQ8YnIvPlxyXG4gICAgICogdGhpcyBmdW5jdGlvbiB0byBtYW51YWxseSBzeW5jaHJvbml6ZSB5b3VyIGNvbXBvbmVudCdzIFwiaW50ZXJuYWwgc3RhdGVzXCIgd2l0aCBpdHMgcHVibGljIHByb3BlcnRpZXMuPGJyLz5cclxuICAgICAqIE9uY2UgeW91IGltcGxlbWVudCB0aGlzIGZ1bmN0aW9uLCBhbGwgdGhlIGdldHNldCBhY2Nlc3NvcnMgb2YgeW91ciBjb21wb25lbnQgd2lsbCBub3QgYmUgY2FsbGVkIHdoZW48YnIvPlxyXG4gICAgICogdGhlIHVzZXIgcGVyZm9ybXMgYW4gdW5kby9yZWRvIG9wZXJhdGlvbi4gV2hpY2ggbWVhbnMgdGhhdCBvbmx5IHRoZSBwcm9wZXJ0aWVzIHdpdGggZGVmYXVsdCB2YWx1ZTxici8+XHJcbiAgICAgKiB3aWxsIGJlIHJlY29yZGVkIG9yIHJlc3RvcmVkIGJ5IGVkaXRvci48YnIvPlxyXG4gICAgICogPGJyLz5cclxuICAgICAqIFNpbWlsYXJseSwgdGhlIGVkaXRvciBtYXkgZmFpbGVkIHRvIHJlc2V0IHlvdXIgY29tcG9uZW50IGNvcnJlY3RseSBpbiBleHRyZW1lIGNhc2VzLiBUaGVuIGlmIHlvdSBuZWVkPGJyLz5cclxuICAgICAqIHRvIHN1cHBvcnQgdGhlIHJlc2V0IG1lbnUsIHlvdSBzaG91bGQgbWFudWFsbHkgc3luY2hyb25pemUgeW91ciBjb21wb25lbnQncyBcImludGVybmFsIHN0YXRlc1wiIHdpdGggaXRzPGJyLz5cclxuICAgICAqIHByb3BlcnRpZXMgaW4gdGhpcyBmdW5jdGlvbi4gT25jZSB5b3UgaW1wbGVtZW50IHRoaXMgZnVuY3Rpb24sIGFsbCB0aGUgZ2V0c2V0IGFjY2Vzc29ycyBvZiB5b3VyIGNvbXBvbmVudDxici8+XHJcbiAgICAgKiB3aWxsIG5vdCBiZSBjYWxsZWQgZHVyaW5nIHJlc2V0IG9wZXJhdGlvbi4gV2hpY2ggbWVhbnMgdGhhdCBvbmx5IHRoZSBwcm9wZXJ0aWVzIHdpdGggZGVmYXVsdCB2YWx1ZTxici8+XHJcbiAgICAgKiB3aWxsIGJlIHJlc2V0IGJ5IGVkaXRvci5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkIGluIGVkaXRvciBtb2RlLlxyXG4gICAgICogQHpoXHJcbiAgICAgKiBvblJlc3RvcmUg5piv55So5oi35Zyo5qOA5p+l5Zmo6I+c5Y2V54K55Ye7IFJlc2V0IOaXtu+8jOWvueatpOe7hOS7tuaJp+ihjOaSpOa2iOaTjeS9nOWQjuiwg+eUqOeahOOAgjxici8+XHJcbiAgICAgKiA8YnIvPlxyXG4gICAgICog5aaC5p6c57uE5Lu25YyF5ZCr5LqG4oCc5YaF6YOo54q25oCB4oCd77yI5LiN5ZyoIENDQ2xhc3Mg5bGe5oCn5Lit5a6a5LmJ55qE5Li05pe25oiQ5ZGY5Y+Y6YeP77yJ77yM6YKj5LmI5L2g5Y+v6IO96ZyA6KaB5a6e546w6K+l5pa55rOV44CCPGJyLz5cclxuICAgICAqIDxici8+XHJcbiAgICAgKiDnvJbovpHlmajmiafooYzmkqTplIAv6YeN5YGa5pON5L2c5pe277yM5bCG6LCD55So57uE5Lu255qEIGdldCBzZXQg5p2l5b2V5Yi25ZKM6L+Y5Y6f57uE5Lu255qE54q25oCB44CCXHJcbiAgICAgKiDnhLbogIzvvIzlnKjmnoHnq6/nmoTmg4XlhrXkuIvvvIzlroPlj6/og73ml6Dms5Xoia/lpb3ov5DkvZzjgII8YnIvPlxyXG4gICAgICog6YKj5LmI5L2g5bCx5bqU6K+l5a6e546w6L+Z5Liq5pa55rOV77yM5omL5Yqo5qC55o2u57uE5Lu255qE5bGe5oCn5ZCM5q2l4oCc5YaF6YOo54q25oCB4oCd44CCXHJcbiAgICAgKiDkuIDml6bkvaDlrp7njrDov5nkuKrmlrnms5XvvIzlvZPnlKjmiLfmkqTplIDmiJbph43lgZrml7bvvIznu4Tku7bnmoTmiYDmnIkgZ2V0IHNldCDpg73kuI3kvJrlho3ooqvosIPnlKjjgIJcclxuICAgICAqIOi/meaEj+WRs+edgOS7heS7heaMh+WumuS6hum7mOiupOWAvOeahOWxnuaAp+Wwhuiiq+e8lui+keWZqOiusOW9leWSjOi/mOWOn+OAgjxici8+XHJcbiAgICAgKiA8YnIvPlxyXG4gICAgICog5ZCM5qC355qE77yM57yW6L6R5Y+v6IO95peg5rOV5Zyo5p6B56uv5oOF5Ya15LiL5q2j56Gu5Zyw6YeN572u5oKo55qE57uE5Lu244CCPGJyLz5cclxuICAgICAqIOS6juaYr+WmguaenOS9oOmcgOimgeaUr+aMgee7hOS7tumHjee9ruiPnOWNle+8jOS9oOmcgOimgeWcqOivpeaWueazleS4reaJi+W3peWQjOatpee7hOS7tuWxnuaAp+WIsOKAnOWGhemDqOeKtuaAgeKAneOAgjxici8+XHJcbiAgICAgKiDkuIDml6bkvaDlrp7njrDov5nkuKrmlrnms5XvvIznu4Tku7bnmoTmiYDmnIkgZ2V0IHNldCDpg73kuI3kvJrlnKjph43nva7mk43kvZzml7booqvosIPnlKjjgIJcclxuICAgICAqIOi/meaEj+WRs+edgOS7heS7heaMh+WumuS6hum7mOiupOWAvOeahOWxnuaAp+Wwhuiiq+e8lui+keWZqOmHjee9ruOAglxyXG4gICAgICogPGJyLz5cclxuICAgICAqIOatpOaWueazleS7heWcqOe8lui+keWZqOS4i+S8muiiq+iwg+eUqOOAglxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgb25SZXN0b3JlPyAoKTogdm9pZDtcclxufVxyXG5cclxuY29uc3QgcHJvdG8gPSBDb21wb25lbnQucHJvdG90eXBlO1xyXG4vLyBAdHMtaWdub3JlXHJcbnByb3RvLnVwZGF0ZSA9IG51bGw7XHJcbi8vIEB0cy1pZ25vcmVcclxucHJvdG8ubGF0ZVVwZGF0ZSA9IG51bGw7XHJcbi8vIEB0cy1pZ25vcmVcclxucHJvdG8uX19wcmVsb2FkID0gbnVsbDtcclxuLy8gQHRzLWlnbm9yZVxyXG5wcm90by5vbkxvYWQgPSBudWxsO1xyXG4vLyBAdHMtaWdub3JlXHJcbnByb3RvLnN0YXJ0ID0gbnVsbDtcclxuLy8gQHRzLWlnbm9yZVxyXG5wcm90by5vbkVuYWJsZSA9IG51bGw7XHJcbi8vIEB0cy1pZ25vcmVcclxucHJvdG8ub25EaXNhYmxlID0gbnVsbDtcclxuLy8gQHRzLWlnbm9yZVxyXG5wcm90by5vbkRlc3Ryb3kgPSBudWxsO1xyXG4vLyBAdHMtaWdub3JlXHJcbnByb3RvLm9uRm9jdXNJbkVkaXRvciA9IG51bGw7XHJcbi8vIEB0cy1pZ25vcmVcclxucHJvdG8ub25Mb3N0Rm9jdXNJbkVkaXRvciA9IG51bGw7XHJcbi8vIEB0cy1pZ25vcmVcclxucHJvdG8ucmVzZXRJbkVkaXRvciA9IG51bGw7XHJcbi8vIEB0cy1pZ25vcmVcclxucHJvdG8uX2dldExvY2FsQm91bmRzID0gbnVsbDtcclxuLy8gQHRzLWlnbm9yZVxyXG5wcm90by5vblJlc3RvcmUgPSBudWxsO1xyXG4vLyBAdHMtaWdub3JlXHJcbkNvbXBvbmVudC5fcmVxdWlyZUNvbXBvbmVudCA9IG51bGw7XHJcbi8vIEB0cy1pZ25vcmVcclxuQ29tcG9uZW50Ll9leGVjdXRpb25PcmRlciA9IDA7XHJcblxyXG5pZiAoRURJVE9SIHx8IFRFU1QpIHtcclxuXHJcbiAgICAvLyBJTkhFUklUQUJMRSBTVEFUSUMgTUVNQkVSU1xyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgQ29tcG9uZW50Ll9leGVjdXRlSW5FZGl0TW9kZSA9IGZhbHNlO1xyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgQ29tcG9uZW50Ll9wbGF5T25Gb2N1cyA9IGZhbHNlO1xyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgQ29tcG9uZW50Ll9kaXNhbGxvd011bHRpcGxlID0gbnVsbDtcclxuICAgIC8vIEB0cy1pZ25vcmVcclxuICAgIENvbXBvbmVudC5faGVscCA9ICcnO1xyXG5cclxuICAgIC8vIE5PTi1JTkhFUklURUQgU1RBVElDIE1FTUJFUlNcclxuICAgIC8vIChUeXBlU2NyaXB0IDIuMyB3aWxsIHN0aWxsIGluaGVyaXQgdGhlbSwgc28gYWx3YXlzIGNoZWNrIGhhc093blByb3BlcnR5IGJlZm9yZSB1c2luZylcclxuXHJcbiAgICB2YWx1ZShDb21wb25lbnQsICdfaW5zcGVjdG9yJywgJycsIHRydWUpO1xyXG4gICAgdmFsdWUoQ29tcG9uZW50LCAnX2ljb24nLCAnJywgdHJ1ZSk7XHJcblxyXG4gICAgLy8gQ09NUE9ORU5UIEhFTFBFUlNcclxuXHJcbiAgICAvLyBUT0RPIEtlZXAgdGVtcG9yYXJpbHksIGNvbXBhdGlibGUgd2l0aCBvbGQgdmVyc2lvblxyXG4gICAgY2MuX2NvbXBvbmVudE1lbnVJdGVtcyA9IFtdO1xyXG59XHJcblxyXG4vLyB3ZSBtYWtlIHRoaXMgbm9uLWVudW1lcmFibGUsIHRvIHByZXZlbnQgaW5oZXJpdGVkIGJ5IHN1YiBjbGFzc2VzLlxyXG52YWx1ZShDb21wb25lbnQsICdfcmVnaXN0ZXJFZGl0b3JQcm9wcycsIGZ1bmN0aW9uIChjbHMsIHByb3BzKSB7XHJcbiAgICBjb25zdCByZXFDb21wID0gcHJvcHMucmVxdWlyZUNvbXBvbmVudDtcclxuICAgIGlmIChyZXFDb21wKSB7XHJcbiAgICAgICAgY2xzLl9yZXF1aXJlQ29tcG9uZW50ID0gcmVxQ29tcDtcclxuICAgIH1cclxuICAgIGNvbnN0IG9yZGVyID0gcHJvcHMuZXhlY3V0aW9uT3JkZXI7XHJcbiAgICBpZiAob3JkZXIgJiYgdHlwZW9mIG9yZGVyID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGNscy5fZXhlY3V0aW9uT3JkZXIgPSBvcmRlcjtcclxuICAgIH1cclxuICAgIGlmIChFRElUT1IgfHwgVEVTVCkge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBnZXRDbGFzc05hbWUoY2xzKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICBjb25zdCB2YWwgPSBwcm9wc1trZXldO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZXhlY3V0ZUluRWRpdE1vZGUnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNscy5fZXhlY3V0ZUluRWRpdE1vZGUgPSAhIXZhbDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdwbGF5T25Gb2N1cyc6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWxsRXhlY3V0ZUluRWRpdE1vZGUgPSAoJ2V4ZWN1dGVJbkVkaXRNb2RlJyBpbiBwcm9wcykgPyBwcm9wcy5leGVjdXRlSW5FZGl0TW9kZSA6IGNscy5fZXhlY3V0ZUluRWRpdE1vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWxsRXhlY3V0ZUluRWRpdE1vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNscy5fcGxheU9uRm9jdXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2Mud2FybklEKDM2MDEsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2luc3BlY3Rvcic6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUoY2xzLCAnX2luc3BlY3RvcicsIHZhbCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAnaWNvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUoY2xzLCAnX2ljb24nLCB2YWwsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ21lbnUnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lID0gUkYucGVlaygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtZW51ID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW51ID0gJ2kxOG46bWVudS5jdXN0b21fc2NyaXB0LycgKyBtZW51O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgRURJVE9SICYmIEVkaXRvckV4dGVuZHMuQ29tcG9uZW50LmFkZE1lbnUoY2xzLCBtZW51LCBwcm9wcy5tZW51UHJpb3JpdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2FsbG93TXVsdGlwbGUnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNscy5fZGlzYWxsb3dNdWx0aXBsZSA9IGNscztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdyZXF1aXJlQ29tcG9uZW50JzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2V4ZWN1dGlvbk9yZGVyJzpcclxuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICdoZWxwJzpcclxuICAgICAgICAgICAgICAgICAgICBjbHMuX2hlbHAgPSB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBjYy53YXJuSUQoMzYwMiwga2V5LCBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSk7XHJcblxyXG5jYy5Db21wb25lbnQgPSBDb21wb25lbnQ7XHJcbmV4cG9ydCB7IENvbXBvbmVudCB9O1xyXG4iXX0=