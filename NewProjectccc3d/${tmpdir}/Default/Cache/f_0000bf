(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "../components/component.js", "../data/class-decorator.js", "../data/object.js", "../platform/debug.js", "../platform/event-manager/event-enum.js", "../utils/id-generator.js", "../utils/js.js", "./base-node-dev.js", "./node-event-processor.js", "../default-constants.js"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("../components/component.js"), require("../data/class-decorator.js"), require("../data/object.js"), require("../platform/debug.js"), require("../platform/event-manager/event-enum.js"), require("../utils/id-generator.js"), require("../utils/js.js"), require("./base-node-dev.js"), require("./node-event-processor.js"), require("../default-constants.js"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.component, global.classDecorator, global.object, global.debug, global.eventEnum, global.idGenerator, global.js, global.baseNodeDev, global.nodeEventProcessor, global.defaultConstants);
    global.baseNode = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _component, _classDecorator, _object, _debug, _eventEnum, _idGenerator, js, _baseNodeDev, _nodeEventProcessor, _defaultConstants) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.BaseNode = _exports.TRANSFORM_ON = void 0;
  _idGenerator = _interopRequireDefault(_idGenerator);
  js = _interopRequireWildcard(js);

  var _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _class3, _temp;

  function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _initializerDefineProperty(target, property, descriptor, context) { if (!descriptor) return; Object.defineProperty(target, property, { enumerable: descriptor.enumerable, configurable: descriptor.configurable, writable: descriptor.writable, value: descriptor.initializer ? descriptor.initializer.call(context) : void 0 }); }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _initializerWarningHelper(descriptor, context) { throw new Error('Decorating class property failed. Please ensure that ' + 'proposal-class-properties is enabled and runs after the decorators transform.'); }

  function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

  // @ts-ignore
  var Destroying = _object.CCObject.Flags.Destroying; // @ts-ignore

  var DontDestroy = _object.CCObject.Flags.DontDestroy; // @ts-ignore

  var Deactivating = _object.CCObject.Flags.Deactivating; // @ts-ignore

  var Activating = _object.CCObject.Flags.Activating;
  var ChangingState = Activating | Deactivating;
  var TRANSFORM_ON = 1 << 0; // const CHILD_ADDED = 'child-added';
  // const CHILD_REMOVED = 'child-removed';

  _exports.TRANSFORM_ON = TRANSFORM_ON;
  var idGenerator = new _idGenerator.default('Node');
  var NullScene = null;

  function getConstructor(typeOrClassName) {
    if (!typeOrClassName) {
      (0, _debug.errorID)(3804);
      return null;
    }

    if (typeof typeOrClassName === 'string') {
      return js.getClassByName(typeOrClassName);
    }

    return typeOrClassName;
  }
  /**
   * @en The base class for [[Node]], it:
   * - maintains scene hierarchy and life cycle logic
   * - provides EventTarget ability
   * - emits events if some properties changed, ref: [[SystemEventType]]
   * - manages components
   * @zh [[Node]] 的基类，他会负责：
   * - 维护场景树以及节点生命周期管理
   * - 提供 EventTarget 的事件管理和注册能力
   * - 派发节点状态相关的事件，参考：[[SystemEventType]]
   * - 管理组件
   */


  var BaseNode = (_dec = (0, _classDecorator.ccclass)('cc.BaseNode'), _dec(_class = (_class2 = (_temp = _class3 = /*#__PURE__*/function (_CCObject) {
    _inherits(BaseNode, _CCObject);

    _createClass(BaseNode, [{
      key: "components",

      /**
       * @en Gets all components attached to this node.
       * @zh 获取附加到此节点的所有组件。
       */
      get: function get() {
        return this._components;
      }
      /**
       * @en If true, the node is an persist node which won't be destroyed during scene transition.
       * If false, the node will be destroyed automatically when loading a new scene. Default is false.
       * @zh 如果为true，则该节点是一个常驻节点，不会在场景转换期间被销毁。
       * 如果为false，节点将在加载新场景时自动销毁。默认为 false。
       * @default false
       * @protected
       */

    }, {
      key: "_persistNode",
      get: function get() {
        return (this._objFlags & DontDestroy) > 0;
      },
      set: function set(value) {
        if (value) {
          this._objFlags |= DontDestroy;
        } else {
          this._objFlags &= ~DontDestroy;
        }
      } // API

      /**
       * @en Name of node.
       * @zh 该节点名称。
       */

    }, {
      key: "name",
      get: function get() {
        return this._name;
      },
      set: function set(value) {
        if (_defaultConstants.DEV && value.indexOf('/') !== -1) {
          (0, _debug.errorID)(1632);
          return;
        }

        this._name = value;
      }
      /**
       * @en The uuid for editor, will be stripped after building project.
       * @zh 主要用于编辑器的 uuid，在编辑器下可用于持久化存储，在项目构建之后将变成自增的 id。
       * @readOnly
       */

    }, {
      key: "uuid",
      get: function get() {
        return this._id;
      }
      /**
       * @en All children nodes.
       * @zh 节点的所有子节点。
       * @readOnly
       */

    }, {
      key: "children",
      get: function get() {
        return this._children;
      }
      /**
       * @en
       * The local active state of this node.
       * Note that a Node may be inactive because a parent is not active, even if this returns true.
       * Use [[activeInHierarchy]]
       * if you want to check if the Node is actually treated as active in the scene.
       * @zh
       * 当前节点的自身激活状态。
       * 值得注意的是，一个节点的父节点如果不被激活，那么即使它自身设为激活，它仍然无法激活。
       * 如果你想检查节点在场景中实际的激活状态可以使用 [[activeInHierarchy]]
       * @default true
       */

    }, {
      key: "active",
      get: function get() {
        return this._active;
      },
      set: function set(isActive) {
        if (this._active !== isActive) {
          this._active = isActive;
          var parent = this._parent;

          if (parent) {
            var couldActiveInScene = parent._activeInHierarchy;

            if (couldActiveInScene) {
              cc.director._nodeActivator.activateNode(this, isActive);
            }
          }
        }
      }
      /**
       * @en Indicates whether this node is active in the scene.
       * @zh 表示此节点是否在场景中激活。
       */

    }, {
      key: "activeInHierarchy",
      get: function get() {
        return this._activeInHierarchy;
      }
      /**
       * @en The parent node
       * @zh 父节点
       */

    }, {
      key: "parent",
      get: function get() {
        return this._parent;
      },
      set: function set(value) {
        this.setParent(value);
      }
      /**
       * @en Which scene this node belongs to.
       * @zh 此节点属于哪个场景。
       * @readonly
       */

    }, {
      key: "scene",
      get: function get() {
        return this._scene;
      }
      /**
       * @en The event processor of the current node, it provides EventTarget ability.
       * @zh 当前节点的事件处理器，提供 EventTarget 能力。
       * @readonly
       */

    }, {
      key: "eventProcessor",
      get: function get() {
        return this._eventProcessor;
      }
    }], [{
      key: "_setScene",
      value: function _setScene(node) {
        if (node instanceof cc.Scene) {
          node._scene = node;
        } else {
          if (node._parent == null) {
            cc.error('Node %s(%s) has not attached to a scene.', node.name, node.uuid);
          } else {
            node._scene = node._parent._scene;
          }
        }
      }
    }, {
      key: "_findComponent",
      value: function _findComponent(node, constructor) {
        var cls = constructor;
        var comps = node._components;

        if (cls._sealed) {
          for (var i = 0; i < comps.length; ++i) {
            var comp = comps[i];

            if (comp.constructor === constructor) {
              return comp;
            }
          }
        } else {
          for (var _i = 0; _i < comps.length; ++_i) {
            var _comp = comps[_i];

            if (_comp instanceof constructor) {
              return _comp;
            }
          }
        }

        return null;
      }
    }, {
      key: "_findComponents",
      value: function _findComponents(node, constructor, components) {
        var cls = constructor;
        var comps = node._components;

        if (cls._sealed) {
          for (var i = 0; i < comps.length; ++i) {
            var comp = comps[i];

            if (comp.constructor === constructor) {
              components.push(comp);
            }
          }
        } else {
          for (var _i2 = 0; _i2 < comps.length; ++_i2) {
            var _comp2 = comps[_i2];

            if (_comp2 instanceof constructor) {
              components.push(_comp2);
            }
          }
        }
      }
    }, {
      key: "_findChildComponent",
      value: function _findChildComponent(children, constructor) {
        for (var i = 0; i < children.length; ++i) {
          var node = children[i];

          var comp = BaseNode._findComponent(node, constructor);

          if (comp) {
            return comp;
          } else if (node._children.length > 0) {
            comp = BaseNode._findChildComponent(node._children, constructor);

            if (comp) {
              return comp;
            }
          }
        }

        return null;
      }
    }, {
      key: "_findChildComponents",
      value: function _findChildComponents(children, constructor, components) {
        for (var i = 0; i < children.length; ++i) {
          var node = children[i];

          BaseNode._findComponents(node, constructor, components);

          if (node._children.length > 0) {
            BaseNode._findChildComponents(node._children, constructor, components);
          }
        }
      }
    }]);

    function BaseNode(name) {
      var _this;

      _classCallCheck(this, BaseNode);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseNode).call(this, name));

      _initializerDefineProperty(_this, "_parent", _descriptor, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_children", _descriptor2, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_active", _descriptor3, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_components", _descriptor4, _assertThisInitialized(_this));

      _initializerDefineProperty(_this, "_prefab", _descriptor5, _assertThisInitialized(_this));

      _this._scene = NullScene;
      _this._activeInHierarchy = false;
      _this._id = idGenerator.getNewId();
      _this._name = void 0;
      _this._eventProcessor = new _nodeEventProcessor.NodeEventProcessor(_assertThisInitialized(_this));
      _this._eventMask = 0;
      _this._siblingIndex = 0;
      _this._registerIfAttached = !_defaultConstants.EDITOR ? undefined : function (register) {
        if (EditorExtends.Node && EditorExtends.Component) {
          if (register) {
            EditorExtends.Node.add(this._id, this);

            for (var i = 0; i < this._components.length; i++) {
              var comp = this._components[i];
              EditorExtends.Component.add(comp._id, comp);
            }
          } else {
            for (var _i3 = 0; _i3 < this._components.length; _i3++) {
              var _comp3 = this._components[_i3];
              EditorExtends.Component.remove(_comp3._id);
            }

            EditorExtends.Node.remove(this._id);
          }
        }

        var children = this._children;

        for (var _i4 = 0, len = children.length; _i4 < len; ++_i4) {
          var child = children[_i4];

          child._registerIfAttached(register);
        }
      };
      _this._name = name !== undefined ? name : 'New Node';
      return _this;
    }
    /**
     * @en
     * Properties configuration function.
     * All properties in attrs will be set to the node, 
     * when the setter of the node is available, 
     * the property will be set via setter function.
     * @zh 属性配置函数。在 attrs 的所有属性将被设置为节点属性。
     * @param attrs - Properties to be set to node
     * @example
     * ```
     * var attrs = { name: 'New Name', active: false };
     * node.attr(attrs);
     * ```
     */


    _createClass(BaseNode, [{
      key: "attr",
      value: function attr(attrs) {
        js.mixin(this, attrs);
      } // HIERARCHY METHODS

      /**
       * @en Get parent of the node.
       * @zh 获取该节点的父节点。
       */

    }, {
      key: "getParent",
      value: function getParent() {
        return this._parent;
      }
      /**
       * @en Set parent of the node.
       * @zh 设置该节点的父节点。
       */

    }, {
      key: "setParent",
      value: function setParent(value) {
        var keepWorldTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (this._parent === value) {
          return;
        }

        var oldParent = this._parent;
        var newParent = value;

        if (_defaultConstants.DEBUG && oldParent && // Change parent when old parent desactivating or activating
        oldParent._objFlags & ChangingState) {
          (0, _debug.errorID)(3821);
        }

        this._parent = newParent; // Reset sibling index

        this._siblingIndex = 0;

        this._onSetParent(oldParent, keepWorldTransform);

        if (this.emit) {
          this.emit(_eventEnum.SystemEventType.PARENT_CHANGED, oldParent);
        }

        if (newParent) {
          if (_defaultConstants.DEBUG && newParent._objFlags & Deactivating) {
            (0, _debug.errorID)(3821);
          }

          newParent._children.push(this);

          this._siblingIndex = newParent._children.length - 1;

          if (newParent.emit) {
            newParent.emit(_eventEnum.SystemEventType.CHILD_ADDED, this);
          }
        }

        if (oldParent) {
          if (!(oldParent._objFlags & Destroying)) {
            var removeAt = oldParent._children.indexOf(this);

            if (_defaultConstants.DEV && removeAt < 0) {
              return (0, _debug.errorID)(1633);
            }

            oldParent._children.splice(removeAt, 1);

            oldParent._updateSiblingIndex();

            if (oldParent.emit) {
              oldParent.emit(_eventEnum.SystemEventType.CHILD_REMOVED, this);
            }
          }
        }

        this._onHierarchyChanged(oldParent);
      }
      /**
       * @en Returns a child with the same uuid.
       * @zh 通过 uuid 获取节点的子节点。
       * @param uuid - The uuid to find the child node.
       * @return a Node whose uuid equals to the input parameter
       */

    }, {
      key: "getChildByUuid",
      value: function getChildByUuid(uuid) {
        if (!uuid) {
          cc.log('Invalid uuid');
          return null;
        }

        var locChildren = this._children;

        for (var i = 0, len = locChildren.length; i < len; i++) {
          if (locChildren[i]._id === uuid) {
            return locChildren[i];
          }
        }

        return null;
      }
      /**
       * @en Returns a child with the same name.
       * @zh 通过名称获取节点的子节点。
       * @param name - A name to find the child node.
       * @return a CCNode object whose name equals to the input parameter
       * @example
       * ```
       * var child = node.getChildByName("Test Node");
       * ```
       */

    }, {
      key: "getChildByName",
      value: function getChildByName(name) {
        if (!name) {
          cc.log('Invalid name');
          return null;
        }

        var locChildren = this._children;

        for (var i = 0, len = locChildren.length; i < len; i++) {
          if (locChildren[i]._name === name) {
            return locChildren[i];
          }
        }

        return null;
      }
      /**
       * @en Returns a child with the given path.
       * @zh 通过路径获取节点的子节点。
       * @param path - A path to find the child node.
       * @return a Node object whose path equals to the input parameter
       * @example
       * ```
       * var child = node.getChildByPath("subNode/Test Node");
       * ```
       */

    }, {
      key: "getChildByPath",
      value: function getChildByPath(path) {
        var segments = path.split('/');
        var lastNode = this;

        var _loop = function _loop(i) {
          var segment = segments[i];

          if (segment.length === 0) {
            return "continue";
          }

          var next = lastNode.children.find(function (childNode) {
            return childNode.name === segment;
          });

          if (!next) {
            return {
              v: null
            };
          }

          lastNode = next;
        };

        for (var i = 0; i < segments.length; ++i) {
          var _ret = _loop(i);

          switch (_ret) {
            case "continue":
              continue;

            default:
              if (_typeof(_ret) === "object") return _ret.v;
          }
        }

        return lastNode;
      }
      /**
       * @en Add a child to the current node, it will be pushed to the end of [[children]] array.
       * @zh 添加一个子节点，它会被添加到 [[children]] 数组的末尾。
       * @param child - the child node to be added
       */

    }, {
      key: "addChild",
      value: function addChild(child) {
        if (_defaultConstants.DEV && !(child instanceof cc._BaseNode)) {
          return (0, _debug.errorID)(1634, cc.js.getClassName(child));
        }

        cc.assertID(child, 1606);
        cc.assertID(child._parent === null, 1605); // invokes the parent setter

        child.setParent(this);
      }
      /**
       * @en Inserts a child to the node at a specified index.
       * @zh 插入子节点到指定位置
       * @param child - the child node to be inserted
       * @param siblingIndex - the sibling index to place the child in
       * @example
       * ```
       * node.insertChild(child, 2);
       * ```
       */

    }, {
      key: "insertChild",
      value: function insertChild(child, siblingIndex) {
        child.parent = this;
        child.setSiblingIndex(siblingIndex);
      }
      /**
       * @en Get the sibling index of the current node in its parent's children array.
       * @zh 获取当前节点在父节点的 children 数组中的位置。
       */

    }, {
      key: "getSiblingIndex",
      value: function getSiblingIndex() {
        return this._siblingIndex;
      }
      /**
       * @en Set the sibling index of the current node in its parent's children array.
       * @zh 设置当前节点在父节点的 children 数组中的位置。
       */

    }, {
      key: "setSiblingIndex",
      value: function setSiblingIndex(index) {
        if (!this._parent) {
          return;
        }

        if (this._parent._objFlags & Deactivating) {
          (0, _debug.errorID)(3821);
          return;
        }

        var siblings = this._parent._children;
        index = index !== -1 ? index : siblings.length - 1;
        var oldIndex = siblings.indexOf(this);

        if (index !== oldIndex) {
          siblings.splice(oldIndex, 1);

          if (index < siblings.length) {
            siblings.splice(index, 0, this);
          } else {
            siblings.push(this);
          }

          this._parent._updateSiblingIndex();

          if (this._onSiblingIndexChanged) {
            this._onSiblingIndexChanged(index);
          }
        }
      }
      /**
       * @en Walk though the sub children tree of the current node.
       * Each node, including the current node, in the sub tree will be visited two times,
       * before all children and after all children.
       * This function call is not recursive, it's based on stack.
       * Please don't walk any other node inside the walk process.
       * @zh 遍历该节点的子树里的所有节点并按规则执行回调函数。
       * 对子树中的所有节点，包含当前节点，会执行两次回调，preFunc 会在访问它的子节点之前调用，postFunc 会在访问所有子节点之后调用。
       * 这个函数的实现不是基于递归的，而是基于栈展开递归的方式。
       * 请不要在 walk 过程中对任何其他的节点嵌套执行 walk。
       * @param preFunc The callback to process node when reach the node for the first time
       * @param postFunc The callback to process node when re-visit the node after walked all children in its sub tree
       * @example
       * ```
       * node.walk(function (target) {
       *     console.log('Walked through node ' + target.name + ' for the first time');
       * }, function (target) {
       *     console.log('Walked through node ' + target.name + ' after walked all children in its sub tree');
       * });
       * ```
       */

    }, {
      key: "walk",
      value: function walk(preFunc, postFunc) {
        // const BaseNode = cc._BaseNode;
        var index = 1;
        var children = null;
        var curr = null;
        var i = 0;
        var stack = BaseNode._stacks[BaseNode._stackId];

        if (!stack) {
          stack = [];

          BaseNode._stacks.push(stack);
        }

        BaseNode._stackId++;
        stack.length = 0;
        stack[0] = this;
        var parent = null;
        var afterChildren = false;

        while (index) {
          index--;
          curr = stack[index];

          if (!curr) {
            continue;
          }

          if (!afterChildren && preFunc) {
            // pre call
            preFunc(curr);
          } else if (afterChildren && postFunc) {
            // post call
            postFunc(curr);
          } // Avoid memory leak


          stack[index] = null; // Do not repeatly visit child tree, just do post call and continue walk

          if (afterChildren) {
            afterChildren = false;
          } else {
            // Children not proceeded and has children, proceed to child tree
            if (curr._children.length > 0) {
              parent = curr;
              children = curr._children;
              i = 0;
              stack[index] = children[i];
              index++;
            } else {
              stack[index] = curr;
              index++;
              afterChildren = true;
            }

            continue;
          } // curr has no sub tree, so look into the siblings in parent children


          if (children) {
            i++; // Proceed to next sibling in parent children

            if (children[i]) {
              stack[index] = children[i];
              index++;
            } else if (parent) {
              stack[index] = parent;
              index++; // Setup parent walk env

              afterChildren = true;

              if (parent._parent) {
                children = parent._parent._children;
                i = children.indexOf(parent);
                parent = parent._parent;
              } else {
                // At root
                parent = null;
                children = null;
              } // ERROR


              if (i < 0) {
                break;
              }
            }
          }
        }

        stack.length = 0;
        BaseNode._stackId--;
      }
      /**
       * @en
       * Remove itself from its parent node. 
       * If the node have no parent, then nothing happens.
       * @zh
       * 从父节点中删除该节点。
       * 如果这个节点是一个孤立节点，那么什么都不会发生。
       */

    }, {
      key: "removeFromParent",
      value: function removeFromParent() {
        if (this._parent) {
          this._parent.removeChild(this);
        }
      }
      /**
       * @en Removes a child from the container.
       * @zh 移除节点中指定的子节点。
       * @param child - The child node which will be removed.
       */

    }, {
      key: "removeChild",
      value: function removeChild(child) {
        if (this._children.indexOf(child) > -1) {
          // invoke the parent setter
          child.parent = null;
        }
      }
      /**
       * @en Removes all children from the container.
       * @zh 移除节点所有的子节点。
       */

    }, {
      key: "removeAllChildren",
      value: function removeAllChildren() {
        // not using detachChild improves speed here
        var children = this._children;

        for (var i = children.length - 1; i >= 0; i--) {
          var node = children[i];

          if (node) {
            node.parent = null;
          }
        }

        this._children.length = 0;
      }
      /**
       * @en Is this node a child of the given node?
       * @zh 是否是指定节点的子节点？
       * @return True if this node is a child, deep child or identical to the given node.
       */

    }, {
      key: "isChildOf",
      value: function isChildOf(parent) {
        var child = this;

        do {
          if (child === parent) {
            return true;
          }

          child = child._parent;
        } while (child);

        return false;
      } // COMPONENT

      /**
       * @en
       * Returns the component of supplied type if the node has one attached, null if it doesn't. 
       * You can also get component in the node by passing in the name of the script.
       * @zh
       * 获取节点上指定类型的组件，如果节点有附加指定类型的组件，则返回，如果没有则为空。
       * 传入参数也可以是脚本的名称。
       * @param classConstructor The class of the target component
       * @example
       * ```
       * // get sprite component.
       * var sprite = node.getComponent(SpriteComponent);
       * ```
       */

    }, {
      key: "getComponent",
      value: function getComponent(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName);

        if (constructor) {
          return BaseNode._findComponent(this, constructor);
        }

        return null;
      }
      /**
       * @en Returns all components of given type in the node.
       * @zh 返回节点上指定类型的所有组件。
       * @param classConstructor The class of the target component
       */

    }, {
      key: "getComponents",
      value: function getComponents(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName);
        var components = [];

        if (constructor) {
          BaseNode._findComponents(this, constructor, components);
        }

        return components;
      }
      /**
       * @en Returns the component of given type in any of its children using depth first search.
       * @zh 递归查找所有子节点中第一个匹配指定类型的组件。
       * @param classConstructor The class of the target component
       * @example
       * ```
       * var sprite = node.getComponentInChildren(SpriteComponent);
       * ```
       */

    }, {
      key: "getComponentInChildren",
      value: function getComponentInChildren(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName);

        if (constructor) {
          return BaseNode._findChildComponent(this._children, constructor);
        }

        return null;
      }
      /**
       * @en Returns all components of given type in self or any of its children.
       * @zh 递归查找自身或所有子节点中指定类型的组件
       * @param classConstructor The class of the target component
       * @example
       * ```
       * var sprites = node.getComponentsInChildren(SpriteComponent);
       * ```
       */

    }, {
      key: "getComponentsInChildren",
      value: function getComponentsInChildren(typeOrClassName) {
        var constructor = getConstructor(typeOrClassName);
        var components = [];

        if (constructor) {
          BaseNode._findComponents(this, constructor, components);

          BaseNode._findChildComponents(this._children, constructor, components);
        }

        return components;
      }
      /**
       * @en Adds a component class to the node. You can also add component to node by passing in the name of the script.
       * @zh 向节点添加一个指定类型的组件类，你还可以通过传入脚本的名称来添加组件。
       * @param classConstructor The class of the component to add
       * @example
       * ```
       * var sprite = node.addComponent(SpriteComponent);
       * ```
       */

    }, {
      key: "addComponent",
      value: function addComponent(typeOrClassName) {
        if (_defaultConstants.EDITOR && this._objFlags & Destroying) {
          cc.error('isDestroying');
          return null;
        } // get component


        var constructor;

        if (typeof typeOrClassName === 'string') {
          constructor = js.getClassByName(typeOrClassName);

          if (!constructor) {
            (0, _debug.errorID)(3807, typeOrClassName);

            if (cc._RF.peek()) {
              (0, _debug.errorID)(3808, typeOrClassName);
            }

            return null;
          }
        } else {
          if (!typeOrClassName) {
            (0, _debug.errorID)(3804);
            return null;
          }

          constructor = typeOrClassName;
        } // check component


        if (typeof constructor !== 'function') {
          (0, _debug.errorID)(3809);
          return null;
        }

        if (!js.isChildClassOf(constructor, cc.Component)) {
          (0, _debug.errorID)(3810);
          return null;
        }

        if (_defaultConstants.EDITOR && constructor._disallowMultiple) {
          if (!this._checkMultipleComp(constructor)) {
            return null;
          }
        } // check requirement


        var ReqComp = constructor._requireComponent;

        if (ReqComp && !this.getComponent(ReqComp)) {
          var depended = this.addComponent(ReqComp);

          if (!depended) {
            // depend conflicts
            return null;
          }
        } //// check conflict
        //
        // if (EDITOR && !_Scene.DetectConflict.beforeAddComponent(this, constructor)) {
        //    return null;
        // }
        //


        var component = new constructor();
        component.node = this;

        this._components.push(component);

        if (_defaultConstants.EDITOR && EditorExtends.Node && EditorExtends.Component) {
          var node = EditorExtends.Node.getNode(this._id);

          if (node) {
            EditorExtends.Component.add(component._id, component);
          }
        }

        if (this._activeInHierarchy) {
          cc.director._nodeActivator.activateComp(component);
        }

        return component;
      }
      /**
       * @en
       * Removes a component identified by the given name or removes the component object given.
       * You can also use component.destroy() if you already have the reference.
       * @zh
       * 删除节点上的指定组件，传入参数可以是一个组件构造函数或组件名，也可以是已经获得的组件引用。
       * 如果你已经获得组件引用，你也可以直接调用 component.destroy()
       * @param classConstructor The class of the component to remove
       * @deprecated please destroy the component to remove it.
       * @example
       * ```
       * node.removeComponent(SpriteComponent);
       * ```
       */

    }, {
      key: "removeComponent",
      value: function removeComponent(component) {
        if (!component) {
          (0, _debug.errorID)(3813);
          return;
        }

        var componentInstance = null;

        if (component instanceof _component.Component) {
          componentInstance = component;
        } else {
          componentInstance = this.getComponent(component);
        }

        if (componentInstance) {
          componentInstance.destroy();
        }
      } // EVENT PROCESSING

      /**
       * @en
       * Register a callback of a specific event type on Node.
       * Use this method to register touch or mouse event permit propagation based on scene graph,
       * These kinds of event are triggered with dispatchEvent, the dispatch process has three steps:
       * 1. Capturing phase: dispatch in capture targets (`_getCapturingTargets`), e.g. parents in node tree, from root to the real target
       * 2. At target phase: dispatch to the listeners of the real target
       * 3. Bubbling phase: dispatch in bubble targets (`_getBubblingTargets`), e.g. parents in node tree, from the real target to root
       * In any moment of the dispatching process, it can be stopped via `event.stopPropagation()` or `event.stopPropagationImmidiate()`.
       * It's the recommended way to register touch/mouse event for Node,
       * please do not use cc.eventManager directly for Node.
       * You can also register custom event and use `emit` to trigger custom event on Node.
       * For such events, there won't be capturing and bubbling phase, your event will be dispatched directly to its listeners registered on the same node.
       * You can also pass event callback parameters with `emit` by passing parameters after `type`.
       * @zh
       * 在节点上注册指定类型的回调函数，也可以设置 target 用于绑定响应函数的 this 对象。
       * 鼠标或触摸事件会被系统调用 dispatchEvent 方法触发，触发的过程包含三个阶段：
       * 1. 捕获阶段：派发事件给捕获目标（通过 `_getCapturingTargets` 获取），比如，节点树中注册了捕获阶段的父节点，从根节点开始派发直到目标节点。
       * 2. 目标阶段：派发给目标节点的监听器。
       * 3. 冒泡阶段：派发事件给冒泡目标（通过 `_getBubblingTargets` 获取），比如，节点树中注册了冒泡阶段的父节点，从目标节点开始派发直到根节点。
       * 同时您可以将事件派发到父节点或者通过调用 stopPropagation 拦截它。
       * 推荐使用这种方式来监听节点上的触摸或鼠标事件，请不要在节点上直接使用 cc.eventManager。
       * 你也可以注册自定义事件到节点上，并通过 emit 方法触发此类事件，对于这类事件，不会发生捕获冒泡阶段，只会直接派发给注册在该节点上的监听器
       * 你可以通过在 emit 方法调用时在 type 之后传递额外的参数作为事件回调的参数列表
       * @param type - A string representing the event type to listen for.<br>See {{#crossLink "Node/EventTyupe/POSITION_CHANGED"}}Node Events{{/crossLink}} for all builtin events.
       * @param callback - The callback that will be invoked when the event is dispatched. The callback is ignored if it is a duplicate (the callbacks are unique).
       * @param target - The target (this object) to invoke the callback, can be null
       * @param useCapture - When set to true, the listener will be triggered at capturing phase which is ahead of the final target emit, otherwise it will be triggered during bubbling phase.
       * @return - Just returns the incoming callback so you can save the anonymous function easier.
       * @example
       * ```typescript
       * this.node.on(SystemEventType.TOUCH_START, this.memberFunction, this);  // if "this" is component and the "memberFunction" declared in CCClass.
       * node.on(SystemEventType.TOUCH_START, callback, this);
       * node.on(SystemEventType.TOUCH_MOVE, callback, this);
       * node.on(SystemEventType.TOUCH_END, callback, this);
       * ```
       */

    }, {
      key: "on",
      value: function on(type, callback, target) {
        var useCapture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        switch (type) {
          case _eventEnum.SystemEventType.TRANSFORM_CHANGED:
            this._eventMask |= TRANSFORM_ON;
            break;
        }

        this._eventProcessor.on(type, callback, target, useCapture);
      }
      /**
       * @en
       * Removes the callback previously registered with the same type, callback, target and or useCapture.
       * This method is merely an alias to removeEventListener.
       * @zh 删除之前与同类型，回调，目标或 useCapture 注册的回调。
       * @param type - A string representing the event type being removed.
       * @param callback - The callback to remove.
       * @param target - The target (this object) to invoke the callback, if it's not given, only callback without target will be removed
       * @param useCapture - When set to true, the listener will be triggered at capturing phase which is ahead of the final target emit, otherwise it will be triggered during bubbling phase.
       * @example
       * ```typescript
       * this.node.off(SystemEventType.TOUCH_START, this.memberFunction, this);
       * node.off(SystemEventType.TOUCH_START, callback, this.node);
       * ```
       */

    }, {
      key: "off",
      value: function off(type, callback, target) {
        var useCapture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

        this._eventProcessor.off(type, callback, target, useCapture);

        var hasListeners = this._eventProcessor.hasEventListener(type); // All listener removed


        if (!hasListeners) {
          switch (type) {
            case _eventEnum.SystemEventType.TRANSFORM_CHANGED:
              this._eventMask &= ~TRANSFORM_ON;
              break;
          }
        }
      }
      /**
       * @en
       * Register an callback of a specific event type on the Node,
       * the callback will remove itself after the first time it is triggered.
       * @zh
       * 注册节点的特定事件类型回调，回调会在第一时间被触发后删除自身。
       *
       * @param type - A string representing the event type to listen for.
       * @param callback - The callback that will be invoked when the event is dispatched.
       *                              The callback is ignored if it is a duplicate (the callbacks are unique).
       * @param target - The target (this object) to invoke the callback, can be null
       */

    }, {
      key: "once",
      value: function once(type, callback, target, useCapture) {
        this._eventProcessor.once(type, callback, target, useCapture);
      }
      /**
       * @en
       * Trigger an event directly with the event name and necessary arguments.
       * @zh
       * 通过事件名发送自定义事件
       * @param type - event type
       * @param arg1 - First argument in callback
       * @param arg2 - Second argument in callback
       * @param arg3 - Third argument in callback
       * @param arg4 - Fourth argument in callback
       * @param arg5 - Fifth argument in callback
       * @example
       * ```typescript
       * eventTarget.emit('fire', event);
       * eventTarget.emit('fire', message, emitter);
       * ```
       */

    }, {
      key: "emit",
      value: function emit(type, arg0, arg1, arg2, arg3, arg4) {
        this._eventProcessor.emit(type, arg0, arg1, arg2, arg3, arg4);
      }
      /**
       * @en
       * Dispatches an event into the event flow.
       * The event target is the EventTarget object upon which the dispatchEvent() method is called.
       * @zh 分发事件到事件流中。
       * @param event - The Event object that is dispatched into the event flow
       */

    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        this._eventProcessor.dispatchEvent(event);
      }
      /**
       * @en Checks whether the EventTarget object has any callback registered for a specific type of event.
       * @zh 检查事件目标对象是否有为特定类型的事件注册的回调。
       * @param type - The type of event.
       * @param callback - The callback function of the event listener, if absent all event listeners for the given type will be removed
       * @param target - The callback callee of the event listener
       * @return True if a callback of the specified type is registered; false otherwise.
       */

    }, {
      key: "hasEventListener",
      value: function hasEventListener(type, callback, target) {
        return this._eventProcessor.hasEventListener(type, callback, target);
      }
      /**
       * @en Removes all callbacks previously registered with the same target.
       * @zh 移除目标上的所有注册事件。
       * @param target - The target to be searched for all related callbacks
       */

    }, {
      key: "targetOff",
      value: function targetOff(target) {
        this._eventProcessor.targetOff(target); // Check for event mask reset


        if (this._eventMask & TRANSFORM_ON && !this._eventProcessor.hasEventListener(_eventEnum.SystemEventType.TRANSFORM_CHANGED)) {
          this._eventMask &= ~TRANSFORM_ON;
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (_get(_getPrototypeOf(BaseNode.prototype), "destroy", this).call(this)) {
          // disable hierarchy
          if (this._activeInHierarchy) {
            this._disableChildComps();
          }

          return true;
        }

        return false;
      }
      /**
       * @en
       * Destroy all children from the node, and release all their own references to other objects.
       * Actual destruct operation will delayed until before rendering.
       * @zh
       * 销毁所有子节点，并释放所有它们对其它对象的引用。
       * 实际销毁操作会延迟到当前帧渲染前执行。
       */

    }, {
      key: "destroyAllChildren",
      value: function destroyAllChildren() {
        var children = this._children;

        for (var i = 0; i < children.length; ++i) {
          children[i].destroy();
        }
      } // Do remove component, only used internally.

    }, {
      key: "_removeComponent",
      value: function _removeComponent(component) {
        if (!component) {
          (0, _debug.errorID)(3814);
          return;
        }

        if (!(this._objFlags & Destroying)) {
          var i = this._components.indexOf(component);

          if (i !== -1) {
            this._components.splice(i, 1);

            if (_defaultConstants.EDITOR && EditorExtends.Component) {
              EditorExtends.Component.remove(component._id);
            }
          } // @ts-ignore
          else if (component.node !== this) {
              (0, _debug.errorID)(3815);
            }
        }
      }
    }, {
      key: "_updateSiblingIndex",
      value: function _updateSiblingIndex() {
        for (var i = 0; i < this._children.length; ++i) {
          this._children[i]._siblingIndex = i;
        }
      }
    }, {
      key: "_onSetParent",
      value: function _onSetParent(oldParent) {
        var keepWorldTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (this._parent) {
          if ((oldParent == null || oldParent._scene !== this._parent._scene) && this._parent._scene != null) {
            this.walk(function (node) {
              BaseNode._setScene(node);
            });
          }
        }
      } // PRIVATE

    }, {
      key: "_onPostActivated",
      value: function _onPostActivated(active) {
        return;
      }
    }, {
      key: "_onBatchRestored",
      value: function _onBatchRestored() {
        return;
      }
    }, {
      key: "_onBatchCreated",
      value: function _onBatchCreated() {
        if (this._parent) {
          this._siblingIndex = this._parent.children.indexOf(this);
        }

        return;
      }
    }, {
      key: "_onPreDestroy",
      value: function _onPreDestroy() {
        this._onPreDestroyBase();
      }
    }, {
      key: "_onHierarchyChanged",
      value: function _onHierarchyChanged(oldParent) {
        return this._onHierarchyChangedBase(oldParent);
      }
    }, {
      key: "_instantiate",
      value: function _instantiate(cloned) {
        if (!cloned) {
          cloned = cc.instantiate._clone(this, this);
        }

        var thisPrefabInfo = this._prefab;

        if (_defaultConstants.EDITOR && thisPrefabInfo) {
          if (this !== thisPrefabInfo.root) {}
        }

        var syncing = thisPrefabInfo && this === thisPrefabInfo.root && thisPrefabInfo.sync;

        if (syncing) {// if (thisPrefabInfo._synced) {
          //    return clone;
          // }
        } else if (_defaultConstants.EDITOR && cc.engine._isPlaying) {
          cloned._name += ' (Clone)';
        } // reset and init


        cloned._parent = null;

        cloned._onBatchRestored();

        return cloned;
      }
    }, {
      key: "_onHierarchyChangedBase",
      value: function _onHierarchyChangedBase(oldParent) {
        var newParent = this._parent;

        if (this._persistNode && !(newParent instanceof cc.Scene)) {
          cc.game.removePersistRootNode(this);

          if (_defaultConstants.EDITOR) {
            (0, _debug.warnID)(1623);
          }
        }

        if (_defaultConstants.EDITOR) {
          var scene = cc.director.getScene();
          var inCurrentSceneBefore = oldParent && oldParent.isChildOf(scene);
          var inCurrentSceneNow = newParent && newParent.isChildOf(scene);

          if (!inCurrentSceneBefore && inCurrentSceneNow) {
            // attached
            this._registerIfAttached(true);
          } else if (inCurrentSceneBefore && !inCurrentSceneNow) {
            // detached
            this._registerIfAttached(false);
          } // conflict detection
          // _Scene.DetectConflict.afterAddChild(this);

        }

        var shouldActiveNow = this._active && !!(newParent && newParent._activeInHierarchy);

        if (this._activeInHierarchy !== shouldActiveNow) {
          cc.director._nodeActivator.activateNode(this, shouldActiveNow);
        }
      }
    }, {
      key: "_onPreDestroyBase",
      value: function _onPreDestroyBase() {
        // marked as destroying
        this._objFlags |= Destroying; // detach self and children from editor

        var parent = this._parent;
        var destroyByParent = !!parent && (parent._objFlags & Destroying) !== 0;

        if (!destroyByParent && _defaultConstants.EDITOR) {
          this._registerIfAttached(false);
        } // remove from persist


        if (this._persistNode) {
          cc.game.removePersistRootNode(this);
        }

        if (!destroyByParent) {
          // remove from parent
          if (parent) {
            this.emit(_eventEnum.SystemEventType.PARENT_CHANGED, this); // During destroy process, siblingIndex is not relyable

            var childIndex = parent._children.indexOf(this);

            parent._children.splice(childIndex, 1);

            this._siblingIndex = 0;

            if (parent.emit) {
              parent.emit(_eventEnum.SystemEventType.CHILD_REMOVED, this);
            }
          }
        } // emit node destroy event (this should before event processor destroy)


        this.emit(_eventEnum.SystemEventType.NODE_DESTROYED, this); // Destroy node event processor

        this._eventProcessor.destroy(); // destroy children


        var children = this._children;

        for (var i = 0; i < children.length; ++i) {
          // destroy immediate so its _onPreDestroy can be called
          children[i]._destroyImmediate();
        } // destroy self components


        var comps = this._components;

        for (var _i5 = 0; _i5 < comps.length; ++_i5) {
          // destroy immediate so its _onPreDestroy can be called
          // TO DO
          comps[_i5]._destroyImmediate();
        }

        return destroyByParent;
      }
    }, {
      key: "_disableChildComps",
      value: function _disableChildComps() {
        // leave this._activeInHierarchy unmodified
        var comps = this._components;

        for (var i = 0; i < comps.length; ++i) {
          var component = comps[i];

          if (component._enabled) {
            cc.director._compScheduler.disableComp(component);
          }
        } // deactivate recursively


        var children = this._children;

        for (var _i6 = 0; _i6 < children.length; ++_i6) {
          var node = children[_i6];

          if (node._active) {
            node._disableChildComps();
          }
        }
      }
    }]);

    return BaseNode;
  }(_object.CCObject), _class3.idGenerator = idGenerator, _class3._stacks = [[]], _class3._stackId = 0, _temp), (_applyDecoratedDescriptor(_class2.prototype, "_persistNode", [_classDecorator.property], Object.getOwnPropertyDescriptor(_class2.prototype, "_persistNode"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "name", [_classDecorator.property], Object.getOwnPropertyDescriptor(_class2.prototype, "name"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "uuid", [_classDecorator.property], Object.getOwnPropertyDescriptor(_class2.prototype, "uuid"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "children", [_classDecorator.property], Object.getOwnPropertyDescriptor(_class2.prototype, "children"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "active", [_classDecorator.property], Object.getOwnPropertyDescriptor(_class2.prototype, "active"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "activeInHierarchy", [_classDecorator.property], Object.getOwnPropertyDescriptor(_class2.prototype, "activeInHierarchy"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "parent", [_classDecorator.property], Object.getOwnPropertyDescriptor(_class2.prototype, "parent"), _class2.prototype), _descriptor = _applyDecoratedDescriptor(_class2.prototype, "_parent", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return null;
    }
  }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_children", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return [];
    }
  }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "_active", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return true;
    }
  }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "_components", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return [];
    }
  }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "_prefab", [_classDecorator.property], {
    configurable: true,
    enumerable: true,
    writable: true,
    initializer: function initializer() {
      return null;
    }
  })), _class2)) || _class);
  _exports.BaseNode = BaseNode;
  (0, _baseNodeDev.baseNodePolyfill)(BaseNode);
  /**
   * @en
   * Note: This event is only emitted from the top most node whose active value did changed,
   * not including its child nodes.
   * @zh
   * 注意：此节点激活时，此事件仅从最顶部的节点发出。
   * @event active-in-hierarchy-changed
   * @param {Event.EventCustom} event
   */

  cc._BaseNode = BaseNode;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkY6L2plbmtpbnMvd29ya3NwYWNlL0NyZWF0b3JfM0QvZWRpdG9yLTNkL3Jlc291cmNlcy8zZC9lbmdpbmUvY29jb3MvY29yZS9zY2VuZS1ncmFwaC9iYXNlLW5vZGUudHMiXSwibmFtZXMiOlsiRGVzdHJveWluZyIsIkNDT2JqZWN0IiwiRmxhZ3MiLCJEb250RGVzdHJveSIsIkRlYWN0aXZhdGluZyIsIkFjdGl2YXRpbmciLCJDaGFuZ2luZ1N0YXRlIiwiVFJBTlNGT1JNX09OIiwiaWRHZW5lcmF0b3IiLCJJZEdlbmVyYXRvciIsIk51bGxTY2VuZSIsImdldENvbnN0cnVjdG9yIiwidHlwZU9yQ2xhc3NOYW1lIiwianMiLCJnZXRDbGFzc0J5TmFtZSIsIkJhc2VOb2RlIiwiX2NvbXBvbmVudHMiLCJfb2JqRmxhZ3MiLCJ2YWx1ZSIsIl9uYW1lIiwiREVWIiwiaW5kZXhPZiIsIl9pZCIsIl9jaGlsZHJlbiIsIl9hY3RpdmUiLCJpc0FjdGl2ZSIsInBhcmVudCIsIl9wYXJlbnQiLCJjb3VsZEFjdGl2ZUluU2NlbmUiLCJfYWN0aXZlSW5IaWVyYXJjaHkiLCJjYyIsImRpcmVjdG9yIiwiX25vZGVBY3RpdmF0b3IiLCJhY3RpdmF0ZU5vZGUiLCJzZXRQYXJlbnQiLCJfc2NlbmUiLCJfZXZlbnRQcm9jZXNzb3IiLCJub2RlIiwiU2NlbmUiLCJlcnJvciIsIm5hbWUiLCJ1dWlkIiwiY29uc3RydWN0b3IiLCJjbHMiLCJjb21wcyIsIl9zZWFsZWQiLCJpIiwibGVuZ3RoIiwiY29tcCIsImNvbXBvbmVudHMiLCJwdXNoIiwiY2hpbGRyZW4iLCJfZmluZENvbXBvbmVudCIsIl9maW5kQ2hpbGRDb21wb25lbnQiLCJfZmluZENvbXBvbmVudHMiLCJfZmluZENoaWxkQ29tcG9uZW50cyIsImdldE5ld0lkIiwiTm9kZUV2ZW50UHJvY2Vzc29yIiwiX2V2ZW50TWFzayIsIl9zaWJsaW5nSW5kZXgiLCJfcmVnaXN0ZXJJZkF0dGFjaGVkIiwiRURJVE9SIiwidW5kZWZpbmVkIiwicmVnaXN0ZXIiLCJFZGl0b3JFeHRlbmRzIiwiTm9kZSIsIkNvbXBvbmVudCIsImFkZCIsInJlbW92ZSIsImxlbiIsImNoaWxkIiwiYXR0cnMiLCJtaXhpbiIsImtlZXBXb3JsZFRyYW5zZm9ybSIsIm9sZFBhcmVudCIsIm5ld1BhcmVudCIsIkRFQlVHIiwiX29uU2V0UGFyZW50IiwiZW1pdCIsIlN5c3RlbUV2ZW50VHlwZSIsIlBBUkVOVF9DSEFOR0VEIiwiQ0hJTERfQURERUQiLCJyZW1vdmVBdCIsInNwbGljZSIsIl91cGRhdGVTaWJsaW5nSW5kZXgiLCJDSElMRF9SRU1PVkVEIiwiX29uSGllcmFyY2h5Q2hhbmdlZCIsImxvZyIsImxvY0NoaWxkcmVuIiwicGF0aCIsInNlZ21lbnRzIiwic3BsaXQiLCJsYXN0Tm9kZSIsInNlZ21lbnQiLCJuZXh0IiwiZmluZCIsImNoaWxkTm9kZSIsIl9CYXNlTm9kZSIsImdldENsYXNzTmFtZSIsImFzc2VydElEIiwic2libGluZ0luZGV4Iiwic2V0U2libGluZ0luZGV4IiwiaW5kZXgiLCJzaWJsaW5ncyIsIm9sZEluZGV4IiwiX29uU2libGluZ0luZGV4Q2hhbmdlZCIsInByZUZ1bmMiLCJwb3N0RnVuYyIsImN1cnIiLCJzdGFjayIsIl9zdGFja3MiLCJfc3RhY2tJZCIsImFmdGVyQ2hpbGRyZW4iLCJyZW1vdmVDaGlsZCIsIl9SRiIsInBlZWsiLCJpc0NoaWxkQ2xhc3NPZiIsIl9kaXNhbGxvd011bHRpcGxlIiwiX2NoZWNrTXVsdGlwbGVDb21wIiwiUmVxQ29tcCIsIl9yZXF1aXJlQ29tcG9uZW50IiwiZ2V0Q29tcG9uZW50IiwiZGVwZW5kZWQiLCJhZGRDb21wb25lbnQiLCJjb21wb25lbnQiLCJnZXROb2RlIiwiYWN0aXZhdGVDb21wIiwiY29tcG9uZW50SW5zdGFuY2UiLCJkZXN0cm95IiwidHlwZSIsImNhbGxiYWNrIiwidGFyZ2V0IiwidXNlQ2FwdHVyZSIsIlRSQU5TRk9STV9DSEFOR0VEIiwib24iLCJvZmYiLCJoYXNMaXN0ZW5lcnMiLCJoYXNFdmVudExpc3RlbmVyIiwib25jZSIsImFyZzAiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJhcmc0IiwiZXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwidGFyZ2V0T2ZmIiwiX2Rpc2FibGVDaGlsZENvbXBzIiwid2FsayIsIl9zZXRTY2VuZSIsImFjdGl2ZSIsIl9vblByZURlc3Ryb3lCYXNlIiwiX29uSGllcmFyY2h5Q2hhbmdlZEJhc2UiLCJjbG9uZWQiLCJpbnN0YW50aWF0ZSIsIl9jbG9uZSIsInRoaXNQcmVmYWJJbmZvIiwiX3ByZWZhYiIsInJvb3QiLCJzeW5jaW5nIiwic3luYyIsImVuZ2luZSIsIl9pc1BsYXlpbmciLCJfb25CYXRjaFJlc3RvcmVkIiwiX3BlcnNpc3ROb2RlIiwiZ2FtZSIsInJlbW92ZVBlcnNpc3RSb290Tm9kZSIsInNjZW5lIiwiZ2V0U2NlbmUiLCJpbkN1cnJlbnRTY2VuZUJlZm9yZSIsImlzQ2hpbGRPZiIsImluQ3VycmVudFNjZW5lTm93Iiwic2hvdWxkQWN0aXZlTm93IiwiZGVzdHJveUJ5UGFyZW50IiwiY2hpbGRJbmRleCIsIk5PREVfREVTVFJPWUVEIiwiX2Rlc3Ryb3lJbW1lZGlhdGUiLCJfZW5hYmxlZCIsIl9jb21wU2NoZWR1bGVyIiwiZGlzYWJsZUNvbXAiLCJwcm9wZXJ0eSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThDQTtBQUNBLE1BQU1BLFVBQVUsR0FBR0MsaUJBQVNDLEtBQVQsQ0FBZUYsVUFBbEMsQyxDQUNBOztBQUNBLE1BQU1HLFdBQVcsR0FBR0YsaUJBQVNDLEtBQVQsQ0FBZUMsV0FBbkMsQyxDQUNBOztBQUNBLE1BQU1DLFlBQVksR0FBR0gsaUJBQVNDLEtBQVQsQ0FBZUUsWUFBcEMsQyxDQUNBOztBQUNBLE1BQU1DLFVBQVUsR0FBR0osaUJBQVNDLEtBQVQsQ0FBZUcsVUFBbEM7QUFDQSxNQUFNQyxhQUFhLEdBQUdELFVBQVUsR0FBR0QsWUFBbkM7QUFF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LFNBQXRCOztBQUNBLGFBQUssSUFBSXVCLEdBQUMsR0FBRyxDQUFiLEVBQWdCQSxHQUFDLEdBQUdLLFFBQVEsQ0FBQ0osTUFBN0IsRUFBcUMsRUFBRUQsR0FBdkMsRUFBMEM7QUFDdEMsY0FBTVQsSUFBSSxHQUFHYyxRQUFRLENBQUNMLEdBQUQsQ0FBckI7O0FBQ0EsY0FBSVQsSUFBSSxDQUFDYixPQUFULEVBQWtCO0FBQ2RhLFlBQUFBLElBQUksQ0FBQzhHLGtCQUFMO0FBQ0g7QUFDSjtBQUNKOzs7O0lBanlDeUJsSixnQixXQW1KVE8sVyxHQUFjQSxXLFVBR2RzRyxPLEdBQTJDLENBQUMsRUFBRCxDLFVBQzNDQyxRLEdBQVcsQyx5RUF0STNCcUUsd0IsaUpBa0JBQSx3Qix5SUFpQkFBLHdCLDZJQVVBQSx3QiwrSUFpQkFBLHdCLHdKQXFCQUEsd0Isd0pBU0FBLHdCLDRKQStHQUEsd0I7Ozs7O2FBQ2dDLEk7O2dGQUVoQ0Esd0I7Ozs7O2FBQzZCLEU7OzhFQUU3QkEsd0I7Ozs7O2FBQ21CLEk7O2tGQUVuQkEsd0I7Ozs7O2FBQ29DLEU7OzhFQUdwQ0Esd0I7Ozs7O2FBQ3dCLEk7Ozs7QUE4akM3QixxQ0FBaUJySyxRQUFqQjtBQUVBOzs7Ozs7Ozs7O0FBVUFlLEVBQUFBLEVBQUUsQ0FBQ21FLFNBQUgsR0FBZWxGLFFBQWYiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gQ29weXJpZ2h0IChjKSAyMDE3LTIwMTggWGlhbWVuIFlhamkgU29mdHdhcmUgQ28uLCBMdGQuXHJcblxyXG4gaHR0cDovL3d3dy5jb2Nvcy5jb21cclxuXHJcbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XHJcbiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGVuZ2luZSBzb3VyY2UgY29kZSAodGhlIFwiU29mdHdhcmVcIiksIGEgbGltaXRlZCxcclxuICB3b3JsZHdpZGUsIHJveWFsdHktZnJlZSwgbm9uLWFzc2lnbmFibGUsIHJldm9jYWJsZSBhbmQgbm9uLWV4Y2x1c2l2ZSBsaWNlbnNlXHJcbiB0byB1c2UgQ29jb3MgQ3JlYXRvciBzb2xlbHkgdG8gZGV2ZWxvcCBnYW1lcyBvbiB5b3VyIHRhcmdldCBwbGF0Zm9ybXMuIFlvdSBzaGFsbFxyXG4gIG5vdCB1c2UgQ29jb3MgQ3JlYXRvciBzb2Z0d2FyZSBmb3IgZGV2ZWxvcGluZyBvdGhlciBzb2Z0d2FyZSBvciB0b29scyB0aGF0J3NcclxuICB1c2VkIGZvciBkZXZlbG9waW5nIGdhbWVzLiBZb3UgYXJlIG5vdCBncmFudGVkIHRvIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsXHJcbiAgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIENvY29zIENyZWF0b3IuXHJcblxyXG4gVGhlIHNvZnR3YXJlIG9yIHRvb2xzIGluIHRoaXMgTGljZW5zZSBBZ3JlZW1lbnQgYXJlIGxpY2Vuc2VkLCBub3Qgc29sZC5cclxuIFhpYW1lbiBZYWppIFNvZnR3YXJlIENvLiwgTHRkLiByZXNlcnZlcyBhbGwgcmlnaHRzIG5vdCBleHByZXNzbHkgZ3JhbnRlZCB0byB5b3UuXHJcblxyXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiBUSEUgU09GVFdBUkUuXHJcbiovXHJcblxyXG4vKipcclxuICogQGNhdGVnb3J5IHNjZW5lLWdyYXBoXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50cy9jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBjY2NsYXNzLCBwcm9wZXJ0eSB9IGZyb20gJy4uL2RhdGEvY2xhc3MtZGVjb3JhdG9yJztcclxuaW1wb3J0IHsgQ0NPYmplY3QgfSBmcm9tICcuLi9kYXRhL29iamVjdCc7XHJcbmltcG9ydCB7IEV2ZW50IH0gZnJvbSAnLi4vZXZlbnQnO1xyXG5pbXBvcnQgeyBlcnJvcklELCB3YXJuSUQgfSBmcm9tICcuLi9wbGF0Zm9ybS9kZWJ1Zyc7XHJcbmltcG9ydCB7IFN5c3RlbUV2ZW50VHlwZSB9IGZyb20gJy4uL3BsYXRmb3JtL2V2ZW50LW1hbmFnZXIvZXZlbnQtZW51bSc7XHJcbmltcG9ydCB7IElTY2hlZHVsYWJsZSB9IGZyb20gJy4uL3NjaGVkdWxlcic7XHJcbmltcG9ydCBJZEdlbmVyYXRvciBmcm9tICcuLi91dGlscy9pZC1nZW5lcmF0b3InO1xyXG5pbXBvcnQgKiBhcyBqcyBmcm9tICcuLi91dGlscy9qcyc7XHJcbmltcG9ydCB7IGJhc2VOb2RlUG9seWZpbGwgfSBmcm9tICcuL2Jhc2Utbm9kZS1kZXYnO1xyXG5pbXBvcnQgeyBOb2RlRXZlbnRQcm9jZXNzb3IgfSBmcm9tICcuL25vZGUtZXZlbnQtcHJvY2Vzc29yJztcclxuaW1wb3J0IHsgREVWLCBERUJVRywgRURJVE9SIH0gZnJvbSAnaW50ZXJuYWw6Y29uc3RhbnRzJztcclxuaW1wb3J0IHsgTm9kZSB9IGZyb20gJy4vbm9kZSc7XHJcbmltcG9ydCB7IFNjZW5lIH0gZnJvbSAnLi9zY2VuZSc7XHJcblxyXG50eXBlIENvbnN0cnVjdG9yPFQgPSB7fT4gPSBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBUO1xyXG5cclxuLy8gQHRzLWlnbm9yZVxyXG5jb25zdCBEZXN0cm95aW5nID0gQ0NPYmplY3QuRmxhZ3MuRGVzdHJveWluZztcclxuLy8gQHRzLWlnbm9yZVxyXG5jb25zdCBEb250RGVzdHJveSA9IENDT2JqZWN0LkZsYWdzLkRvbnREZXN0cm95O1xyXG4vLyBAdHMtaWdub3JlXHJcbmNvbnN0IERlYWN0aXZhdGluZyA9IENDT2JqZWN0LkZsYWdzLkRlYWN0aXZhdGluZztcclxuLy8gQHRzLWlnbm9yZVxyXG5jb25zdCBBY3RpdmF0aW5nID0gQ0NPYmplY3QuRmxhZ3MuQWN0aXZhdGluZztcclxuY29uc3QgQ2hhbmdpbmdTdGF0ZSA9IEFjdGl2YXRpbmcgfCBEZWFjdGl2YXRpbmc7XHJcblxyXG5leHBvcnQgY29uc3QgVFJBTlNGT1JNX09OID0gMSA8PCAwO1xyXG5cclxuLy8gY29uc3QgQ0hJTERfQURERUQgPSAnY2hpbGQtYWRkZWQnO1xyXG4vLyBjb25zdCBDSElMRF9SRU1PVkVEID0gJ2NoaWxkLXJlbW92ZWQnO1xyXG5cclxuY29uc3QgaWRHZW5lcmF0b3IgPSBuZXcgSWRHZW5lcmF0b3IoJ05vZGUnKTtcclxuXHJcbmNvbnN0IE51bGxTY2VuZSA9IG51bGw7XHJcblxyXG5mdW5jdGlvbiBnZXRDb25zdHJ1Y3RvciAodHlwZU9yQ2xhc3NOYW1lOiBzdHJpbmcgfCBGdW5jdGlvbik6IEZ1bmN0aW9uIHwgbnVsbCB7XHJcbiAgICBpZiAoIXR5cGVPckNsYXNzTmFtZSkge1xyXG4gICAgICAgIGVycm9ySUQoMzgwNCk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHR5cGVPckNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4ganMuZ2V0Q2xhc3NCeU5hbWUodHlwZU9yQ2xhc3NOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHlwZU9yQ2xhc3NOYW1lO1xyXG59XHJcblxyXG4vKipcclxuICogQGVuIFRoZSBiYXNlIGNsYXNzIGZvciBbW05vZGVdXSwgaXQ6XHJcbiAqIC0gbWFpbnRhaW5zIHNjZW5lIGhpZXJhcmNoeSBhbmQgbGlmZSBjeWNsZSBsb2dpY1xyXG4gKiAtIHByb3ZpZGVzIEV2ZW50VGFyZ2V0IGFiaWxpdHlcclxuICogLSBlbWl0cyBldmVudHMgaWYgc29tZSBwcm9wZXJ0aWVzIGNoYW5nZWQsIHJlZjogW1tTeXN0ZW1FdmVudFR5cGVdXVxyXG4gKiAtIG1hbmFnZXMgY29tcG9uZW50c1xyXG4gKiBAemggW1tOb2RlXV0g55qE5Z+657G777yM5LuW5Lya6LSf6LSj77yaXHJcbiAqIC0g57u05oqk5Zy65pmv5qCR5Lul5Y+K6IqC54K555Sf5ZG95ZGo5pyf566h55CGXHJcbiAqIC0g5o+Q5L6bIEV2ZW50VGFyZ2V0IOeahOS6i+S7tueuoeeQhuWSjOazqOWGjOiDveWKm1xyXG4gKiAtIOa0vuWPkeiKgueCueeKtuaAgeebuOWFs+eahOS6i+S7tu+8jOWPguiAg++8mltbU3lzdGVtRXZlbnRUeXBlXV1cclxuICogLSDnrqHnkIbnu4Tku7ZcclxuICovXHJcbkBjY2NsYXNzKCdjYy5CYXNlTm9kZScpXHJcbmV4cG9ydCBjbGFzcyBCYXNlTm9kZSBleHRlbmRzIENDT2JqZWN0IGltcGxlbWVudHMgSVNjaGVkdWxhYmxlIHtcclxuICAgIC8qKlxyXG4gICAgICogQGVuIEdldHMgYWxsIGNvbXBvbmVudHMgYXR0YWNoZWQgdG8gdGhpcyBub2RlLlxyXG4gICAgICogQHpoIOiOt+WPlumZhOWKoOWIsOatpOiKgueCueeahOaJgOaciee7hOS7tuOAglxyXG4gICAgICovXHJcbiAgICBnZXQgY29tcG9uZW50cyAoKTogUmVhZG9ubHlBcnJheTxDb21wb25lbnQ+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBJZiB0cnVlLCB0aGUgbm9kZSBpcyBhbiBwZXJzaXN0IG5vZGUgd2hpY2ggd29uJ3QgYmUgZGVzdHJveWVkIGR1cmluZyBzY2VuZSB0cmFuc2l0aW9uLlxyXG4gICAgICogSWYgZmFsc2UsIHRoZSBub2RlIHdpbGwgYmUgZGVzdHJveWVkIGF1dG9tYXRpY2FsbHkgd2hlbiBsb2FkaW5nIGEgbmV3IHNjZW5lLiBEZWZhdWx0IGlzIGZhbHNlLlxyXG4gICAgICogQHpoIOWmguaenOS4unRydWXvvIzliJnor6XoioLngrnmmK/kuIDkuKrluLjpqbvoioLngrnvvIzkuI3kvJrlnKjlnLrmma/ovazmjaLmnJ/pl7TooqvplIDmr4HjgIJcclxuICAgICAqIOWmguaenOS4umZhbHNl77yM6IqC54K55bCG5Zyo5Yqg6L295paw5Zy65pmv5pe26Ieq5Yqo6ZSA5q+B44CC6buY6K6k5Li6IGZhbHNl44CCXHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBAcHJvcGVydHlcclxuICAgIGdldCBfcGVyc2lzdE5vZGUgKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5fb2JqRmxhZ3MgJiBEb250RGVzdHJveSkgPiAwO1xyXG4gICAgfVxyXG4gICAgc2V0IF9wZXJzaXN0Tm9kZSAodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fb2JqRmxhZ3MgfD0gRG9udERlc3Ryb3k7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fb2JqRmxhZ3MgJj0gfkRvbnREZXN0cm95O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBUElcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBOYW1lIG9mIG5vZGUuXHJcbiAgICAgKiBAemgg6K+l6IqC54K55ZCN56ew44CCXHJcbiAgICAgKi9cclxuICAgIEBwcm9wZXJ0eVxyXG4gICAgZ2V0IG5hbWUgKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICB9XHJcbiAgICBzZXQgbmFtZSAodmFsdWUpIHtcclxuICAgICAgICBpZiAoREVWICYmIHZhbHVlLmluZGV4T2YoJy8nKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgZXJyb3JJRCgxNjMyKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9uYW1lID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gVGhlIHV1aWQgZm9yIGVkaXRvciwgd2lsbCBiZSBzdHJpcHBlZCBhZnRlciBidWlsZGluZyBwcm9qZWN0LlxyXG4gICAgICogQHpoIOS4u+imgeeUqOS6jue8lui+keWZqOeahCB1dWlk77yM5Zyo57yW6L6R5Zmo5LiL5Y+v55So5LqO5oyB5LmF5YyW5a2Y5YKo77yM5Zyo6aG555uu5p6E5bu65LmL5ZCO5bCG5Y+Y5oiQ6Ieq5aKe55qEIGlk44CCXHJcbiAgICAgKiBAcmVhZE9ubHlcclxuICAgICAqL1xyXG4gICAgQHByb3BlcnR5XHJcbiAgICBnZXQgdXVpZCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIEFsbCBjaGlsZHJlbiBub2Rlcy5cclxuICAgICAqIEB6aCDoioLngrnnmoTmiYDmnInlrZDoioLngrnjgIJcclxuICAgICAqIEByZWFkT25seVxyXG4gICAgICovXHJcbiAgICBAcHJvcGVydHlcclxuICAgIGdldCBjaGlsZHJlbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBUaGUgbG9jYWwgYWN0aXZlIHN0YXRlIG9mIHRoaXMgbm9kZS5cclxuICAgICAqIE5vdGUgdGhhdCBhIE5vZGUgbWF5IGJlIGluYWN0aXZlIGJlY2F1c2UgYSBwYXJlbnQgaXMgbm90IGFjdGl2ZSwgZXZlbiBpZiB0aGlzIHJldHVybnMgdHJ1ZS5cclxuICAgICAqIFVzZSBbW2FjdGl2ZUluSGllcmFyY2h5XV1cclxuICAgICAqIGlmIHlvdSB3YW50IHRvIGNoZWNrIGlmIHRoZSBOb2RlIGlzIGFjdHVhbGx5IHRyZWF0ZWQgYXMgYWN0aXZlIGluIHRoZSBzY2VuZS5cclxuICAgICAqIEB6aFxyXG4gICAgICog5b2T5YmN6IqC54K555qE6Ieq6Lqr5r+A5rS754q25oCB44CCXHJcbiAgICAgKiDlgLzlvpfms6jmhI/nmoTmmK/vvIzkuIDkuKroioLngrnnmoTniLboioLngrnlpoLmnpzkuI3ooqvmv4DmtLvvvIzpgqPkuYjljbPkvb/lroPoh6rouqvorr7kuLrmv4DmtLvvvIzlroPku43nhLbml6Dms5Xmv4DmtLvjgIJcclxuICAgICAqIOWmguaenOS9oOaDs+ajgOafpeiKgueCueWcqOWcuuaZr+S4reWunumZheeahOa/gOa0u+eKtuaAgeWPr+S7peS9v+eUqCBbW2FjdGl2ZUluSGllcmFyY2h5XV1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqL1xyXG4gICAgQHByb3BlcnR5XHJcbiAgICBnZXQgYWN0aXZlICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlO1xyXG4gICAgfVxyXG4gICAgc2V0IGFjdGl2ZSAoaXNBY3RpdmU6IGJvb2xlYW4pIHtcclxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlICE9PSBpc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSBpc0FjdGl2ZTtcclxuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xyXG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VsZEFjdGl2ZUluU2NlbmUgPSBwYXJlbnQuX2FjdGl2ZUluSGllcmFyY2h5O1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvdWxkQWN0aXZlSW5TY2VuZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNjLmRpcmVjdG9yLl9ub2RlQWN0aXZhdG9yLmFjdGl2YXRlTm9kZSh0aGlzLCBpc0FjdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBub2RlIGlzIGFjdGl2ZSBpbiB0aGUgc2NlbmUuXHJcbiAgICAgKiBAemgg6KGo56S65q2k6IqC54K55piv5ZCm5Zyo5Zy65pmv5Lit5r+A5rS744CCXHJcbiAgICAgKi9cclxuICAgIEBwcm9wZXJ0eVxyXG4gICAgZ2V0IGFjdGl2ZUluSGllcmFyY2h5ICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlSW5IaWVyYXJjaHk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gVGhlIHBhcmVudCBub2RlXHJcbiAgICAgKiBAemgg54i26IqC54K5XHJcbiAgICAgKi9cclxuICAgIEBwcm9wZXJ0eVxyXG4gICAgZ2V0IHBhcmVudCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcclxuICAgIH1cclxuICAgIHNldCBwYXJlbnQgKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFdoaWNoIHNjZW5lIHRoaXMgbm9kZSBiZWxvbmdzIHRvLlxyXG4gICAgICogQHpoIOatpOiKgueCueWxnuS6juWTquS4quWcuuaZr+OAglxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCBzY2VuZSAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjZW5lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFRoZSBldmVudCBwcm9jZXNzb3Igb2YgdGhlIGN1cnJlbnQgbm9kZSwgaXQgcHJvdmlkZXMgRXZlbnRUYXJnZXQgYWJpbGl0eS5cclxuICAgICAqIEB6aCDlvZPliY3oioLngrnnmoTkuovku7blpITnkIblmajvvIzmj5DkvpsgRXZlbnRUYXJnZXQg6IO95Yqb44CCXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IGV2ZW50UHJvY2Vzc29yICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRQcm9jZXNzb3I7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBfc2V0U2NlbmUgKG5vZGU6IEJhc2VOb2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBjYy5TY2VuZSkge1xyXG4gICAgICAgICAgICBub2RlLl9zY2VuZSA9IG5vZGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuX3BhcmVudCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjYy5lcnJvcignTm9kZSAlcyglcykgaGFzIG5vdCBhdHRhY2hlZCB0byBhIHNjZW5lLicsIG5vZGUubmFtZSwgbm9kZS51dWlkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuX3NjZW5lID0gbm9kZS5fcGFyZW50Ll9zY2VuZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIGlkR2VuZXJhdG9yID0gaWRHZW5lcmF0b3I7XHJcblxyXG4gICAgLy8gRm9yIHdhbGtcclxuICAgIHByb3RlY3RlZCBzdGF0aWMgX3N0YWNrczogQXJyYXk8QXJyYXk8KEJhc2VOb2RlIHwgbnVsbCk+PiA9IFtbXV07XHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIF9zdGFja0lkID0gMDtcclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIF9maW5kQ29tcG9uZW50IChub2RlOiBCYXNlTm9kZSwgY29uc3RydWN0b3I6IEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgY2xzID0gY29uc3RydWN0b3IgYXMgYW55O1xyXG4gICAgICAgIGNvbnN0IGNvbXBzID0gbm9kZS5fY29tcG9uZW50cztcclxuICAgICAgICBpZiAoY2xzLl9zZWFsZWQpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21wcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcCA9IGNvbXBzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXAuY29uc3RydWN0b3IgPT09IGNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wID0gY29tcHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBfZmluZENvbXBvbmVudHMgKG5vZGU6IEJhc2VOb2RlLCBjb25zdHJ1Y3RvcjogRnVuY3Rpb24sIGNvbXBvbmVudHM6IENvbXBvbmVudFtdKSB7XHJcbiAgICAgICAgY29uc3QgY2xzID0gY29uc3RydWN0b3IgYXMgYW55O1xyXG4gICAgICAgIGNvbnN0IGNvbXBzID0gbm9kZS5fY29tcG9uZW50cztcclxuICAgICAgICBpZiAoY2xzLl9zZWFsZWQpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21wcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcCA9IGNvbXBzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXAuY29uc3RydWN0b3IgPT09IGNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKGNvbXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21wcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29tcCA9IGNvbXBzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXAgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChjb21wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgc3RhdGljIF9maW5kQ2hpbGRDb21wb25lbnQgKGNoaWxkcmVuOiBCYXNlTm9kZVtdLCBjb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBsZXQgY29tcCA9IEJhc2VOb2RlLl9maW5kQ29tcG9uZW50KG5vZGUsIGNvbnN0cnVjdG9yKTtcclxuICAgICAgICAgICAgaWYgKGNvbXApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuX2NoaWxkcmVuLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbXAgPSBCYXNlTm9kZS5fZmluZENoaWxkQ29tcG9uZW50KG5vZGUuX2NoaWxkcmVuLCBjb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBzdGF0aWMgX2ZpbmRDaGlsZENvbXBvbmVudHMgKGNoaWxkcmVuOiBCYXNlTm9kZVtdLCBjb25zdHJ1Y3RvciwgY29tcG9uZW50cykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBCYXNlTm9kZS5fZmluZENvbXBvbmVudHMobm9kZSwgY29uc3RydWN0b3IsIGNvbXBvbmVudHMpO1xyXG4gICAgICAgICAgICBpZiAobm9kZS5fY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgQmFzZU5vZGUuX2ZpbmRDaGlsZENvbXBvbmVudHMobm9kZS5fY2hpbGRyZW4sIGNvbnN0cnVjdG9yLCBjb21wb25lbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBAcHJvcGVydHlcclxuICAgIHByb3RlY3RlZCBfcGFyZW50OiB0aGlzIHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgQHByb3BlcnR5XHJcbiAgICBwcm90ZWN0ZWQgX2NoaWxkcmVuOiB0aGlzW10gPSBbXTtcclxuXHJcbiAgICBAcHJvcGVydHlcclxuICAgIHByb3RlY3RlZCBfYWN0aXZlID0gdHJ1ZTtcclxuXHJcbiAgICBAcHJvcGVydHlcclxuICAgIHByb3RlY3RlZCBfY29tcG9uZW50czogQ29tcG9uZW50W10gPSBbXTtcclxuXHJcbiAgICAvLyBUaGUgUHJlZmFiSW5mbyBvYmplY3RcclxuICAgIEBwcm9wZXJ0eVxyXG4gICAgcHJvdGVjdGVkIF9wcmVmYWI6IGFueSA9IG51bGw7XHJcblxyXG4gICAgcHJvdGVjdGVkIF9zY2VuZTogYW55ID0gTnVsbFNjZW5lO1xyXG5cclxuICAgIHByb3RlY3RlZCBfYWN0aXZlSW5IaWVyYXJjaHkgPSBmYWxzZTtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2lkOiBzdHJpbmcgPSBpZEdlbmVyYXRvci5nZXROZXdJZCgpO1xyXG5cclxuICAgIHByb3RlY3RlZCBfbmFtZTogc3RyaW5nO1xyXG5cclxuICAgIHByb3RlY3RlZCBfZXZlbnRQcm9jZXNzb3I6IE5vZGVFdmVudFByb2Nlc3NvciA9IG5ldyBOb2RlRXZlbnRQcm9jZXNzb3IodGhpcyk7XHJcbiAgICBwcm90ZWN0ZWQgX2V2ZW50TWFzayA9IDA7XHJcblxyXG4gICAgcHJvdGVjdGVkIF9zaWJsaW5nSW5kZXg6IG51bWJlciA9IDA7XHJcblxyXG4gICAgcHJvdGVjdGVkIF9yZWdpc3RlcklmQXR0YWNoZWQgPSAhRURJVE9SID8gdW5kZWZpbmVkIDogZnVuY3Rpb24gKHRoaXM6IEJhc2VOb2RlLCByZWdpc3Rlcikge1xyXG4gICAgICAgIGlmIChFZGl0b3JFeHRlbmRzLk5vZGUgJiYgRWRpdG9yRXh0ZW5kcy5Db21wb25lbnQpIHtcclxuICAgICAgICAgICAgaWYgKHJlZ2lzdGVyKSB7XHJcbiAgICAgICAgICAgICAgICBFZGl0b3JFeHRlbmRzLk5vZGUuYWRkKHRoaXMuX2lkLCB0aGlzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wID0gdGhpcy5fY29tcG9uZW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBFZGl0b3JFeHRlbmRzLkNvbXBvbmVudC5hZGQoY29tcC5faWQsIGNvbXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9jb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tcCA9IHRoaXMuX2NvbXBvbmVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgRWRpdG9yRXh0ZW5kcy5Db21wb25lbnQucmVtb3ZlKGNvbXAuX2lkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBFZGl0b3JFeHRlbmRzLk5vZGUucmVtb3ZlKHRoaXMuX2lkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgY2hpbGQuX3JlZ2lzdGVySWZBdHRhY2hlZCEocmVnaXN0ZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgY29uc3RydWN0b3IgKG5hbWU/OiBzdHJpbmcpIHtcclxuICAgICAgICBzdXBlcihuYW1lKTtcclxuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZSAhPT0gdW5kZWZpbmVkID8gbmFtZSA6ICdOZXcgTm9kZSc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIFByb3BlcnRpZXMgY29uZmlndXJhdGlvbiBmdW5jdGlvbi5cclxuICAgICAqIEFsbCBwcm9wZXJ0aWVzIGluIGF0dHJzIHdpbGwgYmUgc2V0IHRvIHRoZSBub2RlLCBcclxuICAgICAqIHdoZW4gdGhlIHNldHRlciBvZiB0aGUgbm9kZSBpcyBhdmFpbGFibGUsIFxyXG4gICAgICogdGhlIHByb3BlcnR5IHdpbGwgYmUgc2V0IHZpYSBzZXR0ZXIgZnVuY3Rpb24uXHJcbiAgICAgKiBAemgg5bGe5oCn6YWN572u5Ye95pWw44CC5ZyoIGF0dHJzIOeahOaJgOacieWxnuaAp+Wwhuiiq+iuvue9ruS4uuiKgueCueWxnuaAp+OAglxyXG4gICAgICogQHBhcmFtIGF0dHJzIC0gUHJvcGVydGllcyB0byBiZSBzZXQgdG8gbm9kZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYFxyXG4gICAgICogdmFyIGF0dHJzID0geyBuYW1lOiAnTmV3IE5hbWUnLCBhY3RpdmU6IGZhbHNlIH07XHJcbiAgICAgKiBub2RlLmF0dHIoYXR0cnMpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhdHRyIChhdHRyczogT2JqZWN0KSB7XHJcbiAgICAgICAganMubWl4aW4odGhpcywgYXR0cnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEhJRVJBUkNIWSBNRVRIT0RTXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gR2V0IHBhcmVudCBvZiB0aGUgbm9kZS5cclxuICAgICAqIEB6aCDojrflj5bor6XoioLngrnnmoTniLboioLngrnjgIJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFBhcmVudCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBTZXQgcGFyZW50IG9mIHRoZSBub2RlLlxyXG4gICAgICogQHpoIOiuvue9ruivpeiKgueCueeahOeItuiKgueCueOAglxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0UGFyZW50ICh2YWx1ZTogdGhpcyB8IFNjZW5lIHwgbnVsbCwga2VlcFdvcmxkVHJhbnNmb3JtOiBib29sZWFuID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAodGhpcy5fcGFyZW50ID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9sZFBhcmVudCA9IHRoaXMuX3BhcmVudDtcclxuICAgICAgICBjb25zdCBuZXdQYXJlbnQgPSB2YWx1ZSBhcyB0aGlzO1xyXG4gICAgICAgIGlmIChERUJVRyAmJiBvbGRQYXJlbnQgJiZcclxuICAgICAgICAgICAgLy8gQ2hhbmdlIHBhcmVudCB3aGVuIG9sZCBwYXJlbnQgZGVzYWN0aXZhdGluZyBvciBhY3RpdmF0aW5nXHJcbiAgICAgICAgICAgIChvbGRQYXJlbnQuX29iakZsYWdzICYgQ2hhbmdpbmdTdGF0ZSkpIHtcclxuICAgICAgICAgICAgZXJyb3JJRCgzODIxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG5ld1BhcmVudDtcclxuICAgICAgICAvLyBSZXNldCBzaWJsaW5nIGluZGV4XHJcbiAgICAgICAgdGhpcy5fc2libGluZ0luZGV4ID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5fb25TZXRQYXJlbnQob2xkUGFyZW50LCBrZWVwV29ybGRUcmFuc2Zvcm0pO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5lbWl0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdChTeXN0ZW1FdmVudFR5cGUuUEFSRU5UX0NIQU5HRUQsIG9sZFBhcmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobmV3UGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChERUJVRyAmJiAobmV3UGFyZW50Ll9vYmpGbGFncyAmIERlYWN0aXZhdGluZykpIHtcclxuICAgICAgICAgICAgICAgIGVycm9ySUQoMzgyMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV3UGFyZW50Ll9jaGlsZHJlbi5wdXNoKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9zaWJsaW5nSW5kZXggPSBuZXdQYXJlbnQuX2NoaWxkcmVuLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgIGlmIChuZXdQYXJlbnQuZW1pdCkge1xyXG4gICAgICAgICAgICAgICAgbmV3UGFyZW50LmVtaXQoU3lzdGVtRXZlbnRUeXBlLkNISUxEX0FEREVELCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob2xkUGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmICghKG9sZFBhcmVudC5fb2JqRmxhZ3MgJiBEZXN0cm95aW5nKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlQXQgPSBvbGRQYXJlbnQuX2NoaWxkcmVuLmluZGV4T2YodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoREVWICYmIHJlbW92ZUF0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcklEKDE2MzMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb2xkUGFyZW50Ll9jaGlsZHJlbi5zcGxpY2UocmVtb3ZlQXQsIDEpO1xyXG4gICAgICAgICAgICAgICAgb2xkUGFyZW50Ll91cGRhdGVTaWJsaW5nSW5kZXgoKTtcclxuICAgICAgICAgICAgICAgIGlmIChvbGRQYXJlbnQuZW1pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZFBhcmVudC5lbWl0KFN5c3RlbUV2ZW50VHlwZS5DSElMRF9SRU1PVkVELCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9vbkhpZXJhcmNoeUNoYW5nZWQob2xkUGFyZW50KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gUmV0dXJucyBhIGNoaWxkIHdpdGggdGhlIHNhbWUgdXVpZC5cclxuICAgICAqIEB6aCDpgJrov4cgdXVpZCDojrflj5boioLngrnnmoTlrZDoioLngrnjgIJcclxuICAgICAqIEBwYXJhbSB1dWlkIC0gVGhlIHV1aWQgdG8gZmluZCB0aGUgY2hpbGQgbm9kZS5cclxuICAgICAqIEByZXR1cm4gYSBOb2RlIHdob3NlIHV1aWQgZXF1YWxzIHRvIHRoZSBpbnB1dCBwYXJhbWV0ZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENoaWxkQnlVdWlkICh1dWlkOiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAoIXV1aWQpIHtcclxuICAgICAgICAgICAgY2MubG9nKCdJbnZhbGlkIHV1aWQnKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBsb2NDaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBsb2NDaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAobG9jQ2hpbGRyZW5baV0uX2lkID09PSB1dWlkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jQ2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gUmV0dXJucyBhIGNoaWxkIHdpdGggdGhlIHNhbWUgbmFtZS5cclxuICAgICAqIEB6aCDpgJrov4flkI3np7Dojrflj5boioLngrnnmoTlrZDoioLngrnjgIJcclxuICAgICAqIEBwYXJhbSBuYW1lIC0gQSBuYW1lIHRvIGZpbmQgdGhlIGNoaWxkIG5vZGUuXHJcbiAgICAgKiBAcmV0dXJuIGEgQ0NOb2RlIG9iamVjdCB3aG9zZSBuYW1lIGVxdWFscyB0byB0aGUgaW5wdXQgcGFyYW1ldGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgXHJcbiAgICAgKiB2YXIgY2hpbGQgPSBub2RlLmdldENoaWxkQnlOYW1lKFwiVGVzdCBOb2RlXCIpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDaGlsZEJ5TmFtZSAobmFtZTogc3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgICAgICAgIGNjLmxvZygnSW52YWxpZCBuYW1lJyk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbG9jQ2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbG9jQ2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGxvY0NoaWxkcmVuW2ldLl9uYW1lID09PSBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jQ2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gUmV0dXJucyBhIGNoaWxkIHdpdGggdGhlIGdpdmVuIHBhdGguXHJcbiAgICAgKiBAemgg6YCa6L+H6Lev5b6E6I635Y+W6IqC54K555qE5a2Q6IqC54K544CCXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAtIEEgcGF0aCB0byBmaW5kIHRoZSBjaGlsZCBub2RlLlxyXG4gICAgICogQHJldHVybiBhIE5vZGUgb2JqZWN0IHdob3NlIHBhdGggZXF1YWxzIHRvIHRoZSBpbnB1dCBwYXJhbWV0ZXJcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGBcclxuICAgICAqIHZhciBjaGlsZCA9IG5vZGUuZ2V0Q2hpbGRCeVBhdGgoXCJzdWJOb2RlL1Rlc3QgTm9kZVwiKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q2hpbGRCeVBhdGggKHBhdGg6IHN0cmluZykge1xyXG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLycpO1xyXG4gICAgICAgIGxldCBsYXN0Tm9kZTogdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XHJcbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGxhc3ROb2RlLmNoaWxkcmVuLmZpbmQoKGNoaWxkTm9kZSkgPT4gY2hpbGROb2RlLm5hbWUgPT09IHNlZ21lbnQpO1xyXG4gICAgICAgICAgICBpZiAoIW5leHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhc3ROb2RlID0gbmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxhc3ROb2RlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gQWRkIGEgY2hpbGQgdG8gdGhlIGN1cnJlbnQgbm9kZSwgaXQgd2lsbCBiZSBwdXNoZWQgdG8gdGhlIGVuZCBvZiBbW2NoaWxkcmVuXV0gYXJyYXkuXHJcbiAgICAgKiBAemgg5re75Yqg5LiA5Liq5a2Q6IqC54K577yM5a6D5Lya6KKr5re75Yqg5YiwIFtbY2hpbGRyZW5dXSDmlbDnu4TnmoTmnKvlsL7jgIJcclxuICAgICAqIEBwYXJhbSBjaGlsZCAtIHRoZSBjaGlsZCBub2RlIHRvIGJlIGFkZGVkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRDaGlsZCAoY2hpbGQ6IHRoaXMgfCBOb2RlKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKERFViAmJiAhKGNoaWxkIGluc3RhbmNlb2YgY2MuX0Jhc2VOb2RlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXJyb3JJRCgxNjM0LCBjYy5qcy5nZXRDbGFzc05hbWUoY2hpbGQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2MuYXNzZXJ0SUQoY2hpbGQsIDE2MDYpO1xyXG4gICAgICAgIGNjLmFzc2VydElEKChjaGlsZCBhcyB0aGlzKS5fcGFyZW50ID09PSBudWxsLCAxNjA1KTtcclxuXHJcbiAgICAgICAgLy8gaW52b2tlcyB0aGUgcGFyZW50IHNldHRlclxyXG4gICAgICAgIChjaGlsZCBhcyB0aGlzKS5zZXRQYXJlbnQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gSW5zZXJ0cyBhIGNoaWxkIHRvIHRoZSBub2RlIGF0IGEgc3BlY2lmaWVkIGluZGV4LlxyXG4gICAgICogQHpoIOaPkuWFpeWtkOiKgueCueWIsOaMh+WumuS9jee9rlxyXG4gICAgICogQHBhcmFtIGNoaWxkIC0gdGhlIGNoaWxkIG5vZGUgdG8gYmUgaW5zZXJ0ZWRcclxuICAgICAqIEBwYXJhbSBzaWJsaW5nSW5kZXggLSB0aGUgc2libGluZyBpbmRleCB0byBwbGFjZSB0aGUgY2hpbGQgaW5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGBcclxuICAgICAqIG5vZGUuaW5zZXJ0Q2hpbGQoY2hpbGQsIDIpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpbnNlcnRDaGlsZCAoY2hpbGQ6IHRoaXMgfCBOb2RlLCBzaWJsaW5nSW5kZXg6IG51bWJlcikge1xyXG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgY2hpbGQuc2V0U2libGluZ0luZGV4KHNpYmxpbmdJbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gR2V0IHRoZSBzaWJsaW5nIGluZGV4IG9mIHRoZSBjdXJyZW50IG5vZGUgaW4gaXRzIHBhcmVudCdzIGNoaWxkcmVuIGFycmF5LlxyXG4gICAgICogQHpoIOiOt+WPluW9k+WJjeiKgueCueWcqOeItuiKgueCueeahCBjaGlsZHJlbiDmlbDnu4TkuK3nmoTkvY3nva7jgIJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFNpYmxpbmdJbmRleCAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpYmxpbmdJbmRleDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBTZXQgdGhlIHNpYmxpbmcgaW5kZXggb2YgdGhlIGN1cnJlbnQgbm9kZSBpbiBpdHMgcGFyZW50J3MgY2hpbGRyZW4gYXJyYXkuXHJcbiAgICAgKiBAemgg6K6+572u5b2T5YmN6IqC54K55Zyo54i26IqC54K555qEIGNoaWxkcmVuIOaVsOe7hOS4reeahOS9jee9ruOAglxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0U2libGluZ0luZGV4IChpbmRleDogbnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9wYXJlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcGFyZW50Ll9vYmpGbGFncyAmIERlYWN0aXZhdGluZykge1xyXG4gICAgICAgICAgICBlcnJvcklEKDM4MjEpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gdGhpcy5fcGFyZW50Ll9jaGlsZHJlbjtcclxuICAgICAgICBpbmRleCA9IGluZGV4ICE9PSAtMSA/IGluZGV4IDogc2libGluZ3MubGVuZ3RoIC0gMTtcclxuICAgICAgICBjb25zdCBvbGRJbmRleCA9IHNpYmxpbmdzLmluZGV4T2YodGhpcyk7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSBvbGRJbmRleCkge1xyXG4gICAgICAgICAgICBzaWJsaW5ncy5zcGxpY2Uob2xkSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPCBzaWJsaW5ncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHNpYmxpbmdzLnNwbGljZShpbmRleCwgMCwgdGhpcyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzaWJsaW5ncy5wdXNoKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlU2libGluZ0luZGV4KCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vblNpYmxpbmdJbmRleENoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uU2libGluZ0luZGV4Q2hhbmdlZChpbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gV2FsayB0aG91Z2ggdGhlIHN1YiBjaGlsZHJlbiB0cmVlIG9mIHRoZSBjdXJyZW50IG5vZGUuXHJcbiAgICAgKiBFYWNoIG5vZGUsIGluY2x1ZGluZyB0aGUgY3VycmVudCBub2RlLCBpbiB0aGUgc3ViIHRyZWUgd2lsbCBiZSB2aXNpdGVkIHR3byB0aW1lcyxcclxuICAgICAqIGJlZm9yZSBhbGwgY2hpbGRyZW4gYW5kIGFmdGVyIGFsbCBjaGlsZHJlbi5cclxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsbCBpcyBub3QgcmVjdXJzaXZlLCBpdCdzIGJhc2VkIG9uIHN0YWNrLlxyXG4gICAgICogUGxlYXNlIGRvbid0IHdhbGsgYW55IG90aGVyIG5vZGUgaW5zaWRlIHRoZSB3YWxrIHByb2Nlc3MuXHJcbiAgICAgKiBAemgg6YGN5Y6G6K+l6IqC54K555qE5a2Q5qCR6YeM55qE5omA5pyJ6IqC54K55bm25oyJ6KeE5YiZ5omn6KGM5Zue6LCD5Ye95pWw44CCXHJcbiAgICAgKiDlr7nlrZDmoJHkuK3nmoTmiYDmnInoioLngrnvvIzljIXlkKvlvZPliY3oioLngrnvvIzkvJrmiafooYzkuKTmrKHlm57osIPvvIxwcmVGdW5jIOS8muWcqOiuv+mXruWug+eahOWtkOiKgueCueS5i+WJjeiwg+eUqO+8jHBvc3RGdW5jIOS8muWcqOiuv+mXruaJgOacieWtkOiKgueCueS5i+WQjuiwg+eUqOOAglxyXG4gICAgICog6L+Z5Liq5Ye95pWw55qE5a6e546w5LiN5piv5Z+65LqO6YCS5b2S55qE77yM6ICM5piv5Z+65LqO5qCI5bGV5byA6YCS5b2S55qE5pa55byP44CCXHJcbiAgICAgKiDor7fkuI3opoHlnKggd2FsayDov4fnqIvkuK3lr7nku7vkvZXlhbbku5bnmoToioLngrnltYzlpZfmiafooYwgd2Fsa+OAglxyXG4gICAgICogQHBhcmFtIHByZUZ1bmMgVGhlIGNhbGxiYWNrIHRvIHByb2Nlc3Mgbm9kZSB3aGVuIHJlYWNoIHRoZSBub2RlIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICogQHBhcmFtIHBvc3RGdW5jIFRoZSBjYWxsYmFjayB0byBwcm9jZXNzIG5vZGUgd2hlbiByZS12aXNpdCB0aGUgbm9kZSBhZnRlciB3YWxrZWQgYWxsIGNoaWxkcmVuIGluIGl0cyBzdWIgdHJlZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYFxyXG4gICAgICogbm9kZS53YWxrKGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAqICAgICBjb25zb2xlLmxvZygnV2Fsa2VkIHRocm91Z2ggbm9kZSAnICsgdGFyZ2V0Lm5hbWUgKyAnIGZvciB0aGUgZmlyc3QgdGltZScpO1xyXG4gICAgICogfSwgZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICogICAgIGNvbnNvbGUubG9nKCdXYWxrZWQgdGhyb3VnaCBub2RlICcgKyB0YXJnZXQubmFtZSArICcgYWZ0ZXIgd2Fsa2VkIGFsbCBjaGlsZHJlbiBpbiBpdHMgc3ViIHRyZWUnKTtcclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB3YWxrIChwcmVGdW5jOiAodGFyZ2V0OiB0aGlzKSA9PiB2b2lkLCBwb3N0RnVuYz86ICh0YXJnZXQ6IHRoaXMpID0+IHZvaWQpIHtcclxuICAgICAgICAvLyBjb25zdCBCYXNlTm9kZSA9IGNjLl9CYXNlTm9kZTtcclxuICAgICAgICBsZXQgaW5kZXggPSAxO1xyXG4gICAgICAgIGxldCBjaGlsZHJlbjogdGhpc1tdIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgbGV0IGN1cnI6IHRoaXMgfCBudWxsID0gbnVsbDtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgbGV0IHN0YWNrID0gQmFzZU5vZGUuX3N0YWNrc1tCYXNlTm9kZS5fc3RhY2tJZF07XHJcbiAgICAgICAgaWYgKCFzdGFjaykge1xyXG4gICAgICAgICAgICBzdGFjayA9IFtdO1xyXG4gICAgICAgICAgICBCYXNlTm9kZS5fc3RhY2tzLnB1c2goc3RhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBCYXNlTm9kZS5fc3RhY2tJZCsrO1xyXG5cclxuICAgICAgICBzdGFjay5sZW5ndGggPSAwO1xyXG4gICAgICAgIHN0YWNrWzBdID0gdGhpcztcclxuICAgICAgICBsZXQgcGFyZW50OiB0aGlzIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgbGV0IGFmdGVyQ2hpbGRyZW4gPSBmYWxzZTtcclxuICAgICAgICB3aGlsZSAoaW5kZXgpIHtcclxuICAgICAgICAgICAgaW5kZXgtLTtcclxuICAgICAgICAgICAgY3VyciA9IHN0YWNrW2luZGV4XSBhcyAodGhpcyB8IG51bGwpO1xyXG4gICAgICAgICAgICBpZiAoIWN1cnIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghYWZ0ZXJDaGlsZHJlbiAmJiBwcmVGdW5jKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwcmUgY2FsbFxyXG4gICAgICAgICAgICAgICAgcHJlRnVuYyhjdXJyKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChhZnRlckNoaWxkcmVuICYmIHBvc3RGdW5jKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBwb3N0IGNhbGxcclxuICAgICAgICAgICAgICAgIHBvc3RGdW5jKGN1cnIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBBdm9pZCBtZW1vcnkgbGVha1xyXG4gICAgICAgICAgICBzdGFja1tpbmRleF0gPSBudWxsO1xyXG4gICAgICAgICAgICAvLyBEbyBub3QgcmVwZWF0bHkgdmlzaXQgY2hpbGQgdHJlZSwganVzdCBkbyBwb3N0IGNhbGwgYW5kIGNvbnRpbnVlIHdhbGtcclxuICAgICAgICAgICAgaWYgKGFmdGVyQ2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGFmdGVyQ2hpbGRyZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIENoaWxkcmVuIG5vdCBwcm9jZWVkZWQgYW5kIGhhcyBjaGlsZHJlbiwgcHJvY2VlZCB0byBjaGlsZCB0cmVlXHJcbiAgICAgICAgICAgICAgICBpZiAoY3Vyci5fY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGN1cnI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBjdXJyLl9jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBzdGFja1tpbmRleF0gPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGFja1tpbmRleF0gPSBjdXJyO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJDaGlsZHJlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjdXJyIGhhcyBubyBzdWIgdHJlZSwgc28gbG9vayBpbnRvIHRoZSBzaWJsaW5ncyBpbiBwYXJlbnQgY2hpbGRyZW5cclxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICAvLyBQcm9jZWVkIHRvIG5leHQgc2libGluZyBpbiBwYXJlbnQgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbltpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrW2luZGV4XSA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrW2luZGV4XSA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldHVwIHBhcmVudCB3YWxrIGVudlxyXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyQ2hpbGRyZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQuX3BhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHBhcmVudC5fcGFyZW50Ll9jaGlsZHJlbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGNoaWxkcmVuLmluZGV4T2YocGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXQgcm9vdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFUlJPUlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3RhY2subGVuZ3RoID0gMDtcclxuICAgICAgICBCYXNlTm9kZS5fc3RhY2tJZC0tO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBSZW1vdmUgaXRzZWxmIGZyb20gaXRzIHBhcmVudCBub2RlLiBcclxuICAgICAqIElmIHRoZSBub2RlIGhhdmUgbm8gcGFyZW50LCB0aGVuIG5vdGhpbmcgaGFwcGVucy5cclxuICAgICAqIEB6aFxyXG4gICAgICog5LuO54i26IqC54K55Lit5Yig6Zmk6K+l6IqC54K544CCXHJcbiAgICAgKiDlpoLmnpzov5nkuKroioLngrnmmK/kuIDkuKrlraTnq4voioLngrnvvIzpgqPkuYjku4DkuYjpg73kuI3kvJrlj5HnlJ/jgIJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZUZyb21QYXJlbnQgKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBSZW1vdmVzIGEgY2hpbGQgZnJvbSB0aGUgY29udGFpbmVyLlxyXG4gICAgICogQHpoIOenu+mZpOiKgueCueS4reaMh+WumueahOWtkOiKgueCueOAglxyXG4gICAgICogQHBhcmFtIGNoaWxkIC0gVGhlIGNoaWxkIG5vZGUgd2hpY2ggd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVtb3ZlQ2hpbGQgKGNoaWxkOiB0aGlzIHwgTm9kZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbi5pbmRleE9mKGNoaWxkIGFzIHRoaXMpID4gLTEpIHtcclxuICAgICAgICAgICAgLy8gaW52b2tlIHRoZSBwYXJlbnQgc2V0dGVyXHJcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhlIGNvbnRhaW5lci5cclxuICAgICAqIEB6aCDnp7vpmaToioLngrnmiYDmnInnmoTlrZDoioLngrnjgIJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZUFsbENoaWxkcmVuICgpIHtcclxuICAgICAgICAvLyBub3QgdXNpbmcgZGV0YWNoQ2hpbGQgaW1wcm92ZXMgc3BlZWQgaGVyZVxyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIElzIHRoaXMgbm9kZSBhIGNoaWxkIG9mIHRoZSBnaXZlbiBub2RlP1xyXG4gICAgICogQHpoIOaYr+WQpuaYr+aMh+WumuiKgueCueeahOWtkOiKgueCue+8n1xyXG4gICAgICogQHJldHVybiBUcnVlIGlmIHRoaXMgbm9kZSBpcyBhIGNoaWxkLCBkZWVwIGNoaWxkIG9yIGlkZW50aWNhbCB0byB0aGUgZ2l2ZW4gbm9kZS5cclxuICAgICAqL1xyXG4gICAgcHVibGljIGlzQ2hpbGRPZiAocGFyZW50OiB0aGlzIHwgU2NlbmUgfCBudWxsKTogYm9vbGVhbiB7XHJcbiAgICAgICAgbGV0IGNoaWxkOiBCYXNlTm9kZSB8IG51bGwgPSB0aGlzO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgaWYgKGNoaWxkID09PSBwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuX3BhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGNoaWxkKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ09NUE9ORU5UXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIFJldHVybnMgdGhlIGNvbXBvbmVudCBvZiBzdXBwbGllZCB0eXBlIGlmIHRoZSBub2RlIGhhcyBvbmUgYXR0YWNoZWQsIG51bGwgaWYgaXQgZG9lc24ndC4gXHJcbiAgICAgKiBZb3UgY2FuIGFsc28gZ2V0IGNvbXBvbmVudCBpbiB0aGUgbm9kZSBieSBwYXNzaW5nIGluIHRoZSBuYW1lIG9mIHRoZSBzY3JpcHQuXHJcbiAgICAgKiBAemhcclxuICAgICAqIOiOt+WPluiKgueCueS4iuaMh+Wumuexu+Wei+eahOe7hOS7tu+8jOWmguaenOiKgueCueaciemZhOWKoOaMh+Wumuexu+Wei+eahOe7hOS7tu+8jOWImei/lOWbnu+8jOWmguaenOayoeacieWImeS4uuepuuOAglxyXG4gICAgICog5Lyg5YWl5Y+C5pWw5Lmf5Y+v5Lul5piv6ISa5pys55qE5ZCN56ew44CCXHJcbiAgICAgKiBAcGFyYW0gY2xhc3NDb25zdHJ1Y3RvciBUaGUgY2xhc3Mgb2YgdGhlIHRhcmdldCBjb21wb25lbnRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGBcclxuICAgICAqIC8vIGdldCBzcHJpdGUgY29tcG9uZW50LlxyXG4gICAgICogdmFyIHNwcml0ZSA9IG5vZGUuZ2V0Q29tcG9uZW50KFNwcml0ZUNvbXBvbmVudCk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvbXBvbmVudDxUIGV4dGVuZHMgQ29tcG9uZW50PiAoY2xhc3NDb25zdHJ1Y3RvcjogQ29uc3RydWN0b3I8VD4pOiBUIHwgbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogUmV0dXJucyB0aGUgY29tcG9uZW50IG9mIHN1cHBsaWVkIHR5cGUgaWYgdGhlIG5vZGUgaGFzIG9uZSBhdHRhY2hlZCwgbnVsbCBpZiBpdCBkb2Vzbid0LlxyXG4gICAgICogWW91IGNhbiBhbHNvIGdldCBjb21wb25lbnQgaW4gdGhlIG5vZGUgYnkgcGFzc2luZyBpbiB0aGUgbmFtZSBvZiB0aGUgc2NyaXB0LlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDojrflj5boioLngrnkuIrmjIflrprnsbvlnovnmoTnu4Tku7bvvIzlpoLmnpzoioLngrnmnInpmYTliqDmjIflrprnsbvlnovnmoTnu4Tku7bvvIzliJnov5Tlm57vvIzlpoLmnpzmsqHmnInliJnkuLrnqbrjgIJcclxuICAgICAqIOS8oOWFpeWPguaVsOS5n+WPr+S7peaYr+iEmuacrOeahOWQjeensOOAglxyXG4gICAgICogQHBhcmFtIGNsYXNzTmFtZSBUaGUgY2xhc3MgbmFtZSBvZiB0aGUgdGFyZ2V0IGNvbXBvbmVudFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYFxyXG4gICAgICogLy8gZ2V0IGN1c3RvbSB0ZXN0IGNsYXNzLlxyXG4gICAgICogdmFyIHRlc3QgPSBub2RlLmdldENvbXBvbmVudChcIlRlc3RcIik7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldENvbXBvbmVudCAoY2xhc3NOYW1lOiBzdHJpbmcpOiBDb21wb25lbnQgfCBudWxsO1xyXG5cclxuICAgIHB1YmxpYyBnZXRDb21wb25lbnQgKHR5cGVPckNsYXNzTmFtZTogc3RyaW5nIHwgRnVuY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGdldENvbnN0cnVjdG9yKHR5cGVPckNsYXNzTmFtZSk7XHJcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBCYXNlTm9kZS5fZmluZENvbXBvbmVudCh0aGlzLCBjb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFJldHVybnMgYWxsIGNvbXBvbmVudHMgb2YgZ2l2ZW4gdHlwZSBpbiB0aGUgbm9kZS5cclxuICAgICAqIEB6aCDov5Tlm57oioLngrnkuIrmjIflrprnsbvlnovnmoTmiYDmnInnu4Tku7bjgIJcclxuICAgICAqIEBwYXJhbSBjbGFzc0NvbnN0cnVjdG9yIFRoZSBjbGFzcyBvZiB0aGUgdGFyZ2V0IGNvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q29tcG9uZW50czxUIGV4dGVuZHMgQ29tcG9uZW50PiAoY2xhc3NDb25zdHJ1Y3RvcjogQ29uc3RydWN0b3I8VD4pOiBUW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gUmV0dXJucyBhbGwgY29tcG9uZW50cyBvZiBnaXZlbiB0eXBlIGluIHRoZSBub2RlLlxyXG4gICAgICogQHpoIOi/lOWbnuiKgueCueS4iuaMh+Wumuexu+Wei+eahOaJgOaciee7hOS7tuOAglxyXG4gICAgICogQHBhcmFtIGNsYXNzTmFtZSBUaGUgY2xhc3MgbmFtZSBvZiB0aGUgdGFyZ2V0IGNvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZ2V0Q29tcG9uZW50cyAoY2xhc3NOYW1lOiBzdHJpbmcpOiBDb21wb25lbnRbXTtcclxuXHJcbiAgICBwdWJsaWMgZ2V0Q29tcG9uZW50cyAodHlwZU9yQ2xhc3NOYW1lOiBzdHJpbmcgfCBGdW5jdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gZ2V0Q29uc3RydWN0b3IodHlwZU9yQ2xhc3NOYW1lKTtcclxuICAgICAgICBjb25zdCBjb21wb25lbnRzOiBDb21wb25lbnRbXSA9IFtdO1xyXG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvcikge1xyXG4gICAgICAgICAgICBCYXNlTm9kZS5fZmluZENvbXBvbmVudHModGhpcywgY29uc3RydWN0b3IsIGNvbXBvbmVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tcG9uZW50cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBSZXR1cm5zIHRoZSBjb21wb25lbnQgb2YgZ2l2ZW4gdHlwZSBpbiBhbnkgb2YgaXRzIGNoaWxkcmVuIHVzaW5nIGRlcHRoIGZpcnN0IHNlYXJjaC5cclxuICAgICAqIEB6aCDpgJLlvZLmn6Xmib7miYDmnInlrZDoioLngrnkuK3nrKzkuIDkuKrljLnphY3mjIflrprnsbvlnovnmoTnu4Tku7bjgIJcclxuICAgICAqIEBwYXJhbSBjbGFzc0NvbnN0cnVjdG9yIFRoZSBjbGFzcyBvZiB0aGUgdGFyZ2V0IGNvbXBvbmVudFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYFxyXG4gICAgICogdmFyIHNwcml0ZSA9IG5vZGUuZ2V0Q29tcG9uZW50SW5DaGlsZHJlbihTcHJpdGVDb21wb25lbnQpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDb21wb25lbnRJbkNoaWxkcmVuPFQgZXh0ZW5kcyBDb21wb25lbnQ+IChjbGFzc0NvbnN0cnVjdG9yOiBDb25zdHJ1Y3RvcjxUPik6IFQgfCBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFJldHVybnMgdGhlIGNvbXBvbmVudCBvZiBnaXZlbiB0eXBlIGluIGFueSBvZiBpdHMgY2hpbGRyZW4gdXNpbmcgZGVwdGggZmlyc3Qgc2VhcmNoLlxyXG4gICAgICogQHpoIOmAkuW9kuafpeaJvuaJgOacieWtkOiKgueCueS4reesrOS4gOS4quWMuemFjeaMh+Wumuexu+Wei+eahOe7hOS7tuOAglxyXG4gICAgICogQHBhcmFtIGNsYXNzTmFtZSBUaGUgY2xhc3MgbmFtZSBvZiB0aGUgdGFyZ2V0IGNvbXBvbmVudFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYFxyXG4gICAgICogdmFyIFRlc3QgPSBub2RlLmdldENvbXBvbmVudEluQ2hpbGRyZW4oXCJUZXN0XCIpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDb21wb25lbnRJbkNoaWxkcmVuIChjbGFzc05hbWU6IHN0cmluZyk6IENvbXBvbmVudCB8IG51bGw7XHJcblxyXG4gICAgcHVibGljIGdldENvbXBvbmVudEluQ2hpbGRyZW4gKHR5cGVPckNsYXNzTmFtZTogc3RyaW5nIHwgRnVuY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGdldENvbnN0cnVjdG9yKHR5cGVPckNsYXNzTmFtZSk7XHJcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBCYXNlTm9kZS5fZmluZENoaWxkQ29tcG9uZW50KHRoaXMuX2NoaWxkcmVuLCBjb25zdHJ1Y3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFJldHVybnMgYWxsIGNvbXBvbmVudHMgb2YgZ2l2ZW4gdHlwZSBpbiBzZWxmIG9yIGFueSBvZiBpdHMgY2hpbGRyZW4uXHJcbiAgICAgKiBAemgg6YCS5b2S5p+l5om+6Ieq6Lqr5oiW5omA5pyJ5a2Q6IqC54K55Lit5oyH5a6a57G75Z6L55qE57uE5Lu2XHJcbiAgICAgKiBAcGFyYW0gY2xhc3NDb25zdHJ1Y3RvciBUaGUgY2xhc3Mgb2YgdGhlIHRhcmdldCBjb21wb25lbnRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGBcclxuICAgICAqIHZhciBzcHJpdGVzID0gbm9kZS5nZXRDb21wb25lbnRzSW5DaGlsZHJlbihTcHJpdGVDb21wb25lbnQpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDb21wb25lbnRzSW5DaGlsZHJlbjxUIGV4dGVuZHMgQ29tcG9uZW50PiAoY2xhc3NDb25zdHJ1Y3RvcjogQ29uc3RydWN0b3I8VD4pOiBUW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gUmV0dXJucyBhbGwgY29tcG9uZW50cyBvZiBnaXZlbiB0eXBlIGluIHNlbGYgb3IgYW55IG9mIGl0cyBjaGlsZHJlbi5cclxuICAgICAqIEB6aCDpgJLlvZLmn6Xmib7oh6rouqvmiJbmiYDmnInlrZDoioLngrnkuK3mjIflrprnsbvlnovnmoTnu4Tku7ZcclxuICAgICAqIEBwYXJhbSBjbGFzc05hbWUgVGhlIGNsYXNzIG5hbWUgb2YgdGhlIHRhcmdldCBjb21wb25lbnRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGBcclxuICAgICAqIHZhciB0ZXN0cyA9IG5vZGUuZ2V0Q29tcG9uZW50c0luQ2hpbGRyZW4oXCJUZXN0XCIpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBnZXRDb21wb25lbnRzSW5DaGlsZHJlbiAoY2xhc3NOYW1lOiBzdHJpbmcpOiBDb21wb25lbnRbXTtcclxuXHJcbiAgICBwdWJsaWMgZ2V0Q29tcG9uZW50c0luQ2hpbGRyZW4gKHR5cGVPckNsYXNzTmFtZTogc3RyaW5nIHwgRnVuY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGdldENvbnN0cnVjdG9yKHR5cGVPckNsYXNzTmFtZSk7XHJcbiAgICAgICAgY29uc3QgY29tcG9uZW50czogQ29tcG9uZW50W10gPSBbXTtcclxuICAgICAgICBpZiAoY29uc3RydWN0b3IpIHtcclxuICAgICAgICAgICAgQmFzZU5vZGUuX2ZpbmRDb21wb25lbnRzKHRoaXMsIGNvbnN0cnVjdG9yLCBjb21wb25lbnRzKTtcclxuICAgICAgICAgICAgQmFzZU5vZGUuX2ZpbmRDaGlsZENvbXBvbmVudHModGhpcy5fY2hpbGRyZW4sIGNvbnN0cnVjdG9yLCBjb21wb25lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gQWRkcyBhIGNvbXBvbmVudCBjbGFzcyB0byB0aGUgbm9kZS4gWW91IGNhbiBhbHNvIGFkZCBjb21wb25lbnQgdG8gbm9kZSBieSBwYXNzaW5nIGluIHRoZSBuYW1lIG9mIHRoZSBzY3JpcHQuXHJcbiAgICAgKiBAemgg5ZCR6IqC54K55re75Yqg5LiA5Liq5oyH5a6a57G75Z6L55qE57uE5Lu257G777yM5L2g6L+Y5Y+v5Lul6YCa6L+H5Lyg5YWl6ISa5pys55qE5ZCN56ew5p2l5re75Yqg57uE5Lu244CCXHJcbiAgICAgKiBAcGFyYW0gY2xhc3NDb25zdHJ1Y3RvciBUaGUgY2xhc3Mgb2YgdGhlIGNvbXBvbmVudCB0byBhZGRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGBcclxuICAgICAqIHZhciBzcHJpdGUgPSBub2RlLmFkZENvbXBvbmVudChTcHJpdGVDb21wb25lbnQpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhZGRDb21wb25lbnQ8VCBleHRlbmRzIENvbXBvbmVudD4gKGNsYXNzQ29uc3RydWN0b3I6IENvbnN0cnVjdG9yPFQ+KTogVCB8IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gQWRkcyBhIGNvbXBvbmVudCBjbGFzcyB0byB0aGUgbm9kZS4gWW91IGNhbiBhbHNvIGFkZCBjb21wb25lbnQgdG8gbm9kZSBieSBwYXNzaW5nIGluIHRoZSBuYW1lIG9mIHRoZSBzY3JpcHQuXHJcbiAgICAgKiBAemgg5ZCR6IqC54K55re75Yqg5LiA5Liq5oyH5a6a57G75Z6L55qE57uE5Lu257G777yM5L2g6L+Y5Y+v5Lul6YCa6L+H5Lyg5YWl6ISa5pys55qE5ZCN56ew5p2l5re75Yqg57uE5Lu244CCXHJcbiAgICAgKiBAcGFyYW0gY2xhc3NOYW1lIFRoZSBjbGFzcyBuYW1lIG9mIHRoZSBjb21wb25lbnQgdG8gYWRkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgXHJcbiAgICAgKiB2YXIgdGVzdCA9IG5vZGUuYWRkQ29tcG9uZW50KFwiVGVzdFwiKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkQ29tcG9uZW50IChjbGFzc05hbWU6IHN0cmluZyk6IENvbXBvbmVudCB8IG51bGw7XHJcblxyXG4gICAgcHVibGljIGFkZENvbXBvbmVudCAodHlwZU9yQ2xhc3NOYW1lOiBzdHJpbmcgfCBGdW5jdGlvbikge1xyXG4gICAgICAgIGlmIChFRElUT1IgJiYgKHRoaXMuX29iakZsYWdzICYgRGVzdHJveWluZykpIHtcclxuICAgICAgICAgICAgY2MuZXJyb3IoJ2lzRGVzdHJveWluZycpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGdldCBjb21wb25lbnRcclxuXHJcbiAgICAgICAgbGV0IGNvbnN0cnVjdG9yO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdHlwZU9yQ2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IGpzLmdldENsYXNzQnlOYW1lKHR5cGVPckNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgIGlmICghY29uc3RydWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGVycm9ySUQoMzgwNywgdHlwZU9yQ2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChjYy5fUkYucGVlaygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JJRCgzODA4LCB0eXBlT3JDbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIXR5cGVPckNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JJRCgzODA0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gdHlwZU9yQ2xhc3NOYW1lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY2hlY2sgY29tcG9uZW50XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgZXJyb3JJRCgzODA5KTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghanMuaXNDaGlsZENsYXNzT2YoY29uc3RydWN0b3IsIGNjLkNvbXBvbmVudCkpIHtcclxuICAgICAgICAgICAgZXJyb3JJRCgzODEwKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoRURJVE9SICYmIGNvbnN0cnVjdG9yLl9kaXNhbGxvd011bHRpcGxlKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2hlY2tNdWx0aXBsZUNvbXAhKGNvbnN0cnVjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNoZWNrIHJlcXVpcmVtZW50XHJcblxyXG4gICAgICAgIGNvbnN0IFJlcUNvbXAgPSBjb25zdHJ1Y3Rvci5fcmVxdWlyZUNvbXBvbmVudDtcclxuICAgICAgICBpZiAoUmVxQ29tcCAmJiAhdGhpcy5nZXRDb21wb25lbnQoUmVxQ29tcCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZGVwZW5kZWQgPSB0aGlzLmFkZENvbXBvbmVudChSZXFDb21wKTtcclxuICAgICAgICAgICAgaWYgKCFkZXBlbmRlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gZGVwZW5kIGNvbmZsaWN0c1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vLy8gY2hlY2sgY29uZmxpY3RcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIGlmIChFRElUT1IgJiYgIV9TY2VuZS5EZXRlY3RDb25mbGljdC5iZWZvcmVBZGRDb21wb25lbnQodGhpcywgY29uc3RydWN0b3IpKSB7XHJcbiAgICAgICAgLy8gICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAvL1xyXG5cclxuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBuZXcgY29uc3RydWN0b3IoKTtcclxuICAgICAgICBjb21wb25lbnQubm9kZSA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XHJcbiAgICAgICAgaWYgKEVESVRPUiAmJiBFZGl0b3JFeHRlbmRzLk5vZGUgJiYgRWRpdG9yRXh0ZW5kcy5Db21wb25lbnQpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IEVkaXRvckV4dGVuZHMuTm9kZS5nZXROb2RlKHRoaXMuX2lkKTtcclxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIEVkaXRvckV4dGVuZHMuQ29tcG9uZW50LmFkZChjb21wb25lbnQuX2lkLCBjb21wb25lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVJbkhpZXJhcmNoeSkge1xyXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5fbm9kZUFjdGl2YXRvci5hY3RpdmF0ZUNvbXAoY29tcG9uZW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb21wb25lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIFJlbW92ZXMgYSBjb21wb25lbnQgaWRlbnRpZmllZCBieSB0aGUgZ2l2ZW4gbmFtZSBvciByZW1vdmVzIHRoZSBjb21wb25lbnQgb2JqZWN0IGdpdmVuLlxyXG4gICAgICogWW91IGNhbiBhbHNvIHVzZSBjb21wb25lbnQuZGVzdHJveSgpIGlmIHlvdSBhbHJlYWR5IGhhdmUgdGhlIHJlZmVyZW5jZS5cclxuICAgICAqIEB6aFxyXG4gICAgICog5Yig6Zmk6IqC54K55LiK55qE5oyH5a6a57uE5Lu277yM5Lyg5YWl5Y+C5pWw5Y+v5Lul5piv5LiA5Liq57uE5Lu25p6E6YCg5Ye95pWw5oiW57uE5Lu25ZCN77yM5Lmf5Y+v5Lul5piv5bey57uP6I635b6X55qE57uE5Lu25byV55So44CCXHJcbiAgICAgKiDlpoLmnpzkvaDlt7Lnu4/ojrflvpfnu4Tku7blvJXnlKjvvIzkvaDkuZ/lj6/ku6Xnm7TmjqXosIPnlKggY29tcG9uZW50LmRlc3Ryb3koKVxyXG4gICAgICogQHBhcmFtIGNsYXNzQ29uc3RydWN0b3IgVGhlIGNsYXNzIG9mIHRoZSBjb21wb25lbnQgdG8gcmVtb3ZlXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBwbGVhc2UgZGVzdHJveSB0aGUgY29tcG9uZW50IHRvIHJlbW92ZSBpdC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGBcclxuICAgICAqIG5vZGUucmVtb3ZlQ29tcG9uZW50KFNwcml0ZUNvbXBvbmVudCk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZUNvbXBvbmVudDxUIGV4dGVuZHMgQ29tcG9uZW50PiAoY2xhc3NDb25zdHJ1Y3RvcjogQ29uc3RydWN0b3I8VD4pOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBSZW1vdmVzIGEgY29tcG9uZW50IGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIG5hbWUgb3IgcmVtb3ZlcyB0aGUgY29tcG9uZW50IG9iamVjdCBnaXZlbi5cclxuICAgICAqIFlvdSBjYW4gYWxzbyB1c2UgY29tcG9uZW50LmRlc3Ryb3koKSBpZiB5b3UgYWxyZWFkeSBoYXZlIHRoZSByZWZlcmVuY2UuXHJcbiAgICAgKiBAemhcclxuICAgICAqIOWIoOmZpOiKgueCueS4iueahOaMh+Wumue7hOS7tu+8jOS8oOWFpeWPguaVsOWPr+S7peaYr+S4gOS4que7hOS7tuaehOmAoOWHveaVsOaIlue7hOS7tuWQje+8jOS5n+WPr+S7peaYr+W3sue7j+iOt+W+l+eahOe7hOS7tuW8leeUqOOAglxyXG4gICAgICog5aaC5p6c5L2g5bey57uP6I635b6X57uE5Lu25byV55So77yM5L2g5Lmf5Y+v5Lul55u05o6l6LCD55SoIGNvbXBvbmVudC5kZXN0cm95KClcclxuICAgICAqIEBwYXJhbSBjbGFzc05hbWVPckluc3RhbmNlIFRoZSBjbGFzcyBuYW1lIG9mIHRoZSBjb21wb25lbnQgdG8gcmVtb3ZlIG9yIHRoZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgcmVtb3ZlZFxyXG4gICAgICogQGRlcHJlY2F0ZWQgcGxlYXNlIGRlc3Ryb3kgdGhlIGNvbXBvbmVudCB0byByZW1vdmUgaXQuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgXHJcbiAgICAgKiBjb25zdCBzcHJpdGUgPSBub2RlLmdldENvbXBvbmVudChDQy5TcHJpdGUpO1xyXG4gICAgICogaWYgKHNwcml0ZSkge1xyXG4gICAgICogICAgIG5vZGUucmVtb3ZlQ29tcG9uZW50KHNwcml0ZSk7XHJcbiAgICAgKiB9XHJcbiAgICAgKiBub2RlLnJlbW92ZUNvbXBvbmVudCgnY2MuU3ByaXRlQ29tcG9uZW50Jyk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcHVibGljIHJlbW92ZUNvbXBvbmVudCAoY2xhc3NOYW1lT3JJbnN0YW5jZTogc3RyaW5nIHwgQ29tcG9uZW50KTogdm9pZDtcclxuXHJcbiAgICBwdWJsaWMgcmVtb3ZlQ29tcG9uZW50IChjb21wb25lbnQ6IGFueSkge1xyXG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIGVycm9ySUQoMzgxMyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNvbXBvbmVudEluc3RhbmNlOiBDb21wb25lbnQgfCBudWxsID0gbnVsbDtcclxuICAgICAgICBpZiAoY29tcG9uZW50IGluc3RhbmNlb2YgQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlID0gY29tcG9uZW50O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlID0gdGhpcy5nZXRDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudEluc3RhbmNlLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRVZFTlQgUFJPQ0VTU0lOR1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIG9mIGEgc3BlY2lmaWMgZXZlbnQgdHlwZSBvbiBOb2RlLlxyXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHRvIHJlZ2lzdGVyIHRvdWNoIG9yIG1vdXNlIGV2ZW50IHBlcm1pdCBwcm9wYWdhdGlvbiBiYXNlZCBvbiBzY2VuZSBncmFwaCxcclxuICAgICAqIFRoZXNlIGtpbmRzIG9mIGV2ZW50IGFyZSB0cmlnZ2VyZWQgd2l0aCBkaXNwYXRjaEV2ZW50LCB0aGUgZGlzcGF0Y2ggcHJvY2VzcyBoYXMgdGhyZWUgc3RlcHM6XHJcbiAgICAgKiAxLiBDYXB0dXJpbmcgcGhhc2U6IGRpc3BhdGNoIGluIGNhcHR1cmUgdGFyZ2V0cyAoYF9nZXRDYXB0dXJpbmdUYXJnZXRzYCksIGUuZy4gcGFyZW50cyBpbiBub2RlIHRyZWUsIGZyb20gcm9vdCB0byB0aGUgcmVhbCB0YXJnZXRcclxuICAgICAqIDIuIEF0IHRhcmdldCBwaGFzZTogZGlzcGF0Y2ggdG8gdGhlIGxpc3RlbmVycyBvZiB0aGUgcmVhbCB0YXJnZXRcclxuICAgICAqIDMuIEJ1YmJsaW5nIHBoYXNlOiBkaXNwYXRjaCBpbiBidWJibGUgdGFyZ2V0cyAoYF9nZXRCdWJibGluZ1RhcmdldHNgKSwgZS5nLiBwYXJlbnRzIGluIG5vZGUgdHJlZSwgZnJvbSB0aGUgcmVhbCB0YXJnZXQgdG8gcm9vdFxyXG4gICAgICogSW4gYW55IG1vbWVudCBvZiB0aGUgZGlzcGF0Y2hpbmcgcHJvY2VzcywgaXQgY2FuIGJlIHN0b3BwZWQgdmlhIGBldmVudC5zdG9wUHJvcGFnYXRpb24oKWAgb3IgYGV2ZW50LnN0b3BQcm9wYWdhdGlvbkltbWlkaWF0ZSgpYC5cclxuICAgICAqIEl0J3MgdGhlIHJlY29tbWVuZGVkIHdheSB0byByZWdpc3RlciB0b3VjaC9tb3VzZSBldmVudCBmb3IgTm9kZSxcclxuICAgICAqIHBsZWFzZSBkbyBub3QgdXNlIGNjLmV2ZW50TWFuYWdlciBkaXJlY3RseSBmb3IgTm9kZS5cclxuICAgICAqIFlvdSBjYW4gYWxzbyByZWdpc3RlciBjdXN0b20gZXZlbnQgYW5kIHVzZSBgZW1pdGAgdG8gdHJpZ2dlciBjdXN0b20gZXZlbnQgb24gTm9kZS5cclxuICAgICAqIEZvciBzdWNoIGV2ZW50cywgdGhlcmUgd29uJ3QgYmUgY2FwdHVyaW5nIGFuZCBidWJibGluZyBwaGFzZSwgeW91ciBldmVudCB3aWxsIGJlIGRpc3BhdGNoZWQgZGlyZWN0bHkgdG8gaXRzIGxpc3RlbmVycyByZWdpc3RlcmVkIG9uIHRoZSBzYW1lIG5vZGUuXHJcbiAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBldmVudCBjYWxsYmFjayBwYXJhbWV0ZXJzIHdpdGggYGVtaXRgIGJ5IHBhc3NpbmcgcGFyYW1ldGVycyBhZnRlciBgdHlwZWAuXHJcbiAgICAgKiBAemhcclxuICAgICAqIOWcqOiKgueCueS4iuazqOWGjOaMh+Wumuexu+Wei+eahOWbnuiwg+WHveaVsO+8jOS5n+WPr+S7peiuvue9riB0YXJnZXQg55So5LqO57uR5a6a5ZON5bqU5Ye95pWw55qEIHRoaXMg5a+56LGh44CCXHJcbiAgICAgKiDpvKDmoIfmiJbop6bmkbjkuovku7bkvJrooqvns7vnu5/osIPnlKggZGlzcGF0Y2hFdmVudCDmlrnms5Xop6blj5HvvIzop6blj5HnmoTov4fnqIvljIXlkKvkuInkuKrpmLbmrrXvvJpcclxuICAgICAqIDEuIOaNleiOt+mYtuaute+8mua0vuWPkeS6i+S7tue7meaNleiOt+ebruagh++8iOmAmui/hyBgX2dldENhcHR1cmluZ1RhcmdldHNgIOiOt+WPlu+8ie+8jOavlOWmgu+8jOiKgueCueagkeS4reazqOWGjOS6huaNleiOt+mYtuauteeahOeItuiKgueCue+8jOS7juagueiKgueCueW8gOWni+a0vuWPkeebtOWIsOebruagh+iKgueCueOAglxyXG4gICAgICogMi4g55uu5qCH6Zi25q6177ya5rS+5Y+R57uZ55uu5qCH6IqC54K555qE55uR5ZCs5Zmo44CCXHJcbiAgICAgKiAzLiDlhpLms6HpmLbmrrXvvJrmtL7lj5Hkuovku7bnu5nlhpLms6Hnm67moIfvvIjpgJrov4cgYF9nZXRCdWJibGluZ1RhcmdldHNgIOiOt+WPlu+8ie+8jOavlOWmgu+8jOiKgueCueagkeS4reazqOWGjOS6huWGkuazoemYtuauteeahOeItuiKgueCue+8jOS7juebruagh+iKgueCueW8gOWni+a0vuWPkeebtOWIsOagueiKgueCueOAglxyXG4gICAgICog5ZCM5pe25oKo5Y+v5Lul5bCG5LqL5Lu25rS+5Y+R5Yiw54i26IqC54K55oiW6ICF6YCa6L+H6LCD55SoIHN0b3BQcm9wYWdhdGlvbiDmi6bmiKrlroPjgIJcclxuICAgICAqIOaOqOiNkOS9v+eUqOi/meenjeaWueW8j+adpeebkeWQrOiKgueCueS4iueahOinpuaRuOaIlum8oOagh+S6i+S7tu+8jOivt+S4jeimgeWcqOiKgueCueS4iuebtOaOpeS9v+eUqCBjYy5ldmVudE1hbmFnZXLjgIJcclxuICAgICAqIOS9oOS5n+WPr+S7peazqOWGjOiHquWumuS5ieS6i+S7tuWIsOiKgueCueS4iu+8jOW5tumAmui/hyBlbWl0IOaWueazleinpuWPkeatpOexu+S6i+S7tu+8jOWvueS6jui/meexu+S6i+S7tu+8jOS4jeS8muWPkeeUn+aNleiOt+WGkuazoemYtuaute+8jOWPquS8muebtOaOpea0vuWPkee7meazqOWGjOWcqOivpeiKgueCueS4iueahOebkeWQrOWZqFxyXG4gICAgICog5L2g5Y+v5Lul6YCa6L+H5ZyoIGVtaXQg5pa55rOV6LCD55So5pe25ZyoIHR5cGUg5LmL5ZCO5Lyg6YCS6aKd5aSW55qE5Y+C5pWw5L2c5Li65LqL5Lu25Zue6LCD55qE5Y+C5pWw5YiX6KGoXHJcbiAgICAgKiBAcGFyYW0gdHlwZSAtIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yLjxicj5TZWUge3sjY3Jvc3NMaW5rIFwiTm9kZS9FdmVudFR5dXBlL1BPU0lUSU9OX0NIQU5HRURcIn19Tm9kZSBFdmVudHN7ey9jcm9zc0xpbmt9fSBmb3IgYWxsIGJ1aWx0aW4gZXZlbnRzLlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gdGhlIGV2ZW50IGlzIGRpc3BhdGNoZWQuIFRoZSBjYWxsYmFjayBpcyBpZ25vcmVkIGlmIGl0IGlzIGEgZHVwbGljYXRlICh0aGUgY2FsbGJhY2tzIGFyZSB1bmlxdWUpLlxyXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgKHRoaXMgb2JqZWN0KSB0byBpbnZva2UgdGhlIGNhbGxiYWNrLCBjYW4gYmUgbnVsbFxyXG4gICAgICogQHBhcmFtIHVzZUNhcHR1cmUgLSBXaGVuIHNldCB0byB0cnVlLCB0aGUgbGlzdGVuZXIgd2lsbCBiZSB0cmlnZ2VyZWQgYXQgY2FwdHVyaW5nIHBoYXNlIHdoaWNoIGlzIGFoZWFkIG9mIHRoZSBmaW5hbCB0YXJnZXQgZW1pdCwgb3RoZXJ3aXNlIGl0IHdpbGwgYmUgdHJpZ2dlcmVkIGR1cmluZyBidWJibGluZyBwaGFzZS5cclxuICAgICAqIEByZXR1cm4gLSBKdXN0IHJldHVybnMgdGhlIGluY29taW5nIGNhbGxiYWNrIHNvIHlvdSBjYW4gc2F2ZSB0aGUgYW5vbnltb3VzIGZ1bmN0aW9uIGVhc2llci5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiB0aGlzLm5vZGUub24oU3lzdGVtRXZlbnRUeXBlLlRPVUNIX1NUQVJULCB0aGlzLm1lbWJlckZ1bmN0aW9uLCB0aGlzKTsgIC8vIGlmIFwidGhpc1wiIGlzIGNvbXBvbmVudCBhbmQgdGhlIFwibWVtYmVyRnVuY3Rpb25cIiBkZWNsYXJlZCBpbiBDQ0NsYXNzLlxyXG4gICAgICogbm9kZS5vbihTeXN0ZW1FdmVudFR5cGUuVE9VQ0hfU1RBUlQsIGNhbGxiYWNrLCB0aGlzKTtcclxuICAgICAqIG5vZGUub24oU3lzdGVtRXZlbnRUeXBlLlRPVUNIX01PVkUsIGNhbGxiYWNrLCB0aGlzKTtcclxuICAgICAqIG5vZGUub24oU3lzdGVtRXZlbnRUeXBlLlRPVUNIX0VORCwgY2FsbGJhY2ssIHRoaXMpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvbiAodHlwZTogc3RyaW5nIHwgU3lzdGVtRXZlbnRUeXBlLCBjYWxsYmFjazogRnVuY3Rpb24sIHRhcmdldD86IE9iamVjdCwgdXNlQ2FwdHVyZTogYW55ID0gZmFsc2UpIHtcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBTeXN0ZW1FdmVudFR5cGUuVFJBTlNGT1JNX0NIQU5HRUQ6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudE1hc2sgfD0gVFJBTlNGT1JNX09OO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2V2ZW50UHJvY2Vzc29yLm9uKHR5cGUsIGNhbGxiYWNrLCB0YXJnZXQsIHVzZUNhcHR1cmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBjYWxsYmFjayBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCB0aGUgc2FtZSB0eXBlLCBjYWxsYmFjaywgdGFyZ2V0IGFuZCBvciB1c2VDYXB0dXJlLlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgbWVyZWx5IGFuIGFsaWFzIHRvIHJlbW92ZUV2ZW50TGlzdGVuZXIuXHJcbiAgICAgKiBAemgg5Yig6Zmk5LmL5YmN5LiO5ZCM57G75Z6L77yM5Zue6LCD77yM55uu5qCH5oiWIHVzZUNhcHR1cmUg5rOo5YaM55qE5Zue6LCD44CCXHJcbiAgICAgKiBAcGFyYW0gdHlwZSAtIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSBiZWluZyByZW1vdmVkLlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIHRvIHJlbW92ZS5cclxuICAgICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdGFyZ2V0ICh0aGlzIG9iamVjdCkgdG8gaW52b2tlIHRoZSBjYWxsYmFjaywgaWYgaXQncyBub3QgZ2l2ZW4sIG9ubHkgY2FsbGJhY2sgd2l0aG91dCB0YXJnZXQgd2lsbCBiZSByZW1vdmVkXHJcbiAgICAgKiBAcGFyYW0gdXNlQ2FwdHVyZSAtIFdoZW4gc2V0IHRvIHRydWUsIHRoZSBsaXN0ZW5lciB3aWxsIGJlIHRyaWdnZXJlZCBhdCBjYXB0dXJpbmcgcGhhc2Ugd2hpY2ggaXMgYWhlYWQgb2YgdGhlIGZpbmFsIHRhcmdldCBlbWl0LCBvdGhlcndpc2UgaXQgd2lsbCBiZSB0cmlnZ2VyZWQgZHVyaW5nIGJ1YmJsaW5nIHBoYXNlLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIHRoaXMubm9kZS5vZmYoU3lzdGVtRXZlbnRUeXBlLlRPVUNIX1NUQVJULCB0aGlzLm1lbWJlckZ1bmN0aW9uLCB0aGlzKTtcclxuICAgICAqIG5vZGUub2ZmKFN5c3RlbUV2ZW50VHlwZS5UT1VDSF9TVEFSVCwgY2FsbGJhY2ssIHRoaXMubm9kZSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqL1xyXG4gICAgcHVibGljIG9mZiAodHlwZTogc3RyaW5nLCBjYWxsYmFjaz86IEZ1bmN0aW9uLCB0YXJnZXQ/OiBPYmplY3QsIHVzZUNhcHR1cmU6IGFueSA9IGZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRQcm9jZXNzb3Iub2ZmKHR5cGUsIGNhbGxiYWNrLCB0YXJnZXQsIHVzZUNhcHR1cmUpO1xyXG5cclxuICAgICAgICBjb25zdCBoYXNMaXN0ZW5lcnMgPSB0aGlzLl9ldmVudFByb2Nlc3Nvci5oYXNFdmVudExpc3RlbmVyKHR5cGUpO1xyXG4gICAgICAgIC8vIEFsbCBsaXN0ZW5lciByZW1vdmVkXHJcbiAgICAgICAgaWYgKCFoYXNMaXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFN5c3RlbUV2ZW50VHlwZS5UUkFOU0ZPUk1fQ0hBTkdFRDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudE1hc2sgJj0gflRSQU5TRk9STV9PTjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogUmVnaXN0ZXIgYW4gY2FsbGJhY2sgb2YgYSBzcGVjaWZpYyBldmVudCB0eXBlIG9uIHRoZSBOb2RlLFxyXG4gICAgICogdGhlIGNhbGxiYWNrIHdpbGwgcmVtb3ZlIGl0c2VsZiBhZnRlciB0aGUgZmlyc3QgdGltZSBpdCBpcyB0cmlnZ2VyZWQuXHJcbiAgICAgKiBAemhcclxuICAgICAqIOazqOWGjOiKgueCueeahOeJueWumuS6i+S7tuexu+Wei+Wbnuiwg++8jOWbnuiwg+S8muWcqOesrOS4gOaXtumXtOiiq+inpuWPkeWQjuWIoOmZpOiHqui6q+OAglxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0eXBlIC0gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiBmb3IuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgd2hlbiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGNhbGxiYWNrIGlzIGlnbm9yZWQgaWYgaXQgaXMgYSBkdXBsaWNhdGUgKHRoZSBjYWxsYmFja3MgYXJlIHVuaXF1ZSkuXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCAodGhpcyBvYmplY3QpIHRvIGludm9rZSB0aGUgY2FsbGJhY2ssIGNhbiBiZSBudWxsXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBvbmNlICh0eXBlOiBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbiwgdGFyZ2V0PzogT2JqZWN0LCB1c2VDYXB0dXJlPzogYW55KSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRQcm9jZXNzb3Iub25jZSh0eXBlLCBjYWxsYmFjaywgdGFyZ2V0LCB1c2VDYXB0dXJlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogVHJpZ2dlciBhbiBldmVudCBkaXJlY3RseSB3aXRoIHRoZSBldmVudCBuYW1lIGFuZCBuZWNlc3NhcnkgYXJndW1lbnRzLlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDpgJrov4fkuovku7blkI3lj5HpgIHoh6rlrprkuYnkuovku7ZcclxuICAgICAqIEBwYXJhbSB0eXBlIC0gZXZlbnQgdHlwZVxyXG4gICAgICogQHBhcmFtIGFyZzEgLSBGaXJzdCBhcmd1bWVudCBpbiBjYWxsYmFja1xyXG4gICAgICogQHBhcmFtIGFyZzIgLSBTZWNvbmQgYXJndW1lbnQgaW4gY2FsbGJhY2tcclxuICAgICAqIEBwYXJhbSBhcmczIC0gVGhpcmQgYXJndW1lbnQgaW4gY2FsbGJhY2tcclxuICAgICAqIEBwYXJhbSBhcmc0IC0gRm91cnRoIGFyZ3VtZW50IGluIGNhbGxiYWNrXHJcbiAgICAgKiBAcGFyYW0gYXJnNSAtIEZpZnRoIGFyZ3VtZW50IGluIGNhbGxiYWNrXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogZXZlbnRUYXJnZXQuZW1pdCgnZmlyZScsIGV2ZW50KTtcclxuICAgICAqIGV2ZW50VGFyZ2V0LmVtaXQoJ2ZpcmUnLCBtZXNzYWdlLCBlbWl0dGVyKTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZW1pdCAodHlwZTogc3RyaW5nLCBhcmcwPzogYW55LCBhcmcxPzogYW55LCBhcmcyPzogYW55LCBhcmczPzogYW55LCBhcmc0PzogYW55KSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRQcm9jZXNzb3IuZW1pdCh0eXBlLCBhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogRGlzcGF0Y2hlcyBhbiBldmVudCBpbnRvIHRoZSBldmVudCBmbG93LlxyXG4gICAgICogVGhlIGV2ZW50IHRhcmdldCBpcyB0aGUgRXZlbnRUYXJnZXQgb2JqZWN0IHVwb24gd2hpY2ggdGhlIGRpc3BhdGNoRXZlbnQoKSBtZXRob2QgaXMgY2FsbGVkLlxyXG4gICAgICogQHpoIOWIhuWPkeS6i+S7tuWIsOS6i+S7tua1geS4reOAglxyXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIEV2ZW50IG9iamVjdCB0aGF0IGlzIGRpc3BhdGNoZWQgaW50byB0aGUgZXZlbnQgZmxvd1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGlzcGF0Y2hFdmVudCAoZXZlbnQ6IEV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRQcm9jZXNzb3IuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gQ2hlY2tzIHdoZXRoZXIgdGhlIEV2ZW50VGFyZ2V0IG9iamVjdCBoYXMgYW55IGNhbGxiYWNrIHJlZ2lzdGVyZWQgZm9yIGEgc3BlY2lmaWMgdHlwZSBvZiBldmVudC5cclxuICAgICAqIEB6aCDmo4Dmn6Xkuovku7bnm67moIflr7nosaHmmK/lkKbmnInkuLrnibnlrprnsbvlnovnmoTkuovku7bms6jlhoznmoTlm57osIPjgIJcclxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgZXZlbnQuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gb2YgdGhlIGV2ZW50IGxpc3RlbmVyLCBpZiBhYnNlbnQgYWxsIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIGdpdmVuIHR5cGUgd2lsbCBiZSByZW1vdmVkXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIGNhbGxiYWNrIGNhbGxlZSBvZiB0aGUgZXZlbnQgbGlzdGVuZXJcclxuICAgICAqIEByZXR1cm4gVHJ1ZSBpZiBhIGNhbGxiYWNrIG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBpcyByZWdpc3RlcmVkOyBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBoYXNFdmVudExpc3RlbmVyICh0eXBlOiBzdHJpbmcsIGNhbGxiYWNrPzogRnVuY3Rpb24sIHRhcmdldD86IE9iamVjdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudFByb2Nlc3Nvci5oYXNFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrLCB0YXJnZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFJlbW92ZXMgYWxsIGNhbGxiYWNrcyBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgd2l0aCB0aGUgc2FtZSB0YXJnZXQuXHJcbiAgICAgKiBAemgg56e76Zmk55uu5qCH5LiK55qE5omA5pyJ5rOo5YaM5LqL5Lu244CCXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCB0byBiZSBzZWFyY2hlZCBmb3IgYWxsIHJlbGF0ZWQgY2FsbGJhY2tzXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB0YXJnZXRPZmYgKHRhcmdldDogc3RyaW5nIHwgT2JqZWN0KSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRQcm9jZXNzb3IudGFyZ2V0T2ZmKHRhcmdldCk7XHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGV2ZW50IG1hc2sgcmVzZXRcclxuICAgICAgICBpZiAoKHRoaXMuX2V2ZW50TWFzayAmIFRSQU5TRk9STV9PTikgJiYgIXRoaXMuX2V2ZW50UHJvY2Vzc29yLmhhc0V2ZW50TGlzdGVuZXIoU3lzdGVtRXZlbnRUeXBlLlRSQU5TRk9STV9DSEFOR0VEKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudE1hc2sgJj0gflRSQU5TRk9STV9PTjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRlc3Ryb3kgKCkge1xyXG4gICAgICAgIGlmIChzdXBlci5kZXN0cm95KCkpIHtcclxuICAgICAgICAgICAgLy8gZGlzYWJsZSBoaWVyYXJjaHlcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUluSGllcmFyY2h5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNhYmxlQ2hpbGRDb21wcygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogRGVzdHJveSBhbGwgY2hpbGRyZW4gZnJvbSB0aGUgbm9kZSwgYW5kIHJlbGVhc2UgYWxsIHRoZWlyIG93biByZWZlcmVuY2VzIHRvIG90aGVyIG9iamVjdHMuXHJcbiAgICAgKiBBY3R1YWwgZGVzdHJ1Y3Qgb3BlcmF0aW9uIHdpbGwgZGVsYXllZCB1bnRpbCBiZWZvcmUgcmVuZGVyaW5nLlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDplIDmr4HmiYDmnInlrZDoioLngrnvvIzlubbph4rmlL7miYDmnInlroPku6zlr7nlhbblroPlr7nosaHnmoTlvJXnlKjjgIJcclxuICAgICAqIOWunumZhemUgOavgeaTjeS9nOS8muW7tui/n+WIsOW9k+WJjeW4p+a4suafk+WJjeaJp+ihjOOAglxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgZGVzdHJveUFsbENoaWxkcmVuICgpIHtcclxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgY2hpbGRyZW5baV0uZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyByZW1vdmUgY29tcG9uZW50LCBvbmx5IHVzZWQgaW50ZXJuYWxseS5cclxuICAgIHB1YmxpYyBfcmVtb3ZlQ29tcG9uZW50IChjb21wb25lbnQ6IENvbXBvbmVudCkge1xyXG4gICAgICAgIGlmICghY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIGVycm9ySUQoMzgxNCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghKHRoaXMuX29iakZsYWdzICYgRGVzdHJveWluZykpIHtcclxuICAgICAgICAgICAgY29uc3QgaSA9IHRoaXMuX2NvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKEVESVRPUiAmJiBFZGl0b3JFeHRlbmRzLkNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIEVkaXRvckV4dGVuZHMuQ29tcG9uZW50LnJlbW92ZShjb21wb25lbnQuX2lkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudC5ub2RlICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcklEKDM4MTUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBfdXBkYXRlU2libGluZ0luZGV4ICgpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuW2ldLl9zaWJsaW5nSW5kZXggPSBpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX29uU2V0UGFyZW50IChvbGRQYXJlbnQ6IHRoaXMgfCBudWxsLCBrZWVwV29ybGRUcmFuc2Zvcm06IGJvb2xlYW4gPSBmYWxzZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKChvbGRQYXJlbnQgPT0gbnVsbCB8fCBvbGRQYXJlbnQuX3NjZW5lICE9PSB0aGlzLl9wYXJlbnQuX3NjZW5lKSAmJiB0aGlzLl9wYXJlbnQuX3NjZW5lICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2Fsaygobm9kZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIEJhc2VOb2RlLl9zZXRTY2VuZShub2RlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFBSSVZBVEVcclxuXHJcbiAgICBwcm90ZWN0ZWQgX29uUG9zdEFjdGl2YXRlZCAoYWN0aXZlOiBib29sZWFuKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfb25CYXRjaFJlc3RvcmVkICgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9vbkJhdGNoQ3JlYXRlZCAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zaWJsaW5nSW5kZXggPSB0aGlzLl9wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfb25QcmVEZXN0cm95ICgpIHtcclxuICAgICAgICB0aGlzLl9vblByZURlc3Ryb3lCYXNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvdGVjdGVkIF9vbkhpZXJhcmNoeUNoYW5nZWQgKG9sZFBhcmVudDogdGhpcyB8IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb25IaWVyYXJjaHlDaGFuZ2VkQmFzZShvbGRQYXJlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfaW5zdGFudGlhdGUgKGNsb25lZCkge1xyXG4gICAgICAgIGlmICghY2xvbmVkKSB7XHJcbiAgICAgICAgICAgIGNsb25lZCA9IGNjLmluc3RhbnRpYXRlLl9jbG9uZSh0aGlzLCB0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHRoaXNQcmVmYWJJbmZvID0gdGhpcy5fcHJlZmFiO1xyXG4gICAgICAgIGlmIChFRElUT1IgJiYgdGhpc1ByZWZhYkluZm8pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMgIT09IHRoaXNQcmVmYWJJbmZvLnJvb3QpIHt9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN5bmNpbmcgPSB0aGlzUHJlZmFiSW5mbyAmJiB0aGlzID09PSB0aGlzUHJlZmFiSW5mby5yb290ICYmIHRoaXNQcmVmYWJJbmZvLnN5bmM7XHJcbiAgICAgICAgaWYgKHN5bmNpbmcpIHtcclxuICAgICAgICAgICAgLy8gaWYgKHRoaXNQcmVmYWJJbmZvLl9zeW5jZWQpIHtcclxuICAgICAgICAgICAgLy8gICAgcmV0dXJuIGNsb25lO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChFRElUT1IgJiYgY2MuZW5naW5lLl9pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgY2xvbmVkLl9uYW1lICs9ICcgKENsb25lKSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZXNldCBhbmQgaW5pdFxyXG4gICAgICAgIGNsb25lZC5fcGFyZW50ID0gbnVsbDtcclxuICAgICAgICBjbG9uZWQuX29uQmF0Y2hSZXN0b3JlZCgpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2xvbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfb25IaWVyYXJjaHlDaGFuZ2VkQmFzZSAob2xkUGFyZW50OiB0aGlzIHwgbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcmVudCA9IHRoaXMuX3BhcmVudDtcclxuICAgICAgICBpZiAodGhpcy5fcGVyc2lzdE5vZGUgJiYgIShuZXdQYXJlbnQgaW5zdGFuY2VvZiBjYy5TY2VuZSkpIHtcclxuICAgICAgICAgICAgY2MuZ2FtZS5yZW1vdmVQZXJzaXN0Um9vdE5vZGUodGhpcyk7XHJcbiAgICAgICAgICAgIGlmIChFRElUT1IpIHtcclxuICAgICAgICAgICAgICAgIHdhcm5JRCgxNjIzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKEVESVRPUikge1xyXG4gICAgICAgICAgICBjb25zdCBzY2VuZSA9IGNjLmRpcmVjdG9yLmdldFNjZW5lKCkgYXMgdGhpcyB8IG51bGw7XHJcbiAgICAgICAgICAgIGNvbnN0IGluQ3VycmVudFNjZW5lQmVmb3JlID0gb2xkUGFyZW50ICYmIG9sZFBhcmVudC5pc0NoaWxkT2Yoc2NlbmUpO1xyXG4gICAgICAgICAgICBjb25zdCBpbkN1cnJlbnRTY2VuZU5vdyA9IG5ld1BhcmVudCAmJiBuZXdQYXJlbnQuaXNDaGlsZE9mKHNjZW5lKTtcclxuICAgICAgICAgICAgaWYgKCFpbkN1cnJlbnRTY2VuZUJlZm9yZSAmJiBpbkN1cnJlbnRTY2VuZU5vdykge1xyXG4gICAgICAgICAgICAgICAgLy8gYXR0YWNoZWRcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVySWZBdHRhY2hlZCEodHJ1ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5DdXJyZW50U2NlbmVCZWZvcmUgJiYgIWluQ3VycmVudFNjZW5lTm93KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZXRhY2hlZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJJZkF0dGFjaGVkIShmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGNvbmZsaWN0IGRldGVjdGlvblxyXG4gICAgICAgICAgICAvLyBfU2NlbmUuRGV0ZWN0Q29uZmxpY3QuYWZ0ZXJBZGRDaGlsZCh0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNob3VsZEFjdGl2ZU5vdyA9IHRoaXMuX2FjdGl2ZSAmJiAhIShuZXdQYXJlbnQgJiYgbmV3UGFyZW50Ll9hY3RpdmVJbkhpZXJhcmNoeSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUluSGllcmFyY2h5ICE9PSBzaG91bGRBY3RpdmVOb3cpIHtcclxuICAgICAgICAgICAgY2MuZGlyZWN0b3IuX25vZGVBY3RpdmF0b3IuYWN0aXZhdGVOb2RlKHRoaXMsIHNob3VsZEFjdGl2ZU5vdyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfb25QcmVEZXN0cm95QmFzZSAoKSB7XHJcbiAgICAgICAgLy8gbWFya2VkIGFzIGRlc3Ryb3lpbmdcclxuICAgICAgICB0aGlzLl9vYmpGbGFncyB8PSBEZXN0cm95aW5nO1xyXG5cclxuICAgICAgICAvLyBkZXRhY2ggc2VsZiBhbmQgY2hpbGRyZW4gZnJvbSBlZGl0b3JcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XHJcbiAgICAgICAgY29uc3QgZGVzdHJveUJ5UGFyZW50OiBib29sZWFuID0gKCEhcGFyZW50KSAmJiAoKHBhcmVudC5fb2JqRmxhZ3MgJiBEZXN0cm95aW5nKSAhPT0gMCk7XHJcbiAgICAgICAgaWYgKCFkZXN0cm95QnlQYXJlbnQgJiYgRURJVE9SKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVySWZBdHRhY2hlZCEoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlIGZyb20gcGVyc2lzdFxyXG4gICAgICAgIGlmICh0aGlzLl9wZXJzaXN0Tm9kZSkge1xyXG4gICAgICAgICAgICBjYy5nYW1lLnJlbW92ZVBlcnNpc3RSb290Tm9kZSh0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghZGVzdHJveUJ5UGFyZW50KSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBmcm9tIHBhcmVudFxyXG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoU3lzdGVtRXZlbnRUeXBlLlBBUkVOVF9DSEFOR0VELCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIC8vIER1cmluZyBkZXN0cm95IHByb2Nlc3MsIHNpYmxpbmdJbmRleCBpcyBub3QgcmVseWFibGVcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkSW5kZXggPSBwYXJlbnQuX2NoaWxkcmVuLmluZGV4T2YodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBwYXJlbnQuX2NoaWxkcmVuLnNwbGljZShjaGlsZEluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NpYmxpbmdJbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LmVtaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuZW1pdChTeXN0ZW1FdmVudFR5cGUuQ0hJTERfUkVNT1ZFRCwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGVtaXQgbm9kZSBkZXN0cm95IGV2ZW50ICh0aGlzIHNob3VsZCBiZWZvcmUgZXZlbnQgcHJvY2Vzc29yIGRlc3Ryb3kpXHJcbiAgICAgICAgdGhpcy5lbWl0KFN5c3RlbUV2ZW50VHlwZS5OT0RFX0RFU1RST1lFRCwgdGhpcyk7XHJcblxyXG4gICAgICAgIC8vIERlc3Ryb3kgbm9kZSBldmVudCBwcm9jZXNzb3JcclxuICAgICAgICB0aGlzLl9ldmVudFByb2Nlc3Nvci5kZXN0cm95KCk7XHJcblxyXG4gICAgICAgIC8vIGRlc3Ryb3kgY2hpbGRyZW5cclxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgLy8gZGVzdHJveSBpbW1lZGlhdGUgc28gaXRzIF9vblByZURlc3Ryb3kgY2FuIGJlIGNhbGxlZFxyXG4gICAgICAgICAgICBjaGlsZHJlbltpXS5fZGVzdHJveUltbWVkaWF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZGVzdHJveSBzZWxmIGNvbXBvbmVudHNcclxuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMuX2NvbXBvbmVudHM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21wcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAvLyBkZXN0cm95IGltbWVkaWF0ZSBzbyBpdHMgX29uUHJlRGVzdHJveSBjYW4gYmUgY2FsbGVkXHJcbiAgICAgICAgICAgIC8vIFRPIERPXHJcbiAgICAgICAgICAgIGNvbXBzW2ldLl9kZXN0cm95SW1tZWRpYXRlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGVzdHJveUJ5UGFyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHByb3RlY3RlZCBfZGlzYWJsZUNoaWxkQ29tcHMgKCkge1xyXG4gICAgICAgIC8vIGxlYXZlIHRoaXMuX2FjdGl2ZUluSGllcmFyY2h5IHVubW9kaWZpZWRcclxuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMuX2NvbXBvbmVudHM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21wcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBjb21wc1tpXTtcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5fZW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgY2MuZGlyZWN0b3IuX2NvbXBTY2hlZHVsZXIuZGlzYWJsZUNvbXAoY29tcG9uZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkZWFjdGl2YXRlIHJlY3Vyc2l2ZWx5XHJcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgaWYgKG5vZGUuX2FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5fZGlzYWJsZUNoaWxkQ29tcHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcm90ZWN0ZWQgX29uU2libGluZ0luZGV4Q2hhbmdlZD8gKHNpYmxpbmdJbmRleDogbnVtYmVyKTogdm9pZDtcclxuXHJcbiAgICBwcm90ZWN0ZWQgX2NoZWNrTXVsdGlwbGVDb21wPyAoY29uc3RydWN0b3I6IEZ1bmN0aW9uKTogYm9vbGVhbjtcclxufVxyXG5cclxuYmFzZU5vZGVQb2x5ZmlsbChCYXNlTm9kZSk7XHJcblxyXG4vKipcclxuICogQGVuXHJcbiAqIE5vdGU6IFRoaXMgZXZlbnQgaXMgb25seSBlbWl0dGVkIGZyb20gdGhlIHRvcCBtb3N0IG5vZGUgd2hvc2UgYWN0aXZlIHZhbHVlIGRpZCBjaGFuZ2VkLFxyXG4gKiBub3QgaW5jbHVkaW5nIGl0cyBjaGlsZCBub2Rlcy5cclxuICogQHpoXHJcbiAqIOazqOaEj++8muatpOiKgueCuea/gOa0u+aXtu+8jOatpOS6i+S7tuS7heS7juacgOmhtumDqOeahOiKgueCueWPkeWHuuOAglxyXG4gKiBAZXZlbnQgYWN0aXZlLWluLWhpZXJhcmNoeS1jaGFuZ2VkXHJcbiAqIEBwYXJhbSB7RXZlbnQuRXZlbnRDdXN0b219IGV2ZW50XHJcbiAqL1xyXG5cclxuY2MuX0Jhc2VOb2RlID0gQmFzZU5vZGU7XHJcbiJdfQ==