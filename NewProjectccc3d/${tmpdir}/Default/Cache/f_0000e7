(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "../../core/utils/js.js", "../../core/platform/debug.js"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("../../core/utils/js.js"), require("../../core/platform/debug.js"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.js, global.debug);
    global.actionManager = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, js, _debug) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.ActionManager = void 0;
  js = _interopRequireWildcard(js);

  function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var ID_COUNTER = 0;
  /*
   * @class HashElement
   * @constructor
   * @private
   */

  var HashElement = function HashElement() {
    _classCallCheck(this, HashElement);

    this.actions = [];
    this.target = null;
    this.actionIndex = 0;
    this.currentAction = null;
    this.paused = false;
    this.lock = false;
  };
  /**
   * !#en
   * cc.ActionManager is a class that can manage actions.<br/>
   * Normally you won't need to use this class directly. 99% of the cases you will use the CCNode interface,
   * which uses this class's singleton object.
   * But there are some cases where you might need to use this class. <br/>
   * Examples:<br/>
   * - When you want to run an action where the target is different from a CCNode.<br/>
   * - When you want to pause / resume the actions<br/>
   * !#zh
   * cc.ActionManager 是可以管理动作的单例类。<br/>
   * 通常你并不需要直接使用这个类，99%的情况您将使用 CCNode 的接口。<br/>
   * 但也有一些情况下，您可能需要使用这个类。 <br/>
   * 例如：
   *  - 当你想要运行一个动作，但目标不是 CCNode 类型时。 <br/>
   *  - 当你想要暂停/恢复动作时。 <br/>
   * @class ActionManager
   * @example {@link cocos2d/core/CCActionManager/ActionManager.js}
   */


  var ActionManager = /*#__PURE__*/function () {
    function ActionManager() {
      _classCallCheck(this, ActionManager);

      this._hashTargets = js.createMap(true);
      this._arrayTargets = [];
      this._elementPool = [];
    }

    _createClass(ActionManager, [{
      key: "_searchElementByTarget",
      value: function _searchElementByTarget(arr, target) {
        for (var k = 0; k < arr.length; k++) {
          if (target === arr[k].target) return arr[k];
        }

        return null;
      }
    }, {
      key: "_getElement",
      value: function _getElement(target, paused) {
        var element = this._elementPool.pop();

        if (!element) {
          element = new HashElement();
        }

        element.target = target;
        element.paused = !!paused;
        return element;
      }
    }, {
      key: "_putElement",
      value: function _putElement(element) {
        element.actions.length = 0;
        element.actionIndex = 0;
        element.currentAction = null;
        element.paused = false;
        element.target = null;
        element.lock = false;

        this._elementPool.push(element);
      }
      /**
       * !#en
       * Adds an action with a target.<br/>
       * If the target is already present, then the action will be added to the existing target.
       * If the target is not present, a new instance of this target will be created either paused or not, and the action will be added to the newly created target.
       * When the target is paused, the queued actions won't be 'ticked'.
       * !#zh
       * 增加一个动作，同时还需要提供动作的目标对象，目标对象是否暂停作为参数。<br/>
       * 如果目标已存在，动作将会被直接添加到现有的节点中。<br/>
       * 如果目标不存在，将为这一目标创建一个新的实例，并将动作添加进去。<br/>
       * 当目标状态的 paused 为 true，动作将不会被执行
       *
       * @method addAction
       * @param {Action} action
       * @param {object} target
       * @param {Boolean} paused
       */

    }, {
      key: "addAction",
      value: function addAction(action, target, paused) {
        if (!action || !target) {
          (0, _debug.errorID)(1000);
          return;
        }

        if (target.uuid == null) {
          target.uuid = '_TWEEN_UUID_' + ID_COUNTER++;
        } //check if the action target already exists


        var element = this._hashTargets[target.uuid]; //if doesn't exists, create a hashelement and push in mpTargets

        if (!element) {
          element = this._getElement(target, paused);
          this._hashTargets[target.uuid] = element;

          this._arrayTargets.push(element);
        } else if (!element.actions) {
          element.actions = [];
        }

        element.actions.push(action);
        action.startWithTarget(target);
      }
      /**
       * !#en Removes all actions from all the targets.
       * !#zh 移除所有对象的所有动作。
       * @method removeAllActions
       */

    }, {
      key: "removeAllActions",
      value: function removeAllActions() {
        var locTargets = this._arrayTargets;

        for (var i = 0; i < locTargets.length; i++) {
          var element = locTargets[i];
          if (element) this._putElement(element);
        }

        this._arrayTargets.length = 0;
        this._hashTargets = js.createMap(true);
      }
      /**
       * !#en
       * Removes all actions from a certain target. <br/>
       * All the actions that belongs to the target will be removed.
       * !#zh
       * 移除指定对象上的所有动作。<br/>
       * 属于该目标的所有的动作将被删除。
       * @method removeAllActionsFromTarget
       * @param {Node} target
       * @param {Boolean} forceDelete
       */

    }, {
      key: "removeAllActionsFromTarget",
      value: function removeAllActionsFromTarget(target, forceDelete) {
        // explicit null handling
        if (target == null) return;
        var element = this._hashTargets[target.uuid];

        if (element) {
          element.actions.length = 0;

          this._deleteHashElement(element);
        }
      }
      /**
       * !#en Removes an action given an action reference.
       * !#zh 移除指定的动作。
       * @method removeAction
       * @param {Action} action
       */

    }, {
      key: "removeAction",
      value: function removeAction(action) {
        // explicit null handling
        if (action == null) return;
        var target = action.getOriginalTarget();
        var element = this._hashTargets[target.uuid];

        if (element) {
          for (var i = 0; i < element.actions.length; i++) {
            if (element.actions[i] === action) {
              element.actions.splice(i, 1); // update actionIndex in case we are in tick. looping over the actions

              if (element.actionIndex >= i) element.actionIndex--;
              break;
            }
          }
        }
      }
      /**
       * !#en Removes an action given its tag and the target.
       * !#zh 删除指定对象下特定标签的一个动作，将删除首个匹配到的动作。
       * @method removeActionByTag
       * @param {Number} tag
       * @param {Node} target
       */

    }, {
      key: "removeActionByTag",
      value: function removeActionByTag(tag, target) {
        if (tag === cc.Action.TAG_INVALID) cc.logID(1002);
        cc.assertID(target, 1003);
        var element = this._hashTargets[target.uuid];

        if (element) {
          var limit = element.actions.length;

          for (var i = 0; i < limit; ++i) {
            var action = element.actions[i];

            if (action && action.getTag() === tag && action.getOriginalTarget() === target) {
              this._removeActionAtIndex(i, element);

              break;
            }
          }
        }
      }
      /**
       * !#en Gets an action given its tag an a target.
       * !#zh 通过目标对象和标签获取一个动作。
       * @method getActionByTag
       * @param {Number} tag
       * @param {Node} target
       * @return {Action|null}  return the Action with the given tag on success
       */

    }, {
      key: "getActionByTag",
      value: function getActionByTag(tag, target) {
        if (tag === cc.Action.TAG_INVALID) cc.logID(1004);
        var element = this._hashTargets[target.uuid];

        if (element) {
          if (element.actions != null) {
            for (var i = 0; i < element.actions.length; ++i) {
              var action = element.actions[i];
              if (action && action.getTag() === tag) return action;
            }
          }

          cc.logID(1005, tag);
        }

        return null;
      }
      /**
       * !#en
       * Returns the numbers of actions that are running in a certain target. <br/>
       * Composable actions are counted as 1 action. <br/>
       * Example: <br/>
       * - If you are running 1 Sequence of 7 actions, it will return 1. <br/>
       * - If you are running 7 Sequences of 2 actions, it will return 7.
       * !#zh
       * 返回指定对象下所有正在运行的动作数量。 <br/>
       * 组合动作被算作一个动作。<br/>
       * 例如：<br/>
       *  - 如果您正在运行 7 个动作组成的序列动作（Sequence），这个函数将返回 1。<br/>
       *  - 如果你正在运行 2 个序列动作（Sequence）和 5 个普通动作，这个函数将返回 7。<br/>
       *
       * @method getNumberOfRunningActionsInTarget
       * @param {Node} target
       * @return {Number}
       */

    }, {
      key: "getNumberOfRunningActionsInTarget",
      value: function getNumberOfRunningActionsInTarget(target) {
        var element = this._hashTargets[target.uuid];
        if (element) return element.actions ? element.actions.length : 0;
        return 0;
      }
      /**
       * !#en Pauses the target: all running actions and newly added actions will be paused.
       * !#zh 暂停指定对象：所有正在运行的动作和新添加的动作都将会暂停。
       * @method pauseTarget
       * @param {Node} target
       */

    }, {
      key: "pauseTarget",
      value: function pauseTarget(target) {
        var element = this._hashTargets[target.uuid];
        if (element) element.paused = true;
      }
      /**
       * !#en Resumes the target. All queued actions will be resumed.
       * !#zh 让指定目标恢复运行。在执行序列中所有被暂停的动作将重新恢复运行。
       * @method resumeTarget
       * @param {Node} target
       */

    }, {
      key: "resumeTarget",
      value: function resumeTarget(target) {
        var element = this._hashTargets[target.uuid];
        if (element) element.paused = false;
      }
      /**
       * !#en Pauses all running actions, returning a list of targets whose actions were paused.
       * !#zh 暂停所有正在运行的动作，返回一个包含了那些动作被暂停了的目标对象的列表。
       * @method pauseAllRunningActions
       * @return {Array}  a list of targets whose actions were paused.
       */

    }, {
      key: "pauseAllRunningActions",
      value: function pauseAllRunningActions() {
        var idsWithActions = [];
        var locTargets = this._arrayTargets;

        for (var i = 0; i < locTargets.length; i++) {
          var element = locTargets[i];

          if (element && !element.paused) {
            element.paused = true;
            idsWithActions.push(element.target);
          }
        }

        return idsWithActions;
      }
      /**
       * !#en Resume a set of targets (convenience function to reverse a pauseAllRunningActions or pauseTargets call).
       * !#zh 让一组指定对象恢复运行（用来逆转 pauseAllRunningActions 效果的便捷函数）。
       * @method resumeTargets
       * @param {Array} targetsToResume
       */

    }, {
      key: "resumeTargets",
      value: function resumeTargets(targetsToResume) {
        if (!targetsToResume) return;

        for (var i = 0; i < targetsToResume.length; i++) {
          if (targetsToResume[i]) this.resumeTarget(targetsToResume[i]);
        }
      }
      /**
       * !#en Pause a set of targets.
       * !#zh 暂停一组指定对象。
       * @method pauseTargets
       * @param {Array} targetsToPause
       */

    }, {
      key: "pauseTargets",
      value: function pauseTargets(targetsToPause) {
        if (!targetsToPause) return;

        for (var i = 0; i < targetsToPause.length; i++) {
          if (targetsToPause[i]) this.pauseTarget(targetsToPause[i]);
        }
      }
      /**
       * !#en
       * purges the shared action manager. It releases the retained instance. <br/>
       * because it uses this, so it can not be static.
       * !#zh
       * 清除共用的动作管理器。它释放了持有的实例。 <br/>
       * 因为它使用 this，因此它不能是静态的。
       * @method purgeSharedManager
       */

    }, {
      key: "purgeSharedManager",
      value: function purgeSharedManager() {
        cc.director.getScheduler().unscheduleUpdate(this);
      } //protected

    }, {
      key: "_removeActionAtIndex",
      value: function _removeActionAtIndex(index, element) {
        var action = element.actions[index];
        element.actions.splice(index, 1); // update actionIndex in case we are in tick. looping over the actions

        if (element.actionIndex >= index) element.actionIndex--;

        if (element.actions.length === 0) {
          this._deleteHashElement(element);
        }
      }
    }, {
      key: "_deleteHashElement",
      value: function _deleteHashElement(element) {
        var ret = false;

        if (element && !element.lock) {
          if (this._hashTargets[element.target.uuid]) {
            delete this._hashTargets[element.target.uuid];
            var targets = this._arrayTargets;

            for (var i = 0, l = targets.length; i < l; i++) {
              if (targets[i] === element) {
                targets.splice(i, 1);
                break;
              }
            }

            this._putElement(element);

            ret = true;
          }
        }

        return ret;
      }
      /**
       * !#en The ActionManager update。
       * !#zh ActionManager 主循环。
       * @method update
       * @param {Number} dt delta time in seconds
       */

    }, {
      key: "update",
      value: function update(dt) {
        var locTargets = this._arrayTargets;
        var locCurrTarget;

        for (var elt = 0; elt < locTargets.length; elt++) {
          this._currentTarget = locTargets[elt];
          locCurrTarget = this._currentTarget;

          if (!locCurrTarget.paused && locCurrTarget.actions) {
            locCurrTarget.lock = true; // The 'actions' CCMutableArray may change while inside this loop.

            for (locCurrTarget.actionIndex = 0; locCurrTarget.actionIndex < locCurrTarget.actions.length; locCurrTarget.actionIndex++) {
              locCurrTarget.currentAction = locCurrTarget.actions[locCurrTarget.actionIndex];
              if (!locCurrTarget.currentAction) continue; //use for speed

              locCurrTarget.currentAction.step(dt * (locCurrTarget.currentAction._speedMethod ? locCurrTarget.currentAction._speed : 1));

              if (locCurrTarget.currentAction && locCurrTarget.currentAction.isDone()) {
                locCurrTarget.currentAction.stop();
                var action = locCurrTarget.currentAction; // Make currentAction nil to prevent removeAction from salvaging it.

                locCurrTarget.currentAction = null;
                this.removeAction(action);
              }

              locCurrTarget.currentAction = null;
            }

            locCurrTarget.lock = false;
          } // only delete currentTarget if no actions were scheduled during the cycle (issue #481)


          if (locCurrTarget.actions.length === 0) {
            this._deleteHashElement(locCurrTarget) && elt--;
          }
        }
      }
    }]);

    return ActionManager;
  }();

  _exports.ActionManager = ActionManager;
  ;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkY6L2plbmtpbnMvd29ya3NwYWNlL0NyZWF0b3JfM0QvZWRpdG9yLTNkL3Jlc291cmNlcy8zZC9lbmdpbmUvY29jb3MvdHdlZW4vYWN0aW9ucy9hY3Rpb24tbWFuYWdlci50cyJdLCJuYW1lcyI6WyJJRF9DT1VOVEVSIiwiSGFzaEVsZW1lbnQiLCJhY3Rpb25zIiwidGFyZ2V0IiwiYWN0aW9uSW5kZXgiLCJjdXJyZW50QWN0aW9uIiwicGF1c2VkIiwibG9jayIsIkFjdGlvbk1hbmFnZXIiLCJfaGFzaFRhcmdldHMiLCJqcyIsImNyZWF0ZU1hcCIsIl9hcnJheVRhcmdldHMiLCJfZWxlbWVudFBvb2wiLCJhcnIiLCJrIiwibGVuZ3RoIiwiZWxlbWVudCIsInBvcCIsInB1c2giLCJhY3Rpb24iLCJ1dWlkIiwiX2dldEVsZW1lbnQiLCJzdGFydFdpdGhUYXJnZXQiLCJsb2NUYXJnZXRzIiwiaSIsIl9wdXRFbGVtZW50IiwiZm9yY2VEZWxldGUiLCJfZGVsZXRlSGFzaEVsZW1lbnQiLCJnZXRPcmlnaW5hbFRhcmdldCIsInNwbGljZSIsInRhZyIsImNjIiwiQWN0aW9uIiwiVEFHX0lOVkFMSUQiLCJsb2dJRCIsImFzc2VydElEIiwibGltaXQiLCJnZXRUYWciLCJfcmVtb3ZlQWN0aW9uQXRJbmRleCIsImlkc1dpdGhBY3Rpb25zIiwidGFyZ2V0c1RvUmVzdW1lIiwicmVzdW1lVGFyZ2V0IiwidGFyZ2V0c1RvUGF1c2UiLCJwYXVzZVRhcmdldCIsImRpcmVjdG9yIiwiZ2V0U2NoZWR1bGVyIiwidW5zY2hlZHVsZVVwZGF0ZSIsImluZGV4IiwicmV0IiwidGFyZ2V0cyIsImwiLCJkdCIsImxvY0N1cnJUYXJnZXQiLCJlbHQiLCJfY3VycmVudFRhcmdldCIsInN0ZXAiLCJfc3BlZWRNZXRob2QiLCJfc3BlZWQiLCJpc0RvbmUiLCJzdG9wIiwicmVtb3ZlQWN0aW9uIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0NBLE1BQUlB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YSxDQUFDaEQsYUFBZCxDQUE0Qm1ELElBQTVCLENBQWlDSixFQUFFLElBQUlDLGFBQWEsQ0FBQ2hELGFBQWQsQ0FBNEJvRCxZQUE1QixHQUEyQ0osYUFBYSxDQUFDaEQsYUFBZCxDQUE0QnFELE1BQXZFLEdBQWdGLENBQXBGLENBQW5DOztBQUVBLGtCQUFJTCxhQUFhLENBQUNoRCxhQUFkLElBQStCZ0QsYUFBYSxDQUFDaEQsYUFBZCxDQUE0QnNELE1BQTVCLEVBQW5DLEVBQXlFO0FBQ3JFTixnQkFBQUEsYUFBYSxDQUFDaEQsYUFBZCxDQUE0QnVELElBQTVCO0FBQ0Esb0JBQUl4QyxNQUFNLEdBQUdpQyxhQUFhLENBQUNoRCxhQUEzQixDQUZxRSxDQUdyRTs7QUFDQWdELGdCQUFBQSxhQUFhLENBQUNoRCxhQUFkLEdBQThCLElBQTlCO0FBQ0EscUJBQUt3RCxZQUFMLENBQWtCekMsTUFBbEI7QUFDSDs7QUFFRGlDLGNBQUFBLGFBQWEsQ0FBQ2hELGFBQWQsR0FBOEIsSUFBOUI7QUFDSDs7QUFDRGdELFlBQUFBLGFBQWEsQ0FBQzlDLElBQWQsR0FBcUIsS0FBckI7QUFDSCxXQXpCNkMsQ0EwQjlDOzs7QUFDQSxjQUFJOEMsYUFBYSxDQUFDbkQsT0FBZCxDQUFzQmMsTUFBdEIsS0FBaUMsQ0FBckMsRUFBd0M7QUFDcEMsaUJBQUtZLGtCQUFMLENBQXdCeUIsYUFBeEIsS0FBMENDLEdBQUcsRUFBN0M7QUFDSDtBQUNKO0FBQ0o7Ozs7Ozs7QUFDSiIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiBDb3B5cmlnaHQgKGMpIDIwMDgtMjAxMCBSaWNhcmRvIFF1ZXNhZGFcclxuIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIGNvY29zMmQteC5vcmdcclxuIENvcHlyaWdodCAoYykgMjAxMy0yMDE2IENodWtvbmcgVGVjaG5vbG9naWVzIEluYy5cclxuIENvcHlyaWdodCAoYykgMjAxNy0yMDE4IFhpYW1lbiBZYWppIFNvZnR3YXJlIENvLiwgTHRkLlxyXG5cclxuIGh0dHA6Ly93d3cuY29jb3MyZC14Lm9yZ1xyXG5cclxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcclxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcclxuIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcclxuIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xyXG4gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxyXG4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxyXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXHJcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcclxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcclxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXHJcbiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXHJcbiBUSEUgU09GVFdBUkUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEBoaWRkZW5cclxuICovXHJcblxyXG5pbXBvcnQgKiBhcyBqcyBmcm9tICcuLi8uLi9jb3JlL3V0aWxzL2pzJztcclxuaW1wb3J0IHsgZXJyb3JJRCB9IGZyb20gJy4uLy4uL2NvcmUvcGxhdGZvcm0vZGVidWcnO1xyXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuL2FjdGlvbic7XHJcbmltcG9ydCB7IE5vZGUgfSBmcm9tICcuLi8uLi9jb3JlJztcclxuXHJcbmxldCBJRF9DT1VOVEVSID0gMDtcclxuXHJcbi8qXHJcbiAqIEBjbGFzcyBIYXNoRWxlbWVudFxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHByaXZhdGVcclxuICovXHJcbmNsYXNzIEhhc2hFbGVtZW50IHtcclxuICAgIGFjdGlvbnMgPSBbXTtcclxuICAgIHRhcmdldDogb2JqZWN0IHwgbnVsbCA9IG51bGw7IC8vY2NvYmplY3RcclxuICAgIGFjdGlvbkluZGV4ID0gMDtcclxuICAgIGN1cnJlbnRBY3Rpb24gPSBudWxsOyAvL0NDQWN0aW9uXHJcbiAgICBwYXVzZWQgPSBmYWxzZTtcclxuICAgIGxvY2sgPSBmYWxzZTtcclxufVxyXG5cclxuLyoqXHJcbiAqICEjZW5cclxuICogY2MuQWN0aW9uTWFuYWdlciBpcyBhIGNsYXNzIHRoYXQgY2FuIG1hbmFnZSBhY3Rpb25zLjxici8+XHJcbiAqIE5vcm1hbGx5IHlvdSB3b24ndCBuZWVkIHRvIHVzZSB0aGlzIGNsYXNzIGRpcmVjdGx5LiA5OSUgb2YgdGhlIGNhc2VzIHlvdSB3aWxsIHVzZSB0aGUgQ0NOb2RlIGludGVyZmFjZSxcclxuICogd2hpY2ggdXNlcyB0aGlzIGNsYXNzJ3Mgc2luZ2xldG9uIG9iamVjdC5cclxuICogQnV0IHRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlIHlvdSBtaWdodCBuZWVkIHRvIHVzZSB0aGlzIGNsYXNzLiA8YnIvPlxyXG4gKiBFeGFtcGxlczo8YnIvPlxyXG4gKiAtIFdoZW4geW91IHdhbnQgdG8gcnVuIGFuIGFjdGlvbiB3aGVyZSB0aGUgdGFyZ2V0IGlzIGRpZmZlcmVudCBmcm9tIGEgQ0NOb2RlLjxici8+XHJcbiAqIC0gV2hlbiB5b3Ugd2FudCB0byBwYXVzZSAvIHJlc3VtZSB0aGUgYWN0aW9uczxici8+XHJcbiAqICEjemhcclxuICogY2MuQWN0aW9uTWFuYWdlciDmmK/lj6/ku6XnrqHnkIbliqjkvZznmoTljZXkvovnsbvjgII8YnIvPlxyXG4gKiDpgJrluLjkvaDlubbkuI3pnIDopoHnm7TmjqXkvb/nlKjov5nkuKrnsbvvvIw5OSXnmoTmg4XlhrXmgqjlsIbkvb/nlKggQ0NOb2RlIOeahOaOpeWPo+OAgjxici8+XHJcbiAqIOS9huS5n+acieS4gOS6m+aDheWGteS4i++8jOaCqOWPr+iDvemcgOimgeS9v+eUqOi/meS4quexu+OAgiA8YnIvPlxyXG4gKiDkvovlpoLvvJpcclxuICogIC0g5b2T5L2g5oOz6KaB6L+Q6KGM5LiA5Liq5Yqo5L2c77yM5L2G55uu5qCH5LiN5pivIENDTm9kZSDnsbvlnovml7bjgIIgPGJyLz5cclxuICogIC0g5b2T5L2g5oOz6KaB5pqC5YGcL+aBouWkjeWKqOS9nOaXtuOAgiA8YnIvPlxyXG4gKiBAY2xhc3MgQWN0aW9uTWFuYWdlclxyXG4gKiBAZXhhbXBsZSB7QGxpbmsgY29jb3MyZC9jb3JlL0NDQWN0aW9uTWFuYWdlci9BY3Rpb25NYW5hZ2VyLmpzfVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEFjdGlvbk1hbmFnZXIge1xyXG4gICAgcHJpdmF0ZSBfaGFzaFRhcmdldHMgPSBqcy5jcmVhdGVNYXAodHJ1ZSk7XHJcbiAgICBwcml2YXRlIF9hcnJheVRhcmdldHM6IEhhc2hFbGVtZW50W10gPSBbXTtcclxuICAgIHByaXZhdGUgX2N1cnJlbnRUYXJnZXQhOiBIYXNoRWxlbWVudDtcclxuICAgIHByaXZhdGUgX2VsZW1lbnRQb29sOiBIYXNoRWxlbWVudFtdID0gW107XHJcblxyXG4gICAgcHJpdmF0ZSBfc2VhcmNoRWxlbWVudEJ5VGFyZ2V0IChhcnI6IEhhc2hFbGVtZW50W10sIHRhcmdldDogb2JqZWN0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcnIubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gYXJyW2tdLnRhcmdldClcclxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJba107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2dldEVsZW1lbnQgKHRhcmdldDogb2JqZWN0LCBwYXVzZWQ6IGJvb2xlYW4pIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnRQb29sLnBvcCgpO1xyXG4gICAgICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gbmV3IEhhc2hFbGVtZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZW1lbnQudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIGVsZW1lbnQucGF1c2VkID0gISFwYXVzZWQ7XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfcHV0RWxlbWVudCAoZWxlbWVudDogSGFzaEVsZW1lbnQpIHtcclxuICAgICAgICBlbGVtZW50LmFjdGlvbnMubGVuZ3RoID0gMDtcclxuICAgICAgICBlbGVtZW50LmFjdGlvbkluZGV4ID0gMDtcclxuICAgICAgICBlbGVtZW50LmN1cnJlbnRBY3Rpb24gPSBudWxsO1xyXG4gICAgICAgIGVsZW1lbnQucGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgZWxlbWVudC50YXJnZXQgPSBudWxsO1xyXG4gICAgICAgIGVsZW1lbnQubG9jayA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnRQb29sLnB1c2goZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAhI2VuXHJcbiAgICAgKiBBZGRzIGFuIGFjdGlvbiB3aXRoIGEgdGFyZ2V0Ljxici8+XHJcbiAgICAgKiBJZiB0aGUgdGFyZ2V0IGlzIGFscmVhZHkgcHJlc2VudCwgdGhlbiB0aGUgYWN0aW9uIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGV4aXN0aW5nIHRhcmdldC5cclxuICAgICAqIElmIHRoZSB0YXJnZXQgaXMgbm90IHByZXNlbnQsIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgdGFyZ2V0IHdpbGwgYmUgY3JlYXRlZCBlaXRoZXIgcGF1c2VkIG9yIG5vdCwgYW5kIHRoZSBhY3Rpb24gd2lsbCBiZSBhZGRlZCB0byB0aGUgbmV3bHkgY3JlYXRlZCB0YXJnZXQuXHJcbiAgICAgKiBXaGVuIHRoZSB0YXJnZXQgaXMgcGF1c2VkLCB0aGUgcXVldWVkIGFjdGlvbnMgd29uJ3QgYmUgJ3RpY2tlZCcuXHJcbiAgICAgKiAhI3poXHJcbiAgICAgKiDlop7liqDkuIDkuKrliqjkvZzvvIzlkIzml7bov5jpnIDopoHmj5DkvpvliqjkvZznmoTnm67moIflr7nosaHvvIznm67moIflr7nosaHmmK/lkKbmmoLlgZzkvZzkuLrlj4LmlbDjgII8YnIvPlxyXG4gICAgICog5aaC5p6c55uu5qCH5bey5a2Y5Zyo77yM5Yqo5L2c5bCG5Lya6KKr55u05o6l5re75Yqg5Yiw546w5pyJ55qE6IqC54K55Lit44CCPGJyLz5cclxuICAgICAqIOWmguaenOebruagh+S4jeWtmOWcqO+8jOWwhuS4uui/meS4gOebruagh+WIm+W7uuS4gOS4quaWsOeahOWunuS+i++8jOW5tuWwhuWKqOS9nOa3u+WKoOi/m+WOu+OAgjxici8+XHJcbiAgICAgKiDlvZPnm67moIfnirbmgIHnmoQgcGF1c2VkIOS4uiB0cnVl77yM5Yqo5L2c5bCG5LiN5Lya6KKr5omn6KGMXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBhZGRBY3Rpb25cclxuICAgICAqIEBwYXJhbSB7QWN0aW9ufSBhY3Rpb25cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGF1c2VkXHJcbiAgICAgKi9cclxuICAgIGFkZEFjdGlvbiAoYWN0aW9uOiBBY3Rpb24sIHRhcmdldDogTm9kZSwgcGF1c2VkOiBib29sZWFuKSB7XHJcbiAgICAgICAgaWYgKCFhY3Rpb24gfHwgIXRhcmdldCkge1xyXG4gICAgICAgICAgICBlcnJvcklEKDEwMDApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGFyZ2V0LnV1aWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAodGFyZ2V0IGFzIGFueSkudXVpZCA9ICdfVFdFRU5fVVVJRF8nICsgSURfQ09VTlRFUisrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jaGVjayBpZiB0aGUgYWN0aW9uIHRhcmdldCBhbHJlYWR5IGV4aXN0c1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5faGFzaFRhcmdldHNbdGFyZ2V0LnV1aWRdO1xyXG4gICAgICAgIC8vaWYgZG9lc24ndCBleGlzdHMsIGNyZWF0ZSBhIGhhc2hlbGVtZW50IGFuZCBwdXNoIGluIG1wVGFyZ2V0c1xyXG4gICAgICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gdGhpcy5fZ2V0RWxlbWVudCh0YXJnZXQsIHBhdXNlZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc2hUYXJnZXRzW3RhcmdldC51dWlkXSA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2FycmF5VGFyZ2V0cy5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghZWxlbWVudC5hY3Rpb25zKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuYWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWxlbWVudC5hY3Rpb25zLnB1c2goYWN0aW9uKTtcclxuICAgICAgICBhY3Rpb24uc3RhcnRXaXRoVGFyZ2V0KHRhcmdldCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAhI2VuIFJlbW92ZXMgYWxsIGFjdGlvbnMgZnJvbSBhbGwgdGhlIHRhcmdldHMuXHJcbiAgICAgKiAhI3poIOenu+mZpOaJgOacieWvueixoeeahOaJgOacieWKqOS9nOOAglxyXG4gICAgICogQG1ldGhvZCByZW1vdmVBbGxBY3Rpb25zXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUFsbEFjdGlvbnMgKCkge1xyXG4gICAgICAgIHZhciBsb2NUYXJnZXRzID0gdGhpcy5fYXJyYXlUYXJnZXRzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGxvY1RhcmdldHNbaV07XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHV0RWxlbWVudChlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYXJyYXlUYXJnZXRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5faGFzaFRhcmdldHMgPSBqcy5jcmVhdGVNYXAodHJ1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICEjZW5cclxuICAgICAqIFJlbW92ZXMgYWxsIGFjdGlvbnMgZnJvbSBhIGNlcnRhaW4gdGFyZ2V0LiA8YnIvPlxyXG4gICAgICogQWxsIHRoZSBhY3Rpb25zIHRoYXQgYmVsb25ncyB0byB0aGUgdGFyZ2V0IHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgICAqICEjemhcclxuICAgICAqIOenu+mZpOaMh+WumuWvueixoeS4iueahOaJgOacieWKqOS9nOOAgjxici8+XHJcbiAgICAgKiDlsZ7kuo7or6Xnm67moIfnmoTmiYDmnInnmoTliqjkvZzlsIbooqvliKDpmaTjgIJcclxuICAgICAqIEBtZXRob2QgcmVtb3ZlQWxsQWN0aW9uc0Zyb21UYXJnZXRcclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlRGVsZXRlXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUFsbEFjdGlvbnNGcm9tVGFyZ2V0ICh0YXJnZXQ6IE5vZGUsIGZvcmNlRGVsZXRlOiBib29sZWFuKSB7XHJcbiAgICAgICAgLy8gZXhwbGljaXQgbnVsbCBoYW5kbGluZ1xyXG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5faGFzaFRhcmdldHNbdGFyZ2V0LnV1aWRdO1xyXG4gICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuYWN0aW9ucy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9kZWxldGVIYXNoRWxlbWVudChlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICEjZW4gUmVtb3ZlcyBhbiBhY3Rpb24gZ2l2ZW4gYW4gYWN0aW9uIHJlZmVyZW5jZS5cclxuICAgICAqICEjemgg56e76Zmk5oyH5a6a55qE5Yqo5L2c44CCXHJcbiAgICAgKiBAbWV0aG9kIHJlbW92ZUFjdGlvblxyXG4gICAgICogQHBhcmFtIHtBY3Rpb259IGFjdGlvblxyXG4gICAgICovXHJcbiAgICByZW1vdmVBY3Rpb24gKGFjdGlvbjogQWN0aW9uKSB7XHJcbiAgICAgICAgLy8gZXhwbGljaXQgbnVsbCBoYW5kbGluZ1xyXG4gICAgICAgIGlmIChhY3Rpb24gPT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSBhY3Rpb24uZ2V0T3JpZ2luYWxUYXJnZXQoKSE7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLl9oYXNoVGFyZ2V0c1t0YXJnZXQudXVpZF07XHJcblxyXG4gICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudC5hY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5hY3Rpb25zW2ldID09PSBhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFjdGlvbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBhY3Rpb25JbmRleCBpbiBjYXNlIHdlIGFyZSBpbiB0aWNrLiBsb29waW5nIG92ZXIgdGhlIGFjdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5hY3Rpb25JbmRleCA+PSBpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFjdGlvbkluZGV4LS07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAhI2VuIFJlbW92ZXMgYW4gYWN0aW9uIGdpdmVuIGl0cyB0YWcgYW5kIHRoZSB0YXJnZXQuXHJcbiAgICAgKiAhI3poIOWIoOmZpOaMh+WumuWvueixoeS4i+eJueWumuagh+etvueahOS4gOS4quWKqOS9nO+8jOWwhuWIoOmZpOmmluS4quWMuemFjeWIsOeahOWKqOS9nOOAglxyXG4gICAgICogQG1ldGhvZCByZW1vdmVBY3Rpb25CeVRhZ1xyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRhZ1xyXG4gICAgICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQWN0aW9uQnlUYWcgKHRhZzogbnVtYmVyLCB0YXJnZXQ6IE5vZGUpIHtcclxuICAgICAgICBpZiAodGFnID09PSBjYy5BY3Rpb24uVEFHX0lOVkFMSUQpXHJcbiAgICAgICAgICAgIGNjLmxvZ0lEKDEwMDIpO1xyXG5cclxuICAgICAgICBjYy5hc3NlcnRJRCh0YXJnZXQsIDEwMDMpO1xyXG5cclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2hhc2hUYXJnZXRzW3RhcmdldC51dWlkXTtcclxuXHJcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdmFyIGxpbWl0ID0gZWxlbWVudC5hY3Rpb25zLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW1pdDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gZWxlbWVudC5hY3Rpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAmJiBhY3Rpb24uZ2V0VGFnKCkgPT09IHRhZyAmJiBhY3Rpb24uZ2V0T3JpZ2luYWxUYXJnZXQoKSA9PT0gdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQWN0aW9uQXRJbmRleChpLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqICEjZW4gR2V0cyBhbiBhY3Rpb24gZ2l2ZW4gaXRzIHRhZyBhbiBhIHRhcmdldC5cclxuICAgICAqICEjemgg6YCa6L+H55uu5qCH5a+56LGh5ZKM5qCH562+6I635Y+W5LiA5Liq5Yqo5L2c44CCXHJcbiAgICAgKiBAbWV0aG9kIGdldEFjdGlvbkJ5VGFnXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGFnXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxyXG4gICAgICogQHJldHVybiB7QWN0aW9ufG51bGx9ICByZXR1cm4gdGhlIEFjdGlvbiB3aXRoIHRoZSBnaXZlbiB0YWcgb24gc3VjY2Vzc1xyXG4gICAgICovXHJcbiAgICBnZXRBY3Rpb25CeVRhZyAodGFnOiBudW1iZXIsIHRhcmdldDogTm9kZSk6IEFjdGlvbiB8IG51bGwge1xyXG4gICAgICAgIGlmICh0YWcgPT09IGNjLkFjdGlvbi5UQUdfSU5WQUxJRClcclxuICAgICAgICAgICAgY2MubG9nSUQoMTAwNCk7XHJcblxyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5faGFzaFRhcmdldHNbdGFyZ2V0LnV1aWRdO1xyXG4gICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmFjdGlvbnMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50LmFjdGlvbnMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gZWxlbWVudC5hY3Rpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gJiYgYWN0aW9uLmdldFRhZygpID09PSB0YWcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2MubG9nSUQoMTAwNSwgdGFnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogISNlblxyXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVycyBvZiBhY3Rpb25zIHRoYXQgYXJlIHJ1bm5pbmcgaW4gYSBjZXJ0YWluIHRhcmdldC4gPGJyLz5cclxuICAgICAqIENvbXBvc2FibGUgYWN0aW9ucyBhcmUgY291bnRlZCBhcyAxIGFjdGlvbi4gPGJyLz5cclxuICAgICAqIEV4YW1wbGU6IDxici8+XHJcbiAgICAgKiAtIElmIHlvdSBhcmUgcnVubmluZyAxIFNlcXVlbmNlIG9mIDcgYWN0aW9ucywgaXQgd2lsbCByZXR1cm4gMS4gPGJyLz5cclxuICAgICAqIC0gSWYgeW91IGFyZSBydW5uaW5nIDcgU2VxdWVuY2VzIG9mIDIgYWN0aW9ucywgaXQgd2lsbCByZXR1cm4gNy5cclxuICAgICAqICEjemhcclxuICAgICAqIOi/lOWbnuaMh+WumuWvueixoeS4i+aJgOacieato+WcqOi/kOihjOeahOWKqOS9nOaVsOmHj+OAgiA8YnIvPlxyXG4gICAgICog57uE5ZCI5Yqo5L2c6KKr566X5L2c5LiA5Liq5Yqo5L2c44CCPGJyLz5cclxuICAgICAqIOS+i+Wmgu+8mjxici8+XHJcbiAgICAgKiAgLSDlpoLmnpzmgqjmraPlnKjov5DooYwgNyDkuKrliqjkvZznu4TmiJDnmoTluo/liJfliqjkvZzvvIhTZXF1ZW5jZe+8ie+8jOi/meS4quWHveaVsOWwhui/lOWbniAx44CCPGJyLz5cclxuICAgICAqICAtIOWmguaenOS9oOato+WcqOi/kOihjCAyIOS4quW6j+WIl+WKqOS9nO+8iFNlcXVlbmNl77yJ5ZKMIDUg5Liq5pmu6YCa5Yqo5L2c77yM6L+Z5Liq5Ye95pWw5bCG6L+U5ZueIDfjgII8YnIvPlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgZ2V0TnVtYmVyT2ZSdW5uaW5nQWN0aW9uc0luVGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXROdW1iZXJPZlJ1bm5pbmdBY3Rpb25zSW5UYXJnZXQgKHRhcmdldDogTm9kZSk6IG51bWJlciB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLl9oYXNoVGFyZ2V0c1t0YXJnZXQudXVpZF07XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpXHJcbiAgICAgICAgICAgIHJldHVybiAoZWxlbWVudC5hY3Rpb25zKSA/IGVsZW1lbnQuYWN0aW9ucy5sZW5ndGggOiAwO1xyXG5cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogISNlbiBQYXVzZXMgdGhlIHRhcmdldDogYWxsIHJ1bm5pbmcgYWN0aW9ucyBhbmQgbmV3bHkgYWRkZWQgYWN0aW9ucyB3aWxsIGJlIHBhdXNlZC5cclxuICAgICAqICEjemgg5pqC5YGc5oyH5a6a5a+56LGh77ya5omA5pyJ5q2j5Zyo6L+Q6KGM55qE5Yqo5L2c5ZKM5paw5re75Yqg55qE5Yqo5L2c6YO95bCG5Lya5pqC5YGc44CCXHJcbiAgICAgKiBAbWV0aG9kIHBhdXNlVGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldFxyXG4gICAgICovXHJcbiAgICBwYXVzZVRhcmdldCAodGFyZ2V0OiBOb2RlKSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLl9oYXNoVGFyZ2V0c1t0YXJnZXQudXVpZF07XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpXHJcbiAgICAgICAgICAgIGVsZW1lbnQucGF1c2VkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogISNlbiBSZXN1bWVzIHRoZSB0YXJnZXQuIEFsbCBxdWV1ZWQgYWN0aW9ucyB3aWxsIGJlIHJlc3VtZWQuXHJcbiAgICAgKiAhI3poIOiuqeaMh+Wumuebruagh+aBouWkjei/kOihjOOAguWcqOaJp+ihjOW6j+WIl+S4reaJgOacieiiq+aaguWBnOeahOWKqOS9nOWwhumHjeaWsOaBouWkjei/kOihjOOAglxyXG4gICAgICogQG1ldGhvZCByZXN1bWVUYXJnZXRcclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XHJcbiAgICAgKi9cclxuICAgIHJlc3VtZVRhcmdldCAodGFyZ2V0OiBOb2RlKSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLl9oYXNoVGFyZ2V0c1t0YXJnZXQudXVpZF07XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpXHJcbiAgICAgICAgICAgIGVsZW1lbnQucGF1c2VkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAhI2VuIFBhdXNlcyBhbGwgcnVubmluZyBhY3Rpb25zLCByZXR1cm5pbmcgYSBsaXN0IG9mIHRhcmdldHMgd2hvc2UgYWN0aW9ucyB3ZXJlIHBhdXNlZC5cclxuICAgICAqICEjemgg5pqC5YGc5omA5pyJ5q2j5Zyo6L+Q6KGM55qE5Yqo5L2c77yM6L+U5Zue5LiA5Liq5YyF5ZCr5LqG6YKj5Lqb5Yqo5L2c6KKr5pqC5YGc5LqG55qE55uu5qCH5a+56LGh55qE5YiX6KGo44CCXHJcbiAgICAgKiBAbWV0aG9kIHBhdXNlQWxsUnVubmluZ0FjdGlvbnNcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgYSBsaXN0IG9mIHRhcmdldHMgd2hvc2UgYWN0aW9ucyB3ZXJlIHBhdXNlZC5cclxuICAgICAqL1xyXG4gICAgcGF1c2VBbGxSdW5uaW5nQWN0aW9ucyAoKTogQXJyYXk8YW55PiB7XHJcbiAgICAgICAgdmFyIGlkc1dpdGhBY3Rpb25zOiBvYmplY3RbXSA9IFtdO1xyXG4gICAgICAgIHZhciBsb2NUYXJnZXRzID0gdGhpcy5fYXJyYXlUYXJnZXRzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGxvY1RhcmdldHNbaV07XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmICFlbGVtZW50LnBhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5wYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWRzV2l0aEFjdGlvbnMucHVzaChlbGVtZW50LnRhcmdldCEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpZHNXaXRoQWN0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqICEjZW4gUmVzdW1lIGEgc2V0IG9mIHRhcmdldHMgKGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHJldmVyc2UgYSBwYXVzZUFsbFJ1bm5pbmdBY3Rpb25zIG9yIHBhdXNlVGFyZ2V0cyBjYWxsKS5cclxuICAgICAqICEjemgg6K6p5LiA57uE5oyH5a6a5a+56LGh5oGi5aSN6L+Q6KGM77yI55So5p2l6YCG6L2sIHBhdXNlQWxsUnVubmluZ0FjdGlvbnMg5pWI5p6c55qE5L6/5o235Ye95pWw77yJ44CCXHJcbiAgICAgKiBAbWV0aG9kIHJlc3VtZVRhcmdldHNcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldHNUb1Jlc3VtZVxyXG4gICAgICovXHJcbiAgICByZXN1bWVUYXJnZXRzICh0YXJnZXRzVG9SZXN1bWU6IEFycmF5PGFueT4pIHtcclxuICAgICAgICBpZiAoIXRhcmdldHNUb1Jlc3VtZSlcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHNUb1Jlc3VtZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0c1RvUmVzdW1lW2ldKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWVUYXJnZXQodGFyZ2V0c1RvUmVzdW1lW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAhI2VuIFBhdXNlIGEgc2V0IG9mIHRhcmdldHMuXHJcbiAgICAgKiAhI3poIOaaguWBnOS4gOe7hOaMh+WumuWvueixoeOAglxyXG4gICAgICogQG1ldGhvZCBwYXVzZVRhcmdldHNcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldHNUb1BhdXNlXHJcbiAgICAgKi9cclxuICAgIHBhdXNlVGFyZ2V0cyAodGFyZ2V0c1RvUGF1c2U6IEFycmF5PGFueT4pIHtcclxuICAgICAgICBpZiAoIXRhcmdldHNUb1BhdXNlKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFyZ2V0c1RvUGF1c2UubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldHNUb1BhdXNlW2ldKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXVzZVRhcmdldCh0YXJnZXRzVG9QYXVzZVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogISNlblxyXG4gICAgICogcHVyZ2VzIHRoZSBzaGFyZWQgYWN0aW9uIG1hbmFnZXIuIEl0IHJlbGVhc2VzIHRoZSByZXRhaW5lZCBpbnN0YW5jZS4gPGJyLz5cclxuICAgICAqIGJlY2F1c2UgaXQgdXNlcyB0aGlzLCBzbyBpdCBjYW4gbm90IGJlIHN0YXRpYy5cclxuICAgICAqICEjemhcclxuICAgICAqIOa4hemZpOWFseeUqOeahOWKqOS9nOeuoeeQhuWZqOOAguWug+mHiuaUvuS6huaMgeacieeahOWunuS+i+OAgiA8YnIvPlxyXG4gICAgICog5Zug5Li65a6D5L2/55SoIHRoaXPvvIzlm6DmraTlroPkuI3og73mmK/pnZnmgIHnmoTjgIJcclxuICAgICAqIEBtZXRob2QgcHVyZ2VTaGFyZWRNYW5hZ2VyXHJcbiAgICAgKi9cclxuICAgIHB1cmdlU2hhcmVkTWFuYWdlciAoKSB7XHJcbiAgICAgICAgY2MuZGlyZWN0b3IuZ2V0U2NoZWR1bGVyKCkudW5zY2hlZHVsZVVwZGF0ZSh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvL3Byb3RlY3RlZFxyXG4gICAgcHJpdmF0ZSBfcmVtb3ZlQWN0aW9uQXRJbmRleCAoaW5kZXgsIGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgYWN0aW9uID0gZWxlbWVudC5hY3Rpb25zW2luZGV4XTtcclxuXHJcbiAgICAgICAgZWxlbWVudC5hY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBhY3Rpb25JbmRleCBpbiBjYXNlIHdlIGFyZSBpbiB0aWNrLiBsb29waW5nIG92ZXIgdGhlIGFjdGlvbnNcclxuICAgICAgICBpZiAoZWxlbWVudC5hY3Rpb25JbmRleCA+PSBpbmRleClcclxuICAgICAgICAgICAgZWxlbWVudC5hY3Rpb25JbmRleC0tO1xyXG5cclxuICAgICAgICBpZiAoZWxlbWVudC5hY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZWxldGVIYXNoRWxlbWVudChlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfZGVsZXRlSGFzaEVsZW1lbnQgKGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgcmV0ID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIWVsZW1lbnQubG9jaykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faGFzaFRhcmdldHNbZWxlbWVudC50YXJnZXQudXVpZF0pIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oYXNoVGFyZ2V0c1tlbGVtZW50LnRhcmdldC51dWlkXTtcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRzID0gdGhpcy5fYXJyYXlUYXJnZXRzO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0YXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRzW2ldID09PSBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldHMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wdXRFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogISNlbiBUaGUgQWN0aW9uTWFuYWdlciB1cGRhdGXjgIJcclxuICAgICAqICEjemggQWN0aW9uTWFuYWdlciDkuLvlvqrnjq/jgIJcclxuICAgICAqIEBtZXRob2QgdXBkYXRlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZHQgZGVsdGEgdGltZSBpbiBzZWNvbmRzXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZSAoZHQ6IG51bWJlcikge1xyXG4gICAgICAgIHZhciBsb2NUYXJnZXRzID0gdGhpcy5fYXJyYXlUYXJnZXRzO1xyXG4gICAgICAgIHZhciBsb2NDdXJyVGFyZ2V0O1xyXG4gICAgICAgIGZvciAodmFyIGVsdCA9IDA7IGVsdCA8IGxvY1RhcmdldHMubGVuZ3RoOyBlbHQrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ID0gbG9jVGFyZ2V0c1tlbHRdO1xyXG4gICAgICAgICAgICBsb2NDdXJyVGFyZ2V0ID0gdGhpcy5fY3VycmVudFRhcmdldDtcclxuICAgICAgICAgICAgaWYgKCFsb2NDdXJyVGFyZ2V0LnBhdXNlZCAmJiBsb2NDdXJyVGFyZ2V0LmFjdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGxvY0N1cnJUYXJnZXQubG9jayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgJ2FjdGlvbnMnIENDTXV0YWJsZUFycmF5IG1heSBjaGFuZ2Ugd2hpbGUgaW5zaWRlIHRoaXMgbG9vcC5cclxuICAgICAgICAgICAgICAgIGZvciAobG9jQ3VyclRhcmdldC5hY3Rpb25JbmRleCA9IDA7IGxvY0N1cnJUYXJnZXQuYWN0aW9uSW5kZXggPCBsb2NDdXJyVGFyZ2V0LmFjdGlvbnMubGVuZ3RoOyBsb2NDdXJyVGFyZ2V0LmFjdGlvbkluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2NDdXJyVGFyZ2V0LmN1cnJlbnRBY3Rpb24gPSBsb2NDdXJyVGFyZ2V0LmFjdGlvbnNbbG9jQ3VyclRhcmdldC5hY3Rpb25JbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NDdXJyVGFyZ2V0LmN1cnJlbnRBY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3VzZSBmb3Igc3BlZWRcclxuICAgICAgICAgICAgICAgICAgICBsb2NDdXJyVGFyZ2V0LmN1cnJlbnRBY3Rpb24uc3RlcChkdCAqIChsb2NDdXJyVGFyZ2V0LmN1cnJlbnRBY3Rpb24uX3NwZWVkTWV0aG9kID8gbG9jQ3VyclRhcmdldC5jdXJyZW50QWN0aW9uLl9zcGVlZCA6IDEpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY0N1cnJUYXJnZXQuY3VycmVudEFjdGlvbiAmJiBsb2NDdXJyVGFyZ2V0LmN1cnJlbnRBY3Rpb24uaXNEb25lKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jQ3VyclRhcmdldC5jdXJyZW50QWN0aW9uLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGlvbiA9IGxvY0N1cnJUYXJnZXQuY3VycmVudEFjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBjdXJyZW50QWN0aW9uIG5pbCB0byBwcmV2ZW50IHJlbW92ZUFjdGlvbiBmcm9tIHNhbHZhZ2luZyBpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jQ3VyclRhcmdldC5jdXJyZW50QWN0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3Rpb24oYWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxvY0N1cnJUYXJnZXQuY3VycmVudEFjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsb2NDdXJyVGFyZ2V0LmxvY2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBvbmx5IGRlbGV0ZSBjdXJyZW50VGFyZ2V0IGlmIG5vIGFjdGlvbnMgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoZSBjeWNsZSAoaXNzdWUgIzQ4MSlcclxuICAgICAgICAgICAgaWYgKGxvY0N1cnJUYXJnZXQuYWN0aW9ucy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RlbGV0ZUhhc2hFbGVtZW50KGxvY0N1cnJUYXJnZXQpICYmIGVsdC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG4iXX0=