(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "../math/index.js"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("../math/index.js"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.index);
    global.cylinder = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _index) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = cylinder;

  /**
   * @category 3d/primitive
   */
  var temp1 = new _index.Vec3(0, 0, 0);
  var temp2 = new _index.Vec3(0, 0, 0);
  /**
   * @en
   * Generate a cylinder with radiusTop radiusBottom 0.5, height 2 and centered at origin,
   * but may be repositioned through the `center` option.
   * @zh
   * 生成一个圆柱。
   * @param radiusTop 顶部半径。
   * @param radiusBottom 底部半径。
   * @param opts 圆柱参数选项。
   */

  function cylinder() {
    var radiusTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;
    var radiusBottom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var halfHeight = height * 0.5;
    var radialSegments = opts.radialSegments || 32;
    var heightSegments = opts.heightSegments || 1;
    var capped = opts.capped !== undefined ? opts.capped : true;
    var arc = opts.arc || 2.0 * Math.PI;
    var cntCap = 0;

    if (!capped) {
      if (radiusTop > 0) {
        cntCap++;
      }

      if (radiusBottom > 0) {
        cntCap++;
      }
    } // calculate vertex count


    var vertCount = (radialSegments + 1) * (heightSegments + 1);

    if (capped) {
      vertCount += (radialSegments + 1) * cntCap + radialSegments * cntCap;
    } // calculate index count


    var indexCount = radialSegments * heightSegments * 2 * 3;

    if (capped) {
      indexCount += radialSegments * cntCap * 3;
    }

    var indices = new Array(indexCount);
    var positions = new Array(vertCount * 3);
    var normals = new Array(vertCount * 3);
    var uvs = new Array(vertCount * 2);
    var maxRadius = Math.max(radiusTop, radiusBottom);
    var minPos = new _index.Vec3(-maxRadius, -halfHeight, -maxRadius);
    var maxPos = new _index.Vec3(maxRadius, halfHeight, maxRadius);
    var boundingRadius = Math.sqrt(maxRadius * maxRadius + halfHeight * halfHeight);
    var index = 0;
    var indexOffset = 0;
    generateTorso();

    if (capped) {
      if (radiusBottom > 0) {
        generateCap(false);
      }

      if (radiusTop > 0) {
        generateCap(true);
      }
    }

    return {
      positions: positions,
      normals: normals,
      uvs: uvs,
      indices: indices,
      minPos: minPos,
      maxPos: maxPos,
      boundingRadius: boundingRadius
    }; // =======================
    // internal fucntions
    // =======================

    function generateTorso() {
      var indexArray = []; // this will be used to calculate the normal

      var r = radiusTop - radiusBottom;
      var slope = r * r / height * Math.sign(r); // generate positions, normals and uvs

      for (var y = 0; y <= heightSegments; y++) {
        var indexRow = [];
        var v = y / heightSegments; // calculate the radius of the current row

        var radius = v * r + radiusBottom;

        for (var x = 0; x <= radialSegments; ++x) {
          var u = x / radialSegments;
          var theta = u * arc;
          var sinTheta = Math.sin(theta);
          var cosTheta = Math.cos(theta); // vertex

          positions[3 * index] = radius * sinTheta;
          positions[3 * index + 1] = v * height - halfHeight;
          positions[3 * index + 2] = radius * cosTheta; // normal

          _index.Vec3.normalize(temp1, _index.Vec3.set(temp2, sinTheta, -slope, cosTheta));

          normals[3 * index] = temp1.x;
          normals[3 * index + 1] = temp1.y;
          normals[3 * index + 2] = temp1.z; // uv

          uvs[2 * index] = (1 - u) * 2 % 1;
          uvs[2 * index + 1] = v; // save index of vertex in respective row

          indexRow.push(index); // increase index

          ++index;
        } // now save positions of the row in our index array


        indexArray.push(indexRow);
      } // generate indices


      for (var _y = 0; _y < heightSegments; ++_y) {
        for (var _x = 0; _x < radialSegments; ++_x) {
          // we use the index array to access the correct indices
          var i1 = indexArray[_y][_x];
          var i2 = indexArray[_y + 1][_x];
          var i3 = indexArray[_y + 1][_x + 1];
          var i4 = indexArray[_y][_x + 1]; // face one

          indices[indexOffset] = i1;
          ++indexOffset;
          indices[indexOffset] = i4;
          ++indexOffset;
          indices[indexOffset] = i2;
          ++indexOffset; // face two

          indices[indexOffset] = i4;
          ++indexOffset;
          indices[indexOffset] = i3;
          ++indexOffset;
          indices[indexOffset] = i2;
          ++indexOffset;
        }
      }
    }

    function generateCap(top) {
      var radius = top ? radiusTop : radiusBottom;
      var sign = top ? 1 : -1; // save the index of the first center vertex

      var centerIndexStart = index; // first we generate the center vertex data of the cap.
      // because the geometry needs one set of uvs per face,
      // we must generate a center vertex per face/segment

      for (var x = 1; x <= radialSegments; ++x) {
        // vertex
        positions[3 * index] = 0;
        positions[3 * index + 1] = halfHeight * sign;
        positions[3 * index + 2] = 0; // normal

        normals[3 * index] = 0;
        normals[3 * index + 1] = sign;
        normals[3 * index + 2] = 0; // uv

        uvs[2 * index] = 0.5;
        uvs[2 * index + 1] = 0.5; // increase index

        ++index;
      } // save the index of the last center vertex


      var centerIndexEnd = index; // now we generate the surrounding positions, normals and uvs

      for (var _x2 = 0; _x2 <= radialSegments; ++_x2) {
        var u = _x2 / radialSegments;
        var theta = u * arc;
        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta); // vertex

        positions[3 * index] = radius * sinTheta;
        positions[3 * index + 1] = halfHeight * sign;
        positions[3 * index + 2] = radius * cosTheta; // normal

        normals[3 * index] = 0;
        normals[3 * index + 1] = sign;
        normals[3 * index + 2] = 0; // uv

        uvs[2 * index] = 0.5 - sinTheta * 0.5 * sign;
        uvs[2 * index + 1] = 0.5 + cosTheta * 0.5; // increase index

        ++index;
      } // generate indices


      for (var _x3 = 0; _x3 < radialSegments; ++_x3) {
        var c = centerIndexStart + _x3;
        var i = centerIndexEnd + _x3;

        if (top) {
          // face top
          indices[indexOffset] = i + 1;
          ++indexOffset;
          indices[indexOffset] = c;
          ++indexOffset;
          indices[indexOffset] = i;
          ++indexOffset;
        } else {
          // face bottom
          indices[indexOffset] = c;
          ++indexOffset;
          indices[indexOffset] = i + 1;
          ++indexOffset;
          indices[indexOffset] = i;
          ++indexOffset;
        }
      }
    }
  }
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkY6L2plbmtpbnMvd29ya3NwYWNlL0NyZWF0b3JfM0QvZWRpdG9yLTNkL3Jlc291cmNlcy8zZC9lbmdpbmUvY29jb3MvY29yZS9wcmltaXRpdmUvY3lsaW5kZXIudHMiXSwibmFtZXMiOlsidGVtcDEiLCJWZWMzIiwidGVtcDIiLCJjeWxpbmRlciIsInJhZGl1c1RvcCIsInJhZGl1c0JvdHRvbSIsImhlaWdodCIsIm9wdHMiLCJoYWxmSGVpZ2h0IiwicmFkaWFsU2VnbWVudHMiLCJoZWlnaHRTZWdtZW50cyIsImNhcHBlZCIsInVuZGVmaW5lZCIsImFyYyIsIk1hdGgiLCJQSSIsImNudENhcCIsInZlcnRDb3VudCIsImluZGV4Q291bnQiLCJpbmRpY2VzIiwiQXJyYXkiLCJwb3NpdGlvbnMiLCJub3JtYWxzIiwidXZzIiwibWF4UmFkaXVzIiwibWF4IiwibWluUG9zIiwibWF4UG9zIiwiYm91bmRpbmdSYWRpdXMiLCJzcXJ0IiwiaW5kZXgiLCJpbmRleE9mZnNldCIsImdlbmVyYXRlVG9yc28iLCJnZW5lcmF0ZUNhcCIsImluZGV4QXJyYXkiLCJyIiwic2xvcGUiLCJzaWduIiwieSIsImluZGV4Um93IiwidiIsInJhZGl1cyIsIngiLCJ1IiwidGhldGEiLCJzaW5UaGV0YSIsInNpbiIsImNvc1RoZXRhIiwiY29zIiwibm9ybWFsaXplIiwic2V0IiwieiIsInB1c2giLCJpMSIsImkyIiwiaTMiLCJpNCIsInRvcCIsImNlbnRlckluZGV4U3RhcnQiLCJjZW50ZXJJbmRleEVuZCIsImMiLCJpIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7QUFvQkEsTUFBTUEsS0FBSyxHQUFHLElBQUlDLFdBQUosQ0FBUyxDQUFULEVBQVksQ0FBWixFQUFlLENBQWYsQ0FBZDtBQUNBLE1BQU1DLEtBQUssR0FBRyxJQUFJRCxXQUFKLENBQVMsQ0FBVCxFQUFZLENBQVosRUFBZSxDQUFmLENBQWQ7QUFFQTs7Ozs7Ozs7Ozs7QUFVZSxXQUFTRSxRQUFU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QUMsR0FBRyxDQUFiLEVBQWdCQSxHQUFDLEdBQUdqQyxjQUFwQixFQUFvQyxFQUFFaUMsR0FBdEMsRUFBeUM7QUFDdkMsWUFBTWtCLENBQUMsR0FBR0YsZ0JBQWdCLEdBQUdoQixHQUE3QjtBQUNBLFlBQU1tQixDQUFDLEdBQUdGLGNBQWMsR0FBR2pCLEdBQTNCOztBQUVBLFlBQUllLEdBQUosRUFBUztBQUNQO0FBQ0F0QyxVQUFBQSxPQUFPLENBQUNZLFdBQUQsQ0FBUCxHQUF1QjhCLENBQUMsR0FBRyxDQUEzQjtBQUE4QixZQUFFOUIsV0FBRjtBQUM5QlosVUFBQUEsT0FBTyxDQUFDWSxXQUFELENBQVAsR0FBdUI2QixDQUF2QjtBQUEwQixZQUFFN0IsV0FBRjtBQUMxQlosVUFBQUEsT0FBTyxDQUFDWSxXQUFELENBQVAsR0FBdUI4QixDQUF2QjtBQUEwQixZQUFFOUIsV0FBRjtBQUMzQixTQUxELE1BS087QUFDTDtBQUNBWixVQUFBQSxPQUFPLENBQUNZLFdBQUQsQ0FBUCxHQUF1QjZCLENBQXZCO0FBQTBCLFlBQUU3QixXQUFGO0FBQzFCWixVQUFBQSxPQUFPLENBQUNZLFdBQUQsQ0FBUCxHQUF1QjhCLENBQUMsR0FBRyxDQUEzQjtBQUE4QixZQUFFOUIsV0FBRjtBQUM5QlosVUFBQUEsT0FBTyxDQUFDWSxXQUFELENBQVAsR0FBdUI4QixDQUF2QjtBQUEwQixZQUFFOUIsV0FBRjtBQUMzQjtBQUNGO0FBQ0Y7QUFDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBAY2F0ZWdvcnkgM2QvcHJpbWl0aXZlXHJcbiAqL1xyXG5cclxuaW1wb3J0IHsgVmVjMyB9IGZyb20gJy4uL21hdGgnO1xyXG5pbXBvcnQgeyBJR2VvbWV0cnksIElHZW9tZXRyeU9wdGlvbnMgfSBmcm9tICcuL2RlZmluZSc7XHJcblxyXG4vKipcclxuICogQGVuXHJcbiAqIFRoZSBkZWZpbml0aW9uIG9mIHRoZSBwYXJhbWV0ZXIgZm9yIGJ1aWxkaW5nIGEgY3lsaW5kZXIuXHJcbiAqIEB6aFxyXG4gKiDlnIbmn7Hlj4LmlbDpgInpobnjgIJcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUN5bGluZGVyT3B0aW9ucyBleHRlbmRzIElHZW9tZXRyeU9wdGlvbnMge1xyXG4gIHJhZGlhbFNlZ21lbnRzOiBudW1iZXI7XHJcbiAgaGVpZ2h0U2VnbWVudHM6IG51bWJlcjtcclxuICBjYXBwZWQ6IGJvb2xlYW47XHJcbiAgYXJjOiBudW1iZXI7XHJcbn1cclxuXHJcbmNvbnN0IHRlbXAxID0gbmV3IFZlYzMoMCwgMCwgMCk7XHJcbmNvbnN0IHRlbXAyID0gbmV3IFZlYzMoMCwgMCwgMCk7XHJcblxyXG4vKipcclxuICogQGVuXHJcbiAqIEdlbmVyYXRlIGEgY3lsaW5kZXIgd2l0aCByYWRpdXNUb3AgcmFkaXVzQm90dG9tIDAuNSwgaGVpZ2h0IDIgYW5kIGNlbnRlcmVkIGF0IG9yaWdpbixcclxuICogYnV0IG1heSBiZSByZXBvc2l0aW9uZWQgdGhyb3VnaCB0aGUgYGNlbnRlcmAgb3B0aW9uLlxyXG4gKiBAemhcclxuICog55Sf5oiQ5LiA5Liq5ZyG5p+x44CCXHJcbiAqIEBwYXJhbSByYWRpdXNUb3Ag6aG26YOo5Y2K5b6E44CCXHJcbiAqIEBwYXJhbSByYWRpdXNCb3R0b20g5bqV6YOo5Y2K5b6E44CCXHJcbiAqIEBwYXJhbSBvcHRzIOWchuafseWPguaVsOmAiemhueOAglxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3lsaW5kZXIgKHJhZGl1c1RvcCA9IDAuNSwgcmFkaXVzQm90dG9tID0gMC41LCBoZWlnaHQgPSAyLCBvcHRzOiBSZWN1cnNpdmVQYXJ0aWFsPElDeWxpbmRlck9wdGlvbnM+ID0ge30pOiBJR2VvbWV0cnkge1xyXG4gIGNvbnN0IGhhbGZIZWlnaHQgPSBoZWlnaHQgKiAwLjU7XHJcbiAgY29uc3QgcmFkaWFsU2VnbWVudHMgPSBvcHRzLnJhZGlhbFNlZ21lbnRzIHx8IDMyO1xyXG4gIGNvbnN0IGhlaWdodFNlZ21lbnRzID0gb3B0cy5oZWlnaHRTZWdtZW50cyB8fCAxO1xyXG4gIGNvbnN0IGNhcHBlZCA9IG9wdHMuY2FwcGVkICE9PSB1bmRlZmluZWQgPyBvcHRzLmNhcHBlZCA6IHRydWU7XHJcbiAgY29uc3QgYXJjID0gb3B0cy5hcmMgfHwgMi4wICogTWF0aC5QSTtcclxuXHJcbiAgbGV0IGNudENhcCA9IDA7XHJcbiAgaWYgKCFjYXBwZWQpIHtcclxuICAgIGlmIChyYWRpdXNUb3AgPiAwKSB7XHJcbiAgICAgIGNudENhcCsrO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChyYWRpdXNCb3R0b20gPiAwKSB7XHJcbiAgICAgIGNudENhcCsrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gY2FsY3VsYXRlIHZlcnRleCBjb3VudFxyXG4gIGxldCB2ZXJ0Q291bnQgPSAocmFkaWFsU2VnbWVudHMgKyAxKSAqIChoZWlnaHRTZWdtZW50cyArIDEpO1xyXG4gIGlmIChjYXBwZWQpIHtcclxuICAgIHZlcnRDb3VudCArPSAoKHJhZGlhbFNlZ21lbnRzICsgMSkgKiBjbnRDYXApICsgKHJhZGlhbFNlZ21lbnRzICogY250Q2FwKTtcclxuICB9XHJcblxyXG4gIC8vIGNhbGN1bGF0ZSBpbmRleCBjb3VudFxyXG4gIGxldCBpbmRleENvdW50ID0gcmFkaWFsU2VnbWVudHMgKiBoZWlnaHRTZWdtZW50cyAqIDIgKiAzO1xyXG4gIGlmIChjYXBwZWQpIHtcclxuICAgIGluZGV4Q291bnQgKz0gcmFkaWFsU2VnbWVudHMgKiBjbnRDYXAgKiAzO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaW5kaWNlcyA9IG5ldyBBcnJheShpbmRleENvdW50KTtcclxuICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgQXJyYXkodmVydENvdW50ICogMyk7XHJcbiAgY29uc3Qgbm9ybWFscyA9IG5ldyBBcnJheSh2ZXJ0Q291bnQgKiAzKTtcclxuICBjb25zdCB1dnMgPSBuZXcgQXJyYXkodmVydENvdW50ICogMik7XHJcbiAgY29uc3QgbWF4UmFkaXVzID0gTWF0aC5tYXgocmFkaXVzVG9wLCByYWRpdXNCb3R0b20pO1xyXG4gIGNvbnN0IG1pblBvcyA9IG5ldyBWZWMzKC1tYXhSYWRpdXMsIC1oYWxmSGVpZ2h0LCAtbWF4UmFkaXVzKTtcclxuICBjb25zdCBtYXhQb3MgPSBuZXcgVmVjMyhtYXhSYWRpdXMsIGhhbGZIZWlnaHQsIG1heFJhZGl1cyk7XHJcbiAgY29uc3QgYm91bmRpbmdSYWRpdXMgPSBNYXRoLnNxcnQobWF4UmFkaXVzICogbWF4UmFkaXVzICsgaGFsZkhlaWdodCAqIGhhbGZIZWlnaHQpO1xyXG5cclxuICBsZXQgaW5kZXggPSAwO1xyXG4gIGxldCBpbmRleE9mZnNldCA9IDA7XHJcblxyXG4gIGdlbmVyYXRlVG9yc28oKTtcclxuXHJcbiAgaWYgKGNhcHBlZCkge1xyXG4gICAgaWYgKHJhZGl1c0JvdHRvbSA+IDApIHtcclxuICAgICAgZ2VuZXJhdGVDYXAoZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChyYWRpdXNUb3AgPiAwKSB7XHJcbiAgICAgIGdlbmVyYXRlQ2FwKHRydWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHBvc2l0aW9ucyxcclxuICAgIG5vcm1hbHMsXHJcbiAgICB1dnMsXHJcbiAgICBpbmRpY2VzLFxyXG4gICAgbWluUG9zLFxyXG4gICAgbWF4UG9zLFxyXG4gICAgYm91bmRpbmdSYWRpdXMsXHJcbiAgfTtcclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyBpbnRlcm5hbCBmdWNudGlvbnNcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICBmdW5jdGlvbiBnZW5lcmF0ZVRvcnNvICgpIHtcclxuICAgIGNvbnN0IGluZGV4QXJyYXk6IG51bWJlcltdW10gPSBbXTtcclxuXHJcbiAgICAvLyB0aGlzIHdpbGwgYmUgdXNlZCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbFxyXG4gICAgY29uc3QgciA9IHJhZGl1c1RvcCAtIHJhZGl1c0JvdHRvbTtcclxuICAgIGNvbnN0IHNsb3BlID0gciAqIHIgLyBoZWlnaHQgKiBNYXRoLnNpZ24ocik7XHJcblxyXG4gICAgLy8gZ2VuZXJhdGUgcG9zaXRpb25zLCBub3JtYWxzIGFuZCB1dnNcclxuICAgIGZvciAobGV0IHkgPSAwOyB5IDw9IGhlaWdodFNlZ21lbnRzOyB5KyspIHtcclxuICAgICAgY29uc3QgaW5kZXhSb3c6IG51bWJlcltdID0gW107XHJcbiAgICAgIGNvbnN0IHYgPSB5IC8gaGVpZ2h0U2VnbWVudHM7XHJcblxyXG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIHJhZGl1cyBvZiB0aGUgY3VycmVudCByb3dcclxuICAgICAgY29uc3QgcmFkaXVzID0gdiAqIHIgKyByYWRpdXNCb3R0b207XHJcblxyXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8PSByYWRpYWxTZWdtZW50czsgKyt4KSB7XHJcbiAgICAgICAgY29uc3QgdSA9IHggLyByYWRpYWxTZWdtZW50cztcclxuICAgICAgICBjb25zdCB0aGV0YSA9IHUgKiBhcmM7XHJcblxyXG4gICAgICAgIGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xyXG4gICAgICAgIGNvbnN0IGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xyXG5cclxuICAgICAgICAvLyB2ZXJ0ZXhcclxuICAgICAgICBwb3NpdGlvbnNbMyAqIGluZGV4XSA9IHJhZGl1cyAqIHNpblRoZXRhO1xyXG4gICAgICAgIHBvc2l0aW9uc1szICogaW5kZXggKyAxXSA9IHYgKiBoZWlnaHQgLSBoYWxmSGVpZ2h0O1xyXG4gICAgICAgIHBvc2l0aW9uc1szICogaW5kZXggKyAyXSA9IHJhZGl1cyAqIGNvc1RoZXRhO1xyXG5cclxuICAgICAgICAvLyBub3JtYWxcclxuICAgICAgICBWZWMzLm5vcm1hbGl6ZSh0ZW1wMSwgVmVjMy5zZXQodGVtcDIsIHNpblRoZXRhLCAtc2xvcGUsIGNvc1RoZXRhKSk7XHJcbiAgICAgICAgbm9ybWFsc1szICogaW5kZXhdID0gdGVtcDEueDtcclxuICAgICAgICBub3JtYWxzWzMgKiBpbmRleCArIDFdID0gdGVtcDEueTtcclxuICAgICAgICBub3JtYWxzWzMgKiBpbmRleCArIDJdID0gdGVtcDEuejtcclxuXHJcbiAgICAgICAgLy8gdXZcclxuICAgICAgICB1dnNbMiAqIGluZGV4XSA9ICgxIC0gdSkgKiAyICUgMTtcclxuICAgICAgICB1dnNbMiAqIGluZGV4ICsgMV0gPSB2O1xyXG5cclxuICAgICAgICAvLyBzYXZlIGluZGV4IG9mIHZlcnRleCBpbiByZXNwZWN0aXZlIHJvd1xyXG4gICAgICAgIGluZGV4Um93LnB1c2goaW5kZXgpO1xyXG5cclxuICAgICAgICAvLyBpbmNyZWFzZSBpbmRleFxyXG4gICAgICAgICsraW5kZXg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIG5vdyBzYXZlIHBvc2l0aW9ucyBvZiB0aGUgcm93IGluIG91ciBpbmRleCBhcnJheVxyXG4gICAgICBpbmRleEFycmF5LnB1c2goaW5kZXhSb3cpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGdlbmVyYXRlIGluZGljZXNcclxuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0U2VnbWVudHM7ICsreSkge1xyXG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHJhZGlhbFNlZ21lbnRzOyArK3gpIHtcclxuICAgICAgICAvLyB3ZSB1c2UgdGhlIGluZGV4IGFycmF5IHRvIGFjY2VzcyB0aGUgY29ycmVjdCBpbmRpY2VzXHJcbiAgICAgICAgY29uc3QgaTEgPSBpbmRleEFycmF5W3ldW3hdO1xyXG4gICAgICAgIGNvbnN0IGkyID0gaW5kZXhBcnJheVt5ICsgMV1beF07XHJcbiAgICAgICAgY29uc3QgaTMgPSBpbmRleEFycmF5W3kgKyAxXVt4ICsgMV07XHJcbiAgICAgICAgY29uc3QgaTQgPSBpbmRleEFycmF5W3ldW3ggKyAxXTtcclxuXHJcbiAgICAgICAgLy8gZmFjZSBvbmVcclxuICAgICAgICBpbmRpY2VzW2luZGV4T2Zmc2V0XSA9IGkxOyArK2luZGV4T2Zmc2V0O1xyXG4gICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXRdID0gaTQ7ICsraW5kZXhPZmZzZXQ7XHJcbiAgICAgICAgaW5kaWNlc1tpbmRleE9mZnNldF0gPSBpMjsgKytpbmRleE9mZnNldDtcclxuXHJcbiAgICAgICAgLy8gZmFjZSB0d29cclxuICAgICAgICBpbmRpY2VzW2luZGV4T2Zmc2V0XSA9IGk0OyArK2luZGV4T2Zmc2V0O1xyXG4gICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXRdID0gaTM7ICsraW5kZXhPZmZzZXQ7XHJcbiAgICAgICAgaW5kaWNlc1tpbmRleE9mZnNldF0gPSBpMjsgKytpbmRleE9mZnNldDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2VuZXJhdGVDYXAgKHRvcCkge1xyXG4gICAgY29uc3QgcmFkaXVzID0gdG9wID8gcmFkaXVzVG9wIDogcmFkaXVzQm90dG9tO1xyXG4gICAgY29uc3Qgc2lnbiA9IHRvcCA/IDEgOiAtIDE7XHJcblxyXG4gICAgLy8gc2F2ZSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNlbnRlciB2ZXJ0ZXhcclxuICAgIGNvbnN0IGNlbnRlckluZGV4U3RhcnQgPSBpbmRleDtcclxuXHJcbiAgICAvLyBmaXJzdCB3ZSBnZW5lcmF0ZSB0aGUgY2VudGVyIHZlcnRleCBkYXRhIG9mIHRoZSBjYXAuXHJcbiAgICAvLyBiZWNhdXNlIHRoZSBnZW9tZXRyeSBuZWVkcyBvbmUgc2V0IG9mIHV2cyBwZXIgZmFjZSxcclxuICAgIC8vIHdlIG11c3QgZ2VuZXJhdGUgYSBjZW50ZXIgdmVydGV4IHBlciBmYWNlL3NlZ21lbnRcclxuXHJcbiAgICBmb3IgKGxldCB4ID0gMTsgeCA8PSByYWRpYWxTZWdtZW50czsgKyt4KSB7XHJcbiAgICAgIC8vIHZlcnRleFxyXG4gICAgICBwb3NpdGlvbnNbMyAqIGluZGV4XSA9IDA7XHJcbiAgICAgIHBvc2l0aW9uc1szICogaW5kZXggKyAxXSA9IGhhbGZIZWlnaHQgKiBzaWduO1xyXG4gICAgICBwb3NpdGlvbnNbMyAqIGluZGV4ICsgMl0gPSAwO1xyXG5cclxuICAgICAgLy8gbm9ybWFsXHJcbiAgICAgIG5vcm1hbHNbMyAqIGluZGV4XSA9IDA7XHJcbiAgICAgIG5vcm1hbHNbMyAqIGluZGV4ICsgMV0gPSBzaWduO1xyXG4gICAgICBub3JtYWxzWzMgKiBpbmRleCArIDJdID0gMDtcclxuXHJcbiAgICAgIC8vIHV2XHJcbiAgICAgIHV2c1syICogaW5kZXhdID0gMC41O1xyXG4gICAgICB1dnNbMiAqIGluZGV4ICsgMV0gPSAwLjU7XHJcblxyXG4gICAgICAvLyBpbmNyZWFzZSBpbmRleFxyXG4gICAgICArK2luZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHNhdmUgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNlbnRlciB2ZXJ0ZXhcclxuICAgIGNvbnN0IGNlbnRlckluZGV4RW5kID0gaW5kZXg7XHJcblxyXG4gICAgLy8gbm93IHdlIGdlbmVyYXRlIHRoZSBzdXJyb3VuZGluZyBwb3NpdGlvbnMsIG5vcm1hbHMgYW5kIHV2c1xyXG5cclxuICAgIGZvciAobGV0IHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyArK3gpIHtcclxuICAgICAgY29uc3QgdSA9IHggLyByYWRpYWxTZWdtZW50cztcclxuICAgICAgY29uc3QgdGhldGEgPSB1ICogYXJjO1xyXG5cclxuICAgICAgY29uc3QgY29zVGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XHJcbiAgICAgIGNvbnN0IHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xyXG5cclxuICAgICAgLy8gdmVydGV4XHJcbiAgICAgIHBvc2l0aW9uc1szICogaW5kZXhdID0gcmFkaXVzICogc2luVGhldGE7XHJcbiAgICAgIHBvc2l0aW9uc1szICogaW5kZXggKyAxXSA9IGhhbGZIZWlnaHQgKiBzaWduO1xyXG4gICAgICBwb3NpdGlvbnNbMyAqIGluZGV4ICsgMl0gPSByYWRpdXMgKiBjb3NUaGV0YTtcclxuXHJcbiAgICAgIC8vIG5vcm1hbFxyXG4gICAgICBub3JtYWxzWzMgKiBpbmRleF0gPSAwO1xyXG4gICAgICBub3JtYWxzWzMgKiBpbmRleCArIDFdID0gc2lnbjtcclxuICAgICAgbm9ybWFsc1szICogaW5kZXggKyAyXSA9IDA7XHJcblxyXG4gICAgICAvLyB1dlxyXG4gICAgICB1dnNbMiAqIGluZGV4XSA9IDAuNSAtIChzaW5UaGV0YSAqIDAuNSAqIHNpZ24pO1xyXG4gICAgICB1dnNbMiAqIGluZGV4ICsgMV0gPSAwLjUgKyAoY29zVGhldGEgKiAwLjUpO1xyXG5cclxuICAgICAgLy8gaW5jcmVhc2UgaW5kZXhcclxuICAgICAgKytpbmRleDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBnZW5lcmF0ZSBpbmRpY2VzXHJcblxyXG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgKyt4KSB7XHJcbiAgICAgIGNvbnN0IGMgPSBjZW50ZXJJbmRleFN0YXJ0ICsgeDtcclxuICAgICAgY29uc3QgaSA9IGNlbnRlckluZGV4RW5kICsgeDtcclxuXHJcbiAgICAgIGlmICh0b3ApIHtcclxuICAgICAgICAvLyBmYWNlIHRvcFxyXG4gICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXRdID0gaSArIDE7ICsraW5kZXhPZmZzZXQ7XHJcbiAgICAgICAgaW5kaWNlc1tpbmRleE9mZnNldF0gPSBjOyArK2luZGV4T2Zmc2V0O1xyXG4gICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXRdID0gaTsgKytpbmRleE9mZnNldDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBmYWNlIGJvdHRvbVxyXG4gICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXRdID0gYzsgKytpbmRleE9mZnNldDtcclxuICAgICAgICBpbmRpY2VzW2luZGV4T2Zmc2V0XSA9IGkgKyAxOyArK2luZGV4T2Zmc2V0O1xyXG4gICAgICAgIGluZGljZXNbaW5kZXhPZmZzZXRdID0gaTsgKytpbmRleE9mZnNldDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=