(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports", "./utils/id-generator.js", "./utils/js.js", "./components/system.js"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports, require("./utils/id-generator.js"), require("./utils/js.js"), require("./components/system.js"));
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports, global.idGenerator, global.js, global.system);
    global.scheduler = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports, _idGenerator, _js, _system) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.Scheduler = void 0;
  _idGenerator = _interopRequireDefault(_idGenerator);
  _system = _interopRequireDefault(_system);

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

  function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

  function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  var MAX_POOL_SIZE = 20;
  var idGenerator = new _idGenerator.default('Scheduler');

  // data structures

  /**
   * @en A list double-linked list used for "updates with priority"
   * @zh 用于“优先更新”的列表
   * @class ListEntry
   * @param {Object} target not retained (retained by hashUpdateEntry)
   * @param {Number} priority
   * @param {Boolean} paused
   * @param {Boolean} markedForDeletion selector will no longer be called and entry will be removed at end of the next tick
   */
  var ListEntry = function ListEntry(target, priority, paused, markedForDeletion) {
    _classCallCheck(this, ListEntry);

    this.target = void 0;
    this.priority = void 0;
    this.paused = void 0;
    this.markedForDeletion = void 0;
    this.target = target;
    this.priority = priority;
    this.paused = paused;
    this.markedForDeletion = markedForDeletion;
  };
  /**
   * @en A update entry list
   * @zh 更新条目列表
   * @class HashUpdateEntry
   * @param {Array} list Which list does it belong to ?
   * @param {ListEntry} entry entry in the list
   * @param {Object} target hash key (retained)
   * @param {function} callback
   */


  ListEntry.get = function (target, priority, paused, markedForDeletion) {
    var result = ListEntry._listEntries.pop();

    if (result) {
      result.target = target;
      result.priority = priority;
      result.paused = paused;
      result.markedForDeletion = markedForDeletion;
    } else {
      result = new ListEntry(target, priority, paused, markedForDeletion);
    }

    return result;
  };

  ListEntry.put = function (entry) {
    if (ListEntry._listEntries.length < MAX_POOL_SIZE) {
      entry.target = null;

      ListEntry._listEntries.push(entry);
    }
  };

  ListEntry._listEntries = [];

  var HashUpdateEntry = function HashUpdateEntry(list, entry, target, callback) {
    _classCallCheck(this, HashUpdateEntry);

    this.list = void 0;
    this.entry = void 0;
    this.target = void 0;
    this.callback = void 0;
    this.list = list;
    this.entry = entry;
    this.target = target;
    this.callback = callback;
  };
  /**
   * @en Hash Element used for "selectors with interval"
   * @zh “用于间隔选择”的哈希元素
   * @class HashTimerEntry
   * @param {Array} timers
   * @param {Object} target  hash key (retained)
   * @param {Number} timerIndex
   * @param {Timer} currentTimer
   * @param {Boolean} currentTimerSalvaged
   * @param {Boolean} paused
   */


  HashUpdateEntry.get = function (list, entry, target, callback) {
    var result = HashUpdateEntry._hashUpdateEntries.pop();

    if (result) {
      result.list = list;
      result.entry = entry;
      result.target = target;
      result.callback = callback;
    } else {
      result = new HashUpdateEntry(list, entry, target, callback);
    }

    return result;
  };

  HashUpdateEntry.put = function (entry) {
    if (HashUpdateEntry._hashUpdateEntries.length < MAX_POOL_SIZE) {
      entry.list = entry.entry = entry.target = entry.callback = null;

      HashUpdateEntry._hashUpdateEntries.push(entry);
    }
  };

  HashUpdateEntry._hashUpdateEntries = [];

  var HashTimerEntry = function HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
    _classCallCheck(this, HashTimerEntry);

    this.timers = void 0;
    this.target = void 0;
    this.timerIndex = void 0;
    this.currentTimer = void 0;
    this.currentTimerSalvaged = void 0;
    this.paused = void 0;
    this.timers = timers;
    this.target = target;
    this.timerIndex = timerIndex;
    this.currentTimer = currentTimer;
    this.currentTimerSalvaged = currentTimerSalvaged;
    this.paused = paused;
  };
  /*
   * Light weight timer
   */


  HashTimerEntry.get = function (timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused) {
    var result = HashTimerEntry._hashTimerEntries.pop();

    if (result) {
      result.timers = timers;
      result.target = target;
      result.timerIndex = timerIndex;
      result.currentTimer = currentTimer;
      result.currentTimerSalvaged = currentTimerSalvaged;
      result.paused = paused;
    } else {
      result = new HashTimerEntry(timers, target, timerIndex, currentTimer, currentTimerSalvaged, paused);
    }

    return result;
  };

  HashTimerEntry.put = function (entry) {
    if (HashTimerEntry._hashTimerEntries.length < MAX_POOL_SIZE) {
      entry.timers = entry.target = entry.currentTimer = null;

      HashTimerEntry._hashTimerEntries.push(entry);
    }
  };

  HashTimerEntry._hashTimerEntries = [];

  var CallbackTimer = /*#__PURE__*/function () {
    function CallbackTimer() {
      _classCallCheck(this, CallbackTimer);

      this._lock = void 0;
      this._scheduler = void 0;
      this._elapsed = void 0;
      this._runForever = void 0;
      this._useDelay = void 0;
      this._timesExecuted = void 0;
      this._repeat = void 0;
      this._delay = void 0;
      this._interval = void 0;
      this._target = void 0;
      this._callback = void 0;
      this._lock = false;
      this._scheduler = null;
      this._elapsed = -1;
      this._runForever = false;
      this._useDelay = false;
      this._timesExecuted = 0;
      this._repeat = 0;
      this._delay = 0;
      this._interval = 0;
      this._target = null;
      this._callback = null;
    }

    _createClass(CallbackTimer, [{
      key: "initWithCallback",
      value: function initWithCallback(scheduler, callback, target, seconds, repeat, delay) {
        this._lock = false;
        this._scheduler = scheduler;
        this._target = target;
        this._callback = callback;
        this._elapsed = -1;
        this._interval = seconds;
        this._delay = delay;
        this._useDelay = this._delay > 0;
        this._repeat = repeat;
        this._runForever = this._repeat === cc.macro.REPEAT_FOREVER;
        return true;
      }
      /**
       * @return {Number} returns interval of timer
       */

    }, {
      key: "getInterval",
      value: function getInterval() {
        return this._interval;
      }
      /**
       * @param {Number} interval set interval in seconds
       */

    }, {
      key: "setInterval",
      value: function setInterval(interval) {
        this._interval = interval;
      }
      /**
       * triggers the timer
       * @param {Number} dt delta time
       */

    }, {
      key: "update",
      value: function update(dt) {
        if (this._elapsed === -1) {
          this._elapsed = 0;
          this._timesExecuted = 0;
        } else {
          this._elapsed += dt;

          if (this._runForever && !this._useDelay) {
            // standard timer usage
            if (this._elapsed >= this._interval) {
              this.trigger();
              this._elapsed = 0;
            }
          } else {
            // advanced usage
            if (this._useDelay) {
              if (this._elapsed >= this._delay) {
                this.trigger();
                this._elapsed -= this._delay;
                this._timesExecuted += 1;
                this._useDelay = false;
              }
            } else {
              if (this._elapsed >= this._interval) {
                this.trigger();
                this._elapsed = 0;
                this._timesExecuted += 1;
              }
            }

            if (this._callback && !this._runForever && this._timesExecuted > this._repeat) {
              this.cancel();
            }
          }
        }
      }
    }, {
      key: "getCallback",
      value: function getCallback() {
        return this._callback;
      }
    }, {
      key: "trigger",
      value: function trigger() {
        if (this._target && this._callback) {
          this._lock = true;

          this._callback.call(this._target, this._elapsed);

          this._lock = false;
        }
      }
    }, {
      key: "cancel",
      value: function cancel() {
        // override
        this._scheduler.unschedule(this._callback, this._target);
      }
    }]);

    return CallbackTimer;
  }();
  /**
   * @en
   * Scheduler is responsible of triggering the scheduled callbacks.<br>
   * You should not use NSTimer. Instead use this class.<br>
   * <br>
   * There are 2 different types of callbacks (selectors):<br>
   *     - update callback: the 'update' callback will be called every frame. You can customize the priority.<br>
   *     - custom callback: A custom callback will be called every frame, or with a custom interval of time<br>
   * <br>
   * The 'custom selectors' should be avoided when possible. It is faster,<br>
   * and consumes less memory to use the 'update callback'. *
   * @zh
   * Scheduler 是负责触发回调函数的类。<br>
   * 通常情况下，建议使用 cc.director.getScheduler() 来获取系统定时器。<br>
   * 有两种不同类型的定时器：<br>
   *     - update 定时器：每一帧都会触发。您可以自定义优先级。<br>
   *     - 自定义定时器：自定义定时器可以每一帧或者自定义的时间间隔触发。<br>
   * 如果希望每帧都触发，应该使用 update 定时器，使用 update 定时器更快，而且消耗更少的内存。
   *
   * @class Scheduler
   */


  CallbackTimer._timers = [];

  CallbackTimer.get = function () {
    return CallbackTimer._timers.pop() || new CallbackTimer();
  };

  CallbackTimer.put = function (timer) {
    if (CallbackTimer._timers.length < MAX_POOL_SIZE && !timer._lock) {
      timer._scheduler = timer._target = timer._callback = null;

      CallbackTimer._timers.push(timer);
    }
  };

  var Scheduler = /*#__PURE__*/function (_System) {
    _inherits(Scheduler, _System);

    _createClass(Scheduler, null, [{
      key: "enableForTarget",

      /**
       * @en Priority level reserved for system services.
       * @zh 系统服务的优先级。
       * @property PRIORITY_SYSTEM
       */

      /**
       * @en Minimum priority level for user scheduling.
       * @zh 用户调度最低优先级。
       * @property PRIORITY_NON_SYSTEM
       */

      /**
       * @en This method should be called for any target which needs to schedule tasks, and this method should be called before any scheduler API usage.<bg>
       * This method will add a `id` property if it doesn't exist.
       * @zh 任何需要用 Scheduler 管理任务的对象主体都应该调用这个方法，并且应该在调用任何 Scheduler API 之前调用这个方法。<bg>
       * 这个方法会给对象添加一个 `id` 属性，如果这个属性不存在的话。
       * @param {Object} target
       */
      value: function enableForTarget(target) {
        var found = false;

        if (target.uuid) {
          found = true;
        } else if (target.id) {
          found = true;
        }

        if (!found) {
          // @ts-ignore
          if (target.__instanceId) {
            cc.warnID(1513);
          } else {
            target.id = idGenerator.getNewId();
          }
        }
      }
    }]);

    function Scheduler() {
      var _this;

      _classCallCheck(this, Scheduler);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Scheduler).call(this));
      _this._timeScale = void 0;
      _this._updatesNegList = void 0;
      _this._updates0List = void 0;
      _this._updatesPosList = void 0;
      _this._hashForUpdates = void 0;
      _this._hashForTimers = void 0;
      _this._currentTarget = void 0;
      _this._currentTargetSalvaged = void 0;
      _this._updateHashLocked = void 0;
      _this._arrayForTimers = void 0;
      _this._timeScale = 1.0;
      _this._updatesNegList = []; // list of priority < 0

      _this._updates0List = []; // list of priority == 0

      _this._updatesPosList = []; // list of priority > 0

      _this._hashForUpdates = (0, _js.createMap)(true); // hash used to fetch quickly the list entries for pause, delete, etc

      _this._hashForTimers = (0, _js.createMap)(true); // Used for "selectors with interval"

      _this._currentTarget = null;
      _this._currentTargetSalvaged = false;
      _this._updateHashLocked = false; // If true unschedule will not remove anything from a hash. Elements will only be marked for deletion.

      _this._arrayForTimers = []; // Speed up indexing
      // this._arrayForUpdates = [];   // Speed up indexing

      return _this;
    } // -----------------------public method-------------------------

    /**
     * @en
     * Modifies the time of all scheduled callbacks.<br>
     * You can use this property to create a 'slow motion' or 'fast forward' effect.<br>
     * Default is 1.0. To create a 'slow motion' effect, use values below 1.0.<br>
     * To create a 'fast forward' effect, use values higher than 1.0.<br>
     * Note：It will affect EVERY scheduled selector / action.
     * @zh
     * 设置时间间隔的缩放比例。<br>
     * 您可以使用这个方法来创建一个 “slow motion（慢动作）” 或 “fast forward（快进）” 的效果。<br>
     * 默认是 1.0。要创建一个 “slow motion（慢动作）” 效果,使用值低于 1.0。<br>
     * 要使用 “fast forward（快进）” 效果，使用值大于 1.0。<br>
     * 注意：它影响该 Scheduler 下管理的所有定时器。
     * @param {Number} timeScale
     */


    _createClass(Scheduler, [{
      key: "setTimeScale",
      value: function setTimeScale(timeScale) {
        this._timeScale = timeScale;
      }
      /**
       * @en Returns time scale of scheduler.
       * @zh 获取时间间隔的缩放比例。
       * @return {Number}
       */

    }, {
      key: "getTimeScale",
      value: function getTimeScale() {
        return this._timeScale;
      }
      /**
       * @en 'update' the scheduler. (You should NEVER call this method, unless you know what you are doing.)
       * @zh update 调度函数。(不应该直接调用这个方法，除非完全了解这么做的结果)
       * @param {Number} dt delta time
       */

    }, {
      key: "update",
      value: function update(dt) {
        this._updateHashLocked = true;

        if (this._timeScale !== 1) {
          dt *= this._timeScale;
        }

        var i;
        var list;
        var len;
        var entry;

        for (i = 0, list = this._updatesNegList, len = list.length; i < len; i++) {
          entry = list[i];

          if (!entry.paused && !entry.markedForDeletion) {
            entry.target.update(dt);
          }
        }

        for (i = 0, list = this._updates0List, len = list.length; i < len; i++) {
          entry = list[i];

          if (!entry.paused && !entry.markedForDeletion) {
            entry.target.update(dt);
          }
        }

        for (i = 0, list = this._updatesPosList, len = list.length; i < len; i++) {
          entry = list[i];

          if (!entry.paused && !entry.markedForDeletion) {
            entry.target.update(dt);
          }
        } // Iterate over all the custom selectors


        var elt;
        var arr = this._arrayForTimers;

        for (i = 0; i < arr.length; i++) {
          elt = arr[i];
          this._currentTarget = elt;
          this._currentTargetSalvaged = false;

          if (!elt.paused) {
            // The 'timers' array may change while inside this loop
            for (elt.timerIndex = 0; elt.timerIndex < elt.timers.length; ++elt.timerIndex) {
              elt.currentTimer = elt.timers[elt.timerIndex];
              elt.currentTimerSalvaged = false;
              elt.currentTimer.update(dt);
              elt.currentTimer = null;
            }
          } // only delete currentTarget if no actions were scheduled during the cycle (issue #481)


          if (this._currentTargetSalvaged && this._currentTarget.timers.length === 0) {
            this._removeHashElement(this._currentTarget);

            --i;
          }
        } // delete all updates that are marked for deletion
        // updates with priority < 0


        for (i = 0, list = this._updatesNegList; i < list.length;) {
          entry = list[i];

          if (entry.markedForDeletion) {
            this._removeUpdateFromHash(entry);
          } else {
            i++;
          }
        }

        for (i = 0, list = this._updates0List; i < list.length;) {
          entry = list[i];

          if (entry.markedForDeletion) {
            this._removeUpdateFromHash(entry);
          } else {
            i++;
          }
        }

        for (i = 0, list = this._updatesPosList; i < list.length;) {
          entry = list[i];

          if (entry.markedForDeletion) {
            this._removeUpdateFromHash(entry);
          } else {
            i++;
          }
        }

        this._updateHashLocked = false;
        this._currentTarget = null;
      }
      /**
       * @en
       * <p>
       *   The scheduled method will be called every 'interval' seconds.<br/>
       *   If paused is YES, then it won't be called until it is resumed.<br/>
       *   If 'interval' is 0, it will be called every frame, but if so, it recommended to use 'scheduleUpdateForTarget:' instead.<br/>
       *   If the callback function is already scheduled, then only the interval parameter will be updated without re-scheduling it again.<br/>
       *   repeat let the action be repeated repeat + 1 times, use cc.macro.REPEAT_FOREVER to let the action run continuously<br/>
       *   delay is the amount of time the action will wait before it'll start<br/>
       * </p>
       * @zh
       * 指定回调函数，调用对象等信息来添加一个新的定时器。<br/>
       * 如果 paused 值为 true，那么直到 resume 被调用才开始计时。<br/>
       * 当时间间隔达到指定值时，设置的回调函数将会被调用。<br/>
       * 如果 interval 值为 0，那么回调函数每一帧都会被调用，但如果是这样，
       * 建议使用 scheduleUpdateForTarget 代替。<br/>
       * 如果回调函数已经被定时器使用，那么只会更新之前定时器的时间间隔参数，不会设置新的定时器。<br/>
       * repeat 值可以让定时器触发 repeat + 1 次，使用 cc.macro.REPEAT_FOREVER
       * 可以让定时器一直循环触发。<br/>
       * delay 值指定延迟时间，定时器会在延迟指定的时间之后开始计时。
       * @param {Function} callback
       * @param {Object} target
       * @param {Number} interval
       * @param {Number} [repeat=cc.macro.REPEAT_FOREVER]
       * @param {Number} [delay=0]
       * @param {Boolean} [paused=fasle]
       */

    }, {
      key: "schedule",
      value: function schedule(callback, target, interval, repeat, delay, paused) {
        'use strict';

        if (typeof callback !== 'function') {
          var tmp = callback; // @ts-ignore

          callback = target;
          target = tmp;
        } // selector, target, interval, repeat, delay, paused
        // selector, target, interval, paused


        if (arguments.length === 3 || arguments.length === 4 || arguments.length === 5) {
          paused = !!repeat;
          repeat = cc.macro.REPEAT_FOREVER;
          delay = 0;
        }

        cc.assertID(target, 1502);
        var targetId = target.uuid || target.id;

        if (!targetId) {
          cc.errorID(1510);
          return;
        }

        var element = this._hashForTimers[targetId];

        if (!element) {
          // Is this the 1st element ? Then set the pause level to all the callback_fns of this target
          element = HashTimerEntry.get(null, target, 0, null, null, paused);

          this._arrayForTimers.push(element);

          this._hashForTimers[targetId] = element;
        } else if (element.paused !== paused) {
          cc.warnID(1511);
        }

        var timer;
        var i;

        if (element.timers == null) {
          element.timers = [];
        } else {
          for (i = 0; i < element.timers.length; ++i) {
            timer = element.timers[i];

            if (timer && callback === timer._callback) {
              cc.logID(1507, timer.getInterval(), interval);
              timer._interval = interval;
              return;
            }
          }
        }

        timer = CallbackTimer.get();
        timer.initWithCallback(this, callback, target, interval, repeat, delay);
        element.timers.push(timer);

        if (this._currentTarget === element && this._currentTargetSalvaged) {
          this._currentTargetSalvaged = false;
        }
      }
      /**
       * @en
       * Schedules the update callback for a given target,
       * During every frame after schedule started, the "update" function of target will be invoked.
       * @zh
       * 使用指定的优先级为指定的对象设置 update 定时器。<br>
       * update 定时器每一帧都会被触发，触发时自动调用指定对象的 "update" 函数。<br>
       * 优先级的值越低，定时器被触发的越早。
       * @param {Object} target
       * @param {Number} priority
       * @param {Boolean} paused
       */

    }, {
      key: "scheduleUpdate",
      value: function scheduleUpdate(target, priority, paused) {
        var targetId = target.uuid || target.id;

        if (!targetId) {
          cc.errorID(1510);
          return;
        }

        var hashElement = this._hashForUpdates[targetId];

        if (hashElement && hashElement.entry) {
          // check if priority has changed
          if (hashElement.entry.priority !== priority) {
            if (this._updateHashLocked) {
              cc.logID(1506);
              hashElement.entry.markedForDeletion = false;
              hashElement.entry.paused = paused;
              return;
            } else {
              // will be added again outside if (hashElement).
              this.unscheduleUpdate(target);
            }
          } else {
            hashElement.entry.markedForDeletion = false;
            hashElement.entry.paused = paused;
            return;
          }
        }

        var listElement = ListEntry.get(target, priority, paused, false);
        var ppList; // most of the updates are going to be 0, that's way there
        // is an special list for updates with priority 0

        if (priority === 0) {
          ppList = this._updates0List;

          this._appendIn(ppList, listElement);
        } else {
          ppList = priority < 0 ? this._updatesNegList : this._updatesPosList;

          this._priorityIn(ppList, listElement, priority);
        } // update hash entry for quick access


        this._hashForUpdates[targetId] = HashUpdateEntry.get(ppList, listElement, target, null);
      }
      /**
       * @en
       * Unschedules a callback for a callback and a given target.<br>
       * If you want to unschedule the "update", use `unscheduleUpdate()`
       * @zh
       * 根据指定的回调函数和调用对象。<br>
       * 如果需要取消 update 定时器，请使用 unscheduleUpdate()。
       * @param {Function} callback The callback to be unscheduled
       * @param {Object} target The target bound to the callback.
       */

    }, {
      key: "unschedule",
      value: function unschedule(callback, target) {
        // callback, target
        // explicity handle nil arguments when removing an object
        if (!target || !callback) {
          return;
        }

        var targetId = target.uuid || target.id;

        if (!targetId) {
          cc.errorID(1510);
          return;
        }

        var self = this;
        var element = self._hashForTimers[targetId];

        if (element) {
          var timers = element.timers;

          for (var i = 0, li = timers.length; i < li; i++) {
            var timer = timers[i];

            if (callback === timer._callback) {
              if (timer === element.currentTimer && !element.currentTimerSalvaged) {
                element.currentTimerSalvaged = true;
              }

              timers.splice(i, 1);
              CallbackTimer.put(timer); // update timerIndex in case we are in tick;, looping over the actions

              if (element.timerIndex >= i) {
                element.timerIndex--;
              }

              if (timers.length === 0) {
                if (self._currentTarget === element) {
                  self._currentTargetSalvaged = true;
                } else {
                  self._removeHashElement(element);
                }
              }

              return;
            }
          }
        }
      }
      /**
       * @en Unschedules the update callback for a given target.
       * @zh 取消指定对象的 update 定时器。
       * @param {Object} target The target to be unscheduled.
       */

    }, {
      key: "unscheduleUpdate",
      value: function unscheduleUpdate(target) {
        if (!target) {
          return;
        }

        var targetId = target.uuid || target.id;

        if (!targetId) {
          cc.errorID(1510);
          return;
        }

        var element = this._hashForUpdates[targetId];

        if (element) {
          if (this._updateHashLocked) {
            element.entry.markedForDeletion = true;
          } else {
            this._removeUpdateFromHash(element.entry);
          }
        }
      }
      /**
       * @en
       * Unschedules all scheduled callbacks for a given target.
       * This also includes the "update" callback.
       * @zh 取消指定对象的所有定时器，包括 update 定时器。
       * @param {Object} target The target to be unscheduled.
       */

    }, {
      key: "unscheduleAllForTarget",
      value: function unscheduleAllForTarget(target) {
        // explicit nullptr handling
        if (!target) {
          return;
        }

        var targetId = target.uuid || target.id;

        if (!targetId) {
          cc.errorID(1510);
          return;
        } // Custom Selectors


        var element = this._hashForTimers[targetId];

        if (element) {
          var timers = element.timers;

          if (timers.indexOf(element.currentTimer) > -1 && !element.currentTimerSalvaged) {
            element.currentTimerSalvaged = true;
          }

          for (var i = 0, l = timers.length; i < l; i++) {
            CallbackTimer.put(timers[i]);
          }

          timers.length = 0;

          if (this._currentTarget === element) {
            this._currentTargetSalvaged = true;
          } else {
            this._removeHashElement(element);
          }
        } // update selector


        this.unscheduleUpdate(target);
      }
      /**
       * @en
       * Unschedules all scheduled callbacks from all targets including the system callbacks.<br/>
       * You should NEVER call this method, unless you know what you are doing.
       * @zh
       * 取消所有对象的所有定时器，包括系统定时器。<br/>
       * 不用调用此函数，除非你确定你在做什么。
       */

    }, {
      key: "unscheduleAll",
      value: function unscheduleAll() {
        this.unscheduleAllWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
      }
      /**
       * @en
       * Unschedules all callbacks from all targets with a minimum priority.<br/>
       * You should only call this with `PRIORITY_NON_SYSTEM_MIN` or higher.
       * @zh
       * 取消所有优先级的值大于指定优先级的定时器。<br/>
       * 你应该只取消优先级的值大于 PRIORITY_NON_SYSTEM_MIN 的定时器。
       * @param {Number} minPriority The minimum priority of selector to be unscheduled. Which means, all selectors which
       *        priority is higher than minPriority will be unscheduled.
       */

    }, {
      key: "unscheduleAllWithMinPriority",
      value: function unscheduleAllWithMinPriority(minPriority) {
        // Custom Selectors
        var i;
        var element;
        var arr = this._arrayForTimers;

        for (i = arr.length - 1; i >= 0; i--) {
          element = arr[i];
          this.unscheduleAllForTarget(element.target);
        } // Updates selectors


        var entry;
        var temp_length = 0;

        if (minPriority < 0) {
          for (i = 0; i < this._updatesNegList.length;) {
            temp_length = this._updatesNegList.length;
            entry = this._updatesNegList[i];

            if (entry && entry.priority >= minPriority) {
              this.unscheduleUpdate(entry.target);
            }

            if (temp_length === this._updatesNegList.length) {
              i++;
            }
          }
        }

        if (minPriority <= 0) {
          for (i = 0; i < this._updates0List.length;) {
            temp_length = this._updates0List.length;
            entry = this._updates0List[i];

            if (entry) {
              this.unscheduleUpdate(entry.target);
            }

            if (temp_length === this._updates0List.length) {
              i++;
            }
          }
        }

        for (i = 0; i < this._updatesPosList.length;) {
          temp_length = this._updatesPosList.length;
          entry = this._updatesPosList[i];

          if (entry && entry.priority >= minPriority) {
            this.unscheduleUpdate(entry.target);
          }

          if (temp_length === this._updatesPosList.length) {
            i++;
          }
        }
      }
      /**
       * @en Checks whether a callback for a given target is scheduled.
       * @zh 检查指定的回调函数和回调对象组合是否存在定时器。
       * @param {Function} callback The callback to check.
       * @param {Object} target The target of the callback.
       * @return {Boolean} True if the specified callback is invoked, false if not.
       */

    }, {
      key: "isScheduled",
      value: function isScheduled(callback, target) {
        // key, target
        // selector, target
        cc.assertID(callback, 1508);
        cc.assertID(target, 1509);
        var targetId = target.uuid || target.id;

        if (!targetId) {
          cc.errorID(1510);
          return;
        }

        var element = this._hashForTimers[targetId];

        if (!element) {
          return false;
        }

        if (element.timers == null) {
          return false;
        } else {
          var timers = element.timers; // tslint:disable-next-line: prefer-for-of

          for (var i = 0; i < timers.length; ++i) {
            var timer = timers[i];

            if (callback === timer._callback) {
              return true;
            }
          }

          return false;
        }
      }
      /**
       * @en
       * Pause all selectors from all targets.<br/>
       * You should NEVER call this method, unless you know what you are doing.
       * @zh
       * 暂停所有对象的所有定时器。<br/>
       * 不要调用这个方法，除非你知道你正在做什么。
       */

    }, {
      key: "pauseAllTargets",
      value: function pauseAllTargets() {
        return this.pauseAllTargetsWithMinPriority(cc.Scheduler.PRIORITY_SYSTEM);
      }
      /**
       * @en
       * Pause all selectors from all targets with a minimum priority. <br/>
       * You should only call this with kCCPriorityNonSystemMin or higher.
       * @zh
       * 暂停所有优先级的值大于指定优先级的定时器。<br/>
       * 你应该只暂停优先级的值大于 PRIORITY_NON_SYSTEM_MIN 的定时器。
       * @param {Number} minPriority
       */

    }, {
      key: "pauseAllTargetsWithMinPriority",
      value: function pauseAllTargetsWithMinPriority(minPriority) {
        var idsWithSelectors = [];
        var self = this;
        var element;
        var locArrayForTimers = self._arrayForTimers;
        var i;
        var li; // Custom Selectors

        for (i = 0, li = locArrayForTimers.length; i < li; i++) {
          element = locArrayForTimers[i];

          if (element) {
            element.paused = true;
            idsWithSelectors.push(element.target);
          }
        }

        var entry;

        if (minPriority < 0) {
          for (i = 0; i < this._updatesNegList.length; i++) {
            entry = this._updatesNegList[i];

            if (entry) {
              if (entry.priority >= minPriority) {
                entry.paused = true;
                idsWithSelectors.push(entry.target);
              }
            }
          }
        }

        if (minPriority <= 0) {
          for (i = 0; i < this._updates0List.length; i++) {
            entry = this._updates0List[i];

            if (entry) {
              entry.paused = true;
              idsWithSelectors.push(entry.target);
            }
          }
        }

        for (i = 0; i < this._updatesPosList.length; i++) {
          entry = this._updatesPosList[i];

          if (entry) {
            if (entry.priority >= minPriority) {
              entry.paused = true;
              idsWithSelectors.push(entry.target);
            }
          }
        }

        return idsWithSelectors;
      }
      /**
       * @en
       * Resume selectors on a set of targets.<br/>
       * This can be useful for undoing a call to pauseAllCallbacks.
       * @zh
       * 恢复指定数组中所有对象的定时器。<br/>
       * 这个函数是 pauseAllCallbacks 的逆操作。
       * @param {Array} targetsToResume
       */

    }, {
      key: "resumeTargets",
      value: function resumeTargets(targetsToResume) {
        if (!targetsToResume) {
          return;
        } // tslint:disable-next-line: prefer-for-of


        for (var i = 0; i < targetsToResume.length; i++) {
          this.resumeTarget(targetsToResume[i]);
        }
      }
      /**
       * @en
       * Pauses the target.<br/>
       * All scheduled selectors/update for a given target won't be 'ticked' until the target is resumed.<br/>
       * If the target is not present, nothing happens.
       * @zh
       * 暂停指定对象的定时器。<br/>
       * 指定对象的所有定时器都会被暂停。<br/>
       * 如果指定的对象没有定时器，什么也不会发生。
       * @param {Object} target
       */

    }, {
      key: "pauseTarget",
      value: function pauseTarget(target) {
        cc.assertID(target, 1503);
        var targetId = target.uuid || target.id;

        if (!targetId) {
          cc.errorID(1510);
          return;
        } // customer selectors


        var self = this;
        var element = self._hashForTimers[targetId];

        if (element) {
          element.paused = true;
        } // update callback


        var elementUpdate = self._hashForUpdates[targetId];

        if (elementUpdate) {
          elementUpdate.entry.paused = true;
        }
      }
      /**
       * @en
       * Resumes the target.<br/>
       * The 'target' will be unpaused, so all schedule selectors/update will be 'ticked' again.<br/>
       * If the target is not present, nothing happens.
       * @zh
       * 恢复指定对象的所有定时器。<br/>
       * 指定对象的所有定时器将继续工作。<br/>
       * 如果指定的对象没有定时器，什么也不会发生。
       * @param {Object} target
       */

    }, {
      key: "resumeTarget",
      value: function resumeTarget(target) {
        cc.assertID(target, 1504);
        var targetId = target.uuid || target.id;

        if (!targetId) {
          cc.errorID(1510);
          return;
        } // custom selectors


        var self = this;
        var element = self._hashForTimers[targetId];

        if (element) {
          element.paused = false;
        } // update callback


        var elementUpdate = self._hashForUpdates[targetId];

        if (elementUpdate) {
          elementUpdate.entry.paused = false;
        }
      }
      /**
       * @en Returns whether or not the target is paused.
       * @zh 返回指定对象的定时器是否处于暂停状态。
       * @param {Object} target
       * @return {Boolean}
       */

    }, {
      key: "isTargetPaused",
      value: function isTargetPaused(target) {
        cc.assertID(target, 1505);
        var targetId = target.uuid || target.id;

        if (!targetId) {
          cc.errorID(1510);
          return false;
        } // Custom selectors


        var element = this._hashForTimers[targetId];

        if (element) {
          return element.paused;
        }

        var elementUpdate = this._hashForUpdates[targetId];

        if (elementUpdate) {
          return elementUpdate.entry.paused;
        }

        return false;
      } // -----------------------private method----------------------

    }, {
      key: "_removeHashElement",
      value: function _removeHashElement(element) {
        var targetId = element.target.uuid || element.target.id;
        delete this._hashForTimers[targetId];
        var arr = this._arrayForTimers;

        for (var i = 0, l = arr.length; i < l; i++) {
          if (arr[i] === element) {
            arr.splice(i, 1);
            break;
          }
        }

        HashTimerEntry.put(element);
      }
    }, {
      key: "_removeUpdateFromHash",
      value: function _removeUpdateFromHash(entry) {
        var targetId = entry.target.uuid || entry.target.id;
        var self = this;
        var element = self._hashForUpdates[targetId];

        if (element) {
          // Remove list entry from list
          var list = element.list;
          var listEntry = element.entry;

          for (var i = 0, l = list.length; i < l; i++) {
            if (list[i] === listEntry) {
              list.splice(i, 1);
              break;
            }
          }

          delete self._hashForUpdates[targetId];
          ListEntry.put(listEntry);
          HashUpdateEntry.put(element);
        }
      }
    }, {
      key: "_priorityIn",
      value: function _priorityIn(ppList, listElement, priority) {
        for (var i = 0; i < ppList.length; i++) {
          if (priority < ppList[i].priority) {
            ppList.splice(i, 0, listElement);
            return;
          }
        }

        ppList.push(listElement);
      }
    }, {
      key: "_appendIn",
      value: function _appendIn(ppList, listElement) {
        ppList.push(listElement);
      }
    }]);

    return Scheduler;
  }(_system.default);

  _exports.Scheduler = Scheduler;
  Scheduler.PRIORITY_SYSTEM = 1 << 31;
  Scheduler.PRIORITY_NON_SYSTEM = Scheduler.PRIORITY_SYSTEM + 1;
  Scheduler.ID = 'scheduler';
  cc.Scheduler = Scheduler;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkY6L2plbmtpbnMvd29ya3NwYWNlL0NyZWF0b3JfM0QvZWRpdG9yLTNkL3Jlc291cmNlcy8zZC9lbmdpbmUvY29jb3MvY29yZS9zY2hlZHVsZXIudHMiXSwibmFtZXMiOlsiTUFYX1BPT0xfU0laRSIsImlkR2VuZXJhdG9yIiwiSWRHZW5lcmF0b3IiLCJMaXN0RW50cnkiLCJ0YXJnZXQiLCJwcmlvcml0eSIsInBhdXNlZCIsIm1hcmtlZEZvckRlbGV0aW9uIiwiZ2V0IiwicmVzdWx0IiwiX2xpc3RFbnRyaWVzIiwicG9wIiwicHV0IiwiZW50cnkiLCJsZW5ndGgiLCJwdXNoIiwiSGFzaFVwZGF0ZUVudHJ5IiwibGlzdCIsImNhbGxiYWNrIiwiX2hhc2hVcGRhdGVFbnRyaWVzIiwiSGFzaFRpbWVyRW50cnkiLCJ0aW1lcnMiLCJ0aW1lckluZGV4IiwiY3VycmVudFRpbWVyIiwiY3VycmVudFRpbWVyU2FsdmFnZWQiLCJfaGFzaFRpbWVyRW50cmllcyIsIkNhbGxiYWNrVGltZXIiLCJfbG9jayIsIl9zY2hlZHVsZXIiLCJfZWxhcHNlZCIsIl9ydW5Gb3JldmVyIiwiX3VzZURlbGF5IiwiX3RpbWVzRXhlY3V0ZWQiLCJfcmVwZWF0IiwiX2RlbGF5IiwiX2ludGVydmFsIiwiX3RhcmdldCIsIl9jYWxsYmFjayIsInNjaGVkdWxlciIsInNlY29uZHMiLCJyZXBlYXQiLCJkZWxheSIsImNjIiwibWFjcm8iLCJSRVBFQVRfRk9SRVZFUiIsImludGVydmFsIiwiZHQiLCJ0cmlnZ2VyIiwiY2FuY2VsIiwiY2FsbCIsInVuc2NoZWR1bGUiLCJfdGltZXJzIiwidGltZXIiLCJTY2hlZHVsZXIiLCJmb3VuZCIsInV1aWQiLCJpZCIsIl9faW5zdGFuY2VJZCIsIndhcm5JRCIsImdldE5ld0lkIiwiX3RpbWVTY2FsZSIsIl91cGRhdGVzTmVnTGlzdCIsIl91cGRhdGVzMExpc3QiLCJfdXBkYXRlc1Bvc0xpc3QiLCJfaGFzaEZvclVwZGF0ZXMiLCJfaGFzaEZvclRpbWVycyIsIl9jdXJyZW50VGFyZ2V0IiwiX2N1cnJlbnRUYXJnZXRTYWx2YWdlZCIsIl91cGRhdGVIYXNoTG9ja2VkIiwiX2FycmF5Rm9yVGltZXJzIiwidGltZVNjYWxlIiwiaSIsImxlbiIsInVwZGF0ZSIsImVsdCIsImFyciIsIl9yZW1vdmVIYXNoRWxlbWVudCIsIl9yZW1vdmVVcGRhdGVGcm9tSGFzaCIsInRtcCIsImFyZ3VtZW50cyIsImFzc2VydElEIiwidGFyZ2V0SWQiLCJlcnJvcklEIiwiZWxlbWVudCIsImxvZ0lEIiwiZ2V0SW50ZXJ2YWwiLCJpbml0V2l0aENhbGxiYWNrIiwiaGFzaEVsZW1lbnQiLCJ1bnNjaGVkdWxlVXBkYXRlIiwibGlzdEVsZW1lbnQiLCJwcExpc3QiLCJfYXBwZW5kSW4iLCJfcHJpb3JpdHlJbiIsInNlbGYiLCJsaSIsInNwbGljZSIsImluZGV4T2YiLCJsIiwidW5zY2hlZHVsZUFsbFdpdGhNaW5Qcmlvcml0eSIsIlBSSU9SSVRZX1NZU1RFTSIsIm1pblByaW9yaXR5IiwidW5zY2hlZHVsZUFsbEZvclRhcmdldCIsInRlbXBfbGVuZ3RoIiwicGF1c2VBbGxUYXJnZXRzV2l0aE1pblByaW9yaXR5IiwiaWRzV2l0aFNlbGVjdG9ycyIsImxvY0FycmF5Rm9yVGltZXJzIiwidGFyZ2V0c1RvUmVzdW1lIiwicmVzdW1lVGFyZ2V0IiwiZWxlbWVudFVwZGF0ZSIsImxpc3RFbnRyeSIsIlN5c3RlbSIsIlBSSU9SSVRZX05PTl9TWVNURU0iLCJJRCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUNBLE1BQU1BLGFBQWEsR0FBRyxFQUF0QjtBQUVBLE1BQU1DLFdBQVcsR0FBRyxJQUFJQyxvQkFBSixDQUFnQixXQUFoQixDQUFwQjs7QUFPQTs7QUFDQTs7Ozs7Ozs7O01BU01DLFMsR0E4QkYsbUJBQWFDLE1BQWIsRUFBbUNDLFFBQW5DLEVBQXFEQyxNQUFyRCxFQUFzRUMsaUJBQXRFLEVBQWtHO0FBQUE7O0FBQUEsU0FMM0ZI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IENvcHlyaWdodCAoYykgMjAxMy0yMDE2IENodWtvbmcgVGVjaG5vbG9naWVzIEluYy5cclxuIENvcHlyaWdodCAoYykgMjAxNy0yMDE4IFhpYW1lbiBZYWppIFNvZnR3YXJlIENvLiwgTHRkLlxyXG5cclxuIGh0dHA6Ly93d3cuY29jb3MuY29tXHJcblxyXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxyXG4gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBlbmdpbmUgc291cmNlIGNvZGUgKHRoZSBcIlNvZnR3YXJlXCIpLCBhIGxpbWl0ZWQsXHJcbiAgd29ybGR3aWRlLCByb3lhbHR5LWZyZWUsIG5vbi1hc3NpZ25hYmxlLCByZXZvY2FibGUgYW5kIG5vbi1leGNsdXNpdmUgbGljZW5zZVxyXG4gdG8gdXNlIENvY29zIENyZWF0b3Igc29sZWx5IHRvIGRldmVsb3AgZ2FtZXMgb24geW91ciB0YXJnZXQgcGxhdGZvcm1zLiBZb3Ugc2hhbGxcclxuICBub3QgdXNlIENvY29zIENyZWF0b3Igc29mdHdhcmUgZm9yIGRldmVsb3Bpbmcgb3RoZXIgc29mdHdhcmUgb3IgdG9vbHMgdGhhdCdzXHJcbiAgdXNlZCBmb3IgZGV2ZWxvcGluZyBnYW1lcy4gWW91IGFyZSBub3QgZ3JhbnRlZCB0byBwdWJsaXNoLCBkaXN0cmlidXRlLFxyXG4gIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiBDb2NvcyBDcmVhdG9yLlxyXG5cclxuIFRoZSBzb2Z0d2FyZSBvciB0b29scyBpbiB0aGlzIExpY2Vuc2UgQWdyZWVtZW50IGFyZSBsaWNlbnNlZCwgbm90IHNvbGQuXHJcbiBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC4gcmVzZXJ2ZXMgYWxsIHJpZ2h0cyBub3QgZXhwcmVzc2x5IGdyYW50ZWQgdG8geW91LlxyXG5cclxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcclxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxyXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXHJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxyXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxyXG4gVEhFIFNPRlRXQVJFLlxyXG4qL1xyXG4vKipcclxuICogQGNhdGVnb3J5IGNvcmVcclxuICovXHJcblxyXG5pbXBvcnQgSWRHZW5lcmF0b3IgZnJvbSAnLi91dGlscy9pZC1nZW5lcmF0b3InO1xyXG5pbXBvcnQge2NyZWF0ZU1hcH0gZnJvbSAnLi91dGlscy9qcyc7XHJcbmltcG9ydCBTeXN0ZW0gZnJvbSAnLi9jb21wb25lbnRzL3N5c3RlbSc7XHJcblxyXG5jb25zdCBNQVhfUE9PTF9TSVpFID0gMjA7XHJcblxyXG5jb25zdCBpZEdlbmVyYXRvciA9IG5ldyBJZEdlbmVyYXRvcignU2NoZWR1bGVyJyk7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElTY2hlZHVsYWJsZSB7XHJcbiAgICBpZD86c3RyaW5nO1xyXG4gICAgdXVpZD86c3RyaW5nO1xyXG59XHJcblxyXG4vLyBkYXRhIHN0cnVjdHVyZXNcclxuLyoqXHJcbiAqIEBlbiBBIGxpc3QgZG91YmxlLWxpbmtlZCBsaXN0IHVzZWQgZm9yIFwidXBkYXRlcyB3aXRoIHByaW9yaXR5XCJcclxuICogQHpoIOeUqOS6juKAnOS8mOWFiOabtOaWsOKAneeahOWIl+ihqFxyXG4gKiBAY2xhc3MgTGlzdEVudHJ5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgbm90IHJldGFpbmVkIChyZXRhaW5lZCBieSBoYXNoVXBkYXRlRW50cnkpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmlvcml0eVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHBhdXNlZFxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG1hcmtlZEZvckRlbGV0aW9uIHNlbGVjdG9yIHdpbGwgbm8gbG9uZ2VyIGJlIGNhbGxlZCBhbmQgZW50cnkgd2lsbCBiZSByZW1vdmVkIGF0IGVuZCBvZiB0aGUgbmV4dCB0aWNrXHJcbiAqL1xyXG5jbGFzcyBMaXN0RW50cnkge1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0ID0gKHRhcmdldDogSVNjaGVkdWxhYmxlLCBwcmlvcml0eTogTnVtYmVyLCBwYXVzZWQ6IEJvb2xlYW4sIG1hcmtlZEZvckRlbGV0aW9uOiBCb29sZWFuKSA9PiB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IExpc3RFbnRyeS5fbGlzdEVudHJpZXMucG9wKCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXN1bHQudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICByZXN1bHQucHJpb3JpdHkgPSBwcmlvcml0eTtcclxuICAgICAgICAgICAgcmVzdWx0LnBhdXNlZCA9IHBhdXNlZDtcclxuICAgICAgICAgICAgcmVzdWx0Lm1hcmtlZEZvckRlbGV0aW9uID0gbWFya2VkRm9yRGVsZXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgTGlzdEVudHJ5KHRhcmdldCwgcHJpb3JpdHksIHBhdXNlZCwgbWFya2VkRm9yRGVsZXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcHV0ID0gKGVudHJ5KSA9PiB7XHJcbiAgICAgICAgaWYgKExpc3RFbnRyeS5fbGlzdEVudHJpZXMubGVuZ3RoIDwgTUFYX1BPT0xfU0laRSkge1xyXG4gICAgICAgICAgICBlbnRyeS50YXJnZXQgPSBudWxsO1xyXG4gICAgICAgICAgICBMaXN0RW50cnkuX2xpc3RFbnRyaWVzLnB1c2goZW50cnkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfbGlzdEVudHJpZXM6IGFueSA9IFtdO1xyXG5cclxuICAgIHB1YmxpYyB0YXJnZXQ6IElTY2hlZHVsYWJsZTtcclxuICAgIHB1YmxpYyBwcmlvcml0eTogTnVtYmVyO1xyXG4gICAgcHVibGljIHBhdXNlZDogQm9vbGVhbjtcclxuICAgIHB1YmxpYyBtYXJrZWRGb3JEZWxldGlvbjogQm9vbGVhbjtcclxuXHJcbiAgICBjb25zdHJ1Y3RvciAodGFyZ2V0OiBJU2NoZWR1bGFibGUsIHByaW9yaXR5OiBOdW1iZXIsIHBhdXNlZDogQm9vbGVhbiwgbWFya2VkRm9yRGVsZXRpb246IEJvb2xlYW4pIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XHJcbiAgICAgICAgdGhpcy5wYXVzZWQgPSBwYXVzZWQ7XHJcbiAgICAgICAgdGhpcy5tYXJrZWRGb3JEZWxldGlvbiA9IG1hcmtlZEZvckRlbGV0aW9uO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQGVuIEEgdXBkYXRlIGVudHJ5IGxpc3RcclxuICogQHpoIOabtOaWsOadoeebruWIl+ihqFxyXG4gKiBAY2xhc3MgSGFzaFVwZGF0ZUVudHJ5XHJcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgV2hpY2ggbGlzdCBkb2VzIGl0IGJlbG9uZyB0byA/XHJcbiAqIEBwYXJhbSB7TGlzdEVudHJ5fSBlbnRyeSBlbnRyeSBpbiB0aGUgbGlzdFxyXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IGhhc2gga2V5IChyZXRhaW5lZClcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcclxuICovXHJcbmNsYXNzIEhhc2hVcGRhdGVFbnRyeSB7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgPSAobGlzdDogYW55LCBlbnRyeTogTGlzdEVudHJ5LCB0YXJnZXQ6IElTY2hlZHVsYWJsZSwgY2FsbGJhY2s6IGFueSkgPT4ge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBIYXNoVXBkYXRlRW50cnkuX2hhc2hVcGRhdGVFbnRyaWVzLnBvcCgpO1xyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmVzdWx0Lmxpc3QgPSBsaXN0O1xyXG4gICAgICAgICAgICByZXN1bHQuZW50cnkgPSBlbnRyeTtcclxuICAgICAgICAgICAgcmVzdWx0LnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmVzdWx0LmNhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgSGFzaFVwZGF0ZUVudHJ5KGxpc3QsIGVudHJ5LCB0YXJnZXQsIGNhbGxiYWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHB1dCA9IChlbnRyeSkgPT4ge1xyXG4gICAgICAgIGlmIChIYXNoVXBkYXRlRW50cnkuX2hhc2hVcGRhdGVFbnRyaWVzLmxlbmd0aCA8IE1BWF9QT09MX1NJWkUpIHtcclxuICAgICAgICAgICAgZW50cnkubGlzdCA9IGVudHJ5LmVudHJ5ID0gZW50cnkudGFyZ2V0ID0gZW50cnkuY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICBIYXNoVXBkYXRlRW50cnkuX2hhc2hVcGRhdGVFbnRyaWVzLnB1c2goZW50cnkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfaGFzaFVwZGF0ZUVudHJpZXM6IGFueSA9IFtdO1xyXG5cclxuICAgIHB1YmxpYyBsaXN0OiBhbnk7XHJcbiAgICBwdWJsaWMgZW50cnk6IExpc3RFbnRyeTtcclxuICAgIHB1YmxpYyB0YXJnZXQ6IElTY2hlZHVsYWJsZTtcclxuICAgIHB1YmxpYyBjYWxsYmFjazogYW55O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yIChsaXN0OiBhbnksIGVudHJ5OiBMaXN0RW50cnksIHRhcmdldDogSVNjaGVkdWxhYmxlLCBjYWxsYmFjazogYW55KSB7XHJcbiAgICAgICAgdGhpcy5saXN0ID0gbGlzdDtcclxuICAgICAgICB0aGlzLmVudHJ5ID0gZW50cnk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogQGVuIEhhc2ggRWxlbWVudCB1c2VkIGZvciBcInNlbGVjdG9ycyB3aXRoIGludGVydmFsXCJcclxuICogQHpoIOKAnOeUqOS6jumXtOmalOmAieaLqeKAneeahOWTiOW4jOWFg+e0oFxyXG4gKiBAY2xhc3MgSGFzaFRpbWVyRW50cnlcclxuICogQHBhcmFtIHtBcnJheX0gdGltZXJzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgIGhhc2gga2V5IChyZXRhaW5lZClcclxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVySW5kZXhcclxuICogQHBhcmFtIHtUaW1lcn0gY3VycmVudFRpbWVyXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY3VycmVudFRpbWVyU2FsdmFnZWRcclxuICogQHBhcmFtIHtCb29sZWFufSBwYXVzZWRcclxuICovXHJcbmNsYXNzIEhhc2hUaW1lckVudHJ5IHtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldCA9ICh0aW1lcnM6IGFueSwgdGFyZ2V0OiBJU2NoZWR1bGFibGUsIHRpbWVySW5kZXg6IE51bWJlciwgY3VycmVudFRpbWVyOiBhbnksIGN1cnJlbnRUaW1lclNhbHZhZ2VkOiBhbnksIHBhdXNlZDogYW55KSA9PiB7XHJcbiAgICAgICAgbGV0IHJlc3VsdCA9IEhhc2hUaW1lckVudHJ5Ll9oYXNoVGltZXJFbnRyaWVzLnBvcCgpO1xyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnRpbWVycyA9IHRpbWVycztcclxuICAgICAgICAgICAgcmVzdWx0LnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgcmVzdWx0LnRpbWVySW5kZXggPSB0aW1lckluZGV4O1xyXG4gICAgICAgICAgICByZXN1bHQuY3VycmVudFRpbWVyID0gY3VycmVudFRpbWVyO1xyXG4gICAgICAgICAgICByZXN1bHQuY3VycmVudFRpbWVyU2FsdmFnZWQgPSBjdXJyZW50VGltZXJTYWx2YWdlZDtcclxuICAgICAgICAgICAgcmVzdWx0LnBhdXNlZCA9IHBhdXNlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBIYXNoVGltZXJFbnRyeSh0aW1lcnMsIHRhcmdldCwgdGltZXJJbmRleCwgY3VycmVudFRpbWVyLCBjdXJyZW50VGltZXJTYWx2YWdlZCwgcGF1c2VkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHB1dCA9IChlbnRyeSkgPT4ge1xyXG4gICAgICAgIGlmIChIYXNoVGltZXJFbnRyeS5faGFzaFRpbWVyRW50cmllcy5sZW5ndGggPCBNQVhfUE9PTF9TSVpFKSB7XHJcbiAgICAgICAgICAgIGVudHJ5LnRpbWVycyA9IGVudHJ5LnRhcmdldCA9IGVudHJ5LmN1cnJlbnRUaW1lciA9IG51bGw7XHJcbiAgICAgICAgICAgIEhhc2hUaW1lckVudHJ5Ll9oYXNoVGltZXJFbnRyaWVzLnB1c2goZW50cnkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBfaGFzaFRpbWVyRW50cmllczogYW55ID0gW107XHJcblxyXG4gICAgcHVibGljIHRpbWVyczogYW55O1xyXG4gICAgcHVibGljIHRhcmdldDogSVNjaGVkdWxhYmxlO1xyXG4gICAgcHVibGljIHRpbWVySW5kZXg6IE51bWJlcjtcclxuICAgIHB1YmxpYyBjdXJyZW50VGltZXI6IGFueTtcclxuICAgIHB1YmxpYyBjdXJyZW50VGltZXJTYWx2YWdlZDogYW55O1xyXG4gICAgcHVibGljIHBhdXNlZDogYW55O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yICh0aW1lcnM6IGFueSwgdGFyZ2V0OiBJU2NoZWR1bGFibGUsIHRpbWVySW5kZXg6IE51bWJlciwgY3VycmVudFRpbWVyOiBhbnksIGN1cnJlbnRUaW1lclNhbHZhZ2VkOiBhbnksIHBhdXNlZDogYW55KXtcclxuICAgICAgICB0aGlzLnRpbWVycyA9IHRpbWVycztcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLnRpbWVySW5kZXggPSB0aW1lckluZGV4O1xyXG4gICAgICAgIHRoaXMuY3VycmVudFRpbWVyID0gY3VycmVudFRpbWVyO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFRpbWVyU2FsdmFnZWQgPSBjdXJyZW50VGltZXJTYWx2YWdlZDtcclxuICAgICAgICB0aGlzLnBhdXNlZCA9IHBhdXNlZDtcclxuICAgIH1cclxufVxyXG5cclxuLypcclxuICogTGlnaHQgd2VpZ2h0IHRpbWVyXHJcbiAqL1xyXG5jbGFzcyBDYWxsYmFja1RpbWVyIHtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIF90aW1lcnM6IGFueSA9IFtdO1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXQgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gQ2FsbGJhY2tUaW1lci5fdGltZXJzLnBvcCgpIHx8IG5ldyBDYWxsYmFja1RpbWVyKCk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc3RhdGljIHB1dCA9ICh0aW1lcikgPT4ge1xyXG4gICAgICAgIGlmIChDYWxsYmFja1RpbWVyLl90aW1lcnMubGVuZ3RoIDwgTUFYX1BPT0xfU0laRSAmJiAhdGltZXIuX2xvY2spIHtcclxuICAgICAgICAgICAgdGltZXIuX3NjaGVkdWxlciA9IHRpbWVyLl90YXJnZXQgPSB0aW1lci5fY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgICAgICAgICBDYWxsYmFja1RpbWVyLl90aW1lcnMucHVzaCh0aW1lcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX2xvY2s6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF9zY2hlZHVsZXI6IGFueTtcclxuICAgIHByaXZhdGUgX2VsYXBzZWQ6IG51bWJlcjtcclxuICAgIHByaXZhdGUgX3J1bkZvcmV2ZXI6IGJvb2xlYW47XHJcbiAgICBwcml2YXRlIF91c2VEZWxheTogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgX3RpbWVzRXhlY3V0ZWQ6IG51bWJlcjtcclxuICAgIHByaXZhdGUgX3JlcGVhdDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBfZGVsYXk6IG51bWJlcjtcclxuICAgIHByaXZhdGUgIF9pbnRlcnZhbDogbnVtYmVyO1xyXG4gICAgcHJpdmF0ZSBfdGFyZ2V0OiBJU2NoZWR1bGFibGUgfCBudWxsO1xyXG4gICAgcHJpdmF0ZSBfY2FsbGJhY2s6IGFueTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvciAoKSB7XHJcbiAgICAgICAgdGhpcy5fbG9jayA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3NjaGVkdWxlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZWxhcHNlZCA9IC0xO1xyXG4gICAgICAgIHRoaXMuX3J1bkZvcmV2ZXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl91c2VEZWxheSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3RpbWVzRXhlY3V0ZWQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3JlcGVhdCA9IDA7XHJcbiAgICAgICAgdGhpcy5fZGVsYXkgPSAwO1xyXG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGluaXRXaXRoQ2FsbGJhY2sgKHNjaGVkdWxlcjogYW55LCBjYWxsYmFjazogYW55LCB0YXJnZXQ6IElTY2hlZHVsYWJsZSwgc2Vjb25kczogbnVtYmVyLCByZXBlYXQ6IG51bWJlciwgZGVsYXk6IG51bWJlcikge1xyXG4gICAgICAgIHRoaXMuX2xvY2sgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XHJcblxyXG4gICAgICAgIHRoaXMuX2VsYXBzZWQgPSAtMTtcclxuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IHNlY29uZHM7XHJcbiAgICAgICAgdGhpcy5fZGVsYXkgPSBkZWxheTtcclxuICAgICAgICB0aGlzLl91c2VEZWxheSA9ICh0aGlzLl9kZWxheSA+IDApO1xyXG4gICAgICAgIHRoaXMuX3JlcGVhdCA9IHJlcGVhdDtcclxuICAgICAgICB0aGlzLl9ydW5Gb3JldmVyID0gKHRoaXMuX3JlcGVhdCA9PT0gY2MubWFjcm8uUkVQRUFUX0ZPUkVWRVIpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHJldHVybnMgaW50ZXJ2YWwgb2YgdGltZXJcclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldEludGVydmFsICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJ2YWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbCBzZXQgaW50ZXJ2YWwgaW4gc2Vjb25kc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0SW50ZXJ2YWwgKGludGVydmFsKSB7XHJcbiAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBpbnRlcnZhbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRyaWdnZXJzIHRoZSB0aW1lclxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGR0IGRlbHRhIHRpbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZSAoZHQ6IG51bWJlcikge1xyXG4gICAgICAgIGlmICh0aGlzLl9lbGFwc2VkID09PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbGFwc2VkID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fdGltZXNFeGVjdXRlZCA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZCArPSBkdDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3J1bkZvcmV2ZXIgJiYgIXRoaXMuX3VzZURlbGF5KSB7Ly8gc3RhbmRhcmQgdGltZXIgdXNhZ2VcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbGFwc2VkID49IHRoaXMuX2ludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxhcHNlZCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7Ly8gYWR2YW5jZWQgdXNhZ2VcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl91c2VEZWxheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbGFwc2VkID49IHRoaXMuX2RlbGF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxhcHNlZCAtPSB0aGlzLl9kZWxheTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZXNFeGVjdXRlZCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl91c2VEZWxheSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VsYXBzZWQgPj0gdGhpcy5faW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGFwc2VkID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGltZXNFeGVjdXRlZCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FsbGJhY2sgJiYgIXRoaXMuX3J1bkZvcmV2ZXIgJiYgdGhpcy5fdGltZXNFeGVjdXRlZCA+IHRoaXMuX3JlcGVhdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldENhbGxiYWNrICgpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsYmFjaztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdHJpZ2dlciAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RhcmdldCAmJiB0aGlzLl9jYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2NrID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2suY2FsbCh0aGlzLl90YXJnZXQsIHRoaXMuX2VsYXBzZWQpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2NrID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjYW5jZWwgKCkge1xyXG4gICAgICAgIC8vIG92ZXJyaWRlXHJcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVyLnVuc2NoZWR1bGUodGhpcy5fY2FsbGJhY2ssIHRoaXMuX3RhcmdldCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAZW5cclxuICogU2NoZWR1bGVyIGlzIHJlc3BvbnNpYmxlIG9mIHRyaWdnZXJpbmcgdGhlIHNjaGVkdWxlZCBjYWxsYmFja3MuPGJyPlxyXG4gKiBZb3Ugc2hvdWxkIG5vdCB1c2UgTlNUaW1lci4gSW5zdGVhZCB1c2UgdGhpcyBjbGFzcy48YnI+XHJcbiAqIDxicj5cclxuICogVGhlcmUgYXJlIDIgZGlmZmVyZW50IHR5cGVzIG9mIGNhbGxiYWNrcyAoc2VsZWN0b3JzKTo8YnI+XHJcbiAqICAgICAtIHVwZGF0ZSBjYWxsYmFjazogdGhlICd1cGRhdGUnIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGV2ZXJ5IGZyYW1lLiBZb3UgY2FuIGN1c3RvbWl6ZSB0aGUgcHJpb3JpdHkuPGJyPlxyXG4gKiAgICAgLSBjdXN0b20gY2FsbGJhY2s6IEEgY3VzdG9tIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGV2ZXJ5IGZyYW1lLCBvciB3aXRoIGEgY3VzdG9tIGludGVydmFsIG9mIHRpbWU8YnI+XHJcbiAqIDxicj5cclxuICogVGhlICdjdXN0b20gc2VsZWN0b3JzJyBzaG91bGQgYmUgYXZvaWRlZCB3aGVuIHBvc3NpYmxlLiBJdCBpcyBmYXN0ZXIsPGJyPlxyXG4gKiBhbmQgY29uc3VtZXMgbGVzcyBtZW1vcnkgdG8gdXNlIHRoZSAndXBkYXRlIGNhbGxiYWNrJy4gKlxyXG4gKiBAemhcclxuICogU2NoZWR1bGVyIOaYr+i0n+i0o+inpuWPkeWbnuiwg+WHveaVsOeahOexu+OAgjxicj5cclxuICog6YCa5bi45oOF5Ya15LiL77yM5bu66K6u5L2/55SoIGNjLmRpcmVjdG9yLmdldFNjaGVkdWxlcigpIOadpeiOt+WPluezu+e7n+WumuaXtuWZqOOAgjxicj5cclxuICog5pyJ5Lik56eN5LiN5ZCM57G75Z6L55qE5a6a5pe25Zmo77yaPGJyPlxyXG4gKiAgICAgLSB1cGRhdGUg5a6a5pe25Zmo77ya5q+P5LiA5bin6YO95Lya6Kem5Y+R44CC5oKo5Y+v5Lul6Ieq5a6a5LmJ5LyY5YWI57qn44CCPGJyPlxyXG4gKiAgICAgLSDoh6rlrprkuYnlrprml7blmajvvJroh6rlrprkuYnlrprml7blmajlj6/ku6Xmr4/kuIDluKfmiJbogIXoh6rlrprkuYnnmoTml7bpl7Tpl7TpmpTop6blj5HjgII8YnI+XHJcbiAqIOWmguaenOW4jOacm+avj+W4p+mDveinpuWPke+8jOW6lOivpeS9v+eUqCB1cGRhdGUg5a6a5pe25Zmo77yM5L2/55SoIHVwZGF0ZSDlrprml7blmajmm7Tlv6vvvIzogIzkuJTmtojogJfmm7TlsJHnmoTlhoXlrZjjgIJcclxuICpcclxuICogQGNsYXNzIFNjaGVkdWxlclxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNjaGVkdWxlciBleHRlbmRzIFN5c3RlbSB7XHJcbiAgICAvKipcclxuICAgICAqIEBlbiBQcmlvcml0eSBsZXZlbCByZXNlcnZlZCBmb3Igc3lzdGVtIHNlcnZpY2VzLlxyXG4gICAgICogQHpoIOezu+e7n+acjeWKoeeahOS8mOWFiOe6p+OAglxyXG4gICAgICogQHByb3BlcnR5IFBSSU9SSVRZX1NZU1RFTVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFBSSU9SSVRZX1NZU1RFTTogbnVtYmVyID0gMSA8PCAzMTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBNaW5pbXVtIHByaW9yaXR5IGxldmVsIGZvciB1c2VyIHNjaGVkdWxpbmcuXHJcbiAgICAgKiBAemgg55So5oi36LCD5bqm5pyA5L2O5LyY5YWI57qn44CCXHJcbiAgICAgKiBAcHJvcGVydHkgUFJJT1JJVFlfTk9OX1NZU1RFTVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIFBSSU9SSVRZX05PTl9TWVNURU06IG51bWJlciA9IFNjaGVkdWxlci5QUklPUklUWV9TWVNURU0gKyAxO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgSUQgPSAnc2NoZWR1bGVyJztcclxuXHJcbiAgICBwcml2YXRlIF90aW1lU2NhbGU6IG51bWJlcjtcclxuICAgIHByaXZhdGUgX3VwZGF0ZXNOZWdMaXN0OiBhbnlbXTtcclxuICAgIHByaXZhdGUgX3VwZGF0ZXMwTGlzdDogYW55W107XHJcbiAgICBwcml2YXRlIF91cGRhdGVzUG9zTGlzdDogYW55W107XHJcbiAgICBwcml2YXRlIF9oYXNoRm9yVXBkYXRlczogYW55O1xyXG4gICAgcHJpdmF0ZSBfaGFzaEZvclRpbWVyczogYW55O1xyXG4gICAgcHJpdmF0ZSBfY3VycmVudFRhcmdldDogYW55O1xyXG4gICAgcHJpdmF0ZSBfY3VycmVudFRhcmdldFNhbHZhZ2VkOiBib29sZWFuO1xyXG4gICAgcHJpdmF0ZSBfdXBkYXRlSGFzaExvY2tlZDogYm9vbGVhbjtcclxuICAgIHByaXZhdGUgX2FycmF5Rm9yVGltZXJzO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgZm9yIGFueSB0YXJnZXQgd2hpY2ggbmVlZHMgdG8gc2NoZWR1bGUgdGFza3MsIGFuZCB0aGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBhbnkgc2NoZWR1bGVyIEFQSSB1c2FnZS48Ymc+XHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFkZCBhIGBpZGAgcHJvcGVydHkgaWYgaXQgZG9lc24ndCBleGlzdC5cclxuICAgICAqIEB6aCDku7vkvZXpnIDopoHnlKggU2NoZWR1bGVyIOeuoeeQhuS7u+WKoeeahOWvueixoeS4u+S9k+mDveW6lOivpeiwg+eUqOi/meS4quaWueazle+8jOW5tuS4lOW6lOivpeWcqOiwg+eUqOS7u+S9lSBTY2hlZHVsZXIgQVBJIOS5i+WJjeiwg+eUqOi/meS4quaWueazleOAgjxiZz5cclxuICAgICAqIOi/meS4quaWueazleS8mue7meWvueixoea3u+WKoOS4gOS4qiBgaWRgIOWxnuaAp++8jOWmguaenOi/meS4quWxnuaAp+S4jeWtmOWcqOeahOivneOAglxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc3RhdGljIGVuYWJsZUZvclRhcmdldCAodGFyZ2V0OiBJU2NoZWR1bGFibGUpIHtcclxuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGFyZ2V0LnV1aWQpIHtcclxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0YXJnZXQuaWQpIHtcclxuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWZvdW5kKSB7XHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgaWYgKHRhcmdldC5fX2luc3RhbmNlSWQpIHtcclxuICAgICAgICAgICAgICAgIGNjLndhcm5JRCgxNTEzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5pZCA9IGlkR2VuZXJhdG9yLmdldE5ld0lkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3RydWN0b3IgKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdGltZVNjYWxlID0gMS4wO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZXNOZWdMaXN0ID0gW107ICAvLyBsaXN0IG9mIHByaW9yaXR5IDwgMFxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZXMwTGlzdCA9IFtdOyAgICAvLyBsaXN0IG9mIHByaW9yaXR5ID09IDBcclxuICAgICAgICB0aGlzLl91cGRhdGVzUG9zTGlzdCA9IFtdOyAgLy8gbGlzdCBvZiBwcmlvcml0eSA+IDBcclxuICAgICAgICB0aGlzLl9oYXNoRm9yVXBkYXRlcyA9IGNyZWF0ZU1hcCh0cnVlKTsgIC8vIGhhc2ggdXNlZCB0byBmZXRjaCBxdWlja2x5IHRoZSBsaXN0IGVudHJpZXMgZm9yIHBhdXNlLCBkZWxldGUsIGV0Y1xyXG4gICAgICAgIHRoaXMuX2hhc2hGb3JUaW1lcnMgPSBjcmVhdGVNYXAodHJ1ZSk7ICAgLy8gVXNlZCBmb3IgXCJzZWxlY3RvcnMgd2l0aCBpbnRlcnZhbFwiXHJcbiAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldFNhbHZhZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlSGFzaExvY2tlZCA9IGZhbHNlOyAvLyBJZiB0cnVlIHVuc2NoZWR1bGUgd2lsbCBub3QgcmVtb3ZlIGFueXRoaW5nIGZyb20gYSBoYXNoLiBFbGVtZW50cyB3aWxsIG9ubHkgYmUgbWFya2VkIGZvciBkZWxldGlvbi5cclxuXHJcbiAgICAgICAgdGhpcy5fYXJyYXlGb3JUaW1lcnMgPSBbXTsgIC8vIFNwZWVkIHVwIGluZGV4aW5nXHJcbiAgICAgICAgLy8gdGhpcy5fYXJyYXlGb3JVcGRhdGVzID0gW107ICAgLy8gU3BlZWQgdXAgaW5kZXhpbmdcclxuICAgIH1cclxuXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXB1YmxpYyBtZXRob2QtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIE1vZGlmaWVzIHRoZSB0aW1lIG9mIGFsbCBzY2hlZHVsZWQgY2FsbGJhY2tzLjxicj5cclxuICAgICAqIFlvdSBjYW4gdXNlIHRoaXMgcHJvcGVydHkgdG8gY3JlYXRlIGEgJ3Nsb3cgbW90aW9uJyBvciAnZmFzdCBmb3J3YXJkJyBlZmZlY3QuPGJyPlxyXG4gICAgICogRGVmYXVsdCBpcyAxLjAuIFRvIGNyZWF0ZSBhICdzbG93IG1vdGlvbicgZWZmZWN0LCB1c2UgdmFsdWVzIGJlbG93IDEuMC48YnI+XHJcbiAgICAgKiBUbyBjcmVhdGUgYSAnZmFzdCBmb3J3YXJkJyBlZmZlY3QsIHVzZSB2YWx1ZXMgaGlnaGVyIHRoYW4gMS4wLjxicj5cclxuICAgICAqIE5vdGXvvJpJdCB3aWxsIGFmZmVjdCBFVkVSWSBzY2hlZHVsZWQgc2VsZWN0b3IgLyBhY3Rpb24uXHJcbiAgICAgKiBAemhcclxuICAgICAqIOiuvue9ruaXtumXtOmXtOmalOeahOe8qeaUvuavlOS+i+OAgjxicj5cclxuICAgICAqIOaCqOWPr+S7peS9v+eUqOi/meS4quaWueazleadpeWIm+W7uuS4gOS4qiDigJxzbG93IG1vdGlvbu+8iOaFouWKqOS9nO+8ieKAnSDmiJYg4oCcZmFzdCBmb3J3YXJk77yI5b+r6L+b77yJ4oCdIOeahOaViOaenOOAgjxicj5cclxuICAgICAqIOm7mOiupOaYryAxLjDjgILopoHliJvlu7rkuIDkuKog4oCcc2xvdyBtb3Rpb27vvIjmhaLliqjkvZzvvInigJ0g5pWI5p6cLOS9v+eUqOWAvOS9juS6jiAxLjDjgII8YnI+XHJcbiAgICAgKiDopoHkvb/nlKgg4oCcZmFzdCBmb3J3YXJk77yI5b+r6L+b77yJ4oCdIOaViOaenO+8jOS9v+eUqOWAvOWkp+S6jiAxLjDjgII8YnI+XHJcbiAgICAgKiDms6jmhI/vvJrlroPlvbHlk43or6UgU2NoZWR1bGVyIOS4i+euoeeQhueahOaJgOacieWumuaXtuWZqOOAglxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVTY2FsZVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgc2V0VGltZVNjYWxlICh0aW1lU2NhbGUpIHtcclxuICAgICAgICB0aGlzLl90aW1lU2NhbGUgPSB0aW1lU2NhbGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gUmV0dXJucyB0aW1lIHNjYWxlIG9mIHNjaGVkdWxlci5cclxuICAgICAqIEB6aCDojrflj5bml7bpl7Tpl7TpmpTnmoTnvKnmlL7mr5TkvovjgIJcclxuICAgICAqIEByZXR1cm4ge051bWJlcn1cclxuICAgICAqL1xyXG4gICAgcHVibGljIGdldFRpbWVTY2FsZSAoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGltZVNjYWxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuICd1cGRhdGUnIHRoZSBzY2hlZHVsZXIuIChZb3Ugc2hvdWxkIE5FVkVSIGNhbGwgdGhpcyBtZXRob2QsIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuKVxyXG4gICAgICogQHpoIHVwZGF0ZSDosIPluqblh73mlbDjgIIo5LiN5bqU6K+l55u05o6l6LCD55So6L+Z5Liq5pa55rOV77yM6Zmk6Z2e5a6M5YWo5LqG6Kej6L+Z5LmI5YGa55qE57uT5p6cKVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGR0IGRlbHRhIHRpbWVcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVwZGF0ZSAoZHQpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVIYXNoTG9ja2VkID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5fdGltZVNjYWxlICE9PSAxKSB7XHJcbiAgICAgICAgICAgIGR0ICo9IHRoaXMuX3RpbWVTY2FsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBpOiBudW1iZXI7XHJcbiAgICAgICAgbGV0IGxpc3Q7XHJcbiAgICAgICAgbGV0IGxlbjogbnVtYmVyO1xyXG4gICAgICAgIGxldCBlbnRyeTtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMCwgbGlzdCA9IHRoaXMuX3VwZGF0ZXNOZWdMaXN0LCBsZW4gPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcclxuICAgICAgICAgICAgZW50cnkgPSBsaXN0W2ldO1xyXG4gICAgICAgICAgICBpZiAoIWVudHJ5LnBhdXNlZCAmJiAhZW50cnkubWFya2VkRm9yRGVsZXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGVudHJ5LnRhcmdldC51cGRhdGUoZHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKCBpID0gMCwgbGlzdCA9IHRoaXMuX3VwZGF0ZXMwTGlzdCwgbGVuID0gbGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XHJcbiAgICAgICAgICAgIGVudHJ5ID0gbGlzdFtpXTtcclxuICAgICAgICAgICAgaWYgKCFlbnRyeS5wYXVzZWQgJiYgIWVudHJ5Lm1hcmtlZEZvckRlbGV0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS50YXJnZXQudXBkYXRlKGR0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggaSA9IDAsIGxpc3QgPSB0aGlzLl91cGRhdGVzUG9zTGlzdCwgbGVuID0gbGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XHJcbiAgICAgICAgICAgIGVudHJ5ID0gbGlzdFtpXTtcclxuICAgICAgICAgICAgaWYgKCFlbnRyeS5wYXVzZWQgJiYgIWVudHJ5Lm1hcmtlZEZvckRlbGV0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRyeS50YXJnZXQudXBkYXRlKGR0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCB0aGUgY3VzdG9tIHNlbGVjdG9yc1xyXG4gICAgICAgIGxldCBlbHQ7XHJcbiAgICAgICAgY29uc3QgYXJyID0gdGhpcy5fYXJyYXlGb3JUaW1lcnM7XHJcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBlbHQgPSBhcnJbaV07XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXQgPSBlbHQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXRTYWx2YWdlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFlbHQucGF1c2VkKXtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSAndGltZXJzJyBhcnJheSBtYXkgY2hhbmdlIHdoaWxlIGluc2lkZSB0aGlzIGxvb3BcclxuICAgICAgICAgICAgICAgIGZvciAoZWx0LnRpbWVySW5kZXggPSAwOyBlbHQudGltZXJJbmRleCA8IGVsdC50aW1lcnMubGVuZ3RoOyArKyhlbHQudGltZXJJbmRleCkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGVsdC5jdXJyZW50VGltZXIgPSBlbHQudGltZXJzW2VsdC50aW1lckluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBlbHQuY3VycmVudFRpbWVyU2FsdmFnZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZWx0LmN1cnJlbnRUaW1lci51cGRhdGUoZHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsdC5jdXJyZW50VGltZXIgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBvbmx5IGRlbGV0ZSBjdXJyZW50VGFyZ2V0IGlmIG5vIGFjdGlvbnMgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoZSBjeWNsZSAoaXNzdWUgIzQ4MSlcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUYXJnZXRTYWx2YWdlZCAmJiB0aGlzLl9jdXJyZW50VGFyZ2V0LnRpbWVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUhhc2hFbGVtZW50KHRoaXMuX2N1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgLS1pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBkZWxldGUgYWxsIHVwZGF0ZXMgdGhhdCBhcmUgbWFya2VkIGZvciBkZWxldGlvblxyXG4gICAgICAgIC8vIHVwZGF0ZXMgd2l0aCBwcmlvcml0eSA8IDBcclxuICAgICAgICBmb3IgKCBpID0gMCwgbGlzdCA9IHRoaXMuX3VwZGF0ZXNOZWdMaXN0OyBpIDwgbGlzdC5sZW5ndGg7ICl7XHJcbiAgICAgICAgICAgIGVudHJ5ID0gbGlzdFtpXTtcclxuICAgICAgICAgICAgaWYgKGVudHJ5Lm1hcmtlZEZvckRlbGV0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVVcGRhdGVGcm9tSGFzaChlbnRyeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoIGkgPSAwLCBsaXN0ID0gdGhpcy5fdXBkYXRlczBMaXN0OyBpIDwgbGlzdC5sZW5ndGg7ICl7XHJcbiAgICAgICAgICAgIGVudHJ5ID0gbGlzdFtpXTtcclxuICAgICAgICAgICAgaWYgKGVudHJ5Lm1hcmtlZEZvckRlbGV0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVVcGRhdGVGcm9tSGFzaChlbnRyeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoIGkgPSAwLCBsaXN0ID0gdGhpcy5fdXBkYXRlc1Bvc0xpc3Q7IGkgPCBsaXN0Lmxlbmd0aDsgKXtcclxuICAgICAgICAgICAgZW50cnkgPSBsaXN0W2ldO1xyXG4gICAgICAgICAgICBpZiAoZW50cnkubWFya2VkRm9yRGVsZXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVVwZGF0ZUZyb21IYXNoKGVudHJ5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlSGFzaExvY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiA8cD5cclxuICAgICAqICAgVGhlIHNjaGVkdWxlZCBtZXRob2Qgd2lsbCBiZSBjYWxsZWQgZXZlcnkgJ2ludGVydmFsJyBzZWNvbmRzLjxici8+XHJcbiAgICAgKiAgIElmIHBhdXNlZCBpcyBZRVMsIHRoZW4gaXQgd29uJ3QgYmUgY2FsbGVkIHVudGlsIGl0IGlzIHJlc3VtZWQuPGJyLz5cclxuICAgICAqICAgSWYgJ2ludGVydmFsJyBpcyAwLCBpdCB3aWxsIGJlIGNhbGxlZCBldmVyeSBmcmFtZSwgYnV0IGlmIHNvLCBpdCByZWNvbW1lbmRlZCB0byB1c2UgJ3NjaGVkdWxlVXBkYXRlRm9yVGFyZ2V0OicgaW5zdGVhZC48YnIvPlxyXG4gICAgICogICBJZiB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgYWxyZWFkeSBzY2hlZHVsZWQsIHRoZW4gb25seSB0aGUgaW50ZXJ2YWwgcGFyYW1ldGVyIHdpbGwgYmUgdXBkYXRlZCB3aXRob3V0IHJlLXNjaGVkdWxpbmcgaXQgYWdhaW4uPGJyLz5cclxuICAgICAqICAgcmVwZWF0IGxldCB0aGUgYWN0aW9uIGJlIHJlcGVhdGVkIHJlcGVhdCArIDEgdGltZXMsIHVzZSBjYy5tYWNyby5SRVBFQVRfRk9SRVZFUiB0byBsZXQgdGhlIGFjdGlvbiBydW4gY29udGludW91c2x5PGJyLz5cclxuICAgICAqICAgZGVsYXkgaXMgdGhlIGFtb3VudCBvZiB0aW1lIHRoZSBhY3Rpb24gd2lsbCB3YWl0IGJlZm9yZSBpdCdsbCBzdGFydDxici8+XHJcbiAgICAgKiA8L3A+XHJcbiAgICAgKiBAemhcclxuICAgICAqIOaMh+WumuWbnuiwg+WHveaVsO+8jOiwg+eUqOWvueixoeetieS/oeaBr+adpea3u+WKoOS4gOS4quaWsOeahOWumuaXtuWZqOOAgjxici8+XHJcbiAgICAgKiDlpoLmnpwgcGF1c2VkIOWAvOS4uiB0cnVl77yM6YKj5LmI55u05YiwIHJlc3VtZSDooqvosIPnlKjmiY3lvIDlp4vorqHml7bjgII8YnIvPlxyXG4gICAgICog5b2T5pe26Ze06Ze06ZqU6L6+5Yiw5oyH5a6a5YC85pe277yM6K6+572u55qE5Zue6LCD5Ye95pWw5bCG5Lya6KKr6LCD55So44CCPGJyLz5cclxuICAgICAqIOWmguaenCBpbnRlcnZhbCDlgLzkuLogMO+8jOmCo+S5iOWbnuiwg+WHveaVsOavj+S4gOW4p+mDveS8muiiq+iwg+eUqO+8jOS9huWmguaenOaYr+i/meagt++8jFxyXG4gICAgICog5bu66K6u5L2/55SoIHNjaGVkdWxlVXBkYXRlRm9yVGFyZ2V0IOS7o+abv+OAgjxici8+XHJcbiAgICAgKiDlpoLmnpzlm57osIPlh73mlbDlt7Lnu4/ooqvlrprml7blmajkvb/nlKjvvIzpgqPkuYjlj6rkvJrmm7TmlrDkuYvliY3lrprml7blmajnmoTml7bpl7Tpl7TpmpTlj4LmlbDvvIzkuI3kvJrorr7nva7mlrDnmoTlrprml7blmajjgII8YnIvPlxyXG4gICAgICogcmVwZWF0IOWAvOWPr+S7peiuqeWumuaXtuWZqOinpuWPkSByZXBlYXQgKyAxIOasoe+8jOS9v+eUqCBjYy5tYWNyby5SRVBFQVRfRk9SRVZFUlxyXG4gICAgICog5Y+v5Lul6K6p5a6a5pe25Zmo5LiA55u05b6q546v6Kem5Y+R44CCPGJyLz5cclxuICAgICAqIGRlbGF5IOWAvOaMh+WumuW7tui/n+aXtumXtO+8jOWumuaXtuWZqOS8muWcqOW7tui/n+aMh+WumueahOaXtumXtOS5i+WQjuW8gOWni+iuoeaXtuOAglxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyZXBlYXQ9Y2MubWFjcm8uUkVQRUFUX0ZPUkVWRVJdXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2RlbGF5PTBdXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXVzZWQ9ZmFzbGVdXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2hlZHVsZSAoY2FsbGJhY2s6IEZ1bmN0aW9uLCB0YXJnZXQ6IElTY2hlZHVsYWJsZSwgaW50ZXJ2YWw6IG51bWJlciwgcmVwZWF0PzogbnVtYmVyLCBkZWxheT86IG51bWJlciwgcGF1c2VkPzogYm9vbGVhbikge1xyXG4gICAgICAgICd1c2Ugc3RyaWN0JztcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IGNhbGxiYWNrO1xyXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICB0YXJnZXQgPSB0bXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNlbGVjdG9yLCB0YXJnZXQsIGludGVydmFsLCByZXBlYXQsIGRlbGF5LCBwYXVzZWRcclxuICAgICAgICAvLyBzZWxlY3RvciwgdGFyZ2V0LCBpbnRlcnZhbCwgcGF1c2VkXHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gNCB8fCBhcmd1bWVudHMubGVuZ3RoID09PSA1KSB7XHJcbiAgICAgICAgICAgIHBhdXNlZCA9ICEhcmVwZWF0O1xyXG4gICAgICAgICAgICByZXBlYXQgPSBjYy5tYWNyby5SRVBFQVRfRk9SRVZFUjtcclxuICAgICAgICAgICAgZGVsYXkgPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY2MuYXNzZXJ0SUQodGFyZ2V0LCAxNTAyKTtcclxuXHJcbiAgICAgICAgbGV0IHRhcmdldElkID0gdGFyZ2V0LnV1aWQgfHwgdGFyZ2V0LmlkO1xyXG4gICAgICAgIGlmICghdGFyZ2V0SWQpIHtcclxuICAgICAgICAgICAgY2MuZXJyb3JJRCgxNTEwKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZWxlbWVudCA9IHRoaXMuX2hhc2hGb3JUaW1lcnNbdGFyZ2V0SWRdO1xyXG4gICAgICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICAgICAgICAvLyBJcyB0aGlzIHRoZSAxc3QgZWxlbWVudCA/IFRoZW4gc2V0IHRoZSBwYXVzZSBsZXZlbCB0byBhbGwgdGhlIGNhbGxiYWNrX2ZucyBvZiB0aGlzIHRhcmdldFxyXG4gICAgICAgICAgICBlbGVtZW50ID0gSGFzaFRpbWVyRW50cnkuZ2V0KG51bGwsIHRhcmdldCwgMCwgbnVsbCwgbnVsbCwgcGF1c2VkKTtcclxuICAgICAgICAgICAgdGhpcy5fYXJyYXlGb3JUaW1lcnMucHVzaChlbGVtZW50KTtcclxuICAgICAgICAgICAgdGhpcy5faGFzaEZvclRpbWVyc1t0YXJnZXRJZF0gPSBlbGVtZW50O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5wYXVzZWQgIT09IHBhdXNlZCkge1xyXG4gICAgICAgICAgICBjYy53YXJuSUQoMTUxMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdGltZXI7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQudGltZXJzID09IG51bGwpIHtcclxuICAgICAgICAgICAgZWxlbWVudC50aW1lcnMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50LnRpbWVycy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdGltZXIgPSBlbGVtZW50LnRpbWVyc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lciAmJiBjYWxsYmFjayA9PT0gdGltZXIuX2NhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MubG9nSUQoMTUwNywgdGltZXIuZ2V0SW50ZXJ2YWwoKSwgaW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVyLl9pbnRlcnZhbCA9IGludGVydmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGltZXIgPSBDYWxsYmFja1RpbWVyLmdldCgpO1xyXG4gICAgICAgIHRpbWVyLmluaXRXaXRoQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssIHRhcmdldCwgaW50ZXJ2YWwsIHJlcGVhdCwgZGVsYXkpO1xyXG4gICAgICAgIGVsZW1lbnQudGltZXJzLnB1c2godGltZXIpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fY3VycmVudFRhcmdldCA9PT0gZWxlbWVudCAmJiB0aGlzLl9jdXJyZW50VGFyZ2V0U2FsdmFnZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldFNhbHZhZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBTY2hlZHVsZXMgdGhlIHVwZGF0ZSBjYWxsYmFjayBmb3IgYSBnaXZlbiB0YXJnZXQsXHJcbiAgICAgKiBEdXJpbmcgZXZlcnkgZnJhbWUgYWZ0ZXIgc2NoZWR1bGUgc3RhcnRlZCwgdGhlIFwidXBkYXRlXCIgZnVuY3Rpb24gb2YgdGFyZ2V0IHdpbGwgYmUgaW52b2tlZC5cclxuICAgICAqIEB6aFxyXG4gICAgICog5L2/55So5oyH5a6a55qE5LyY5YWI57qn5Li65oyH5a6a55qE5a+56LGh6K6+572uIHVwZGF0ZSDlrprml7blmajjgII8YnI+XHJcbiAgICAgKiB1cGRhdGUg5a6a5pe25Zmo5q+P5LiA5bin6YO95Lya6KKr6Kem5Y+R77yM6Kem5Y+R5pe26Ieq5Yqo6LCD55So5oyH5a6a5a+56LGh55qEIFwidXBkYXRlXCIg5Ye95pWw44CCPGJyPlxyXG4gICAgICog5LyY5YWI57qn55qE5YC86LaK5L2O77yM5a6a5pe25Zmo6KKr6Kem5Y+R55qE6LaK5pep44CCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJpb3JpdHlcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGF1c2VkXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBzY2hlZHVsZVVwZGF0ZSAodGFyZ2V0OiBJU2NoZWR1bGFibGUsIHByaW9yaXR5OiBOdW1iZXIsIHBhdXNlZDogQm9vbGVhbikge1xyXG4gICAgICAgIGxldCB0YXJnZXRJZCA9IHRhcmdldC51dWlkIHx8IHRhcmdldC5pZDtcclxuICAgICAgICBpZiAoIXRhcmdldElkKSB7XHJcbiAgICAgICAgICAgIGNjLmVycm9ySUQoMTUxMCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaGFzaEVsZW1lbnQgPSB0aGlzLl9oYXNoRm9yVXBkYXRlc1t0YXJnZXRJZF07XHJcbiAgICAgICAgaWYgKGhhc2hFbGVtZW50ICYmIGhhc2hFbGVtZW50LmVudHJ5KXtcclxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgcHJpb3JpdHkgaGFzIGNoYW5nZWRcclxuICAgICAgICAgICAgaWYgKGhhc2hFbGVtZW50LmVudHJ5LnByaW9yaXR5ICE9PSBwcmlvcml0eSl7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdXBkYXRlSGFzaExvY2tlZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2MubG9nSUQoMTUwNik7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzaEVsZW1lbnQuZW50cnkubWFya2VkRm9yRGVsZXRpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBoYXNoRWxlbWVudC5lbnRyeS5wYXVzZWQgPSBwYXVzZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBiZSBhZGRlZCBhZ2FpbiBvdXRzaWRlIGlmIChoYXNoRWxlbWVudCkuXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnNjaGVkdWxlVXBkYXRlKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgaGFzaEVsZW1lbnQuZW50cnkubWFya2VkRm9yRGVsZXRpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGhhc2hFbGVtZW50LmVudHJ5LnBhdXNlZCA9IHBhdXNlZDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgbGlzdEVsZW1lbnQgPSBMaXN0RW50cnkuZ2V0KHRhcmdldCwgcHJpb3JpdHksIHBhdXNlZCwgZmFsc2UpO1xyXG4gICAgICAgIGxldCBwcExpc3Q7XHJcblxyXG4gICAgICAgIC8vIG1vc3Qgb2YgdGhlIHVwZGF0ZXMgYXJlIGdvaW5nIHRvIGJlIDAsIHRoYXQncyB3YXkgdGhlcmVcclxuICAgICAgICAvLyBpcyBhbiBzcGVjaWFsIGxpc3QgZm9yIHVwZGF0ZXMgd2l0aCBwcmlvcml0eSAwXHJcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHBwTGlzdCA9IHRoaXMuX3VwZGF0ZXMwTGlzdDtcclxuICAgICAgICAgICAgdGhpcy5fYXBwZW5kSW4ocHBMaXN0LCBsaXN0RWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwcExpc3QgPSBwcmlvcml0eSA8IDAgPyB0aGlzLl91cGRhdGVzTmVnTGlzdCA6IHRoaXMuX3VwZGF0ZXNQb3NMaXN0O1xyXG4gICAgICAgICAgICB0aGlzLl9wcmlvcml0eUluKHBwTGlzdCwgbGlzdEVsZW1lbnQsIHByaW9yaXR5KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBoYXNoIGVudHJ5IGZvciBxdWljayBhY2Nlc3NcclxuICAgICAgICB0aGlzLl9oYXNoRm9yVXBkYXRlc1t0YXJnZXRJZF0gPSBIYXNoVXBkYXRlRW50cnkuZ2V0KHBwTGlzdCwgbGlzdEVsZW1lbnQsIHRhcmdldCwgbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIFVuc2NoZWR1bGVzIGEgY2FsbGJhY2sgZm9yIGEgY2FsbGJhY2sgYW5kIGEgZ2l2ZW4gdGFyZ2V0Ljxicj5cclxuICAgICAqIElmIHlvdSB3YW50IHRvIHVuc2NoZWR1bGUgdGhlIFwidXBkYXRlXCIsIHVzZSBgdW5zY2hlZHVsZVVwZGF0ZSgpYFxyXG4gICAgICogQHpoXHJcbiAgICAgKiDmoLnmja7mjIflrprnmoTlm57osIPlh73mlbDlkozosIPnlKjlr7nosaHjgII8YnI+XHJcbiAgICAgKiDlpoLmnpzpnIDopoHlj5bmtoggdXBkYXRlIOWumuaXtuWZqO+8jOivt+S9v+eUqCB1bnNjaGVkdWxlVXBkYXRlKCnjgIJcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBiZSB1bnNjaGVkdWxlZFxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IGJvdW5kIHRvIHRoZSBjYWxsYmFjay5cclxuICAgICAqL1xyXG4gICAgcHVibGljIHVuc2NoZWR1bGUgKGNhbGxiYWNrLCB0YXJnZXQ6SVNjaGVkdWxhYmxlKSB7XHJcbiAgICAgICAgLy8gY2FsbGJhY2ssIHRhcmdldFxyXG5cclxuICAgICAgICAvLyBleHBsaWNpdHkgaGFuZGxlIG5pbCBhcmd1bWVudHMgd2hlbiByZW1vdmluZyBhbiBvYmplY3RcclxuICAgICAgICBpZiAoIXRhcmdldCB8fCAhY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdGFyZ2V0SWQgPSB0YXJnZXQudXVpZCB8fCB0YXJnZXQuaWQ7XHJcbiAgICAgICAgaWYgKCF0YXJnZXRJZCkge1xyXG4gICAgICAgICAgICBjYy5lcnJvcklEKDE1MTApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gc2VsZi5faGFzaEZvclRpbWVyc1t0YXJnZXRJZF07XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgdGltZXJzID0gZWxlbWVudC50aW1lcnM7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsaSA9IHRpbWVycy5sZW5ndGg7IGkgPCBsaTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lciA9IHRpbWVyc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayA9PT0gdGltZXIuX2NhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aW1lciA9PT0gZWxlbWVudC5jdXJyZW50VGltZXIpICYmICghZWxlbWVudC5jdXJyZW50VGltZXJTYWx2YWdlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5jdXJyZW50VGltZXJTYWx2YWdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgQ2FsbGJhY2tUaW1lci5wdXQodGltZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aW1lckluZGV4IGluIGNhc2Ugd2UgYXJlIGluIHRpY2s7LCBsb29waW5nIG92ZXIgdGhlIGFjdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC50aW1lckluZGV4ID49IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC50aW1lckluZGV4LS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fY3VycmVudFRhcmdldCA9PT0gZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fY3VycmVudFRhcmdldFNhbHZhZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3JlbW92ZUhhc2hFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlbiBVbnNjaGVkdWxlcyB0aGUgdXBkYXRlIGNhbGxiYWNrIGZvciBhIGdpdmVuIHRhcmdldC5cclxuICAgICAqIEB6aCDlj5bmtojmjIflrprlr7nosaHnmoQgdXBkYXRlIOWumuaXtuWZqOOAglxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IHRvIGJlIHVuc2NoZWR1bGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdW5zY2hlZHVsZVVwZGF0ZSAodGFyZ2V0OklTY2hlZHVsYWJsZSkge1xyXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRhcmdldElkID0gdGFyZ2V0LnV1aWQgfHwgdGFyZ2V0LmlkO1xyXG4gICAgICAgIGlmICghdGFyZ2V0SWQpIHtcclxuICAgICAgICAgICAgY2MuZXJyb3JJRCgxNTEwKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2hhc2hGb3JVcGRhdGVzW3RhcmdldElkXTtcclxuICAgICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdXBkYXRlSGFzaExvY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5lbnRyeS5tYXJrZWRGb3JEZWxldGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVVcGRhdGVGcm9tSGFzaChlbGVtZW50LmVudHJ5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogVW5zY2hlZHVsZXMgYWxsIHNjaGVkdWxlZCBjYWxsYmFja3MgZm9yIGEgZ2l2ZW4gdGFyZ2V0LlxyXG4gICAgICogVGhpcyBhbHNvIGluY2x1ZGVzIHRoZSBcInVwZGF0ZVwiIGNhbGxiYWNrLlxyXG4gICAgICogQHpoIOWPlua2iOaMh+WumuWvueixoeeahOaJgOacieWumuaXtuWZqO+8jOWMheaLrCB1cGRhdGUg5a6a5pe25Zmo44CCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRoZSB0YXJnZXQgdG8gYmUgdW5zY2hlZHVsZWQuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyB1bnNjaGVkdWxlQWxsRm9yVGFyZ2V0ICh0YXJnZXQpIHtcclxuICAgICAgICAvLyBleHBsaWNpdCBudWxscHRyIGhhbmRsaW5nXHJcbiAgICAgICAgaWYgKCF0YXJnZXQpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0YXJnZXRJZCA9IHRhcmdldC51dWlkIHx8IHRhcmdldC5pZDtcclxuICAgICAgICBpZiAoIXRhcmdldElkKSB7XHJcbiAgICAgICAgICAgIGNjLmVycm9ySUQoMTUxMCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEN1c3RvbSBTZWxlY3RvcnNcclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5faGFzaEZvclRpbWVyc1t0YXJnZXRJZF07XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgdGltZXJzID0gZWxlbWVudC50aW1lcnM7XHJcbiAgICAgICAgICAgIGlmICh0aW1lcnMuaW5kZXhPZihlbGVtZW50LmN1cnJlbnRUaW1lcikgPiAtMSAmJlxyXG4gICAgICAgICAgICAgICAgKCFlbGVtZW50LmN1cnJlbnRUaW1lclNhbHZhZ2VkKSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jdXJyZW50VGltZXJTYWx2YWdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aW1lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBDYWxsYmFja1RpbWVyLnB1dCh0aW1lcnNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRpbWVycy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUYXJnZXQgPT09IGVsZW1lbnQpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldFNhbHZhZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVIYXNoRWxlbWVudChlbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIHNlbGVjdG9yXHJcbiAgICAgICAgdGhpcy51bnNjaGVkdWxlVXBkYXRlKHRhcmdldCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIFVuc2NoZWR1bGVzIGFsbCBzY2hlZHVsZWQgY2FsbGJhY2tzIGZyb20gYWxsIHRhcmdldHMgaW5jbHVkaW5nIHRoZSBzeXN0ZW0gY2FsbGJhY2tzLjxici8+XHJcbiAgICAgKiBZb3Ugc2hvdWxkIE5FVkVSIGNhbGwgdGhpcyBtZXRob2QsIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXHJcbiAgICAgKiBAemhcclxuICAgICAqIOWPlua2iOaJgOacieWvueixoeeahOaJgOacieWumuaXtuWZqO+8jOWMheaLrOezu+e7n+WumuaXtuWZqOOAgjxici8+XHJcbiAgICAgKiDkuI3nlKjosIPnlKjmraTlh73mlbDvvIzpmaTpnZ7kvaDnoa7lrprkvaDlnKjlgZrku4DkuYjjgIJcclxuICAgICAqL1xyXG4gICAgcHVibGljIHVuc2NoZWR1bGVBbGwgKCl7XHJcbiAgICAgICAgdGhpcy51bnNjaGVkdWxlQWxsV2l0aE1pblByaW9yaXR5KGNjLlNjaGVkdWxlci5QUklPUklUWV9TWVNURU0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBVbnNjaGVkdWxlcyBhbGwgY2FsbGJhY2tzIGZyb20gYWxsIHRhcmdldHMgd2l0aCBhIG1pbmltdW0gcHJpb3JpdHkuPGJyLz5cclxuICAgICAqIFlvdSBzaG91bGQgb25seSBjYWxsIHRoaXMgd2l0aCBgUFJJT1JJVFlfTk9OX1NZU1RFTV9NSU5gIG9yIGhpZ2hlci5cclxuICAgICAqIEB6aFxyXG4gICAgICog5Y+W5raI5omA5pyJ5LyY5YWI57qn55qE5YC85aSn5LqO5oyH5a6a5LyY5YWI57qn55qE5a6a5pe25Zmo44CCPGJyLz5cclxuICAgICAqIOS9oOW6lOivpeWPquWPlua2iOS8mOWFiOe6p+eahOWAvOWkp+S6jiBQUklPUklUWV9OT05fU1lTVEVNX01JTiDnmoTlrprml7blmajjgIJcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5Qcmlvcml0eSBUaGUgbWluaW11bSBwcmlvcml0eSBvZiBzZWxlY3RvciB0byBiZSB1bnNjaGVkdWxlZC4gV2hpY2ggbWVhbnMsIGFsbCBzZWxlY3RvcnMgd2hpY2hcclxuICAgICAqICAgICAgICBwcmlvcml0eSBpcyBoaWdoZXIgdGhhbiBtaW5Qcmlvcml0eSB3aWxsIGJlIHVuc2NoZWR1bGVkLlxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgdW5zY2hlZHVsZUFsbFdpdGhNaW5Qcmlvcml0eSAobWluUHJpb3JpdHk6IG51bWJlcil7XHJcbiAgICAgICAgLy8gQ3VzdG9tIFNlbGVjdG9yc1xyXG4gICAgICAgIGxldCBpO1xyXG4gICAgICAgIGxldCBlbGVtZW50O1xyXG4gICAgICAgIGNvbnN0IGFyciA9IHRoaXMuX2FycmF5Rm9yVGltZXJzO1xyXG4gICAgICAgIGZvciAoIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgZWxlbWVudCA9IGFycltpXTtcclxuICAgICAgICAgICAgdGhpcy51bnNjaGVkdWxlQWxsRm9yVGFyZ2V0KGVsZW1lbnQudGFyZ2V0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZXMgc2VsZWN0b3JzXHJcbiAgICAgICAgbGV0IGVudHJ5O1xyXG4gICAgICAgIGxldCB0ZW1wX2xlbmd0aCA9IDA7XHJcbiAgICAgICAgaWYgKG1pblByaW9yaXR5IDwgMCl7XHJcbiAgICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgdGhpcy5fdXBkYXRlc05lZ0xpc3QubGVuZ3RoOyApIHtcclxuICAgICAgICAgICAgICAgIHRlbXBfbGVuZ3RoID0gdGhpcy5fdXBkYXRlc05lZ0xpc3QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZW50cnkgPSB0aGlzLl91cGRhdGVzTmVnTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIGlmIChlbnRyeSAmJiBlbnRyeS5wcmlvcml0eSA+PSBtaW5Qcmlvcml0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zY2hlZHVsZVVwZGF0ZShlbnRyeS50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRlbXBfbGVuZ3RoID09PSB0aGlzLl91cGRhdGVzTmVnTGlzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtaW5Qcmlvcml0eSA8PSAwICkge1xyXG4gICAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IHRoaXMuX3VwZGF0ZXMwTGlzdC5sZW5ndGg7ICkge1xyXG4gICAgICAgICAgICAgICAgdGVtcF9sZW5ndGggPSB0aGlzLl91cGRhdGVzMExpc3QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZW50cnkgPSB0aGlzLl91cGRhdGVzMExpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc2NoZWR1bGVVcGRhdGUoZW50cnkudGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0ZW1wX2xlbmd0aCA9PT0gdGhpcy5fdXBkYXRlczBMaXN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCB0aGlzLl91cGRhdGVzUG9zTGlzdC5sZW5ndGg7ICkge1xyXG4gICAgICAgICAgICB0ZW1wX2xlbmd0aCA9IHRoaXMuX3VwZGF0ZXNQb3NMaXN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgZW50cnkgPSB0aGlzLl91cGRhdGVzUG9zTGlzdFtpXTtcclxuICAgICAgICAgICAgaWYgKCBlbnRyeSAmJiBlbnRyeS5wcmlvcml0eSA+PSBtaW5Qcmlvcml0eSApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5zY2hlZHVsZVVwZGF0ZShlbnRyeS50YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0ZW1wX2xlbmd0aCA9PT0gdGhpcy5fdXBkYXRlc1Bvc0xpc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gQ2hlY2tzIHdoZXRoZXIgYSBjYWxsYmFjayBmb3IgYSBnaXZlbiB0YXJnZXQgaXMgc2NoZWR1bGVkLlxyXG4gICAgICogQHpoIOajgOafpeaMh+WumueahOWbnuiwg+WHveaVsOWSjOWbnuiwg+Wvueixoee7hOWQiOaYr+WQpuWtmOWcqOWumuaXtuWZqOOAglxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIHRvIGNoZWNrLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUaGUgdGFyZ2V0IG9mIHRoZSBjYWxsYmFjay5cclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBpcyBpbnZva2VkLCBmYWxzZSBpZiBub3QuXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc1NjaGVkdWxlZCAoY2FsbGJhY2ssIHRhcmdldDpJU2NoZWR1bGFibGUpe1xyXG4gICAgICAgIC8vIGtleSwgdGFyZ2V0XHJcbiAgICAgICAgLy8gc2VsZWN0b3IsIHRhcmdldFxyXG4gICAgICAgIGNjLmFzc2VydElEKGNhbGxiYWNrLCAxNTA4KTtcclxuICAgICAgICBjYy5hc3NlcnRJRCh0YXJnZXQsIDE1MDkpO1xyXG4gICAgICAgIGxldCB0YXJnZXRJZCA9IHRhcmdldC51dWlkIHx8IHRhcmdldC5pZDtcclxuICAgICAgICBpZiAoIXRhcmdldElkKSB7XHJcbiAgICAgICAgICAgIGNjLmVycm9ySUQoMTUxMCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9oYXNoRm9yVGltZXJzW3RhcmdldElkXTtcclxuXHJcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlbGVtZW50LnRpbWVycyA9PSBudWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgdGltZXJzID0gZWxlbWVudC50aW1lcnM7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcHJlZmVyLWZvci1vZlxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRpbWVycy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSAgdGltZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrID09PSB0aW1lci5fY2FsbGJhY2spe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW5cclxuICAgICAqIFBhdXNlIGFsbCBzZWxlY3RvcnMgZnJvbSBhbGwgdGFyZ2V0cy48YnIvPlxyXG4gICAgICogWW91IHNob3VsZCBORVZFUiBjYWxsIHRoaXMgbWV0aG9kLCB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UgYXJlIGRvaW5nLlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDmmoLlgZzmiYDmnInlr7nosaHnmoTmiYDmnInlrprml7blmajjgII8YnIvPlxyXG4gICAgICog5LiN6KaB6LCD55So6L+Z5Liq5pa55rOV77yM6Zmk6Z2e5L2g55+l6YGT5L2g5q2j5Zyo5YGa5LuA5LmI44CCXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBwYXVzZUFsbFRhcmdldHMgKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBhdXNlQWxsVGFyZ2V0c1dpdGhNaW5Qcmlvcml0eShjYy5TY2hlZHVsZXIuUFJJT1JJVFlfU1lTVEVNKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogUGF1c2UgYWxsIHNlbGVjdG9ycyBmcm9tIGFsbCB0YXJnZXRzIHdpdGggYSBtaW5pbXVtIHByaW9yaXR5LiA8YnIvPlxyXG4gICAgICogWW91IHNob3VsZCBvbmx5IGNhbGwgdGhpcyB3aXRoIGtDQ1ByaW9yaXR5Tm9uU3lzdGVtTWluIG9yIGhpZ2hlci5cclxuICAgICAqIEB6aFxyXG4gICAgICog5pqC5YGc5omA5pyJ5LyY5YWI57qn55qE5YC85aSn5LqO5oyH5a6a5LyY5YWI57qn55qE5a6a5pe25Zmo44CCPGJyLz5cclxuICAgICAqIOS9oOW6lOivpeWPquaaguWBnOS8mOWFiOe6p+eahOWAvOWkp+S6jiBQUklPUklUWV9OT05fU1lTVEVNX01JTiDnmoTlrprml7blmajjgIJcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtaW5Qcmlvcml0eVxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcGF1c2VBbGxUYXJnZXRzV2l0aE1pblByaW9yaXR5IChtaW5Qcmlvcml0eTogbnVtYmVyKSB7XHJcbiAgICAgICAgY29uc3QgaWRzV2l0aFNlbGVjdG9yczogYW55ID0gW107XHJcblxyXG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG4gICAgICAgIGxldCBlbGVtZW50O1xyXG4gICAgICAgIGNvbnN0IGxvY0FycmF5Rm9yVGltZXJzID0gc2VsZi5fYXJyYXlGb3JUaW1lcnM7XHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgbGV0IGxpO1xyXG4gICAgICAgIC8vIEN1c3RvbSBTZWxlY3RvcnNcclxuICAgICAgICBmb3IgKGkgPSAwLCBsaSA9IGxvY0FycmF5Rm9yVGltZXJzLmxlbmd0aDsgaSA8IGxpOyBpKyspIHtcclxuICAgICAgICAgICAgZWxlbWVudCA9IGxvY0FycmF5Rm9yVGltZXJzW2ldO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5wYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWRzV2l0aFNlbGVjdG9ycy5wdXNoKGVsZW1lbnQudGFyZ2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGVudHJ5O1xyXG4gICAgICAgIGlmIChtaW5Qcmlvcml0eSA8IDApIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX3VwZGF0ZXNOZWdMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRyeSA9IHRoaXMuX3VwZGF0ZXNOZWdMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LnByaW9yaXR5ID49IG1pblByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5LnBhdXNlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkc1dpdGhTZWxlY3RvcnMucHVzaChlbnRyeS50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1pblByaW9yaXR5IDw9IDApIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX3VwZGF0ZXMwTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZW50cnkgPSB0aGlzLl91cGRhdGVzMExpc3RbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5wYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlkc1dpdGhTZWxlY3RvcnMucHVzaChlbnRyeS50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5fdXBkYXRlc1Bvc0xpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZW50cnkgPSB0aGlzLl91cGRhdGVzUG9zTGlzdFtpXTtcclxuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkucHJpb3JpdHkgPj0gbWluUHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5wYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlkc1dpdGhTZWxlY3RvcnMucHVzaChlbnRyeS50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gaWRzV2l0aFNlbGVjdG9ycztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBlblxyXG4gICAgICogUmVzdW1lIHNlbGVjdG9ycyBvbiBhIHNldCBvZiB0YXJnZXRzLjxici8+XHJcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yIHVuZG9pbmcgYSBjYWxsIHRvIHBhdXNlQWxsQ2FsbGJhY2tzLlxyXG4gICAgICogQHpoXHJcbiAgICAgKiDmgaLlpI3mjIflrprmlbDnu4TkuK3miYDmnInlr7nosaHnmoTlrprml7blmajjgII8YnIvPlxyXG4gICAgICog6L+Z5Liq5Ye95pWw5pivIHBhdXNlQWxsQ2FsbGJhY2tzIOeahOmAhuaTjeS9nOOAglxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0c1RvUmVzdW1lXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXN1bWVUYXJnZXRzICh0YXJnZXRzVG9SZXN1bWUpIHtcclxuICAgICAgICBpZiAoIXRhcmdldHNUb1Jlc3VtZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogcHJlZmVyLWZvci1vZlxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0c1RvUmVzdW1lLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzdW1lVGFyZ2V0KHRhcmdldHNUb1Jlc3VtZVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBQYXVzZXMgdGhlIHRhcmdldC48YnIvPlxyXG4gICAgICogQWxsIHNjaGVkdWxlZCBzZWxlY3RvcnMvdXBkYXRlIGZvciBhIGdpdmVuIHRhcmdldCB3b24ndCBiZSAndGlja2VkJyB1bnRpbCB0aGUgdGFyZ2V0IGlzIHJlc3VtZWQuPGJyLz5cclxuICAgICAqIElmIHRoZSB0YXJnZXQgaXMgbm90IHByZXNlbnQsIG5vdGhpbmcgaGFwcGVucy5cclxuICAgICAqIEB6aFxyXG4gICAgICog5pqC5YGc5oyH5a6a5a+56LGh55qE5a6a5pe25Zmo44CCPGJyLz5cclxuICAgICAqIOaMh+WumuWvueixoeeahOaJgOacieWumuaXtuWZqOmDveS8muiiq+aaguWBnOOAgjxici8+XHJcbiAgICAgKiDlpoLmnpzmjIflrprnmoTlr7nosaHmsqHmnInlrprml7blmajvvIzku4DkuYjkuZ/kuI3kvJrlj5HnlJ/jgIJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcclxuICAgICAqL1xyXG4gICAgcHVibGljIHBhdXNlVGFyZ2V0ICh0YXJnZXQ6SVNjaGVkdWxhYmxlKSB7XHJcbiAgICAgICAgY2MuYXNzZXJ0SUQodGFyZ2V0LCAxNTAzKTtcclxuICAgICAgICBsZXQgdGFyZ2V0SWQgPSB0YXJnZXQudXVpZCB8fCB0YXJnZXQuaWQ7XHJcbiAgICAgICAgaWYgKCF0YXJnZXRJZCkge1xyXG4gICAgICAgICAgICBjYy5lcnJvcklEKDE1MTApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjdXN0b21lciBzZWxlY3RvcnNcclxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gc2VsZi5faGFzaEZvclRpbWVyc1t0YXJnZXRJZF07XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5wYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdXBkYXRlIGNhbGxiYWNrXHJcbiAgICAgICAgY29uc3QgZWxlbWVudFVwZGF0ZSA9IHNlbGYuX2hhc2hGb3JVcGRhdGVzW3RhcmdldElkXTtcclxuICAgICAgICBpZiAoZWxlbWVudFVwZGF0ZSkge1xyXG4gICAgICAgICAgICBlbGVtZW50VXBkYXRlLmVudHJ5LnBhdXNlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGVuXHJcbiAgICAgKiBSZXN1bWVzIHRoZSB0YXJnZXQuPGJyLz5cclxuICAgICAqIFRoZSAndGFyZ2V0JyB3aWxsIGJlIHVucGF1c2VkLCBzbyBhbGwgc2NoZWR1bGUgc2VsZWN0b3JzL3VwZGF0ZSB3aWxsIGJlICd0aWNrZWQnIGFnYWluLjxici8+XHJcbiAgICAgKiBJZiB0aGUgdGFyZ2V0IGlzIG5vdCBwcmVzZW50LCBub3RoaW5nIGhhcHBlbnMuXHJcbiAgICAgKiBAemhcclxuICAgICAqIOaBouWkjeaMh+WumuWvueixoeeahOaJgOacieWumuaXtuWZqOOAgjxici8+XHJcbiAgICAgKiDmjIflrprlr7nosaHnmoTmiYDmnInlrprml7blmajlsIbnu6fnu63lt6XkvZzjgII8YnIvPlxyXG4gICAgICog5aaC5p6c5oyH5a6a55qE5a+56LGh5rKh5pyJ5a6a5pe25Zmo77yM5LuA5LmI5Lmf5LiN5Lya5Y+R55Sf44CCXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyByZXN1bWVUYXJnZXQgKHRhcmdldDpJU2NoZWR1bGFibGUpIHtcclxuICAgICAgICBjYy5hc3NlcnRJRCh0YXJnZXQsIDE1MDQpO1xyXG4gICAgICAgIGxldCB0YXJnZXRJZCA9IHRhcmdldC51dWlkIHx8IHRhcmdldC5pZDtcclxuICAgICAgICBpZiAoIXRhcmdldElkKSB7XHJcbiAgICAgICAgICAgIGNjLmVycm9ySUQoMTUxMCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGN1c3RvbSBzZWxlY3RvcnNcclxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gc2VsZi5faGFzaEZvclRpbWVyc1t0YXJnZXRJZF07XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5wYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHVwZGF0ZSBjYWxsYmFja1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRVcGRhdGUgPSBzZWxmLl9oYXNoRm9yVXBkYXRlc1t0YXJnZXRJZF07XHJcbiAgICAgICAgaWYgKGVsZW1lbnRVcGRhdGUpIHtcclxuICAgICAgICAgICAgZWxlbWVudFVwZGF0ZS5lbnRyeS5wYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAZW4gUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdGFyZ2V0IGlzIHBhdXNlZC5cclxuICAgICAqIEB6aCDov5Tlm57mjIflrprlr7nosaHnmoTlrprml7blmajmmK/lkKblpITkuo7mmoLlgZznirbmgIHjgIJcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBpc1RhcmdldFBhdXNlZCAodGFyZ2V0OklTY2hlZHVsYWJsZSkge1xyXG4gICAgICAgIGNjLmFzc2VydElEKHRhcmdldCwgMTUwNSk7XHJcbiAgICAgICAgbGV0IHRhcmdldElkID0gdGFyZ2V0LnV1aWQgfHwgdGFyZ2V0LmlkO1xyXG4gICAgICAgIGlmICghdGFyZ2V0SWQpIHtcclxuICAgICAgICAgICAgY2MuZXJyb3JJRCgxNTEwKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ3VzdG9tIHNlbGVjdG9yc1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9oYXNoRm9yVGltZXJzW3RhcmdldElkXTtcclxuICAgICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5wYXVzZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGVsZW1lbnRVcGRhdGUgPSB0aGlzLl9oYXNoRm9yVXBkYXRlc1t0YXJnZXRJZF07XHJcbiAgICAgICAgaWYgKGVsZW1lbnRVcGRhdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRVcGRhdGUuZW50cnkucGF1c2VkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1wcml2YXRlIG1ldGhvZC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIHByaXZhdGUgX3JlbW92ZUhhc2hFbGVtZW50IChlbGVtZW50KSB7XHJcbiAgICAgICAgbGV0IHRhcmdldElkID0gZWxlbWVudC50YXJnZXQudXVpZCB8fCBlbGVtZW50LnRhcmdldC5pZDtcclxuICAgICAgICBkZWxldGUgdGhpcy5faGFzaEZvclRpbWVyc1t0YXJnZXRJZF07XHJcbiAgICAgICAgY29uc3QgYXJyID0gdGhpcy5fYXJyYXlGb3JUaW1lcnM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhcnJbaV0gPT09IGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGFyci5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBIYXNoVGltZXJFbnRyeS5wdXQoZWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfcmVtb3ZlVXBkYXRlRnJvbUhhc2ggKGVudHJ5KSB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0SWQgPSBlbnRyeS50YXJnZXQudXVpZCB8fCBlbnRyeS50YXJnZXQuaWQ7XHJcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHNlbGYuX2hhc2hGb3JVcGRhdGVzW3RhcmdldElkXTtcclxuICAgICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAvLyBSZW1vdmUgbGlzdCBlbnRyeSBmcm9tIGxpc3RcclxuICAgICAgICAgICAgY29uc3QgbGlzdCA9IGVsZW1lbnQubGlzdDtcclxuICAgICAgICAgICAgY29uc3QgbGlzdEVudHJ5ID0gZWxlbWVudC5lbnRyeTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RFbnRyeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkZWxldGUgc2VsZi5faGFzaEZvclVwZGF0ZXNbdGFyZ2V0SWRdO1xyXG4gICAgICAgICAgICBMaXN0RW50cnkucHV0KGxpc3RFbnRyeSk7XHJcbiAgICAgICAgICAgIEhhc2hVcGRhdGVFbnRyeS5wdXQoZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX3ByaW9yaXR5SW4gKHBwTGlzdCwgbGlzdEVsZW1lbnQsIHByaW9yaXR5KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcExpc3QubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBpZiAocHJpb3JpdHkgPCBwcExpc3RbaV0ucHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgICAgIHBwTGlzdC5zcGxpY2UoaSwgMCwgbGlzdEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBwTGlzdC5wdXNoKGxpc3RFbGVtZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9hcHBlbmRJbiAocHBMaXN0LCBsaXN0RWxlbWVudCkge1xyXG4gICAgICAgIHBwTGlzdC5wdXNoKGxpc3RFbGVtZW50KTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmNjLlNjaGVkdWxlciA9IFNjaGVkdWxlcjtcclxuIl19