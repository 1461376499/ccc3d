(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define(["exports"], factory);
  } else if (typeof exports !== "undefined") {
    factory(exports);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod.exports);
    global.effects = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (_exports) {
  "use strict";

  Object.defineProperty(_exports, "__esModule", {
    value: true
  });
  _exports.default = void 0;
  // tslint:disable
  // absolute essential effects
  var _default = [{
    "name": "builtin-billboard",
    "_uuid": "711ebe11-f673-4cd9-9a83-63c60ba54c5b",
    "techniques": [{
      "name": "add",
      "passes": [{
        "rasterizerState": {
          "cullMode": 0
        },
        "blendState": {
          "targets": [{
            "blend": true,
            "blendSrc": 2,
            "blendDst": 1,
            "blendSrcAlpha": 2,
            "blendDstAlpha": 1
          }]
        },
        "program": "builtin-billboard|vert:vs_main|tinted-fs:add",
        "depthStencilState": {
          "depthTest": true,
          "depthWrite": false
        },
        "properties": {
          "mainTexture": {
            "value": "grey",
            "type": 28
          },
          "mainTiling_Offset": {
            "value": [1, 1, 0, 0],
            "type": 16
          },
          "tintColor": {
            "value": [0.5, 0.5, 0.5, 0.5],
            "type": 16
          }
        }
      }]
    }],
    "shaders": [{
      "name": "builtin-billboard|vert:vs_main|tinted-fs:add",
      "hash": 3052980566,
      "glsl3": {
        "vert": "\nprecision mediump float;\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n  , mat4 viewInv\n) {\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nuniform builtin {\n  vec4 cc_size_rotation;\n};\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = a_texCoord.xy - 0.5;\n  computeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
        "frag": "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
      },
      "glsl1": {
        "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n  , mat4 viewInv\n) {\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nuniform vec4 cc_size_rotation;\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = a_texCoord.xy - 0.5;\n  computeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
        "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCLocal",
            "defines": []
          }],
          "samplers": []
        }
      },
      "defines": [{
        "name": "CC_USE_HDR",
        "type": "boolean"
      }],
      "blocks": [{
        "name": "Constants",
        "defines": [],
        "binding": 0,
        "members": [{
          "name": "mainTiling_Offset",
          "type": 16,
          "count": 1
        }, {
          "name": "frameTile_velLenScale",
          "type": 16,
          "count": 1
        }, {
          "name": "scale",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "builtin",
        "defines": [],
        "binding": 1,
        "members": [{
          "name": "cc_size_rotation",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "FragConstants",
        "defines": [],
        "binding": 2,
        "members": [{
          "name": "tintColor",
          "type": 16,
          "count": 1
        }]
      }],
      "samplers": [{
        "name": "mainTexture",
        "type": 28,
        "count": 1,
        "defines": [],
        "binding": 31
      }],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "format": 32,
        "location": 0
      }, {
        "name": "a_texCoord",
        "type": 14,
        "count": 1,
        "defines": [],
        "format": 21,
        "location": 1
      }, {
        "name": "a_color",
        "type": 16,
        "count": 1,
        "defines": [],
        "format": 43,
        "location": 2
      }]
    }]
  }, {
    "name": "builtin-particle-gpu",
    "_uuid": "971bdb23-3ff6-43eb-b422-1c30165a3663",
    "techniques": [{
      "name": "add",
      "passes": [{
        "rasterizerState": {
          "cullMode": 0
        },
        "blendState": {
          "targets": [{
            "blend": true,
            "blendSrc": 2,
            "blendDst": 1,
            "blendSrcAlpha": 2,
            "blendDstAlpha": 1
          }]
        },
        "program": "builtin-particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
        "depthStencilState": {
          "depthTest": true,
          "depthWrite": false
        },
        "properties": {
          "mainTexture": {
            "value": "grey",
            "type": 28
          },
          "mainTiling_Offset": {
            "value": [1, 1, 0, 0],
            "type": 16
          },
          "tintColor": {
            "value": [0.5, 0.5, 0.5, 0.5],
            "type": 16
          }
        }
      }]
    }],
    "shaders": [{
      "name": "builtin-particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
      "hash": 4003605751,
      "glsl3": {
        "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nuniform SampleConstants {\n  vec4 u_sampleInfo;\n};\nuniform TickConstants {\n  vec4 u_worldRot;\n  vec4 u_timeDelta;\n};\nin vec4 a_position_starttime;\nin vec4 a_size_uv;\nin vec4 a_rotation_uv;\nin vec4 a_color;\nin vec4 a_dir_life;\nin float a_rndSeed;\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord;\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\n    vec4 a = texture(tex, coord);\n    vec4 b = texture(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    return mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\n    vec4 a = texture(tex, coord);\n    vec4 b = texture(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    w = mix(a.w, b.w, c);\n    return mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom (float seed) {\n  seed = mod(seed, 233280.);\n  float q = (seed * 9301. + 49297.) / 233280.;\n  return fract(q);\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D color_over_time_tex0;\n  uniform ColorConstant {\n    int u_color_mode;\n  };\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D rotation_over_time_tex0;\n  uniform RotationConstant {\n    int u_rotation_mode;\n  };\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D size_over_time_tex0;\n  uniform SizeConstant {\n    int u_size_mode;\n  };\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D force_over_time_tex0;\n  uniform ForceConstant {\n    int u_force_mode;\n    int u_force_space;\n  };\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D velocity_over_time_tex0;\n  uniform VelocityConstant {\n    int u_velocity_mode;\n    int u_velocity_space;\n  };\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\n  uniform sampler2D texture_animation_tex0;\n  uniform AnimationConstant {\n    vec4 u_anim_info;\n  };\n#endif\nfloat repeat (float t, float length) {\n  return t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\n  vec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\n  vec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\n  return vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\n  float activeTime = u_timeDelta.x - a_position_starttime.w;\n  float normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\n  vec2 timeCoord0 = vec2(normalizedTime, 0.);\n  vec2 timeCoord1 = vec2(normalizedTime, 1.);\n  #if CC_RENDER_MODE == 4\n    vec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n  #else\n    vec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n  #endif\n  vec4 velocity = vec4(a_dir_life.xyz, 0.);\n  vec4 pos = vec4(a_position_starttime.xyz, 1.);\n  vec3 size = a_size_uv.xyz;\n  #if SIZE_OVER_TIME_MODULE_ENABLE\n    if (u_size_mode == 1) {\n      size *= unpackCurveData(size_over_time_tex0, timeCoord0);\n    } else {\n      vec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\n      vec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\n      float factor_s = pseudoRandom(a_rndSeed + 39825.);\n      size *= mix(size_0, size_1, factor_s);\n    }\n  #endif\n  vec3 compScale = scale.xyz * size;\n  #if FORCE_OVER_TIME_MODULE_ENABLE\n    vec3 forceAnim = vec3(0.);\n    if (u_force_mode == 1) {\n      forceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n    } else {\n      vec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\n      vec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\n      float factor_f =  pseudoRandom(a_rndSeed + 212165.);\n      forceAnim = mix(force_0, force_1, factor_f);\n    }\n    vec4 forceTrack = vec4(forceAnim, 0.);\n    if (u_force_space == 0) {\n      forceTrack = rotateQuat(forceTrack, u_worldRot);\n    }\n    velocity.xyz += forceTrack.xyz;\n  #endif\n  #if VELOCITY_OVER_TIME_MODULE_ENABLE\n    float speedModifier0 = 1.;\n    float speedModifier1 = 1.;\n    vec3 velocityAnim = vec3(0.);\n    if (u_velocity_mode == 1) {\n      velocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n    } else {\n      vec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n      vec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\n      float factor_v = pseudoRandom(a_rndSeed + 197866.);\n      velocityAnim = mix(vectory_0, vectory_1, factor_v);\n      speedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n    }\n    vec4 velocityTrack = vec4(velocityAnim, 0.);\n    if (u_velocity_space == 0) {\n      velocityTrack = rotateQuat(velocityTrack, u_worldRot);\n    }\n    velocity.xyz += velocityTrack.xyz;\n    velocity.xyz *= speedModifier0;\n  #endif\n  pos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = rotateQuat(velocity, u_worldRot);\n    #endif\n  #endif\n  vec3 rotation = a_rotation_uv.xyz;\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    if (u_rotation_mode == 1) {\n      rotation += unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\n    } else {\n      vec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\n      vec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\n      float factor_r = pseudoRandom(a_rndSeed + 125292.);\n      rotation += mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n    }\n  #endif\n  #if COLOR_OVER_TIME_MODULE_ENABLE\n    if (u_color_mode == 1) {\n      color = a_color * texture(color_over_time_tex0, timeCoord0);\n    } else {\n      vec4 color_0 = texture(color_over_time_tex0, timeCoord0);\n      vec4 color_1 = texture(color_over_time_tex0, timeCoord1);\n      float factor_c = pseudoRandom(a_rndSeed + 91041.);\n      color = a_color * mix(color_0, color_1, factor_c);\n    }\n  #else\n    color = a_color;\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((vertIdx - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = rotation.xyz;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., rotation.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n      #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n        , cc_matViewInv\n      #endif\n      #if CC_RENDER_MODE == 1\n        , cc_cameraPos.xyz\n        , velocity\n        , frameTile_velLenScale.z\n        , frameTile_velLenScale.w\n        , a_size_uv.w\n      #endif\n    );\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(rotation), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(rotation), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color *= a_color1;\n  #endif\n  pos = cc_matViewProj * pos;\n  float frameIndex = 0.;\n  #if TEXTURE_ANIMATION_MODULE_ENABLE\n    float startFrame = 0.;\n    vec3 frameInfo = vec3(0.);\n    if (int(u_anim_info.x) == 1) {\n      frameInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n    } else {\n      vec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\n      vec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\n      float factor_t = pseudoRandom(a_rndSeed + 90794.);\n      frameInfo = mix(frameInfo0, frameInfo1, factor_t);\n    }\n    startFrame = frameInfo.x / u_anim_info.y;\n    frameIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n  #endif\n  uv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  return pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
        "frag": "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
      },
      "glsl1": {
        "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nuniform vec4 u_sampleInfo;\nuniform vec4 u_worldRot;\nuniform vec4 u_timeDelta;\nattribute vec4 a_position_starttime;\nattribute vec4 a_size_uv;\nattribute vec4 a_rotation_uv;\nattribute vec4 a_color;\nattribute vec4 a_dir_life;\nattribute float a_rndSeed;\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord;\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\n    vec4 a = texture2D(tex, coord);\n    vec4 b = texture2D(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    return mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\n    vec4 a = texture2D(tex, coord);\n    vec4 b = texture2D(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    w = mix(a.w, b.w, c);\n    return mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom (float seed) {\n  seed = mod(seed, 233280.);\n  float q = (seed * 9301. + 49297.) / 233280.;\n  return fract(q);\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D color_over_time_tex0;\n  uniform int u_color_mode;\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D rotation_over_time_tex0;\n  uniform int u_rotation_mode;\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D size_over_time_tex0;\n  uniform int u_size_mode;\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D force_over_time_tex0;\n  uniform int u_force_mode;\nuniform int u_force_space;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D velocity_over_time_tex0;\n  uniform int u_velocity_mode;\nuniform int u_velocity_space;\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\n  uniform sampler2D texture_animation_tex0;\n  uniform vec4 u_anim_info;\n#endif\nfloat repeat (float t, float length) {\n  return t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\n  vec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\n  vec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\n  return vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\n  float activeTime = u_timeDelta.x - a_position_starttime.w;\n  float normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\n  vec2 timeCoord0 = vec2(normalizedTime, 0.);\n  vec2 timeCoord1 = vec2(normalizedTime, 1.);\n  #if CC_RENDER_MODE == 4\n    vec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n  #else\n    vec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n  #endif\n  vec4 velocity = vec4(a_dir_life.xyz, 0.);\n  vec4 pos = vec4(a_position_starttime.xyz, 1.);\n  vec3 size = a_size_uv.xyz;\n  #if SIZE_OVER_TIME_MODULE_ENABLE\n    if (u_size_mode == 1) {\n      size *= unpackCurveData(size_over_time_tex0, timeCoord0);\n    } else {\n      vec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\n      vec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\n      float factor_s = pseudoRandom(a_rndSeed + 39825.);\n      size *= mix(size_0, size_1, factor_s);\n    }\n  #endif\n  vec3 compScale = scale.xyz * size;\n  #if FORCE_OVER_TIME_MODULE_ENABLE\n    vec3 forceAnim = vec3(0.);\n    if (u_force_mode == 1) {\n      forceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n    } else {\n      vec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\n      vec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\n      float factor_f =  pseudoRandom(a_rndSeed + 212165.);\n      forceAnim = mix(force_0, force_1, factor_f);\n    }\n    vec4 forceTrack = vec4(forceAnim, 0.);\n    if (u_force_space == 0) {\n      forceTrack = rotateQuat(forceTrack, u_worldRot);\n    }\n    velocity.xyz += forceTrack.xyz;\n  #endif\n  #if VELOCITY_OVER_TIME_MODULE_ENABLE\n    float speedModifier0 = 1.;\n    float speedModifier1 = 1.;\n    vec3 velocityAnim = vec3(0.);\n    if (u_velocity_mode == 1) {\n      velocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n    } else {\n      vec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n      vec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\n      float factor_v = pseudoRandom(a_rndSeed + 197866.);\n      velocityAnim = mix(vectory_0, vectory_1, factor_v);\n      speedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n    }\n    vec4 velocityTrack = vec4(velocityAnim, 0.);\n    if (u_velocity_space == 0) {\n      velocityTrack = rotateQuat(velocityTrack, u_worldRot);\n    }\n    velocity.xyz += velocityTrack.xyz;\n    velocity.xyz *= speedModifier0;\n  #endif\n  pos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = rotateQuat(velocity, u_worldRot);\n    #endif\n  #endif\n  vec3 rotation = a_rotation_uv.xyz;\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    if (u_rotation_mode == 1) {\n      rotation += unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\n    } else {\n      vec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\n      vec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\n      float factor_r = pseudoRandom(a_rndSeed + 125292.);\n      rotation += mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n    }\n  #endif\n  #if COLOR_OVER_TIME_MODULE_ENABLE\n    if (u_color_mode == 1) {\n      color = a_color * texture2D(color_over_time_tex0, timeCoord0);\n    } else {\n      vec4 color_0 = texture2D(color_over_time_tex0, timeCoord0);\n      vec4 color_1 = texture2D(color_over_time_tex0, timeCoord1);\n      float factor_c = pseudoRandom(a_rndSeed + 91041.);\n      color = a_color * mix(color_0, color_1, factor_c);\n    }\n  #else\n    color = a_color;\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((vertIdx - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = rotation.xyz;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., rotation.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n      #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n        , cc_matViewInv\n      #endif\n      #if CC_RENDER_MODE == 1\n        , cc_cameraPos.xyz\n        , velocity\n        , frameTile_velLenScale.z\n        , frameTile_velLenScale.w\n        , a_size_uv.w\n      #endif\n    );\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(rotation), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(rotation), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color *= a_color1;\n  #endif\n  pos = cc_matViewProj * pos;\n  float frameIndex = 0.;\n  #if TEXTURE_ANIMATION_MODULE_ENABLE\n    float startFrame = 0.;\n    vec3 frameInfo = vec3(0.);\n    if (int(u_anim_info.x) == 1) {\n      frameInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n    } else {\n      vec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\n      vec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\n      float factor_t = pseudoRandom(a_rndSeed + 90794.);\n      frameInfo = mix(frameInfo0, frameInfo1, factor_t);\n    }\n    startFrame = frameInfo.x / u_anim_info.y;\n    frameIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n  #endif\n  uv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  return pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
        "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCLocal",
            "defines": []
          }],
          "samplers": []
        }
      },
      "defines": [{
        "name": "CC_RENDER_MODE",
        "type": "number",
        "range": [0, 4]
      }, {
        "name": "COLOR_OVER_TIME_MODULE_ENABLE",
        "type": "boolean"
      }, {
        "name": "ROTATION_OVER_TIME_MODULE_ENABLE",
        "type": "boolean"
      }, {
        "name": "SIZE_OVER_TIME_MODULE_ENABLE",
        "type": "boolean"
      }, {
        "name": "FORCE_OVER_TIME_MODULE_ENABLE",
        "type": "boolean"
      }, {
        "name": "VELOCITY_OVER_TIME_MODULE_ENABLE",
        "type": "boolean"
      }, {
        "name": "TEXTURE_ANIMATION_MODULE_ENABLE",
        "type": "boolean"
      }, {
        "name": "CC_USE_WORLD_SPACE",
        "type": "boolean"
      }, {
        "name": "CC_USE_HDR",
        "type": "boolean"
      }],
      "blocks": [{
        "name": "Constants",
        "defines": [],
        "binding": 0,
        "members": [{
          "name": "mainTiling_Offset",
          "type": 16,
          "count": 1
        }, {
          "name": "frameTile_velLenScale",
          "type": 16,
          "count": 1
        }, {
          "name": "scale",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "SampleConstants",
        "defines": [],
        "binding": 1,
        "members": [{
          "name": "u_sampleInfo",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "TickConstants",
        "defines": [],
        "binding": 2,
        "members": [{
          "name": "u_worldRot",
          "type": 16,
          "count": 1
        }, {
          "name": "u_timeDelta",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "ColorConstant",
        "defines": ["COLOR_OVER_TIME_MODULE_ENABLE"],
        "binding": 3,
        "members": [{
          "name": "u_color_mode",
          "type": 5,
          "count": 1
        }]
      }, {
        "name": "RotationConstant",
        "defines": ["ROTATION_OVER_TIME_MODULE_ENABLE"],
        "binding": 4,
        "members": [{
          "name": "u_rotation_mode",
          "type": 5,
          "count": 1
        }]
      }, {
        "name": "SizeConstant",
        "defines": ["SIZE_OVER_TIME_MODULE_ENABLE"],
        "binding": 5,
        "members": [{
          "name": "u_size_mode",
          "type": 5,
          "count": 1
        }]
      }, {
        "name": "ForceConstant",
        "defines": ["FORCE_OVER_TIME_MODULE_ENABLE"],
        "binding": 6,
        "members": [{
          "name": "u_force_mode",
          "type": 5,
          "count": 1
        }, {
          "name": "u_force_space",
          "type": 5,
          "count": 1
        }]
      }, {
        "name": "VelocityConstant",
        "defines": ["VELOCITY_OVER_TIME_MODULE_ENABLE"],
        "binding": 7,
        "members": [{
          "name": "u_velocity_mode",
          "type": 5,
          "count": 1
        }, {
          "name": "u_velocity_space",
          "type": 5,
          "count": 1
        }]
      }, {
        "name": "AnimationConstant",
        "defines": ["TEXTURE_ANIMATION_MODULE_ENABLE"],
        "binding": 8,
        "members": [{
          "name": "u_anim_info",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "FragConstants",
        "defines": [],
        "binding": 9,
        "members": [{
          "name": "tintColor",
          "type": 16,
          "count": 1
        }]
      }],
      "samplers": [{
        "name": "color_over_time_tex0",
        "type": 28,
        "count": 1,
        "defines": ["COLOR_OVER_TIME_MODULE_ENABLE"],
        "binding": 31
      }, {
        "name": "rotation_over_time_tex0",
        "type": 28,
        "count": 1,
        "defines": ["ROTATION_OVER_TIME_MODULE_ENABLE"],
        "binding": 32
      }, {
        "name": "size_over_time_tex0",
        "type": 28,
        "count": 1,
        "defines": ["SIZE_OVER_TIME_MODULE_ENABLE"],
        "binding": 33
      }, {
        "name": "force_over_time_tex0",
        "type": 28,
        "count": 1,
        "defines": ["FORCE_OVER_TIME_MODULE_ENABLE"],
        "binding": 34
      }, {
        "name": "velocity_over_time_tex0",
        "type": 28,
        "count": 1,
        "defines": ["VELOCITY_OVER_TIME_MODULE_ENABLE"],
        "binding": 35
      }, {
        "name": "texture_animation_tex0",
        "type": 28,
        "count": 1,
        "defines": ["TEXTURE_ANIMATION_MODULE_ENABLE"],
        "binding": 36
      }, {
        "name": "mainTexture",
        "type": 28,
        "count": 1,
        "defines": [],
        "binding": 37
      }],
      "attributes": [{
        "name": "a_position_starttime",
        "type": 16,
        "count": 1,
        "defines": [],
        "format": 43,
        "location": 0
      }, {
        "name": "a_size_uv",
        "type": 16,
        "count": 1,
        "defines": [],
        "format": 43,
        "location": 1
      }, {
        "name": "a_rotation_uv",
        "type": 16,
        "count": 1,
        "defines": [],
        "format": 43,
        "location": 2
      }, {
        "name": "a_color",
        "type": 16,
        "count": 1,
        "defines": [],
        "format": 43,
        "location": 3
      }, {
        "name": "a_dir_life",
        "type": 16,
        "count": 1,
        "defines": [],
        "format": 43,
        "location": 4
      }, {
        "name": "a_rndSeed",
        "type": 13,
        "count": 1,
        "defines": [],
        "format": 11,
        "location": 5
      }, {
        "name": "a_texCoord",
        "type": 15,
        "count": 1,
        "defines": ["CC_RENDER_MODE"],
        "format": 32,
        "location": 6
      }, {
        "name": "a_texCoord3",
        "type": 15,
        "count": 1,
        "defines": ["CC_RENDER_MODE"],
        "format": 32,
        "location": 7
      }, {
        "name": "a_normal",
        "type": 15,
        "count": 1,
        "defines": ["CC_RENDER_MODE"],
        "format": 32,
        "location": 8
      }, {
        "name": "a_color1",
        "type": 16,
        "count": 1,
        "defines": ["CC_RENDER_MODE"],
        "format": 43,
        "location": 9
      }]
    }]
  }, {
    "name": "builtin-particle-trail",
    "_uuid": "17debcc3-0a6b-4b8a-b00b-dc58b885581e",
    "techniques": [{
      "name": "add",
      "passes": [{
        "rasterizerState": {
          "cullMode": 0
        },
        "blendState": {
          "targets": [{
            "blend": true,
            "blendSrc": 2,
            "blendDst": 1,
            "blendSrcAlpha": 2,
            "blendDstAlpha": 1
          }]
        },
        "program": "builtin-particle-trail|particle-trail:vs_main|tinted-fs:add",
        "depthStencilState": {
          "depthTest": true,
          "depthWrite": false
        },
        "properties": {
          "mainTexture": {
            "value": "grey",
            "type": 28
          },
          "mainTiling_Offset": {
            "value": [1, 1, 0, 0],
            "type": 16
          },
          "frameTile_velLenScale": {
            "value": [1, 1, 0, 0],
            "type": 16
          },
          "tintColor": {
            "value": [0.5, 0.5, 0.5, 0.5],
            "type": 16
          }
        }
      }]
    }],
    "shaders": [{
      "name": "builtin-particle-trail|particle-trail:vs_main|tinted-fs:add",
      "hash": 535523547,
      "glsl3": {
        "vert": "\nprecision mediump float;\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout vec2 uv;\nout vec4 color;\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
        "frag": "\n  precision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  in vec2 uv;\n  in vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    in vec3 vBarycentric;\n  #endif\n  uniform sampler2D mainTexture;\n  uniform FragConstants {\n    vec4 tintColor;\n  };\n  vec4 add () {\n    vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., 1.);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
      },
      "glsl1": {
        "vert": "\nprecision mediump float;\nuniform vec4 mainTiling_Offset;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  varying vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
        "frag": "\n  precision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  varying vec2 uv;\n  varying vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    varying vec3 vBarycentric;\n  #endif\n  uniform sampler2D mainTexture;\n  uniform vec4 tintColor;\n  vec4 add () {\n    vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., 1.);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nvoid main() { gl_FragColor = add(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCLocal",
            "defines": []
          }],
          "samplers": []
        }
      },
      "defines": [{
        "name": "CC_RENDER_MODE",
        "type": "number",
        "range": [0, 4]
      }, {
        "name": "CC_DRAW_WIRE_FRAME",
        "type": "boolean"
      }, {
        "name": "CC_USE_WORLD_SPACE",
        "type": "boolean"
      }, {
        "name": "CC_USE_HDR",
        "type": "boolean"
      }],
      "blocks": [{
        "name": "Constants",
        "defines": [],
        "binding": 0,
        "members": [{
          "name": "mainTiling_Offset",
          "type": 16,
          "count": 1
        }, {
          "name": "frameTile_velLenScale",
          "type": 16,
          "count": 1
        }, {
          "name": "scale",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "FragConstants",
        "defines": [],
        "binding": 1,
        "members": [{
          "name": "tintColor",
          "type": 16,
          "count": 1
        }]
      }],
      "samplers": [{
        "name": "mainTexture",
        "type": 28,
        "count": 1,
        "defines": [],
        "binding": 31
      }],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "format": 32,
        "location": 0
      }, {
        "name": "a_texCoord",
        "type": 16,
        "count": 1,
        "defines": [],
        "format": 43,
        "location": 1
      }, {
        "name": "a_texCoord1",
        "type": 15,
        "count": 1,
        "defines": [],
        "format": 32,
        "location": 2
      }, {
        "name": "a_texCoord2",
        "type": 15,
        "count": 1,
        "defines": [],
        "format": 32,
        "location": 3
      }, {
        "name": "a_color",
        "type": 16,
        "count": 1,
        "defines": [],
        "format": 43,
        "location": 4
      }]
    }]
  }, {
    "name": "builtin-particle",
    "_uuid": "d1346436-ac96-4271-b863-1f4fdead95b0",
    "techniques": [{
      "name": "add",
      "passes": [{
        "rasterizerState": {
          "cullMode": 0
        },
        "blendState": {
          "targets": [{
            "blend": true,
            "blendSrc": 2,
            "blendDst": 1,
            "blendSrcAlpha": 2,
            "blendDstAlpha": 1
          }]
        },
        "program": "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
        "depthStencilState": {
          "depthTest": true,
          "depthWrite": false
        },
        "properties": {
          "mainTexture": {
            "value": "grey",
            "type": 28
          },
          "mainTiling_Offset": {
            "value": [1, 1, 0, 0],
            "type": 16
          },
          "tintColor": {
            "value": [0.5, 0.5, 0.5, 0.5],
            "type": 16
          }
        }
      }]
    }],
    "shaders": [{
      "name": "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
      "hash": 2171161221,
      "glsl3": {
        "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout vec2 uv;\nout vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
        "frag": "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nuniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying vec2 uv;\nvarying vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
        "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCLocal",
            "defines": []
          }],
          "samplers": []
        }
      },
      "defines": [{
        "name": "CC_RENDER_MODE",
        "type": "number",
        "range": [0, 4]
      }, {
        "name": "CC_USE_WORLD_SPACE",
        "type": "boolean"
      }, {
        "name": "CC_USE_HDR",
        "type": "boolean"
      }],
      "blocks": [{
        "name": "Constants",
        "defines": [],
        "binding": 0,
        "members": [{
          "name": "mainTiling_Offset",
          "type": 16,
          "count": 1
        }, {
          "name": "frameTile_velLenScale",
          "type": 16,
          "count": 1
        }, {
          "name": "scale",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "FragConstants",
        "defines": [],
        "binding": 1,
        "members": [{
          "name": "tintColor",
          "type": 16,
          "count": 1
        }]
      }],
      "samplers": [{
        "name": "mainTexture",
        "type": 28,
        "count": 1,
        "defines": [],
        "binding": 31
      }],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "format": 32,
        "location": 0
      }, {
        "name": "a_texCoord",
        "type": 15,
        "count": 1,
        "defines": [],
        "format": 32,
        "location": 1
      }, {
        "name": "a_texCoord1",
        "type": 15,
        "count": 1,
        "defines": [],
        "format": 32,
        "location": 2
      }, {
        "name": "a_texCoord2",
        "type": 15,
        "count": 1,
        "defines": [],
        "format": 32,
        "location": 3
      }, {
        "name": "a_color",
        "type": 16,
        "count": 1,
        "defines": [],
        "format": 43,
        "location": 4
      }, {
        "name": "a_color1",
        "type": 15,
        "count": 1,
        "defines": ["CC_RENDER_MODE"],
        "format": 32,
        "location": 5
      }, {
        "name": "a_texCoord3",
        "type": 15,
        "count": 1,
        "defines": ["CC_RENDER_MODE"],
        "format": 32,
        "location": 6
      }, {
        "name": "a_normal",
        "type": 15,
        "count": 1,
        "defines": ["CC_RENDER_MODE"],
        "format": 32,
        "location": 7
      }]
    }]
  }, {
    "name": "builtin-sprite",
    "_uuid": "60f7195c-ec2a-45eb-ba94-8955f60e81d0",
    "techniques": [{
      "passes": [{
        "blendState": {
          "targets": [{
            "blend": true,
            "blendSrc": 2,
            "blendDst": 4,
            "blendDstAlpha": 4
          }]
        },
        "rasterizerState": {
          "cullMode": 0
        },
        "program": "builtin-sprite|sprite-vs:vert|sprite-fs:frag",
        "priority": 244,
        "depthStencilState": {
          "depthTest": false,
          "depthWrite": false
        },
        "properties": {
          "mainTexture": {
            "value": "white",
            "type": 28
          }
        }
      }]
    }],
    "shaders": [{
      "name": "builtin-sprite|sprite-vs:vert|sprite-fs:frag",
      "hash": 447598955,
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\n#if USE_LOCAL\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nin vec3 a_position;\nin vec4 a_color;\nout vec4 color;\nin vec2 a_texCoord;\nout vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nin vec4 color;\n#if USE_TEXTURE\n  in vec2 uv0;\n  uniform sampler2D mainTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture(mainTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  return o;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 color;\nattribute vec2 a_texCoord;\nvarying vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nvarying vec4 color;\n#if USE_TEXTURE\n  varying vec2 uv0;\n  uniform sampler2D mainTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCLocal",
            "defines": ["USE_LOCAL"]
          }],
          "samplers": []
        }
      },
      "defines": [{
        "name": "USE_LOCAL",
        "type": "boolean"
      }, {
        "name": "USE_TEXTURE",
        "type": "boolean"
      }, {
        "name": "IS_GRAY",
        "type": "boolean"
      }],
      "blocks": [],
      "samplers": [{
        "name": "mainTexture",
        "type": 28,
        "count": 1,
        "defines": ["USE_TEXTURE"],
        "binding": 31
      }],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "format": 32,
        "location": 0
      }, {
        "name": "a_color",
        "type": 16,
        "count": 1,
        "defines": [],
        "format": 43,
        "location": 1
      }, {
        "name": "a_texCoord",
        "type": 14,
        "count": 1,
        "defines": [],
        "format": 21,
        "location": 2
      }]
    }]
  }, {
    "name": "builtin-standard",
    "_uuid": "1baf0fc9-befa-459c-8bdd-af1a450a0319",
    "techniques": [{
      "name": "opaque",
      "passes": [{
        "program": "builtin-standard|standard-vs:vert|standard-fs:frag",
        "properties": {
          "tilingOffset": {
            "value": [1, 1, 0, 0],
            "type": 16
          },
          "mainColor": {
            "value": [1, 1, 1, 1],
            "type": 16,
            "handleInfo": ["albedo", 0, 16]
          },
          "albedoScale": {
            "value": [1, 1, 1],
            "type": 15,
            "handleInfo": ["albedoScaleAndCutoff", 0, 15]
          },
          "alphaThreshold": {
            "value": [0.5],
            "type": 13,
            "handleInfo": ["albedoScaleAndCutoff", 3, 13]
          },
          "occlusion": {
            "value": [1],
            "type": 13,
            "handleInfo": ["pbrParams", 0, 13]
          },
          "roughness": {
            "value": [0.8],
            "type": 13,
            "handleInfo": ["pbrParams", 1, 13]
          },
          "metallic": {
            "value": [0.6],
            "type": 13,
            "handleInfo": ["pbrParams", 2, 13]
          },
          "normalStrenth": {
            "value": [1],
            "type": 13,
            "handleInfo": ["pbrParams", 3, 13]
          },
          "emissive": {
            "value": [0, 0, 0, 1],
            "type": 16
          },
          "emissiveScale": {
            "value": [1, 1, 1],
            "type": 15,
            "handleInfo": ["emissiveScaleParam", 0, 15]
          },
          "mainTexture": {
            "value": "grey",
            "type": 28,
            "handleInfo": ["albedoMap", 0, 28]
          },
          "normalMap": {
            "value": "normal",
            "type": 28
          },
          "pbrMap": {
            "value": "grey",
            "type": 28
          },
          "metallicRoughnessMap": {
            "value": "grey",
            "type": 28
          },
          "occlusionMap": {
            "value": "white",
            "type": 28
          },
          "emissiveMap": {
            "value": "grey",
            "type": 28
          },
          "albedo": {
            "type": 16,
            "value": [1, 1, 1, 1]
          },
          "albedoScaleAndCutoff": {
            "type": 16,
            "value": [1, 1, 1, 0.5]
          },
          "pbrParams": {
            "type": 16,
            "value": [1, 0.8, 0.6, 1]
          },
          "emissiveScaleParam": {
            "type": 16,
            "value": [1, 1, 1, 0]
          },
          "albedoMap": {
            "type": 28,
            "value": "grey"
          }
        }
      }]
    }],
    "shaders": [{
      "name": "builtin-standard|standard-vs:vert|standard-fs:frag",
      "hash": 3284921961,
      "glsl3": {
        "vert": "\nprecision highp float;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\n    vec4 fetchFlatPixel(sampler2D tex, int pixelIndex) {\n        float pixelIndexF = float(pixelIndex);\n        vec2 textureResolution = vec2(float(cc_displacementTextureInfo.x), float(cc_displacementTextureInfo.y));\n        float pixelX = mod(pixelIndexF, textureResolution.x);\n        float pixelY = floor(pixelIndexF / textureResolution.x);\n        vec2 uv = (vec2(pixelX, pixelY) + .5) / textureResolution;\n        return texture(tex, uv);\n    }\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchFlatPixel(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchFlatPixel(tex, iTarget).r);\n        result += (fetchFlatPixel(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_weights;\nin vec4 a_joints;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  uniform sampler2D cc_jointTexture;\n    #if !CC_SUPPORT_FLOAT_TEXTURE\n    highp float decode32 (highp vec4 rgba) {\n      rgba = rgba * 255.0;\n      highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n      highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n      highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n      return Sign * exp2(Exponent - 23.0) * Mantissa;\n    }\n  #endif\n#else\n  uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\n#if USE_VERTEX_COLOR\n  in vec3 a_color;\n  out vec3 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\nin vec2 a_texCoord;\nout vec2 v_uv;\nin vec2 a_texCoord1;\nout vec2 v_uv1;\n#if USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING\n  out vec2 v_luv;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  #if USE_LIGHTMAP && HAS_SECOND_UV && !USE_BATCHING && !USE_INSTANCING\n    v_luv = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n  #endif\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision highp float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform CCForwardLight {\n  highp vec4 cc_sphereLitPos[2];\n  vec4 cc_sphereLitSizeRange[2];\n  vec4 cc_sphereLitColor[2];\n  highp vec4 cc_spotLitPos[2];\n  vec4 cc_spotLitSizeRangeAngle[2];\n  vec4 cc_spotLitDir[2];\n  vec4 cc_spotLitColor[2];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nvec3 CalcDynamicLighting (vec3 worldPos, vec3 N, vec3 V, vec3 diffuse, vec3 specular, float roughness) {\n  vec3 lighting = vec3(0.0);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  for (int i = 0; i < 2; i++) {\n    vec3 PLU = cc_sphereLitPos[i].xyz - worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL + V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    lighting += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  for (int i = 0; i < 2; i++) {\n    vec3 SLU = cc_spotLitPos[i].xyz - worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL + V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    lighting += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  return lighting;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShading (StandardSurface s) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(N, V)), 0.001);\n  float NL = max(dot(N, L), 0.001);\n  float NH = max(dot(N, H), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n  finalColor += CalcDynamicLighting(s.position, N, V, diffuse, specular, s.roughness);\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb);\n    #endif\n    finalColor += env * cc_ambientSky.w * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nuniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\n#if USE_VERTEX_COLOR\n  in vec3 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_LIGHTMAP\n  in vec2 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.OCCLUSION_CHANNEL;\n    pbr.y *= res.ROUGHNESS_CHANNEL;\n    pbr.z *= res.METALLIC_CHANNEL;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);\n    pbr.z *= metallicRoughness.METALLIC_CHANNEL;\n    pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  #if USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING\n    vec4 lighting = texture(cc_lightingMap, v_luv);\n    float fAmb = 0.5 - s.normal.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n    vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);\n    finalColor += lighting.rgb *  s.albedo.rgb;\n    finalColor = finalColor * s.occlusion;\n    finalColor += s.emissive;\n    color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;\n  #endif\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\n    vec4 fetchFlatPixel(sampler2D tex, int pixelIndex) {\n        float pixelIndexF = float(pixelIndex);\n        vec2 textureResolution = vec2(float(cc_displacementTextureInfo.x), float(cc_displacementTextureInfo.y));\n        float pixelX = mod(pixelIndexF, textureResolution.x);\n        float pixelY = floor(pixelIndexF / textureResolution.x);\n        vec2 uv = (vec2(pixelX, pixelY) + .5) / textureResolution;\n        return texture2D(tex, uv);\n    }\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchFlatPixel(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchFlatPixel(tex, iTarget).r);\n        result += (fetchFlatPixel(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_weights;\nattribute vec4 a_joints;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  uniform highp vec4 cc_jointTextureInfo;\n  uniform highp vec4 cc_jointAnimInfo;\n  uniform sampler2D cc_jointTexture;\n    #if !CC_SUPPORT_FLOAT_TEXTURE\n    highp float decode32 (highp vec4 rgba) {\n      rgba = rgba * 255.0;\n      highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n      highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n      highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n      return Sign * exp2(Exponent - 23.0) * Mantissa;\n    }\n  #endif\n#else\n  uniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\nuniform highp vec4 cc_lightingMapUVParam;\n#endif\nuniform vec4 tilingOffset;\n#if USE_VERTEX_COLOR\n  attribute vec3 a_color;\n  varying vec3 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nattribute vec2 a_texCoord1;\nvarying vec2 v_uv1;\n#if USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING\n  varying vec2 v_luv;\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  #if USE_LIGHTMAP && HAS_SECOND_UV && !USE_BATCHING && !USE_INSTANCING\n    v_luv = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n  #endif\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\n  #ifdef GL_EXT_shader_texture_lod\n    #extension GL_EXT_shader_texture_lod : enable\n  #endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nuniform highp vec4 cc_sphereLitPos[2];\nuniform vec4 cc_sphereLitSizeRange[2];\nuniform vec4 cc_sphereLitColor[2];\nuniform highp vec4 cc_spotLitPos[2];\nuniform vec4 cc_spotLitSizeRangeAngle[2];\nuniform vec4 cc_spotLitDir[2];\nuniform vec4 cc_spotLitColor[2];\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nvec3 CalcDynamicLighting (vec3 worldPos, vec3 N, vec3 V, vec3 diffuse, vec3 specular, float roughness) {\n  vec3 lighting = vec3(0.0);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  for (int i = 0; i < 2; i++) {\n    vec3 PLU = cc_sphereLitPos[i].xyz - worldPos;\n    vec3 PL = normalize(PLU);\n    vec3 PH = normalize(PL + V);\n    float PNL = max(dot(N, PL), 0.001);\n    float PNH = max(dot(N, PH), 0.0);\n    float distSqr = dot(PLU, PLU);\n    float litRadius = cc_sphereLitSizeRange[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_sphereLitSizeRange[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    vec3 lspec = specular * CalcSpecular(roughness, PNH, PH, N);\n    lighting += PNL * cc_sphereLitColor[i].rgb * cc_sphereLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  for (int i = 0; i < 2; i++) {\n    vec3 SLU = cc_spotLitPos[i].xyz - worldPos;\n    vec3 SL = normalize(SLU);\n    vec3 SH = normalize(SL + V);\n    float SNL = max(dot(N, SL), 0.001);\n    float SNH = max(dot(N, SH), 0.0);\n    float distSqr = dot(SLU, SLU);\n    float litRadius = cc_spotLitSizeRangeAngle[i].x;\n    float litRadiusSqr = litRadius * litRadius;\n    float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n    float attRadiusSqrInv = 1.0 / max(cc_spotLitSizeRangeAngle[i].y, 0.01);\n    attRadiusSqrInv *= attRadiusSqrInv;\n    float cosInner = max(dot(-cc_spotLitDir[i].xyz, SL), 0.01);\n    float cosOuter = cc_spotLitSizeRangeAngle[i].z;\n    float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n    float litAngleOffset = -cosOuter * litAngleScale;\n    float att = GetDistAtt(distSqr, attRadiusSqrInv);\n    att *= GetAngleAtt(SL, -cc_spotLitDir[i].xyz, litAngleScale, litAngleOffset);\n    vec3 lspec = specular * CalcSpecular(roughness, SNH, SH, N);\n    lighting += SNL * cc_spotLitColor[i].rgb * cc_spotLitColor[i].w * illum * att * (diffuseContrib + lspec);\n  }\n  return lighting;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\nvec4 CCStandardShading (StandardSurface s) {\n  vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n  vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n  vec3 N = normalize(s.normal);\n  vec3 V = normalize(cc_cameraPos.xyz - s.position);\n  vec3 L = normalize(-cc_mainLitDir.xyz);\n  vec3 H = normalize(L+V);\n  float NV = max(abs(dot(N, V)), 0.001);\n  float NL = max(dot(N, L), 0.001);\n  float NH = max(dot(N, H), 0.0);\n  specular = BRDFApprox(specular, s.roughness, NV);\n  vec3 diffuseContrib = diffuse / 3.14159265359;\n  vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n  vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w * (diffuseContrib + specularContrib);\n  finalColor += CalcDynamicLighting(s.position, N, V, diffuse, specular, s.roughness);\n  float fAmb = 0.5 - N.y * 0.5;\n  vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n  finalColor += (ambDiff.rgb * diffuse);\n  #if CC_USE_IBL\n    vec3 R = normalize(reflect(-V, N));\n    vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n    #if CC_USE_IBL == 2\n      vec3 env = unpackRGBE(envmap);\n    #else\n      vec3 env = SRGBToLinear(envmap.rgb);\n    #endif\n    finalColor += env * cc_ambientSky.w * specular;\n  #endif\n  finalColor = finalColor * s.occlusion;\n  #if CC_USE_HDR\n    s.emissive *= cc_exposure.w;\n  #endif\n  finalColor += s.emissive;\n  return vec4(finalColor, s.albedo.a);\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nuniform vec4 pbrParams;\nuniform vec4 emissive;\nuniform vec4 emissiveScaleParam;\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\n#if USE_VERTEX_COLOR\n  varying vec3 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_LIGHTMAP\n  varying vec2 v_luv;\n  uniform sampler2D cc_lightingMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.OCCLUSION_CHANNEL;\n    pbr.y *= res.ROUGHNESS_CHANNEL;\n    pbr.z *= res.METALLIC_CHANNEL;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, METALLIC_ROUGHNESS_UV);\n    pbr.z *= metallicRoughness.METALLIC_CHANNEL;\n    pbr.y *= metallicRoughness.ROUGHNESS_CHANNEL;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, OCCLUSION_UV).OCCLUSION_CHANNEL;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  #if USE_LIGHTMAP && !USE_BATCHING && !USE_INSTANCING\n    vec4 lighting = texture2D(cc_lightingMap, v_luv);\n    float fAmb = 0.5 - s.normal.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n    vec3 finalColor = (ambDiff.rgb * s.albedo.rgb);\n    finalColor += lighting.rgb *  s.albedo.rgb;\n    finalColor = finalColor * s.occlusion;\n    finalColor += s.emissive;\n    color.rgb = lighting.a * finalColor + (1.0 - lighting.a) * color.rgb;\n  #endif\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": [{
            "name": "cc_environment",
            "defines": ["CC_USE_IBL"]
          }]
        },
        "locals": {
          "blocks": [{
            "name": "CCMorph",
            "defines": ["CC_USE_MORPH"]
          }, {
            "name": "CCSkinningTexture",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCSkinningAnimation",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCSkinning",
            "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCLocalBatched",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"]
          }, {
            "name": "CCLocal",
            "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
          }, {
            "name": "CCForwardLight",
            "defines": []
          }],
          "samplers": [{
            "name": "cc_PositionDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
          }, {
            "name": "cc_NormalDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
          }, {
            "name": "cc_TangentDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
          }, {
            "name": "cc_jointTexture",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "cc_lightingMap",
            "defines": ["USE_LIGHTMAP"]
          }]
        }
      },
      "defines": [{
        "name": "CC_USE_MORPH",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_COUNT",
        "type": "number",
        "range": [2, 8]
      }, {
        "name": "CC_MORPH_PRECOMPUTED",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_POSITION",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_NORMAL",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_TANGENT",
        "type": "boolean"
      }, {
        "name": "CC_USE_SKINNING",
        "type": "boolean"
      }, {
        "name": "CC_USE_BAKED_ANIMATION",
        "type": "boolean"
      }, {
        "name": "USE_INSTANCING",
        "type": "boolean"
      }, {
        "name": "CC_SUPPORT_FLOAT_TEXTURE",
        "type": "boolean"
      }, {
        "name": "USE_BATCHING",
        "type": "boolean"
      }, {
        "name": "USE_VERTEX_COLOR",
        "type": "boolean"
      }, {
        "name": "USE_NORMAL_MAP",
        "type": "boolean"
      }, {
        "name": "USE_LIGHTMAP",
        "type": "boolean"
      }, {
        "name": "HAS_SECOND_UV",
        "type": "boolean"
      }, {
        "name": "CC_USE_IBL",
        "type": "number",
        "range": [0, 2]
      }, {
        "name": "CC_USE_HDR",
        "type": "boolean"
      }, {
        "name": "USE_ALBEDO_MAP",
        "type": "boolean"
      }, {
        "name": "ALBEDO_UV",
        "type": "string",
        "options": ["v_uv", "v_uv1"]
      }, {
        "name": "NORMAL_UV",
        "type": "string",
        "options": ["v_uv", "v_uv1"]
      }, {
        "name": "USE_PBR_MAP",
        "type": "boolean"
      }, {
        "name": "PBR_UV",
        "type": "string",
        "options": ["v_uv", "v_uv1"]
      }, {
        "name": "USE_METALLIC_ROUGHNESS_MAP",
        "type": "boolean"
      }, {
        "name": "METALLIC_ROUGHNESS_UV",
        "type": "string",
        "options": ["v_uv", "v_uv1"]
      }, {
        "name": "USE_OCCLUSION_MAP",
        "type": "boolean"
      }, {
        "name": "OCCLUSION_UV",
        "type": "string",
        "options": ["v_uv", "v_uv1"]
      }, {
        "name": "USE_EMISSIVE_MAP",
        "type": "boolean"
      }, {
        "name": "EMISSIVE_UV",
        "type": "string",
        "options": ["v_uv", "v_uv1"]
      }, {
        "name": "OCCLUSION_CHANNEL",
        "type": "string",
        "options": ["r", "g", "b"]
      }, {
        "name": "ROUGHNESS_CHANNEL",
        "type": "string",
        "options": ["g", "b", "r"]
      }, {
        "name": "METALLIC_CHANNEL",
        "type": "string",
        "options": ["b", "r", "g"]
      }, {
        "name": "USE_ALPHA_TEST",
        "type": "boolean"
      }, {
        "name": "ALPHA_TEST_CHANNEL",
        "type": "string",
        "options": ["a", "r"]
      }],
      "blocks": [{
        "name": "Constants",
        "defines": [],
        "binding": 0,
        "members": [{
          "name": "tilingOffset",
          "type": 16,
          "count": 1
        }, {
          "name": "albedo",
          "type": 16,
          "count": 1
        }, {
          "name": "albedoScaleAndCutoff",
          "type": 16,
          "count": 1
        }, {
          "name": "pbrParams",
          "type": 16,
          "count": 1
        }, {
          "name": "emissive",
          "type": 16,
          "count": 1
        }, {
          "name": "emissiveScaleParam",
          "type": 16,
          "count": 1
        }]
      }],
      "samplers": [{
        "name": "albedoMap",
        "type": 28,
        "count": 1,
        "defines": ["USE_ALBEDO_MAP"],
        "binding": 31
      }, {
        "name": "normalMap",
        "type": 28,
        "count": 1,
        "defines": ["USE_NORMAL_MAP"],
        "binding": 32
      }, {
        "name": "pbrMap",
        "type": 28,
        "count": 1,
        "defines": ["USE_PBR_MAP"],
        "binding": 33
      }, {
        "name": "metallicRoughnessMap",
        "type": 28,
        "count": 1,
        "defines": ["USE_METALLIC_ROUGHNESS_MAP"],
        "binding": 34
      }, {
        "name": "occlusionMap",
        "type": 28,
        "count": 1,
        "defines": ["USE_OCCLUSION_MAP"],
        "binding": 35
      }, {
        "name": "emissiveMap",
        "type": 28,
        "count": 1,
        "defines": ["USE_EMISSIVE_MAP"],
        "binding": 36
      }],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "format": 32,
        "location": 0
      }, {
        "name": "a_normal",
        "type": 15,
        "count": 1,
        "defines": [],
        "format": 32,
        "location": 1
      }, {
        "name": "a_tangent",
        "type": 16,
        "count": 1,
        "defines": [],
        "format": 43,
        "location": 2
      }, {
        "name": "a_vertexId",
        "type": 13,
        "count": 1,
        "defines": ["CC_USE_MORPH"],
        "format": 11,
        "location": 3
      }, {
        "name": "a_weights",
        "type": 16,
        "count": 1,
        "defines": ["CC_USE_SKINNING"],
        "format": 43,
        "location": 4
      }, {
        "name": "a_joints",
        "type": 16,
        "count": 1,
        "defines": ["CC_USE_SKINNING"],
        "format": 43,
        "location": 5
      }, {
        "name": "a_jointAnimInfo",
        "type": 16,
        "count": 1,
        "precision": "highp ",
        "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
        "format": 43,
        "isInstanced": true,
        "location": 6
      }, {
        "name": "a_matWorld0",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "format": 43,
        "isInstanced": true,
        "location": 7
      }, {
        "name": "a_matWorld1",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "format": 43,
        "isInstanced": true,
        "location": 8
      }, {
        "name": "a_matWorld2",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "format": 43,
        "isInstanced": true,
        "location": 9
      }, {
        "name": "a_dyn_batch_id",
        "type": 13,
        "count": 1,
        "defines": ["!USE_INSTANCING", "USE_BATCHING"],
        "format": 11,
        "location": 10
      }, {
        "name": "a_color",
        "type": 15,
        "count": 1,
        "defines": ["USE_VERTEX_COLOR"],
        "format": 32,
        "location": 11
      }, {
        "name": "a_texCoord",
        "type": 14,
        "count": 1,
        "defines": [],
        "format": 21,
        "location": 12
      }, {
        "name": "a_texCoord1",
        "type": 14,
        "count": 1,
        "defines": [],
        "format": 21,
        "location": 13
      }]
    }]
  }, {
    "name": "builtin-terrain",
    "_uuid": "1d08ef62-a503-4ce2-8b9a-46c90873f7d3",
    "techniques": [{
      "name": "opaque",
      "passes": [{
        "program": "builtin-terrain|terrain-vs:vert|terrain-fs:frag",
        "properties": {
          "UVScale": {
            "value": [1, 1, 1, 1],
            "type": 16
          },
          "lightMapUVParam": {
            "value": [0, 0, 0, 0],
            "type": 16
          },
          "weightMap": {
            "value": "black",
            "type": 28
          },
          "detailMap0": {
            "value": "grey",
            "type": 28
          },
          "detailMap1": {
            "value": "grey",
            "type": 28
          },
          "detailMap2": {
            "value": "grey",
            "type": 28
          },
          "detailMap3": {
            "value": "grey",
            "type": 28
          },
          "lightMap": {
            "value": "grey",
            "type": 28
          }
        }
      }]
    }],
    "shaders": [{
      "name": "builtin-terrain|terrain-vs:vert|terrain-fs:frag",
      "hash": 29493851,
      "glsl3": {
        "vert": "\n  precision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n  in vec3 a_position;\n  in vec3 a_normal;\n  in vec2 a_texCoord;\n  out vec2 uvw;\n  out vec2 uv0;\n  out vec2 uv1;\n  out vec2 uv2;\n  out vec2 uv3;\n  out vec2 luv;\n  out vec3 diffuse;\n  uniform TexCoords {\n    vec4 UVScale;\n    vec4 lightMapUVParam;\n  };\n  vec4 vert () {\n    vec3 worldPos;\n    worldPos.x = cc_matWorld[3][0] + a_position.x;\n    worldPos.y = cc_matWorld[3][1] + a_position.y;\n    worldPos.z = cc_matWorld[3][2] + a_position.z;\n    vec4 pos = vec4(worldPos, 1);\n    pos = cc_matViewProj * pos;\n    uvw = a_texCoord;\n    uv0 = a_position.xz * UVScale.x;\n    uv1 = a_position.xz * UVScale.y;\n    uv2 = a_position.xz * UVScale.z;\n    uv3 = a_position.xz * UVScale.w;\n    float fAmb = dot(a_normal, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n#if LIGHT_MAP == 0\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 N = a_normal;\n    diffuse = ambDiff + vec3(dot(N, L)) * cc_mainLitColor.rgb;\n#else\n    diffuse = ambDiff;\n    luv = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\n#endif\n    return pos;\n  }\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  in vec2 uvw;\n  in vec2 uv0;\n  in vec2 uv1;\n  in vec2 uv2;\n  in vec2 uv3;\n  in vec3 diffuse;\n  in vec2 luv;\n  uniform sampler2D weightMap;\n  uniform sampler2D detailMap0;\n  uniform sampler2D detailMap1;\n  uniform sampler2D detailMap2;\n  uniform sampler2D detailMap3;\n  uniform sampler2D lightMap;\nvec4 frag () {\n  vec4 color = vec4(0, 0, 0, 0);\n  #if LAYERS == 1\n    color = texture(detailMap0, uv0);\n  #elif LAYERS == 2\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n  #elif LAYERS == 3\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n  #elif LAYERS == 4\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n    color += texture(detailMap3, uv3) * w.a;\n  #else\n    color = texture(detailMap0, uv0);\n  #endif\n  vec3 lighting = diffuse;\n  #if LIGHT_MAP == 1\n    lighting += texture(lightMap, luv).rgb;\n  #endif\n  color.rgb *= lighting;\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "glsl1": {
        "vert": "\n  precision mediump float;\nuniform highp mat4 cc_matViewProj;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform highp mat4 cc_matWorld;\n  attribute vec3 a_position;\n  attribute vec3 a_normal;\n  attribute vec2 a_texCoord;\n  varying vec2 uvw;\n  varying vec2 uv0;\n  varying vec2 uv1;\n  varying vec2 uv2;\n  varying vec2 uv3;\n  varying vec2 luv;\n  varying vec3 diffuse;\n  uniform vec4 UVScale;\nuniform vec4 lightMapUVParam;\n  vec4 vert () {\n    vec3 worldPos;\n    worldPos.x = cc_matWorld[3][0] + a_position.x;\n    worldPos.y = cc_matWorld[3][1] + a_position.y;\n    worldPos.z = cc_matWorld[3][2] + a_position.z;\n    vec4 pos = vec4(worldPos, 1);\n    pos = cc_matViewProj * pos;\n    uvw = a_texCoord;\n    uv0 = a_position.xz * UVScale.x;\n    uv1 = a_position.xz * UVScale.y;\n    uv2 = a_position.xz * UVScale.z;\n    uv3 = a_position.xz * UVScale.w;\n    float fAmb = dot(a_normal, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n#if LIGHT_MAP == 0\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 N = a_normal;\n    diffuse = ambDiff + vec3(dot(N, L)) * cc_mainLitColor.rgb;\n#else\n    diffuse = ambDiff;\n    luv = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\n#endif\n    return pos;\n  }\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  varying vec2 uvw;\n  varying vec2 uv0;\n  varying vec2 uv1;\n  varying vec2 uv2;\n  varying vec2 uv3;\n  varying vec3 diffuse;\n  varying vec2 luv;\n  uniform sampler2D weightMap;\n  uniform sampler2D detailMap0;\n  uniform sampler2D detailMap1;\n  uniform sampler2D detailMap2;\n  uniform sampler2D detailMap3;\n  uniform sampler2D lightMap;\nvec4 frag () {\n  vec4 color = vec4(0, 0, 0, 0);\n  #if LAYERS == 1\n    color = texture2D(detailMap0, uv0);\n  #elif LAYERS == 2\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n  #elif LAYERS == 3\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n    color += texture2D(detailMap2, uv2) * w.b;\n  #elif LAYERS == 4\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n    color += texture2D(detailMap2, uv2) * w.b;\n    color += texture2D(detailMap3, uv3) * w.a;\n  #else\n    color = texture2D(detailMap0, uv0);\n  #endif\n  vec3 lighting = diffuse;\n  #if LIGHT_MAP == 1\n    lighting += texture2D(lightMap, luv).rgb;\n  #endif\n  color.rgb *= lighting;\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCLocal",
            "defines": []
          }],
          "samplers": []
        }
      },
      "defines": [{
        "name": "LIGHT_MAP",
        "type": "number",
        "range": [0, 3]
      }, {
        "name": "CC_USE_HDR",
        "type": "boolean"
      }, {
        "name": "LAYERS",
        "type": "number",
        "range": [0, 4]
      }],
      "blocks": [{
        "name": "TexCoords",
        "defines": [],
        "binding": 0,
        "members": [{
          "name": "UVScale",
          "type": 16,
          "count": 1
        }, {
          "name": "lightMapUVParam",
          "type": 16,
          "count": 1
        }]
      }],
      "samplers": [{
        "name": "weightMap",
        "type": 28,
        "count": 1,
        "defines": [],
        "binding": 31
      }, {
        "name": "detailMap0",
        "type": 28,
        "count": 1,
        "defines": [],
        "binding": 32
      }, {
        "name": "detailMap1",
        "type": 28,
        "count": 1,
        "defines": [],
        "binding": 33
      }, {
        "name": "detailMap2",
        "type": 28,
        "count": 1,
        "defines": [],
        "binding": 34
      }, {
        "name": "detailMap3",
        "type": 28,
        "count": 1,
        "defines": [],
        "binding": 35
      }, {
        "name": "lightMap",
        "type": 28,
        "count": 1,
        "defines": [],
        "binding": 36
      }],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "format": 32,
        "location": 0
      }, {
        "name": "a_normal",
        "type": 15,
        "count": 1,
        "defines": [],
        "format": 32,
        "location": 1
      }, {
        "name": "a_texCoord",
        "type": 14,
        "count": 1,
        "defines": [],
        "format": 21,
        "location": 2
      }]
    }]
  }, {
    "name": "builtin-unlit",
    "_uuid": "a3cd009f-0ab0-420d-9278-b9fdab939bbc",
    "techniques": [{
      "name": "opaque",
      "passes": [{
        "program": "builtin-unlit|unlit-vs:vert|unlit-fs:frag",
        "properties": {
          "mainTexture": {
            "value": "grey",
            "type": 28
          },
          "tilingOffset": {
            "value": [1, 1, 0, 0],
            "type": 16
          },
          "mainColor": {
            "value": [1, 1, 1, 1],
            "type": 16
          },
          "colorScale": {
            "value": [1, 1, 1],
            "type": 15,
            "handleInfo": ["colorScaleAndCutoff", 0, 15]
          },
          "alphaThreshold": {
            "value": [0.5],
            "type": 13,
            "handleInfo": ["colorScaleAndCutoff", 3, 13]
          },
          "color": {
            "type": 16,
            "handleInfo": ["mainColor", 0, 16]
          },
          "colorScaleAndCutoff": {
            "type": 16,
            "value": [1, 1, 1, 0.5]
          }
        }
      }]
    }],
    "shaders": [{
      "name": "builtin-unlit|unlit-vs:vert|unlit-fs:frag",
      "hash": 2113725771,
      "glsl3": {
        "vert": "\nprecision highp float;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\n    vec4 fetchFlatPixel(sampler2D tex, int pixelIndex) {\n        float pixelIndexF = float(pixelIndex);\n        vec2 textureResolution = vec2(float(cc_displacementTextureInfo.x), float(cc_displacementTextureInfo.y));\n        float pixelX = mod(pixelIndexF, textureResolution.x);\n        float pixelY = floor(pixelIndexF / textureResolution.x);\n        vec2 uv = (vec2(pixelX, pixelY) + .5) / textureResolution;\n        return texture(tex, uv);\n    }\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchFlatPixel(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchFlatPixel(tex, iTarget).r);\n        result += (fetchFlatPixel(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_weights;\nin vec4 a_joints;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  uniform sampler2D cc_jointTexture;\n    #if !CC_SUPPORT_FLOAT_TEXTURE\n    highp float decode32 (highp vec4 rgba) {\n      rgba = rgba * 255.0;\n      highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n      highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n      highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n      return Sign * exp2(Exponent - 23.0) * Mantissa;\n    }\n  #endif\n#else\n  uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\n#if USE_VERTEX_COLOR\n  in vec4 a_color;\n  out vec4 v_color;\n#endif\n#if USE_TEXTURE\n  in vec2 a_texCoord;\n  out vec2 v_uv;\n  uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord;\n    #if FLIP_UV\n      v_uv.y = 1.0 - v_uv.y;\n    #endif\n    v_uv = v_uv * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  in vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nuniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  in vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  return CCFragOutput(o);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\n    vec4 fetchFlatPixel(sampler2D tex, int pixelIndex) {\n        float pixelIndexF = float(pixelIndex);\n        vec2 textureResolution = vec2(float(cc_displacementTextureInfo.x), float(cc_displacementTextureInfo.y));\n        float pixelX = mod(pixelIndexF, textureResolution.x);\n        float pixelY = floor(pixelIndexF / textureResolution.x);\n        vec2 uv = (vec2(pixelX, pixelY) + .5) / textureResolution;\n        return texture2D(tex, uv);\n    }\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchFlatPixel(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchFlatPixel(tex, iTarget).r);\n        result += (fetchFlatPixel(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_weights;\nattribute vec4 a_joints;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  uniform highp vec4 cc_jointTextureInfo;\n  uniform highp vec4 cc_jointAnimInfo;\n  uniform sampler2D cc_jointTexture;\n    #if !CC_SUPPORT_FLOAT_TEXTURE\n    highp float decode32 (highp vec4 rgba) {\n      rgba = rgba * 255.0;\n      highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n      highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n      highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n      return Sign * exp2(Exponent - 23.0) * Mantissa;\n    }\n  #endif\n#else\n  uniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\n#if USE_VERTEX_COLOR\n  attribute vec4 a_color;\n  varying vec4 v_color;\n#endif\n#if USE_TEXTURE\n  attribute vec2 a_texCoord;\n  varying vec2 v_uv;\n  uniform vec4 tilingOffset;\n#endif\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord;\n    #if FLIP_UV\n      v_uv.y = 1.0 - v_uv.y;\n    #endif\n    v_uv = v_uv * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nuniform vec4 mainColor;\nuniform vec4 colorScaleAndCutoff;\n#if USE_VERTEX_COLOR\n  varying vec4 v_color;\n#endif\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  return CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCMorph",
            "defines": ["CC_USE_MORPH"]
          }, {
            "name": "CCSkinningTexture",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCSkinningAnimation",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCSkinning",
            "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCLocalBatched",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"]
          }, {
            "name": "CCLocal",
            "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
          }],
          "samplers": [{
            "name": "cc_PositionDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
          }, {
            "name": "cc_NormalDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
          }, {
            "name": "cc_TangentDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
          }, {
            "name": "cc_jointTexture",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }]
        }
      },
      "defines": [{
        "name": "CC_USE_MORPH",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_COUNT",
        "type": "number",
        "range": [2, 8]
      }, {
        "name": "CC_MORPH_PRECOMPUTED",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_POSITION",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_NORMAL",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_TANGENT",
        "type": "boolean"
      }, {
        "name": "CC_USE_SKINNING",
        "type": "boolean"
      }, {
        "name": "CC_USE_BAKED_ANIMATION",
        "type": "boolean"
      }, {
        "name": "USE_INSTANCING",
        "type": "boolean"
      }, {
        "name": "CC_SUPPORT_FLOAT_TEXTURE",
        "type": "boolean"
      }, {
        "name": "USE_BATCHING",
        "type": "boolean"
      }, {
        "name": "USE_VERTEX_COLOR",
        "type": "boolean"
      }, {
        "name": "USE_TEXTURE",
        "type": "boolean"
      }, {
        "name": "FLIP_UV",
        "type": "boolean"
      }, {
        "name": "CC_USE_HDR",
        "type": "boolean"
      }, {
        "name": "USE_ALPHA_TEST",
        "type": "boolean"
      }, {
        "name": "ALPHA_TEST_CHANNEL",
        "type": "string",
        "options": ["a", "r", "g", "b"]
      }],
      "blocks": [{
        "name": "TexCoords",
        "defines": ["USE_TEXTURE"],
        "binding": 0,
        "members": [{
          "name": "tilingOffset",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "Constant",
        "defines": [],
        "binding": 1,
        "members": [{
          "name": "mainColor",
          "type": 16,
          "count": 1
        }, {
          "name": "colorScaleAndCutoff",
          "type": 16,
          "count": 1
        }]
      }],
      "samplers": [{
        "name": "mainTexture",
        "type": 28,
        "count": 1,
        "defines": ["USE_TEXTURE"],
        "binding": 31
      }],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "format": 32,
        "location": 0
      }, {
        "name": "a_vertexId",
        "type": 13,
        "count": 1,
        "defines": ["CC_USE_MORPH"],
        "format": 11,
        "location": 1
      }, {
        "name": "a_weights",
        "type": 16,
        "count": 1,
        "defines": ["CC_USE_SKINNING"],
        "format": 43,
        "location": 2
      }, {
        "name": "a_joints",
        "type": 16,
        "count": 1,
        "defines": ["CC_USE_SKINNING"],
        "format": 43,
        "location": 3
      }, {
        "name": "a_jointAnimInfo",
        "type": 16,
        "count": 1,
        "precision": "highp ",
        "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
        "format": 43,
        "isInstanced": true,
        "location": 4
      }, {
        "name": "a_matWorld0",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "format": 43,
        "isInstanced": true,
        "location": 5
      }, {
        "name": "a_matWorld1",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "format": 43,
        "isInstanced": true,
        "location": 6
      }, {
        "name": "a_matWorld2",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "format": 43,
        "isInstanced": true,
        "location": 7
      }, {
        "name": "a_dyn_batch_id",
        "type": 13,
        "count": 1,
        "defines": ["!USE_INSTANCING", "USE_BATCHING"],
        "format": 11,
        "location": 8
      }, {
        "name": "a_color",
        "type": 16,
        "count": 1,
        "defines": ["USE_VERTEX_COLOR"],
        "format": 43,
        "location": 9
      }, {
        "name": "a_texCoord",
        "type": 14,
        "count": 1,
        "defines": ["USE_TEXTURE"],
        "format": 21,
        "location": 10
      }]
    }]
  }, {
    "name": "pipeline/planar-shadow",
    "_uuid": "9361fd90-ba52-4f84-aa93-6e878fd576ca",
    "techniques": [{
      "passes": [{
        "phase": "planarShadow",
        "blendState": {
          "targets": [{
            "blend": true,
            "blendSrc": 2,
            "blendDst": 4,
            "blendDstAlpha": 4
          }]
        },
        "program": "pipeline/planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
        "depthStencilState": {
          "depthTest": true,
          "depthWrite": false,
          "stencilTestFront": true,
          "stencilFuncFront": 5,
          "stencilPassOpFront": 2,
          "stencilRefBack": 128,
          "stencilRefFront": 128,
          "stencilReadMaskBack": 128,
          "stencilReadMaskFront": 128,
          "stencilWriteMaskBack": 128,
          "stencilWriteMaskFront": 128
        }
      }]
    }],
    "shaders": [{
      "name": "pipeline/planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
      "hash": 3024494042,
      "glsl3": {
        "vert": "\nprecision highp float;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\n    vec4 fetchFlatPixel(sampler2D tex, int pixelIndex) {\n        float pixelIndexF = float(pixelIndex);\n        vec2 textureResolution = vec2(float(cc_displacementTextureInfo.x), float(cc_displacementTextureInfo.y));\n        float pixelX = mod(pixelIndexF, textureResolution.x);\n        float pixelY = floor(pixelIndexF / textureResolution.x);\n        vec2 uv = (vec2(pixelX, pixelY) + .5) / textureResolution;\n        return texture(tex, uv);\n    }\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchFlatPixel(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchFlatPixel(tex, iTarget).r);\n        result += (fetchFlatPixel(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_weights;\nin vec4 a_joints;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  uniform sampler2D cc_jointTexture;\n    #if !CC_SUPPORT_FLOAT_TEXTURE\n    highp float decode32 (highp vec4 rgba) {\n      rgba = rgba * 255.0;\n      highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n      highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n      highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n      return Sign * exp2(Exponent - 23.0) * Mantissa;\n    }\n  #endif\n#else\n  uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nuniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nuniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  lowp vec4 cc_shadowColor;\n};\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  position = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\n  position.z -= 0.0001;\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nuniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  lowp vec4 cc_shadowColor;\n};\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvec4 frag () {\n  return CCFragOutput(cc_shadowColor);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\n    vec4 fetchFlatPixel(sampler2D tex, int pixelIndex) {\n        float pixelIndexF = float(pixelIndex);\n        vec2 textureResolution = vec2(float(cc_displacementTextureInfo.x), float(cc_displacementTextureInfo.y));\n        float pixelX = mod(pixelIndexF, textureResolution.x);\n        float pixelY = floor(pixelIndexF / textureResolution.x);\n        vec2 uv = (vec2(pixelX, pixelY) + .5) / textureResolution;\n        return texture2D(tex, uv);\n    }\nfloat getDisplacementWeight(int index) {\n    float m = mod(float(index), 4.0);\n    if (m < 1.0) {\n        return cc_displacementWeights[index / 4].x;\n    } else if (m < 2.0) {\n        return cc_displacementWeights[index / 4].y;\n    } else if (m < 3.0) {\n        return cc_displacementWeights[index / 4].z;\n    } else {\n        return cc_displacementWeights[index / 4].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchFlatPixel(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchFlatPixel(tex, iTarget).r);\n        result += (fetchFlatPixel(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_weights;\nattribute vec4 a_joints;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  uniform highp vec4 cc_jointTextureInfo;\n  uniform highp vec4 cc_jointAnimInfo;\n  uniform sampler2D cc_jointTexture;\n    #if !CC_SUPPORT_FLOAT_TEXTURE\n    highp float decode32 (highp vec4 rgba) {\n      rgba = rgba * 255.0;\n      highp float Sign = 1.0 - step(128.0, rgba[3]) * 2.0;\n      highp float Exponent = 2.0 * mod(rgba[3], 128.0) + step(128.0, rgba[2]) - 127.0;\n      highp float Mantissa = mod(rgba[2], 128.0) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n      return Sign * exp2(Exponent - 23.0) * Mantissa;\n    }\n  #endif\n#else\n  uniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\nuniform highp mat4 cc_matLightPlaneProj;\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  position = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\n  position.z -= 0.0001;\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nuniform lowp vec4 cc_shadowColor;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvec4 frag () {\n  return CCFragOutput(cc_shadowColor);\n}\nvoid main() { gl_FragColor = frag(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }, {
            "name": "CCShadow",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [{
            "name": "CCMorph",
            "defines": ["CC_USE_MORPH"]
          }, {
            "name": "CCSkinningTexture",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCSkinningAnimation",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCSkinning",
            "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
          }, {
            "name": "CCLocalBatched",
            "defines": ["!USE_INSTANCING", "USE_BATCHING"]
          }, {
            "name": "CCLocal",
            "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
          }],
          "samplers": [{
            "name": "cc_PositionDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
          }, {
            "name": "cc_NormalDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
          }, {
            "name": "cc_TangentDisplacements",
            "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
          }, {
            "name": "cc_jointTexture",
            "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
          }]
        }
      },
      "defines": [{
        "name": "CC_USE_MORPH",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_COUNT",
        "type": "number",
        "range": [2, 8]
      }, {
        "name": "CC_MORPH_PRECOMPUTED",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_POSITION",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_NORMAL",
        "type": "boolean"
      }, {
        "name": "CC_MORPH_TARGET_HAS_TANGENT",
        "type": "boolean"
      }, {
        "name": "CC_USE_SKINNING",
        "type": "boolean"
      }, {
        "name": "CC_USE_BAKED_ANIMATION",
        "type": "boolean"
      }, {
        "name": "USE_INSTANCING",
        "type": "boolean"
      }, {
        "name": "CC_SUPPORT_FLOAT_TEXTURE",
        "type": "boolean"
      }, {
        "name": "USE_BATCHING",
        "type": "boolean"
      }, {
        "name": "CC_USE_HDR",
        "type": "boolean"
      }],
      "blocks": [],
      "samplers": [],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "format": 32,
        "location": 0
      }, {
        "name": "a_vertexId",
        "type": 13,
        "count": 1,
        "defines": ["CC_USE_MORPH"],
        "format": 11,
        "location": 1
      }, {
        "name": "a_weights",
        "type": 16,
        "count": 1,
        "defines": ["CC_USE_SKINNING"],
        "format": 43,
        "location": 2
      }, {
        "name": "a_joints",
        "type": 16,
        "count": 1,
        "defines": ["CC_USE_SKINNING"],
        "format": 43,
        "location": 3
      }, {
        "name": "a_jointAnimInfo",
        "type": 16,
        "count": 1,
        "precision": "highp ",
        "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
        "format": 43,
        "isInstanced": true,
        "location": 4
      }, {
        "name": "a_matWorld0",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "format": 43,
        "isInstanced": true,
        "location": 5
      }, {
        "name": "a_matWorld1",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "format": 43,
        "isInstanced": true,
        "location": 6
      }, {
        "name": "a_matWorld2",
        "type": 16,
        "count": 1,
        "defines": ["USE_INSTANCING"],
        "format": 43,
        "isInstanced": true,
        "location": 7
      }, {
        "name": "a_dyn_batch_id",
        "type": 13,
        "count": 1,
        "defines": ["!USE_INSTANCING", "USE_BATCHING"],
        "format": 11,
        "location": 8
      }]
    }]
  }, {
    "name": "pipeline/skybox",
    "_uuid": "511d2633-09a7-4bdd-ac42-f778032124b3",
    "techniques": [{
      "passes": [{
        "rasterizerState": {
          "cullMode": 0
        },
        "program": "pipeline/skybox|sky-vs:vert|sky-fs:frag",
        "priority": 245,
        "depthStencilState": {
          "depthTest": true,
          "depthWrite": false
        }
      }]
    }],
    "shaders": [{
      "name": "pipeline/skybox|sky-vs:vert|sky-fs:frag",
      "hash": 1449700672,
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nout vec4 viewDir;\nvec4 vert () {\n  viewDir = vec4(a_position, 1.0);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  vec4 pos = matViewRotOnly * viewDir;\n  vec2 f = cc_matProj[3][3] > 0.0 ? vec2(4.8, 2.4) : vec2(cc_matProj[1][1]);\n  pos.xy *= vec2(cc_screenSize.y * cc_screenSize.z, 1.0) * f;\n  pos.zw = vec2(-0.99999 * pos.z, -pos.z);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nin vec4 viewDir;\nvec4 frag () {\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(texture(cc_environment, viewDir.xyz));\n  #else\n    vec3 c = SRGBToLinear(texture(cc_environment, viewDir.xyz).rgb);\n  #endif\n  return CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mediump vec4 cc_screenSize;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nvarying vec4 viewDir;\nvec4 vert () {\n  viewDir = vec4(a_position, 1.0);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  vec4 pos = matViewRotOnly * viewDir;\n  vec2 f = cc_matProj[3][3] > 0.0 ? vec2(4.8, 2.4) : vec2(cc_matProj[1][1]);\n  pos.xy *= vec2(cc_screenSize.y * cc_screenSize.z, 1.0) * f;\n  pos.zw = vec2(-0.99999 * pos.z, -pos.z);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_ambientSky;\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nvarying vec4 viewDir;\nvec4 frag () {\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(textureCube(cc_environment, viewDir.xyz));\n  #else\n    vec3 c = SRGBToLinear(textureCube(cc_environment, viewDir.xyz).rgb);\n  #endif\n  return CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nvoid main() { gl_FragColor = frag(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": [{
            "name": "cc_environment",
            "defines": []
          }]
        },
        "locals": {
          "blocks": [],
          "samplers": []
        }
      },
      "defines": [{
        "name": "CC_USE_IBL",
        "type": "number",
        "range": [0, 2]
      }, {
        "name": "CC_USE_HDR",
        "type": "boolean"
      }, {
        "name": "USE_RGBE_CUBEMAP",
        "type": "boolean"
      }],
      "blocks": [],
      "samplers": [],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "format": 32,
        "location": 0
      }]
    }]
  }, {
    "name": "util/profiler",
    "_uuid": "871c3b6c-7379-419d-bda3-794b239ab90d",
    "techniques": [{
      "passes": [{
        "blendState": {
          "targets": [{
            "blend": true,
            "blendSrc": 2,
            "blendDst": 4,
            "blendDstAlpha": 4
          }]
        },
        "rasterizerState": {
          "cullMode": 0
        },
        "program": "util/profiler|profiler-vs:vert|profiler-fs:frag",
        "depthStencilState": {
          "depthTest": false,
          "depthWrite": false
        }
      }]
    }],
    "shaders": [{
      "name": "util/profiler|profiler-vs:vert|profiler-fs:frag",
      "hash": 3438710735,
      "glsl3": {
        "vert": "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec2 v_uv;\nuniform Constants {\n  vec4 offset;\n};\nuniform PerFrameInfo {\n  vec4 digits[8 * 10 / 4];\n};\nfloat getComponent(vec4 v, float i) {\n  if (i < 1.0) { return v.x; }\n  else if (i < 2.0) { return v.y; }\n  else if (i < 3.0) { return v.z; }\n  else { return v.w; }\n}\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  position.x *= cc_screenSize.y * cc_screenSize.z;\n  position.xy += offset.xy + abs(position.xy);\n  v_uv = a_color.xy;\n  if (a_color.z >= 0.0) {\n    float n = getComponent(digits[int(a_color.z)], a_color.w);\n    v_uv += vec2(offset.z * n, 0.0);\n  }\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nuniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\n  return CCFragOutput(texture(mainTexture, v_uv));\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
      },
      "glsl1": {
        "vert": "\nprecision mediump float;\nuniform mediump vec4 cc_screenSize;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec2 v_uv;\nuniform vec4 offset;\nuniform vec4 digits[20];\nfloat getComponent(vec4 v, float i) {\n  if (i < 1.0) { return v.x; }\n  else if (i < 2.0) { return v.y; }\n  else if (i < 3.0) { return v.z; }\n  else { return v.w; }\n}\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  position.x *= cc_screenSize.y * cc_screenSize.z;\n  position.xy += offset.xy + abs(position.xy);\n  v_uv = a_color.xy;\n  if (a_color.z >= 0.0) {\n    float n = getComponent(digits[int(a_color.z)], a_color.w);\n    v_uv += vec2(offset.z * n, 0.0);\n  }\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
        "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\n  return CCFragOutput(texture2D(mainTexture, v_uv));\n}\nvoid main() { gl_FragColor = frag(); }"
      },
      "builtins": {
        "globals": {
          "blocks": [{
            "name": "CCGlobal",
            "defines": []
          }],
          "samplers": []
        },
        "locals": {
          "blocks": [],
          "samplers": []
        }
      },
      "defines": [{
        "name": "CC_USE_HDR",
        "type": "boolean"
      }],
      "blocks": [{
        "name": "Constants",
        "defines": [],
        "binding": 0,
        "members": [{
          "name": "offset",
          "type": 16,
          "count": 1
        }]
      }, {
        "name": "PerFrameInfo",
        "defines": [],
        "binding": 1,
        "members": [{
          "name": "digits",
          "type": 16,
          "count": 20
        }]
      }],
      "samplers": [{
        "name": "mainTexture",
        "type": 28,
        "count": 1,
        "defines": [],
        "binding": 31
      }],
      "attributes": [{
        "name": "a_position",
        "type": 15,
        "count": 1,
        "defines": [],
        "format": 32,
        "location": 0
      }, {
        "name": "a_color",
        "type": 16,
        "count": 1,
        "defines": [],
        "format": 43,
        "location": 1
      }]
    }]
  }];
  _exports.default = _default;
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkY6L2plbmtpbnMvd29ya3NwYWNlL0NyZWF0b3JfM0QvZWRpdG9yLTNkL3Jlc291cmNlcy8zZC9lbmdpbmUvY29jb3MvY29yZS8zZC9idWlsdGluL2VmZmVjdHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7aUJBQ2UsQ0FDYjtBQUNFLFlBQVEsbUJBRFY7QUFFRSxhQUFTLHNDQUZYO0FBR0Usa0JBQWMsQ0FDWjtBQUFFLGNBQVEsS0FBVjtBQUFpQixnQkFBVSxDQUFDO0FBQUUsMkJBQW1CO0FBQUUsc0JBQVk7QUFBZCxTQUFyQjtBQUF3QyxzQkFBYztBQUFFLHFCQUFXLENBQUM7QUFBRSxxQkFBUyxJQUFYO0FBQWlCLHdCQUFZLENBQTdCO0FBQWdDLHdCQUFZLENBQTVDO0FBQStDLDZCQUFpQixDQUFoRTtBQUFtRSw2QkFBaUI7QUFBcEYsV0FBRDtBQUFiLFNBQXREO0FBQWdLLG1CQUFXLDhDQUEzSztBQUEyTiw2QkFBcUI7QUFBRSx1QkFBYSxJQUFmO0FBQXFCLHdCQUFjO0FBQW5DLFNBQWhQO0FBQTRSLHNCQUFjO0FBQUUseUJBQWU7QUFBRSxxQkFBUyxNQUFYO0FBQW1CLG9CQUFRO0FBQTNCLFdBQWpCO0FBQWtELCtCQUFxQjtBQUFFLHFCQUFTLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixDQUFYO0FBQXlCLG9CQUFRO0FBQWpDLFdBQXZFO0FBQThHLHVCQUFhO0FBQUUscUJBQVMsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFBZ0IsR0FBaEIsQ0FBWDtBQUFpQyxvQkFBUTtBQUF6QztBQUEzSDtBQUExUyxPQUFEO0FBQTNCLEtBRFksQ0FIaEI7QUFNRSxlQUFXLENBQ1Q7QUFDRSxjQUFRLDhDQURWO0FBRUUsY0FBUSxVQUZWO0FBR0UsZUFBUztBQUNQLDZwSkFETztBQUVQO0FBRk8sT0FIWDtBQU9FLGVBQVM7QUFDUCx1bElBRE87QUFFUDtBQUZPLE9BUFg7QUFXRSxrQkFBWTtBQUNWLG1CQUFXO0FBQUUsb0JBQVUsQ0FBQztBQUFFLG9CQUFRLFVBQVY7QUFBc0IsdUJBQVc7QUFBakMsV0FBRCxDQUFaO0FBQXFELHNCQUFZO0FBQWpFLFNBREQ7QUFFVixrQkFBVTtBQUFFLG9CQUFVLENBQUM7QUFBRSxvQkFBUSxTQUFWO0FBQXFCLHVCQUFXO0FBQWhDLFdBQUQsQ0FBWjtBQUFvRCxzQkFBWTtBQUFoRTtBQUZBLE9BWGQ7QUFlRSxpQkFBVyxDQUNUO0FBQUUsZ0JBQVEsWUFBVjtBQUF3QixnQkFBUTtBQUFoQyxPQURTLENBZmI7QUFrQkUsZ0JBQVUsQ0FDUjtBQUFDLGdCQUFRLFdBQVQ7QUFBc0IsbUJBQVcsRUFBakM7QUFBcUMsbUJBQVcsQ0FBaEQ7QUFBbUQsbUJBQVcsQ0FDNUQ7QUFBRSxrQkFBUSxtQkFBVjtBQUErQixrQkFBUSxFQUF2QztBQUEyQyxtQkFBUztBQUFwRCxTQUQ0RCxFQUU1RDtBQUFFLGtCQUFRLHVCQUFWO0FBQW1DLGtCQUFRLEVBQTNDO0FBQStDLG1CQUFTO0FBQXhELFNBRjRELEVBRzVEO0FBQUUsa0JBQVEsT0FBVjtBQUFtQixrQkFBUSxFQUEzQjtBQUErQixtQkFBUztBQUF4QyxTQUg0RDtBQUE5RCxPQURRLEVBTVI7QUFBQyxnQkFBUSxTQUFUO0FBQW9CLG1CQUFXLEVBQS9CO0FBQW1DLG1CQUFXLENBQTlDO0FBQWlELG1CQUFXLENBQzFEO0FBQUUsa0JBQVEsa0JBQVY7QUFBOEIsa0JBQVEsRUFBdEM7QUFBMEMsbUJBQVM7QUFBbkQsU0FEMEQ7QUFBNUQsT0FOUSxFQVNSO0FBQUMsZ0JBQVEsZUFBVDtBQUEwQixtQkFBVyxFQUFyQztBQUF5QyxtQkFBVyxDQUFwRDtBQUF1RCxtQkFBVyxDQUNoRTtBQUFFLGtCQUFRLFdBQVY7QUFBdUIsa0JBQVEsRUFBL0I7QUFBbUMsbUJBQVM7QUFBNUMsU0FEZ0U7QUFBbEUsT0FUUSxDQWxCWjtBQStCRSxrQkFBWSxDQUNWO0FBQUUsZ0JBQVEsYUFBVjtBQUF5QixnQkFBUSxFQUFqQztBQUFxQyxpQkFBUyxDQUE5QztBQUFpRCxtQkFBVyxFQUE1RDtBQUFnRSxtQkFBVztBQUEzRSxPQURVLENBL0JkO0FBa0NFLG9CQUFjLENBQ1o7QUFBRSxnQkFBUSxZQUFWO0FBQXdCLGdCQUFRLEVBQWhDO0FBQW9DLGlCQUFTLENBQTdDO0FBQWdELG1CQUFXLEVBQTNEO0FBQStELGtCQUFVLEVBQXpFO0FBQTZFLG9CQUFZO0FBQXpGLE9BRFksRUFFWjtBQUFFLGdCQUFRLFlBQVY7QUFBd0IsZ0JBQVEsRUFBaEM7QUFBb0MsaUJBQVMsQ0FBN0M7QUFBZ0QsbUJBQVcsRUFBM0Q7QUFBK0Qsa0JBQVUsRUFBekU7QUFBNkUsb0JBQVk7QUFBekYsT0FGWSxFQUdaO0FBQUUsZ0JBQVEsU0FBVjtBQUFxQixnQkFBUSxFQUE3QjtBQUFpQyxpQkFBUyxDQUExQztBQUE2QyxtQkFBVyxFQUF4RDtBQUE0RCxrQkFBVSxFQUF0RTtBQUEwRSxvQkFBWTtBQUF0RixPQUhZO0FBbENoQixLQURTO0FBTmIsR0FEYSxFQWtEYjtBQUNFLFlBQVEsc0JBRFY7QUFFRSxhQUFTLHNDQUZYO0FBR0Usa0JBQWMsQ0FDWjtBQUFFLGNBQVEsS0FBVjtBQUFpQixnQkFBVSxDQUFDO0FBQUUsMkJBQW1CO0FBQUUsc0JBQVk7QUFBZCxTQUFyQjtBQUF3QyxzQkFBYztBQUFFLHFCQUFXLENBQUM7QUFBRSxxQkFBUyxJQUFYO0FBQWlCLHdCQUFZLENBQTdCO0FBQWdDLHdCQUFZLENBQTVDO0FBQStDLDZCQUFpQixDQUFoRTtBQUFtRSw2QkFBaUI7QUFBcEYsV0FBRDtBQUFiLFNBQXREO0FBQWdLLG1CQUFXLDhEQUEzSztBQUEyTyw2QkFBcUI7QUFBRSx1QkFBYSxJQUFmO0FBQXFCLHdCQUFjO0FBQW5DLFNBQWhRO0FBQTRTLHNCQUFjO0FBQUUseUJBQWU7QUFBRSxxQkFBUyxNQUFYO0FBQW1CLG9CQUFRO0FBQTNCLFdBQWpCO0FBQWtELCtCQUFxQjtBQUFFLHFCQUFTLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixDQUFYO0FBQXlCLG9CQUFRO0FBQWpDLFdBQXZFO0FBQThHLHVCQUFhO0FBQUUscUJBQVMsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFBZ0IsR0FBaEIsQ0FBWDtBQUFpQyxvQkFBUTtBQUF6QztBQUEzSDtBQUExVCxPQUFEO0FBQTNCLEtBRFksQ0FIaEI7QUFNRSxlQUFXLENBQ1Q7QUFDRSxjQUFRLDhEQURWO0FBRUUsY0FBUSxVQUZWO0FBR0UsZUFBUztBQUNQLGd3Y0FETztBQUVQO0FBRk8sT0FIWDtBQU9FLGVBQVM7QUFDUCwwcmJBRE87QUFFUDtBQUZPLE9BUFg7QUFXRSxrQkFBWTtBQUNWLG1CQUFXO0FBQUUsb0JBQVUsQ0FBQztBQUFFLG9CQUFRLFVBQVY7QUFBc0IsdUJBQVc7QUFBakMsV0FBRCxDQUFaO0FBQXFELHNCQUFZO0FBQWpFLFNBREQ7QUFFVixrQkFBVTtBQUFFLG9CQUFVLENBQUM7QUFBRSxvQkFBUSxTQUFWO0FBQXFCLHVCQUFXO0FBQWhDLFdBQUQsQ0FBWjtBQUFvRCxzQkFBWTtBQUFoRTtBQUZBLE9BWGQ7QUFlRSxpQkFBVyxDQUNUO0FBQUUsZ0JBQVEsZ0JBQVY7QUFBNEIsZ0JBQVEsUUFBcEM7QUFBOEMsaUJBQVMsQ0FBQyxDQUFELEVBQUksQ0FBSjtBQUF2RCxPQURTLEVBRVQ7QUFBRSxnQkFBUSwrQkFBVjtBQUEyQyxnQkFBUTtBQUFuRCxPQUZTLEVBR1Q7QUFBRSxnQkFBUSxrQ0FBVjtBQUE4QyxnQkFBUTtBQUF0RCxPQUhTLEVBSVQ7QUFBRSxnQkFBUSw4QkFBVjtBQUEwQyxnQkFBUTtBQUFsRCxPQUpTLEVBS1Q7QUFBRSxnQkFBUSwrQkFBVjtBQUEyQyxnQkFBUTtBQUFuRCxPQUxTLEVBTVQ7QUFBRSxnQkFBUSxrQ0FBVjtBQUE4QyxnQkFBUTtBQUF0RCxPQU5TLEVBT1Q7QUFBRSxnQkFBUSxpQ0FBVjtBQUE2QyxnQkFBUTtBQUFyRCxPQVBTLEVBUVQ7QUFBRSxnQkFBUSxvQkFBVjtBQUFnQyxnQkFBUTtBQUF4QyxPQVJTLEVBU1Q7QUFBRSxnQkFBUSxZQUFWO0FBQXdCLGdCQUFRO0FBQWhDLE9BVFMsQ0FmYjtBQTBCRSxnQkFBVSxDQUNSO0FBQUMsZ0JBQVEsV0FBVDtBQUFzQixtQkFBVyxFQUFqQztBQUFxQyxtQkFBVyxDQUFoRDtBQUFtRCxtQkFBVyxDQUM1RDtBQUFFLGtCQUFRLG1CQUFWO0FBQStCLGtCQUFRLEVBQXZDO0FBQTJDLG1CQUFTO0FBQXBELFNBRDRELEVBRTVEO0FBQUUsa0JBQVEsdUJBQVY7QUFBbUMsa0JBQVEsRUFBM0M7QUFBK0MsbUJBQVM7QUFBeEQsU0FGNEQsRUFHNUQ7QUFBRSxrQkFBUSxPQUFWO0FBQW1CLGtCQUFRLEVBQTNCO0FBQStCLG1CQUFTO0FBQXhDLFNBSDREO0FBQTlELE9BRFEsRUFNUjtBQUFDLGdCQUFRLGlCQUFUO0FBQTRCLG1CQUFXLEVBQXZDO0FBQTJDLG1CQUFXLENBQXREO0FBQXlELG1CQUFXLENBQ2xFO0FBQUUsa0JBQVEsY0FBVjtBQUEwQixrQkFBUSxFQUFsQztBQUFzQyxtQkFBUztBQUEvQyxTQURrRTtBQUFwRSxPQU5RLEVBU1I7QUFBQyxnQkFBUSxlQUFUO0FBQTBCLG1CQUFXLEVBQXJDO0FBQXlDLG1CQUFXLENBQXBEO0FBQXVELG1CQUFXLENBQ2hFO0FBQUUsa0JBQVEsWUFBVjtBQUF3QixrQkFBUSxFQUFoQztBQUFvQyxtQkFBUztBQUE3QyxTQURnRSxFQUVoRTtBQUFFLGtCQUFRLGFBQVY7QUFBeUIsa0JBQVEsRUFBakM7QUFBcUMsbUJBQVM7QUFBOUMsU0FGZ0U7QUFBbEUsT0FUUSxFQWFSO0FBQUMsZ0JBQVEsZUFBVDtBQUEwQixtQkFBVyxDQUFDLCtCQUFELENBQXJDO0FBQXdFLG1CQUFXLENBQW5GO0FBQXNGLG1CQUFXLENBQy9GO0FBQUUsa0JBQVEsY0FBVjtBQUEwQixrQkFBUSxDQUFsQztBQUFxQyxtQkFBUztBQUE5QyxTQUQrRjtBQUFqRyxPQWJRLEVBZ0JSO0FBQUMsZ0JBQVEsa0JBQVQ7QUFBNkIsbUJBQVcsQ0FBQyxrQ0FBRCxDQUF4QztBQUE4RSxtQkFBVyxDQUF6RjtBQUE0RixtQkFBVyxDQUNyRztBQUFFLGtCQUFRLGlCQUFWO0FBQTZCLGtCQUFRLENBQXJDO0FBQXdDLG1CQUFTO0FBQWpELFNBRHFHO0FBQXZHLE9BaEJRLEVBbUJSO0FBQUMsZ0JBQVEsY0FBVDtBQUF5QixtQkFBVyxDQUFDLDhCQUFELENBQXBDO0FBQXNFLG1CQUFXLENBQWpGO0FBQW9GLG1CQUFXLENBQzdGO0FBQUUsa0JBQVEsYUFBVjtBQUF5QixrQkFBUSxDQUFqQztBQUFvQyxtQkFBUztBQUE3QyxTQUQ2RjtBQUEvRixPQW5CUSxFQXNCUjtBQUFDLGdCQUFRLGVBQVQ7QUFBMEIsbUJBQVcsQ0FBQywrQkFBRCxDQUFyQztBQUF3RSxtQkFBVyxDQUFuRjtBQUFzRixtQkFBVyxDQUMvRjtBQUFFLGtCQUFRLGNBQVY7QUFBMEIsa0JBQVEsQ0FBbEM7QUFBcUMsbUJBQVM7QUFBOUMsU0FEK0YsRUFFL0Y7QUFBRSxrQkFBUSxlQUFWO0FBQTJCLGtCQUFRLENBQW5DO0FBQXNDLG1CQUFTO0FBQS9DLFNBRitGO0FBQWpHLE9BdEJRLEVBMEJSO0FBQUMsZ0JBQVEsa0JBQVQ7QUFBNkIsbUJBQVcsQ0FBQyxrQ0FBRCxDQUF4QztBQUE4RSxtQkFBVyxDQUF6RjtBQUE0RixtQkFBVyxDQUNyRztBQUFFLGtCQUFRLGlCQUFWO0FBQTZCLGtCQUFRLENBQXJDO0FBQXdDLG1CQUFTO0FBQWpELFNBRHFHLEVBRXJHO0FBQUUsa0JBQVEsa0JBQVY7QUFBOEIsa0JBQVEsQ0FBdEM7QUFBeUMsbUJBQVM7QUFBbEQsU0FGcUc7QUFBdkcsT0ExQlEsRUE4QlI7QUFBQyxnQkFBUSxtQkFBVDtBQUE4QixtQkFBVyxDQUFDLGlDQUFELENBQXpDO0FBQThFLG1CQUFXLENBQXpGO0FBQTRGLG1CQUFXLENBQ3JHO0FBQUUsa0JBQVEsYUFBVjtBQUF5QixrQkFBUSxFQUFqQztBQUFxQyxtQkFBUztBQUE5QyxTQURxRztBQUF2RyxPQTlCUSxFQWlDUjtBQUFDLGdCQUFRLGVBQVQ7QUFBMEIsbUJBQVcsRUFBckM7QUFBeUMsbUJBQVcsQ0FBcEQ7QUFBdUQsbUJBQVcsQ0FDaEU7QUFBRSxrQkFBUSxXQUFWO0FBQXVCLGtCQUFRLEVBQS9CO0FBQW1DLG1CQUFTO0FBQTVDLFNBRGdFO0FBQWxFLE9BakNRLENBMUJaO0FBK0RFLGtCQUFZLENBQ1Y7QUFBRSxnQkFBUSxzQkFBVjtBQUFrQyxnQkFBUSxFQUExQztBQUE4QyxpQkFBUyxDQUF2RDtBQUEwRCxtQkFBVyxDQUFDLCtCQUFELENBQXJFO0FBQXdHLG1CQUFXO0FBQW5ILE9BRFUsRUFFVjtBQUFFLGdCQUFRLHlCQUFWO0FBQXFDLGdCQUFRLEVBQTdDO0FBQWlELGlCQUFTLENBQTFEO0FBQTZELG1CQUFXLENBQUMsa0NBQUQsQ0FBeEU7QUFBOEcsbUJBQVc7QUFBekgsT0FGVSxFQUdWO0FBQUUsZ0JBQVEscUJBQVY7QUFBaUMsZ0JBQVEsRUFBekM7QUFBNkMsaUJBQVMsQ0FBdEQ7QUFBeUQsbUJBQVcsQ0FBQyw4QkFBRCxDQUFwRTtBQUFzRyxtQkFBVztBQUFqSCxPQUhVLEVBSVY7QUFBRSxnQkFBUSxzQkFBVjtBQUFrQyxnQkFBUSxFQUExQztBQUE4QyxpQkFBUyxDQUF2RDtBQUEwRCxtQkFBVyxDQUFDLCtCQUFELENBQXJFO0FBQXdHLG1CQUFXO0FBQW5ILE9BSlUsRUFLVjtBQUFFLGdCQUFRLHlCQUFWO0FBQXFDLGdCQUFRLEVBQTdDO0FBQWlELGlCQUFTLENBQTFEO0FBQTZELG1CQUFXLENBQUMsa0NBQUQsQ0FBeEU7QUFBOEcsbUJBQVc7QUFBekgsT0FMVSxFQU1WO0FBQUUsZ0JBQVEsd0JBQVY7QUFBb0MsZ0JBQVEsRUFBNUM7QUFBZ0QsaUJBQVMsQ0FBekQ7QUFBNEQsbUJBQVcsQ0FBQyxpQ0FBRCxDQUF2RTtBQUE0RyxtQkFBVztBQUF2SCxPQU5VLEVBT1Y7QUFBRSxnQkFBUSxhQUFWO0FBQXlCLGdCQUFRLEVBQWpDO0FBQXFDLGlCQUFTLENBQTlDO0FBQWlELG1CQUFXLEVBQTVEO0FBQWdFLG1CQUFXO0FBQTNFLE9BUFUsQ0EvRGQ7QUF3RUUsb0JBQWMsQ0FDWjtBQUFFLGdCQUFRLHNCQUFWO0FBQWtDLGdCQUFRLEVBQTFDO0FBQThDLGlCQUFTLENBQXZEO0FBQTBELG1CQUFXLEVBQXJFO0FBQXlFLGtCQUFVLEVBQW5GO0FBQXVGLG9CQUFZO0FBQW5HLE9BRFksRUFFWjtBQUFFLGdCQUFRLFdBQVY7QUFBdUIsZ0JBQVEsRUFBL0I7QUFBbUMsaUJBQVMsQ0FBNUM7QUFBK0MsbUJBQVcsRUFBMUQ7QUFBOEQsa0JBQVUsRUFBeEU7QUFBNEUsb0JBQVk7QUFBeEYsT0FGWSxFQUdaO0FBQUUsZ0JBQVEsZUFBVjtBQUEyQixnQkFBUSxFQUFuQztBQUF1QyxpQkFBUyxDQUFoRDtBQUFtRCxtQkFBVyxFQUE5RDtBQUFrRSxrQkFBVSxFQUE1RTtBQUFnRixvQkFBWTtBQUE1RixPQUhZLEVBSVo7QUFBRSxnQkFBUSxTQUFWO0FBQXFCLGdCQUFRLEVBQTdCO0FBQWlDLGlCQUFTLENBQTFDO0FBQTZDLG1CQUFXLEVBQXhEO0FBQTRELGtCQUFVLEVBQXRFO0FBQTBFLG9CQUFZO0FBQXRGLE9BSlksRUFLWjtBQUFFLGdCQUFRLFlBQVY7QUFBd0IsZ0JBQVEsRUFBaEM7QUFBb0MsaUJBQVMsQ0FBN0M7QUFBZ0QsbUJBQVcsRUFBM0Q7QUFBK0Qsa0JBQVUsRUFBekU7QUFBNkUsb0JBQVk7QUFBekYsT0FMWSxFQU1aO0FBQUUsZ0JBQVEsV0FBVjtBQUF1QixnQkFBUSxFQUEvQjtBQUFtQyxpQkFBUyxDQUE1QztBQUErQyxtQkFBVyxFQUExRDtBQUE4RCxrQkFBVSxFQUF4RTtBQUE0RSxvQkFBWTtBQUF4RixPQU5ZLEVBT1o7QUFBRSxnQkFBUSxZQUFWO0FBQXdCLGdCQUFRLEVBQWhDO0FBQW9DLGlCQUFTLENBQTdDO0FBQWdELG1CQUFXLENBQUMsZ0JBQUQsQ0FBM0Q7QUFBK0Usa0JBQVUsRUFBekY7QUFBNkYsb0JBQVk7QUFBekcsT0FQWSxFQVFaO0FBQUUsZ0JBQVEsYUFBVjtBQUF5QixnQkFBUSxFQUFqQztBQUFxQyxpQkFBUyxDQUE5QztBQUFpRCxtQkFBVyxDQUFDLGdCQUFELENBQTVEO0FBQWdGLGtCQUFVLEVBQTFGO0FBQThGLG9CQUFZO0FBQTFHLE9BUlksRUFTWjtBQUFFLGdCQUFRLFVBQVY7QUFBc0IsZ0JBQVEsRUFBOUI7QUFBa0MsaUJBQVMsQ0FBM0M7QUFBOEMsbUJBQVcsQ0FBQyxnQkFBRCxDQUF6RDtBQUE2RSxrQkFBVSxFQUF2RjtBQUEyRixvQkFBWTtBQUF2RyxPQVRZLEVBVVo7QUFBRSxnQkFBUSxVQUFWO0FBQXNCLGdCQUFRLEVBQTlCO0FBQWtDLGlCQUFTLENBQTNDO0FBQThDLG1CQUFXLENBQUMsZ0JBQUQsQ0FBekQ7QUFBNkUsa0JBQVUsRUFBdkY7QUFBMkYsb0JBQVk7QUFBdkcsT0FWWTtBQXhFaEIsS0FEUztBQU5iLEdBbERhLEVBZ0piO0FBQ0UsWUFBUSx3QkFEVjtBQUVFLGFBQVMsc0NBRlg7QUFHRSxrQkFBYyxDQUNaO0FBQUUsY0FBUSxLQUFWO0FBQWlCLGdCQUFVLENBQUM7QUFBRSwyQkFBbUI7QUFBRSxzQkFBWTtBQUFkLFNBQXJCO0FBQXdDLHNCQUFjO0FBQUUscUJBQVcsQ0FBQztBQUFFLHFCQUFTLElBQVg7QUFBaUIsd0JBQVksQ0FBN0I7QUFBZ0Msd0JBQVksQ0FBNUM7QUFBK0MsNkJBQWlCLENBQWhFO0FBQW1FLDZCQUFpQjtBQUFwRixXQUFEO0FBQWIsU0FBdEQ7QUFBZ0ssbUJBQVcsNkRBQTNLO0FBQTBPLDZCQUFxQjtBQUFFLHVCQUFhLElBQWY7QUFBcUIsd0JBQWM7QUFBbkMsU0FBL1A7QUFBMlMsc0JBQWM7QUFBRSx5QkFBZTtBQUFFLHFCQUFTLE1BQVg7QUFBbUIsb0JBQVE7QUFBM0IsV0FBakI7QUFBa0QsK0JBQXFCO0FBQUUscUJBQVMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBQVg7QUFBeUIsb0JBQVE7QUFBakMsV0FBdkU7QUFBOEcsbUNBQXlCO0FBQUUscUJBQVMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBQVg7QUFBeUIsb0JBQVE7QUFBakMsV0FBdkk7QUFBOEssdUJBQWE7QUFBRSxxQkFBUyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixHQUFoQixDQUFYO0FBQWlDLG9CQUFRO0FBQXpDO0FBQTNMO0FBQXpULE9BQUQ7QUFBM0IsS0FEWSxDQUhoQjtBQU1FLGVBQVcsQ0FDVDtBQUNFLGNBQVEsNkRBRFY7QUFFRSxjQUFRLFNBRlY7QUFHRSxlQUFTO0FBQ1AsNmpEQURPO0FBRVA7QUFGTyxPQUhYO0FBT0UsZUFBUztBQUNQLDBoQ0FETztBQUVQO0FBRk8sT0FQWDtBQVdFLGtCQUFZO0FBQ1YsbUJBQVc7QUFBRSxvQkFBVSxDQUFDO0FBQUUsb0JBQVEsVUFBVjtBQUFzQix1QkFBVztBQUFqQyxXQUFELENBQVo7QUFBcUQsc0JBQVk7QUFBakUsU0FERDtBQUVWLGtCQUFVO0FBQUUsb0JBQVUsQ0FBQztBQUFFLG9CQUFRLFNBQVY7QUFBcUIsdUJBQVc7QUFBaEMsV0FBRCxDQUFaO0FBQW9ELHNCQUFZO0FBQWhFO0FBRkEsT0FYZDtBQWVFLGlCQUFXLENBQ1Q7QUFBRSxnQkFBUSxnQkFBVjtBQUE0QixnQkFBUSxRQUFwQztBQUE4QyxpQkFBUyxDQUFDLENBQUQsRUFBSSxDQUFKO0FBQXZELE9BRFMsRUFFVDtBQUFFLGdCQUFRLG9CQUFWO0FBQWdDLGdCQUFRO0FBQXhDLE9BRlMsRUFHVDtBQUFFLGdCQUFRLG9CQUFWO0FBQWdDLGdCQUFRO0FBQXhDLE9BSFMsRUFJVDtBQUFFLGdCQUFRLFlBQVY7QUFBd0IsZ0JBQVE7QUFBaEMsT0FKUyxDQWZiO0FBcUJFLGdCQUFVLENBQ1I7QUFBQyxnQkFBUSxXQUFUO0FBQXNCLG1CQUFXLEVBQWpDO0FBQXFDLG1CQUFXLENBQWhEO0FBQW1ELG1CQUFXLENBQzVEO0FBQUUsa0JBQVEsbUJBQVY7QUFBK0Isa0JBQVEsRUFBdkM7QUFBMkMsbUJBQVM7QUFBcEQsU0FENEQsRUFFNUQ7QUFBRSxrQkFBUSx1QkFBVjtBQUFtQyxrQkFBUSxFQUEzQztBQUErQyxtQkFBUztBQUF4RCxTQUY0RCxFQUc1RDtBQUFFLGtCQUFRLE9BQVY7QUFBbUIsa0JBQVEsRUFBM0I7QUFBK0IsbUJBQVM7QUFBeEMsU0FINEQ7QUFBOUQsT0FEUSxFQU1SO0FBQUMsZ0JBQVEsZUFBVDtBQUEwQixtQkFBVyxFQUFyQztBQUF5QyxtQkFBVyxDQUFwRDtBQUF1RCxtQkFBVyxDQUNoRTtBQUFFLGtCQUFRLFdBQVY7QUFBdUIsa0JBQVEsRUFBL0I7QUFBbUMsbUJBQVM7QUFBNUMsU0FEZ0U7QUFBbEUsT0FOUSxDQXJCWjtBQStCRSxrQkFBWSxDQUNWO0FBQUUsZ0JBQVEsYUFBVjtBQUF5QixnQkFBUSxFQUFqQztBQUFxQyxpQkFBUyxDQUE5QztBQUFpRCxtQkFBVyxFQUE1RDtBQUFnRSxtQkFBVztBQUEzRSxPQURVLENBL0JkO0FBa0NFLG9CQUFjLENBQ1o7QUFBRSxnQkFBUSxZQUFWO0FBQXdCLGdCQUFRLEVBQWhDO0FBQW9DLGlCQUFTLENBQTdDO0FBQWdELG1CQUFXLEVBQTNEO0FBQStELGtCQUFVLEVBQXpFO0FBQTZFLG9CQUFZO0FBQXpGLE9BRFksRUFFWjtBQUFFLGdCQUFRLFlBQVY7QUFBd0IsZ0JBQVEsRUFBaEM7QUFBb0MsaUJBQVMsQ0FBN0M7QUFBZ0QsbUJBQVcsRUFBM0Q7QUFBK0Qsa0JBQVUsRUFBekU7QUFBNkUsb0JBQVk7QUFBekYsT0FGWSxFQUdaO0FBQUUsZ0JBQVEsYUFBVjtBQUF5QixnQkFBUSxFQUFqQztBQUFxQyxpQkFBUyxDQUE5QztBQUFpRCxtQkFBVyxFQUE1RDtBQUFnRSxrQkFBVSxFQUExRTtBQUE4RSxvQkFBWTtBQUExRixPQUhZLEVBSVo7QUFBRSxnQkFBUSxhQUFWO0FBQXlCLGdCQUFRLEVBQWpDO0FBQXFDLGlCQUFTLENBQTlDO0FBQWlELG1CQUFXLEVBQTVEO0FBQWdFLGtCQUFVLEVBQTFFO0FBQThFLG9CQUFZO0FBQTFGLE9BSlksRUFLWjtBQUFFLGdCQUFRLFNBQVY7QUFBcUIsZ0JBQVEsRUFBN0I7QUFBaUMsaUJBQVMsQ0FBMUM7QUFBNkMsbUJBQVcsRUFBeEQ7QUFBNEQsa0JBQVUsRUFBdEU7QUFBMEUsb0JBQVk7QUFBdEYsT0FMWTtBQWxDaEIsS0FEUztBQU5iLEdBaEphLEVBbU1iO0FBQ0UsWUFBUSxrQkFEVjtBQUVFLGFBQVMsc0NBRlg7QUFHRSxrQkFBYyxDQUNaO0FBQUUsY0FBUSxLQUFWO0FBQWlCLGdCQUFVLENBQUM7QUFBRSwyQkFBbUI7QUFBRSxzQkFBWTtBQUFkLFNBQXJCO0FBQXdDLHNCQUFjO0FBQUUscUJBQVcsQ0FBQztBQUFFLHFCQUFTLElBQVg7QUFBaUIsd0JBQVksQ0FBN0I7QUFBZ0Msd0JBQVksQ0FBNUM7QUFBK0MsNkJBQWlCLENBQWhFO0FBQW1FLDZCQUFpQjtBQUFwRixXQUFEO0FBQWIsU0FBdEQ7QUFBZ0ssbUJBQVcsNkRBQTNLO0FBQTBPLDZCQUFxQjtBQUFFLHVCQUFhLElBQWY7QUFBcUIsd0JBQWM7QUFBbkMsU0FBL1A7QUFBMlMsc0JBQWM7QUFBRSx5QkFBZTtBQUFFLHFCQUFTLE1BQVg7QUFBbUIsb0JBQVE7QUFBM0IsV0FBakI7QUFBa0QsK0JBQXFCO0FBQUUscUJBQVMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBQVg7QUFBeUIsb0JBQVE7QUFBakMsV0FBdkU7QUFBOEcsdUJBQWE7QUFBRSxxQkFBUyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWCxFQUFnQixHQUFoQixDQUFYO0FBQWlDLG9CQUFRO0FBQXpDO0FBQTNIO0FBQXpULE9BQUQ7QUFBM0IsS0FEWSxDQUhoQjtBQU1FLGVBQVcsQ0FDVDtBQUNFLGNBQVEsNkRBRFY7QUFFRSxjQUFRLFVBRlY7QUFHRSxlQUFTO0FBQ1AsdzhRQURPO0FBRVA7QUFGTyxPQUhYO0FBT0UsZUFBUztBQUNQLDBqUUFETztBQUVQO0FBRk8sT0FQWDtBQVdFLGtCQUFZO0FBQ1YsbUJBQVc7QUFBRSxvQkFBVSxDQUFDO0FBQUUsb0JBQVEsVUFBVjtBQUFzQix1QkFBVztBQUFqQyxXQUFELENBQVo7QUFBcUQsc0JBQVk7QUFBakUsU0FERDtBQUVWLGtCQUFVO0FBQUUsb0JBQVUsQ0FBQztBQUFFLG9CQUFRLFNBQVY7QUFBcUIsdUJBQVc7QUFBaEMsV0FBRCxDQUFaO0FBQW9ELHNCQUFZO0FBQWhFO0FBRkEsT0FYZDtBQWVFLGlCQUFXLENBQ1Q7QUFBRSxnQkFBUSxnQkFBVjtBQUE0QixnQkFBUSxRQUFwQztBQUE4QyxpQkFBUyxDQUFDLENBQUQsRUFBSSxDQUFKO0FBQXZELE9BRFMsRUFFVDtBQUFFLGdCQUFRLG9CQUFWO0FBQWdDLGdCQUFRO0FBQXhDLE9BRlMsRUFHVDtBQUFFLGdCQUFRLFlBQVY7QUFBd0IsZ0JBQVE7QUFBaEMsT0FIUyxDQWZiO0FBb0JFLGdCQUFVLENBQ1I7QUFBQyxnQkFBUSxXQUFUO0FBQXNCLG1CQUFXLEVBQWpDO0FBQXFDLG1CQUFXLENBQWhEO0FBQW1ELG1CQUFXLENBQzVEO0FBQUUsa0JBQVEsbUJBQVY7QUFBK0Isa0JBQVEsRUFBdkM7QUFBMkMsbUJBQVM7QUFBcEQsU0FENEQsRUFFNUQ7QUFBRSxrQkFBUSx1QkFBVjtBQUFtQyxrQkFBUSxFQUEzQztBQUErQyxtQkFBUztBQUF4RCxTQUY0RCxFQUc1RDtBQUFFLGtCQUFRLE9BQVY7QUFBbUIsa0JBQVEsRUFBM0I7QUFBK0IsbUJBQVM7QUFBeEMsU0FINEQ7QUFBOUQsT0FEUSxFQU1SO0FBQUMsZ0JBQVEsZUFBVDtBQUEwQixtQkFBVyxFQUFyQztBQUF5QyxtQkFBVyxDQUFwRDtBQUF1RCxtQkFBVyxDQUNoRTtBQUFFLGtCQUFRLFdBQVY7QUFBdUIsa0JBQVEsRUFBL0I7QUFBbUMsbUJBQVM7QUFBNUMsU0FEZ0U7QUFBbEUsT0FOUSxDQXBCWjtBQThCRSxrQkFBWSxDQUNWO0FBQUUsZ0JBQVEsYUFBVjtBQUF5QixnQkFBUSxFQUFqQztBQUFxQyxpQkFBUyxDQUE5QztBQUFpRCxtQkFBVyxFQUE1RDtBQUFnRSxtQkFBVztBQUEzRSxPQURVLENBOUJkO0FBaUNFLG9CQUFjLENBQ1o7QUFBRSxnQkFBUSxZQUFWO0FBQXdCLGdCQUFRLEVBQWhDO0FBQW9DLGlCQUFTLENBQTdDO0FBQWdELG1CQUFXLEVBQTNEO0FBQStELGtCQUFVLEVBQXpFO0FBQTZFLG9CQUFZO0FBQXpGLE9BRFksRUFFWjtBQUFFLGdCQUFRLFlBQVY7QUFBd0IsZ0JBQVEsRUFBaEM7QUFBb0MsaUJBQVMsQ0FBN0M7QUFBZ0QsbUJBQVcsRUFBM0Q7QUFBK0Qsa0JBQVUsRUFBekU7QUFBNkUsb0JBQVk7QUFBekYsT0FGWSxFQUdaO0FBQUUsZ0JBQVEsYUFBVjtBQUF5QixnQkFBUSxFQUFqQztBQUFxQyxpQkFBUyxDQUE5QztBQUFpRCxtQkFBVyxFQUE1RDtBQUFnRSxrQkFBVSxFQUExRTtBQUE4RSxvQkFBWTtBQUExRixPQUhZLEVBSVo7QUFBRSxnQkFBUSxhQUFWO0FBQXlCLGdCQUFRLEVBQWpDO0FBQXFDLGlCQUFTLENBQTlDO0FBQWlELG1CQUFXLEVBQTVEO0FBQWdFLGtCQUFVLEVBQTFFO0FBQThFLG9CQUFZO0FBQTFGLE9BSlksRUFLWjtBQUFFLGdCQUFRLFNBQVY7QUFBcUIsZ0JBQVEsRUFBN0I7QUFBaUMsaUJBQVMsQ0FBMUM7QUFBNkMsbUJBQVcsRUFBeEQ7QUFBNEQsa0JBQVUsRUFBdEU7QUFBMEUsb0JBQVk7QUFBdEYsT0FMWSxFQU1aO0FBQUUsZ0JBQVEsVUFBVjtBQUFzQixnQkFBUSxFQUE5QjtBQUFrQyxpQkFBUyxDQUEzQztBQUE4QyxtQkFBVyxDQUFDLGdCQUFELENBQXpEO0FBQTZFLGtCQUFVLEVBQXZGO0FBQTJGLG9CQUFZO0FBQXZHLE9BTlksRUFPWjtBQUFFLGdCQUFRLGFBQVY7QUFBeUIsZ0JBQVEsRUFBakM7QUFBcUMsaUJBQVMsQ0FBOUM7QUFBaUQsbUJBQVcsQ0FBQyxnQkFBRCxDQUE1RDtBQUFnRixrQkFBVSxFQUExRjtBQUE4RixvQkFBWTtBQUExRyxPQVBZLEVBUVo7QUFBRSxnQkFBUSxVQUFWO0FBQXNCLGdCQUFRLEVBQTlCO0FBQWtDLGlCQUFTLENBQTNDO0FBQThDLG1CQUFXLENBQUMsZ0JBQUQsQ0FBekQ7QUFBNkUsa0JBQVUsRUFBdkY7QUFBMkYsb0JBQVk7QUFBdkcsT0FSWTtBQWpDaEIsS0FEUztBQU5iLEdBbk1hLEVBd1BiO0FBQ0UsWUFBUSxnQkFEVjtBQUVFLGFBQVMsc0NBRlg7QUFHRSxrQkFBYyxDQUNaO0FBQUUsZ0JBQVUsQ0FBQztBQUFFLHNCQUFjO0FBQUUscUJBQVcsQ0FBQztBQUFFLHFCQUFTLElBQVg7QUFBaUIsd0JBQVksQ0FBN0I7QUFBZ0Msd0JBQVksQ0FBNUM7QUFBK0MsNkJBQWlCO0FBQWhFLFdBQUQ7QUFBYixTQUFoQjtBQUFzRywyQkFBbUI7QUFBRSxzQkFBWTtBQUFkLFNBQXpIO0FBQTRJLG1CQUFXLDhDQUF2SjtBQUF1TSxvQkFBWSxHQUFuTjtBQUF3Tiw2QkFBcUI7QUFBRSx1QkFBYSxLQUFmO0FBQXNCLHdCQUFjO0FBQXBDLFNBQTdPO0FBQTBSLHNCQUFjO0FBQUUseUJBQWU7QUFBRSxxQkFBUyxPQUFYO0FBQW9CLG9CQUFRO0FBQTVCO0FBQWpCO0FBQXhTLE9BQUQ7QUFBWixLQURZLENBSGhCO0FBTUUsZUFBVyxDQUNUO0FBQ0UsY0FBUSw4Q0FEVjtBQUVFLGNBQVEsU0FGVjtBQUdFLGVBQVM7QUFDUCw4aENBRE87QUFFUDtBQUZPLE9BSFg7QUFPRSxlQUFTO0FBQ1Asd2dCQURPO0FBRVA7QUFGTyxPQVBYO0FBV0Usa0JBQVk7QUFDVixtQkFBVztBQUFFLG9CQUFVLENBQUM7QUFBRSxvQkFBUSxVQUFWO0FBQXNCLHVCQUFXO0FBQWpDLFdBQUQsQ0FBWjtBQUFxRCxzQkFBWTtBQUFqRSxTQUREO0FBRVYsa0JBQVU7QUFBRSxvQkFBVSxDQUFDO0FBQUUsb0JBQVEsU0FBVjtBQUFxQix1QkFBVyxDQUFDLFdBQUQ7QUFBaEMsV0FBRCxDQUFaO0FBQStELHNCQUFZO0FBQTNFO0FBRkEsT0FYZDtBQWVFLGlCQUFXLENBQ1Q7QUFBRSxnQkFBUSxXQUFWO0FBQXVCLGdCQUFRO0FBQS9CLE9BRFMsRUFFVDtBQUFFLGdCQUFRLGFBQVY7QUFBeUIsZ0JBQVE7QUFBakMsT0FGUyxFQUdUO0FBQUUsZ0JBQVEsU0FBVjtBQUFxQixnQkFBUTtBQUE3QixPQUhTLENBZmI7QUFvQkUsZ0JBQVUsRUFwQlo7QUFxQkUsa0JBQVksQ0FDVjtBQUFFLGdCQUFRLGFBQVY7QUFBeUIsZ0JBQVEsRUFBakM7QUFBcUMsaUJBQVMsQ0FBOUM7QUFBaUQsbUJBQVcsQ0FBQyxhQUFELENBQTVEO0FBQTZFLG1CQUFXO0FBQXhGLE9BRFUsQ0FyQmQ7QUF3QkUsb0JBQWMsQ0FDWjtBQUFFLGdCQUFRLFlBQVY7QUFBd0IsZ0JBQVEsRUFBaEM7QUFBb0MsaUJBQVMsQ0FBN0M7QUFBZ0QsbUJBQVcsRUFBM0Q7QUFBK0Qsa0JBQVUsRUFBekU7QUFBNkUsb0JBQVk7QUFBekYsT0FEWSxFQUVaO0FBQUUsZ0JBQVEsU0FBVjtBQUFxQixnQkFBUSxFQUE3QjtBQUFpQyxpQkFBUyxDQUExQztBQUE2QyxtQkFBVyxFQUF4RDtBQUE0RCxrQkFBVSxFQUF0RTtBQUEwRSxvQkFBWTtBQUF0RixPQUZZLEVBR1o7QUFBRSxnQkFBUSxZQUFWO0FBQXdCLGdCQUFRLEVBQWhDO0FBQW9DLGlCQUFTLENBQTdDO0FBQWdELG1CQUFXLEVBQTNEO0FBQStELGtCQUFVLEVBQXpFO0FBQTZFLG9CQUFZO0FBQXpGLE9BSFk7QUF4QmhCLEtBRFM7QUFOYixHQXhQYSxFQStSYjtBQUNFLFlBQVEsa0JBRFY7QUFFRSxhQUFTLHNDQUZYO0FBR0Usa0JBQWMsQ0FDWjtBQUFFLGNBQVEsUUFBVjtBQUFvQixnQkFBVSxDQUFDO0FBQUUsbUJBQVcsb0RBQWI7QUFBbUUsc0JBQWM7QUFBRSwwQkFBZ0I7QUFBRSxxQkFBUyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBWDtBQUF5QixvQkFBUTtBQUFqQyxXQUFsQjtBQUF5RCx1QkFBYTtBQUFFLHFCQUFTLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixDQUFYO0FBQXlCLG9CQUFRLEVBQWpDO0FBQXFDLDBCQUFjLENBQUMsUUFBRCxFQUFXLENBQVgsRUFBYyxFQUFkO0FBQW5ELFdBQXRFO0FBQThJLHlCQUFlO0FBQUUscUJBQVMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBWDtBQUFzQixvQkFBUSxFQUE5QjtBQUFrQywwQkFBYyxDQUFDLHNCQUFELEVBQXlCLENBQXpCLEVBQTRCLEVBQTVCO0FBQWhELFdBQTdKO0FBQWdQLDRCQUFrQjtBQUFFLHFCQUFTLENBQUMsR0FBRCxDQUFYO0FBQWtCLG9CQUFRLEVBQTFCO0FBQThCLDBCQUFjLENBQUMsc0JBQUQsRUFBeUIsQ0FBekIsRUFBNEIsRUFBNUI7QUFBNUMsV0FBbFE7QUFBaVYsdUJBQWE7QUFBRSxxQkFBUyxDQUFDLENBQUQsQ0FBWDtBQUFnQixvQkFBUSxFQUF4QjtBQUE0QiwwQkFBYyxDQUFDLFdBQUQsRUFBYyxDQUFkLEVBQWlCLEVBQWpCO0FBQTFDLFdBQTlWO0FBQWdhLHVCQUFhO0FBQUUscUJBQVMsQ0FBQyxHQUFELENBQVg7QUFBa0Isb0JBQVEsRUFBMUI7QUFBOEIsMEJBQWMsQ0FBQyxXQUFELEVBQWMsQ0FBZCxFQUFpQixFQUFqQjtBQUE1QyxXQUE3YTtBQUFpZixzQkFBWTtBQUFFLHFCQUFTLENBQUMsR0FBRCxDQUFYO0FBQWtCLG9CQUFRLEVBQTFCO0FBQThCLDBCQUFjLENBQUMsV0FBRCxFQUFjLENBQWQsRUFBaUIsRUFBakI7QUFBNUMsV0FBN2Y7QUFBaWtCLDJCQUFpQjtBQUFFLHFCQUFTLENBQUMsQ0FBRCxDQUFYO0FBQWdCLG9CQUFRLEVBQXhCO0FBQTRCLDBCQUFjLENBQUMsV0FBRCxFQUFjLENBQWQsRUFBaUIsRUFBakI7QUFBMUMsV0FBbGxCO0FBQW9wQixzQkFBWTtBQUFFLHFCQUFTLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixDQUFYO0FBQXlCLG9CQUFRO0FBQWpDLFdBQWhxQjtBQUF1c0IsMkJBQWlCO0FBQUUscUJBQVMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsQ0FBWDtBQUFzQixvQkFBUSxFQUE5QjtBQUFrQywwQkFBYyxDQUFDLG9CQUFELEVBQXVCLENBQXZCLEVBQTBCLEVBQTFCO0FBQWhELFdBQXh0QjtBQUF5eUIseUJBQWU7QUFBRSxxQkFBUyxNQUFYO0FBQW1CLG9CQUFRLEVBQTNCO0FBQStCLDBCQUFjLENBQUMsV0FBRCxFQUFjLENBQWQsRUFBaUIsRUFBakI7QUFBN0MsV0FBeHpCO0FBQTYzQix1QkFBYTtBQUFFLHFCQUFTLFFBQVg7QUFBcUIsb0JBQVE7QUFBN0IsV0FBMTRCO0FBQTY2QixvQkFBVTtBQUFFLHFCQUFTLE1BQVg7QUFBbUIsb0JBQVE7QUFBM0IsV0FBdjdCO0FBQXc5QixrQ0FBd0I7QUFBRSxxQkFBUyxNQUFYO0FBQW1CLG9CQUFRO0FBQTNCLFdBQWgvQjtBQUFpaEMsMEJBQWdCO0FBQUUscUJBQVMsT0FBWDtBQUFvQixvQkFBUTtBQUE1QixXQUFqaUM7QUFBbWtDLHlCQUFlO0FBQUUscUJBQVMsTUFBWDtBQUFtQixvQkFBUTtBQUEzQixXQUFsbEM7QUFBbW5DLG9CQUFVO0FBQUUsb0JBQVEsRUFBVjtBQUFjLHFCQUFTLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVjtBQUF2QixXQUE3bkM7QUFBb3FDLGtDQUF3QjtBQUFFLG9CQUFRLEVBQVY7QUFBYyxxQkFBUyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLEdBQVY7QUFBdkIsV0FBNXJDO0FBQXF1Qyx1QkFBYTtBQUFFLG9CQUFRLEVBQVY7QUFBYyxxQkFBUyxDQUFDLENBQUQsRUFBSSxHQUFKLEVBQVMsR0FBVCxFQUFjLENBQWQ7QUFBdkIsV0FBbHZDO0FBQTZ4QyxnQ0FBc0I7QUFBRSxvQkFBUSxFQUFWO0FBQWMscUJBQVMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWO0FBQXZCLFdBQW56QztBQUEwMUMsdUJBQWE7QUFBRSxvQkFBUSxFQUFWO0FBQWMscUJBQVM7QUFBdkI7QUFBdjJDO0FBQWpGLE9BQUQ7QUFBOUIsS0FEWSxDQUhoQjtBQU1FLGVBQVcsQ0FDVDtBQUNFLGNBQVEsb0RBRFY7QUFFRSxjQUFRLFVBRlY7QUFHRSxlQUFTO0FBQ1Asd3ZUQURPO0FBRVA7QUFGTyxPQUhYO0FBT0UsZUFBUztBQUNQLHdzU0FETztBQUVQO0FBRk8sT0FQWDtBQVdFLGtCQUFZO0FBQ1YsbUJBQVc7QUFBRSxvQkFBVSxDQUFDO0FBQUUsb0JBQVEsVUFBVjtBQUFzQix1QkFBVztBQUFqQyxXQUFELENBQVo7QUFBcUQsc0JBQVksQ0FBQztBQUFFLG9CQUFRLGdCQUFWO0FBQTRCLHVCQUFXLENBQUMsWUFBRDtBQUF2QyxXQUFEO0FBQWpFLFNBREQ7QUFFVixrQkFBVTtBQUFFLG9CQUFVLENBQUM7QUFBRSxvQkFBUSxTQUFWO0FBQXFCLHVCQUFXLENBQUMsY0FBRDtBQUFoQyxXQUFELEVBQXFEO0FBQUUsb0JBQVEsbUJBQVY7QUFBK0IsdUJBQVcsQ0FBQyxpQkFBRCxFQUFvQix3QkFBcEI7QUFBMUMsV0FBckQsRUFBZ0o7QUFBRSxvQkFBUSxxQkFBVjtBQUFpQyx1QkFBVyxDQUFDLGlCQUFELEVBQW9CLHdCQUFwQjtBQUE1QyxXQUFoSixFQUE2TztBQUFFLG9CQUFRLFlBQVY7QUFBd0IsdUJBQVcsQ0FBQyxpQkFBRCxFQUFvQix5QkFBcEI7QUFBbkMsV0FBN08sRUFBa1U7QUFBRSxvQkFBUSxnQkFBVjtBQUE0Qix1QkFBVyxDQUFDLGlCQUFELEVBQW9CLGNBQXBCO0FBQXZDLFdBQWxVLEVBQWdaO0FBQUUsb0JBQVEsU0FBVjtBQUFxQix1QkFBVyxDQUFDLGlCQUFELEVBQW9CLGVBQXBCO0FBQWhDLFdBQWhaLEVBQXdkO0FBQUUsb0JBQVEsZ0JBQVY7QUFBNEIsdUJBQVc7QUFBdkMsV0FBeGQsQ0FBWjtBQUFraEIsc0JBQVksQ0FBQztBQUFFLG9CQUFRLDBCQUFWO0FBQXNDLHVCQUFXLENBQUMsY0FBRCxFQUFpQiw4QkFBakI7QUFBakQsV0FBRCxFQUFzRztBQUFFLG9CQUFRLHdCQUFWO0FBQW9DLHVCQUFXLENBQUMsY0FBRCxFQUFpQiw0QkFBakI7QUFBL0MsV0FBdEcsRUFBdU07QUFBRSxvQkFBUSx5QkFBVjtBQUFxQyx1QkFBVyxDQUFDLGNBQUQsRUFBaUIsNkJBQWpCO0FBQWhELFdBQXZNLEVBQTBTO0FBQUUsb0JBQVEsaUJBQVY7QUFBNkIsdUJBQVcsQ0FBQyxpQkFBRCxFQUFvQix3QkFBcEI7QUFBeEMsV0FBMVMsRUFBbVk7QUFBRSxvQkFBUSxnQkFBVjtBQUE0Qix1QkFBVyxDQUFDLGNBQUQ7QUFBdkMsV0FBblk7QUFBOWhCO0FBRkEsT0FYZDtBQWVFLGlCQUFXLENBQ1Q7QUFBRSxnQkFBUSxjQUFWO0FBQTBCLGdCQUFRO0FBQWxDLE9BRFMsRUFFVDtBQUFFLGdCQUFRLHVCQUFWO0FBQW1DLGdCQUFRLFFBQTNDO0FBQXFELGlCQUFTLENBQUMsQ0FBRCxFQUFJLENBQUo7QUFBOUQsT0FGUyxFQUdUO0FBQUUsZ0JBQVEsc0JBQVY7QUFBa0MsZ0JBQVE7QUFBMUMsT0FIUyxFQUlUO0FBQUUsZ0JBQVEsOEJBQVY7QUFBMEMsZ0JBQVE7QUFBbEQsT0FKUyxFQUtUO0FBQUUsZ0JBQVEsNEJBQVY7QUFBd0MsZ0JBQVE7QUFBaEQsT0FMUyxFQU1UO0FBQUUsZ0JBQVEsNkJBQVY7QUFBeUMsZ0JBQVE7QUFBakQsT0FOUyxFQU9UO0FBQUUsZ0JBQVEsaUJBQVY7QUFBNkIsZ0JBQVE7QUFBckMsT0FQUyxFQVFUO0FBQUUsZ0JBQVEsd0JBQVY7QUFBb0MsZ0JBQVE7QUFBNUMsT0FSUyxFQVNUO0FBQUUsZ0JBQVEsZ0JBQVY7QUFBNEIsZ0JBQVE7QUFBcEMsT0FUUyxFQVVUO0FBQUUsZ0JBQVEsMEJBQVY7QUFBc0MsZ0JBQVE7QUFBOUMsT0FWUyxFQVdUO0FBQUUsZ0JBQVEsY0FBVjtBQUEwQixnQkFBUTtBQUFsQyxPQVhTLEVBWVQ7QUFBRSxnQkFBUSxrQkFBVjtBQUE4QixnQkFBUTtBQUF0QyxPQVpTLEVBYVQ7QUFBRSxnQkFBUSxnQkFBVjtBQUE0QixnQkFBUTtBQUFwQyxPQWJTLEVBY1Q7QUFBRSxnQkFBUSxjQUFWO0FBQTBCLGdCQUFRO0FBQWxDLE9BZFMsRUFlVDtBQUFFLGdCQUFRLGVBQVY7QUFBMkIsZ0JBQVE7QUFBbkMsT0FmUyxFQWdCVDtBQUFFLGdCQUFRLFlBQVY7QUFBd0IsZ0JBQVEsUUFBaEM7QUFBMEMsaUJBQVMsQ0FBQyxDQUFELEVBQUksQ0FBSjtBQUFuRCxPQWhCUyxFQWlCVDtBQUFFLGdCQUFRLFlBQVY7QUFBd0IsZ0JBQVE7QUFBaEMsT0FqQlMsRUFrQlQ7QUFBRSxnQkFBUSxnQkFBVjtBQUE0QixnQkFBUTtBQUFwQyxPQWxCUyxFQW1CVDtBQUFFLGdCQUFRLFdBQVY7QUFBdUIsZ0JBQVEsUUFBL0I7QUFBeUMsbUJBQVcsQ0FBQyxNQUFELEVBQVMsT0FBVDtBQUFwRCxPQW5CUyxFQW9CVDtBQUFFLGdCQUFRLFdBQVY7QUFBdUIsZ0JBQVEsUUFBL0I7QUFBeUMsbUJBQVcsQ0FBQyxNQUFELEVBQVMsT0FBVDtBQUFwRCxPQXBCUyxFQXFCVDtBQUFFLGdCQUFRLGFBQVY7QUFBeUIsZ0JBQVE7QUFBakMsT0FyQlMsRUFzQlQ7QUFBRSxnQkFBUSxRQUFWO0FBQW9CLGdCQUFRLFFBQTVCO0FBQXNDLG1CQUFXLENBQUMsTUFBRCxFQUFTLE9BQVQ7QUFBakQsT0F0QlMsRUF1QlQ7QUFBRSxnQkFBUSw0QkFBVjtBQUF3QyxnQkFBUTtBQUFoRCxPQXZCUyxFQXdCVDtBQUFFLGdCQUFRLHVCQUFWO0FBQW1DLGdCQUFRLFFBQTNDO0FBQXFELG1CQUFXLENBQUMsTUFBRCxFQUFTLE9BQVQ7QUFBaEUsT0F4QlMsRUF5QlQ7QUFBRSxnQkFBUSxtQkFBVjtBQUErQixnQkFBUTtBQUF2QyxPQXpCUyxFQTBCVDtBQUFFLGdCQUFRLGNBQVY7QUFBMEIsZ0JBQVEsUUFBbEM7QUFBNEMsbUJBQVcsQ0FBQyxNQUFELEVBQVMsT0FBVDtBQUF2RCxPQTFCUyxFQTJCVDtBQUFFLGdCQUFRLGtCQUFWO0FBQThCLGdCQUFRO0FBQXRDLE9BM0JTLEVBNEJUO0FBQUUsZ0JBQVEsYUFBVjtBQUF5QixnQkFBUSxRQUFqQztBQUEyQyxtQkFBVyxDQUFDLE1BQUQsRUFBUyxPQUFUO0FBQXRELE9BNUJTLEVBNkJUO0FBQUUsZ0JBQVEsbUJBQVY7QUFBK0IsZ0JBQVEsUUFBdkM7QUFBaUQsbUJBQVcsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVg7QUFBNUQsT0E3QlMsRUE4QlQ7QUFBRSxnQkFBUSxtQkFBVjtBQUErQixnQkFBUSxRQUF2QztBQUFpRCxtQkFBVyxDQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsR0FBWDtBQUE1RCxPQTlCUyxFQStCVDtBQUFFLGdCQUFRLGtCQUFWO0FBQThCLGdCQUFRLFFBQXRDO0FBQWdELG1CQUFXLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYO0FBQTNELE9BL0JTLEVBZ0NUO0FBQUUsZ0JBQVEsZ0JBQVY7QUFBNEIsZ0JBQVE7QUFBcEMsT0FoQ1MsRUFpQ1Q7QUFBRSxnQkFBUSxvQkFBVjtBQUFnQyxnQkFBUSxRQUF4QztBQUFrRCxtQkFBVyxDQUFDLEdBQUQsRUFBTSxHQUFOO0FBQTdELE9BakNTLENBZmI7QUFrREUsZ0JBQVUsQ0FDUjtBQUFDLGdCQUFRLFdBQVQ7QUFBc0IsbUJBQVcsRUFBakM7QUFBcUMsbUJBQVcsQ0FBaEQ7QUFBbUQsbUJBQVcsQ0FDNUQ7QUFBRSxrQkFBUSxjQUFWO0FBQTBCLGtCQUFRLEVBQWxDO0FBQXNDLG1CQUFTO0FBQS9DLFNBRDRELEVBRTVEO0FBQUUsa0JBQVEsUUFBVjtBQUFvQixrQkFBUSxFQUE1QjtBQUFnQyxtQkFBUztBQUF6QyxTQUY0RCxFQUc1RDtBQUFFLGtCQUFRLHNCQUFWO0FBQWtDLGtCQUFRLEVBQTFDO0FBQThDLG1CQUFTO0FBQXZELFNBSDRELEVBSTVEO0FBQUUsa0JBQVEsV0FBVjtBQUF1QixrQkFBUSxFQUEvQjtBQUFtQyxtQkFBUztBQUE1QyxTQUo0RCxFQUs1RDtBQUFFLGtCQUFRLFVBQVY7QUFBc0Isa0JBQVEsRUFBOUI7QUFBa0MsbUJBQVM7QUFBM0MsU0FMNEQsRUFNNUQ7QUFBRSxrQkFBUSxvQkFBVjtBQUFnQyxrQkFBUSxFQUF4QztBQUE0QyxtQkFBUztBQUFyRCxTQU40RDtBQUE5RCxPQURRLENBbERaO0FBNERFLGtCQUFZLENBQ1Y7QUFBRSxnQkFBUSxXQUFWO0FBQXVCLGdCQUFRLEVBQS9CO0FBQW1DLGlCQUFTLENBQTVDO0FBQStDLG1CQUFXLENBQUMsZ0JBQUQsQ0FBMUQ7QUFBOEUsbUJBQVc7QUFBekYsT0FEVSxFQUVWO0FBQUUsZ0JBQVEsV0FBVjtBQUF1QixnQkFBUSxFQUEvQjtBQUFtQyxpQkFBUyxDQUE1QztBQUErQyxtQkFBVyxDQUFDLGdCQUFELENBQTFEO0FBQThFLG1CQUFXO0FBQXpGLE9BRlUsRUFHVjtBQUFFLGdCQUFRLFFBQVY7QUFBb0IsZ0JBQVEsRUFBNUI7QUFBZ0MsaUJBQVMsQ0FBekM7QUFBNEMsbUJBQVcsQ0FBQyxhQUFELENBQXZEO0FBQXdFLG1CQUFXO0FBQW5GLE9BSFUsRUFJVjtBQUFFLGdCQUFRLHNCQUFWO0FBQWtDLGdCQUFRLEVBQTFDO0FBQThDLGlCQUFTLENBQXZEO0FBQTBELG1CQUFXLENBQUMsNEJBQUQsQ0FBckU7QUFBcUcsbUJBQVc7QUFBaEgsT0FKVSxFQUtWO0FBQUUsZ0JBQVEsY0FBVjtBQUEwQixnQkFBUSxFQUFsQztBQUFzQyxpQkFBUyxDQUEvQztBQUFrRCxtQkFBVyxDQUFDLG1CQUFELENBQTdEO0FBQW9GLG1CQUFXO0FBQS9GLE9BTFUsRUFNVjtBQUFFLGdCQUFRLGFBQVY7QUFBeUIsZ0JBQVEsRUFBakM7QUFBcUMsaUJBQVMsQ0FBOUM7QUFBaUQsbUJBQVcsQ0FBQyxrQkFBRCxDQUE1RDtBQUFrRixtQkFBVztBQUE3RixPQU5VLENBNURkO0FBb0VFLG9CQUFjLENBQ1o7QUFBRSxnQkFBUSxZQUFWO0FBQXdCLGdCQUFRLEVBQWhDO0FBQW9DLGlCQUFTLENBQTdDO0FBQWdELG1CQUFXLEVBQTNEO0FBQStELGtCQUFVLEVBQXpFO0FBQTZFLG9CQUFZO0FBQXpGLE9BRFksRUFFWjtBQUFFLGdCQUFRLFVBQVY7QUFBc0IsZ0JBQVEsRUFBOUI7QUFBa0MsaUJBQVMsQ0FBM0M7QUFBOEMsbUJBQVcsRUFBekQ7QUFBNkQsa0JBQVUsRUFBdkU7QUFBMkUsb0JBQVk7QUFBdkYsT0FGWSxFQUdaO0FBQUUsZ0JBQVEsV0FBVjtBQUF1QixnQkFBUSxFQUEvQjtBQUFtQyxpQkFBUyxDQUE1QztBQUErQyxtQkFBVyxFQUExRDtBQUE4RCxrQkFBVSxFQUF4RTtBQUE0RSxvQkFBWTtBQUF4RixPQUhZLEVBSVo7QUFBRSxnQkFBUSxZQUFWO0FBQXdCLGdCQUFRLEVBQWhDO0FBQW9DLGlCQUFTLENBQTdDO0FBQWdELG1CQUFXLENBQUMsY0FBRCxDQUEzRDtBQUE2RSxrQkFBVSxFQUF2RjtBQUEyRixvQkFBWTtBQUF2RyxPQUpZLEVBS1o7QUFBRSxnQkFBUSxXQUFWO0FBQXVCLGdCQUFRLEVBQS9CO0FBQW1DLGlCQUFTLENBQTVDO0FBQStDLG1CQUFXLENBQUMsaUJBQUQsQ0FBMUQ7QUFBK0Usa0JBQVUsRUFBekY7QUFBNkYsb0JBQVk7QUFBekcsT0FMWSxFQU1aO0FBQUUsZ0JBQVEsVUFBVjtBQUFzQixnQkFBUSxFQUE5QjtBQUFrQyxpQkFBUyxDQUEzQztBQUE4QyxtQkFBVyxDQUFDLGlCQUFELENBQXpEO0FBQThFLGtCQUFVLEVBQXhGO0FBQTRGLG9CQUFZO0FBQXhHLE9BTlksRUFPWjtBQUFFLGdCQUFRLGlCQUFWO0FBQTZCLGdCQUFRLEVBQXJDO0FBQXlDLGlCQUFTLENBQWxEO0FBQXFELHFCQUFhLFFBQWxFO0FBQTRFLG1CQUFXLENBQUMsaUJBQUQsRUFBb0Isd0JBQXBCLEVBQThDLGdCQUE5QyxDQUF2RjtBQUF3SixrQkFBVSxFQUFsSztBQUFzSyx1QkFBZSxJQUFyTDtBQUEyTCxvQkFBWTtBQUF2TSxPQVBZLEVBUVo7QUFBRSxnQkFBUSxhQUFWO0FBQXlCLGdCQUFRLEVBQWpDO0FBQXFDLGlCQUFTLENBQTlDO0FBQWlELG1CQUFXLENBQUMsZ0JBQUQsQ0FBNUQ7QUFBZ0Ysa0JBQVUsRUFBMUY7QUFBOEYsdUJBQWUsSUFBN0c7QUFBbUgsb0JBQVk7QUFBL0gsT0FSWSxFQVNaO0FBQUUsZ0JBQVEsYUFBVjtBQUF5QixnQkFBUSxFQUFqQztBQUFxQyxpQkFBUyxDQUE5QztBQUFpRCxtQkFBVyxDQUFDLGdCQUFELENBQTVEO0FBQWdGLGtCQUFVLEVBQTFGO0FBQThGLHVCQUFlLElBQTdHO0FBQW1ILG9CQUFZO0FBQS9ILE9BVFksRUFVWjtBQUFFLGdCQUFRLGFBQVY7QUFBeUIsZ0JBQVEsRUFBakM7QUFBcUMsaUJBQVMsQ0FBOUM7QUFBaUQsbUJBQVcsQ0FBQyxnQkFBRCxDQUE1RDtBQUFnRixrQkFBVSxFQUExRjtBQUE4Rix1QkFBZSxJQUE3RztBQUFtSCxvQkFBWTtBQUEvSCxPQVZZLEVBV1o7QUFBRSxnQkFBUSxnQkFBVjtBQUE0QixnQkFBUSxFQUFwQztBQUF3QyxpQkFBUyxDQUFqRDtBQUFvRCxtQkFBVyxDQUFDLGlCQUFELEVBQW9CLGNBQXBCLENBQS9EO0FBQW9HLGtCQUFVLEVBQTlHO0FBQWtILG9CQUFZO0FBQTlILE9BWFksRUFZWjtBQUFFLGdCQUFRLFNBQVY7QUFBcUIsZ0JBQVEsRUFBN0I7QUFBaUMsaUJBQVMsQ0FBMUM7QUFBNkMsbUJBQVcsQ0FBQyxrQkFBRCxDQUF4RDtBQUE4RSxrQkFBVSxFQUF4RjtBQUE0RixvQkFBWTtBQUF4RyxPQVpZLEVBYVo7QUFBRSxnQkFBUSxZQUFWO0FBQXdCLGdCQUFRLEVBQWhDO0FBQW9DLGlCQUFTLENBQTdDO0FBQWdELG1CQUFXLEVBQTNEO0FBQStELGtCQUFVLEVBQXpFO0FBQTZFLG9CQUFZO0FBQXpGLE9BYlksRUFjWjtBQUFFLGdCQUFRLGFBQVY7QUFBeUIsZ0JBQVEsRUFBakM7QUFBcUMsaUJBQVMsQ0FBOUM7QUFBaUQsbUJBQVcsRUFBNUQ7QUFBZ0Usa0JBQVUsRUFBMUU7QUFBOEUsb0JBQVk7QUFBMUYsT0FkWTtBQXBFaEIsS0FEUztBQU5iLEdBL1JhLEVBNlhiO0FBQ0UsWUFBUSxpQkFEVjtBQUVFLGFBQVMsc0NBRlg7QUFHRSxrQkFBYyxDQUNaO0FBQUUsY0FBUSxRQUFWO0FBQW9CLGdCQUFVLENBQUM7QUFBRSxtQkFBVyxpREFBYjtBQUFnRSxzQkFBYztBQUFFLHFCQUFXO0FBQUUscUJBQVMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBQVg7QUFBeUIsb0JBQVE7QUFBakMsV0FBYjtBQUFvRCw2QkFBbUI7QUFBRSxxQkFBUyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBWDtBQUF5QixvQkFBUTtBQUFqQyxXQUF2RTtBQUE4Ryx1QkFBYTtBQUFFLHFCQUFTLE9BQVg7QUFBb0Isb0JBQVE7QUFBNUIsV0FBM0g7QUFBNkosd0JBQWM7QUFBRSxxQkFBUyxNQUFYO0FBQW1CLG9CQUFRO0FBQTNCLFdBQTNLO0FBQTRNLHdCQUFjO0FBQUUscUJBQVMsTUFBWDtBQUFtQixvQkFBUTtBQUEzQixXQUExTjtBQUEyUCx3QkFBYztBQUFFLHFCQUFTLE1BQVg7QUFBbUIsb0JBQVE7QUFBM0IsV0FBelE7QUFBMFMsd0JBQWM7QUFBRSxxQkFBUyxNQUFYO0FBQW1CLG9CQUFRO0FBQTNCLFdBQXhUO0FBQXlWLHNCQUFZO0FBQUUscUJBQVMsTUFBWDtBQUFtQixvQkFBUTtBQUEzQjtBQUFyVztBQUE5RSxPQUFEO0FBQTlCLEtBRFksQ0FIaEI7QUFNRSxlQUFXLENBQ1Q7QUFDRSxjQUFRLGlEQURWO0FBRUUsY0FBUSxRQUZWO0FBR0UsZUFBUztBQUNQLCt6REFETztBQUVQO0FBRk8sT0FIWDtBQU9FLGVBQVM7QUFDUCxtOENBRE87QUFFUDtBQUZPLE9BUFg7QUFXRSxrQkFBWTtBQUNWLG1CQUFXO0FBQUUsb0JBQVUsQ0FBQztBQUFFLG9CQUFRLFVBQVY7QUFBc0IsdUJBQVc7QUFBakMsV0FBRCxDQUFaO0FBQXFELHNCQUFZO0FBQWpFLFNBREQ7QUFFVixrQkFBVTtBQUFFLG9CQUFVLENBQUM7QUFBRSxvQkFBUSxTQUFWO0FBQXFCLHVCQUFXO0FBQWhDLFdBQUQsQ0FBWjtBQUFvRCxzQkFBWTtBQUFoRTtBQUZBLE9BWGQ7QUFlRSxpQkFBVyxDQUNUO0FBQUUsZ0JBQVEsV0FBVjtBQUF1QixnQkFBUSxRQUEvQjtBQUF5QyxpQkFBUyxDQUFDLENBQUQsRUFBSSxDQUFKO0FBQWxELE9BRFMsRUFFVDtBQUFFLGdCQUFRLFlBQVY7QUFBd0IsZ0JBQVE7QUFBaEMsT0FGUyxFQUdUO0FBQUUsZ0JBQVEsUUFBVjtBQUFvQixnQkFBUSxRQUE1QjtBQUFzQyxpQkFBUyxDQUFDLENBQUQsRUFBSSxDQUFKO0FBQS9DLE9BSFMsQ0FmYjtBQW9CRSxnQkFBVSxDQUNSO0FBQUMsZ0JBQVEsV0FBVDtBQUFzQixtQkFBVyxFQUFqQztBQUFxQyxtQkFBVyxDQUFoRDtBQUFtRCxtQkFBVyxDQUM1RDtBQUFFLGtCQUFRLFNBQVY7QUFBcUIsa0JBQVEsRUFBN0I7QUFBaUMsbUJBQVM7QUFBMUMsU0FENEQsRUFFNUQ7QUFBRSxrQkFBUSxpQkFBVjtBQUE2QixrQkFBUSxFQUFyQztBQUF5QyxtQkFBUztBQUFsRCxTQUY0RDtBQUE5RCxPQURRLENBcEJaO0FBMEJFLGtCQUFZLENBQ1Y7QUFBRSxnQkFBUSxXQUFWO0FBQXVCLGdCQUFRLEVBQS9CO0FBQW1DLGlCQUFTLENBQTVDO0FBQStDLG1CQUFXLEVBQTFEO0FBQThELG1CQUFXO0FBQXpFLE9BRFUsRUFFVjtBQUFFLGdCQUFRLFlBQVY7QUFBd0IsZ0JBQVEsRUFBaEM7QUFBb0MsaUJBQVMsQ0FBN0M7QUFBZ0QsbUJBQVcsRUFBM0Q7QUFBK0QsbUJBQVc7QUFBMUUsT0FGVSxFQUdWO0FBQUUsZ0JBQVEsWUFBVjtBQUF3QixnQkFBUSxFQUFoQztBQUFvQyxpQkFBUyxDQUE3QztBQUFnRCxtQkFBVyxFQUEzRDtBQUErRCxtQkFBVztBQUExRSxPQUhVLEVBSVY7QUFBRSxnQkFBUSxZQUFWO0FBQXdCLGdCQUFRLEVBQWhDO0FBQW9DLGlCQUFTLENBQTdDO0FBQWdELG1CQUFXLEVBQTNEO0FBQStELG1CQUFXO0FBQTFFLE9BSlUsRUFLVjtBQUFFLGdCQUFRLFlBQVY7QUFBd0IsZ0JBQVEsRUFBaEM7QUFBb0MsaUJBQVMsQ0FBN0M7QUFBZ0QsbUJBQVcsRUFBM0Q7QUFBK0QsbUJBQVc7QUFBMUUsT0FMVSxFQU1WO0FBQUUsZ0JBQVEsVUFBVjtBQUFzQixnQkFBUSxFQUE5QjtBQUFrQyxpQkFBUyxDQUEzQztBQUE4QyxtQkFBVyxFQUF6RDtBQUE2RCxtQkFBVztBQUF4RSxPQU5VLENBMUJkO0FBa0NFLG9CQUFjLENBQ1o7QUFBRSxnQkFBUSxZQUFWO0FBQXdCLGdCQUFRLEVBQWhDO0FBQW9DLGlCQUFTLENBQTdDO0FBQWdELG1CQUFXLEVBQTNEO0FBQStELGtCQUFVLEVBQXpFO0FBQTZFLG9CQUFZO0FBQXpGLE9BRFksRUFFWjtBQUFFLGdCQUFRLFVBQVY7QUFBc0IsZ0JBQVEsRUFBOUI7QUFBa0MsaUJBQVMsQ0FBM0M7QUFBOEMsbUJBQVcsRUFBekQ7QUFBNkQsa0JBQVUsRUFBdkU7QUFBMkUsb0JBQVk7QUFBdkYsT0FGWSxFQUdaO0FBQUUsZ0JBQVEsWUFBVjtBQUF3QixnQkFBUSxFQUFoQztBQUFvQyxpQkFBUyxDQUE3QztBQUFnRCxtQkFBVyxFQUEzRDtBQUErRCxrQkFBVSxFQUF6RTtBQUE2RSxvQkFBWTtBQUF6RixPQUhZO0FBbENoQixLQURTO0FBTmIsR0E3WGEsRUE4YWI7QUFDRSxZQUFRLGVBRFY7QUFFRSxhQUFTLHNDQUZYO0FBR0Usa0JBQWMsQ0FDWjtBQUFFLGNBQVEsUUFBVjtBQUFvQixnQkFBVSxDQUFDO0FBQUUsbUJBQVcsMkNBQWI7QUFBMEQsc0JBQWM7QUFBRSx5QkFBZTtBQUFFLHFCQUFTLE1BQVg7QUFBbUIsb0JBQVE7QUFBM0IsV0FBakI7QUFBa0QsMEJBQWdCO0FBQUUscUJBQVMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBQVg7QUFBeUIsb0JBQVE7QUFBakMsV0FBbEU7QUFBeUcsdUJBQWE7QUFBRSxxQkFBUyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sQ0FBUCxFQUFVLENBQVYsQ0FBWDtBQUF5QixvQkFBUTtBQUFqQyxXQUF0SDtBQUE2Six3QkFBYztBQUFFLHFCQUFTLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLENBQVg7QUFBc0Isb0JBQVEsRUFBOUI7QUFBa0MsMEJBQWMsQ0FBQyxxQkFBRCxFQUF3QixDQUF4QixFQUEyQixFQUEzQjtBQUFoRCxXQUEzSztBQUE2UCw0QkFBa0I7QUFBRSxxQkFBUyxDQUFDLEdBQUQsQ0FBWDtBQUFrQixvQkFBUSxFQUExQjtBQUE4QiwwQkFBYyxDQUFDLHFCQUFELEVBQXdCLENBQXhCLEVBQTJCLEVBQTNCO0FBQTVDLFdBQS9RO0FBQTZWLG1CQUFTO0FBQUUsb0JBQVEsRUFBVjtBQUFjLDBCQUFjLENBQUMsV0FBRCxFQUFjLENBQWQsRUFBaUIsRUFBakI7QUFBNUIsV0FBdFc7QUFBMFosaUNBQXVCO0FBQUUsb0JBQVEsRUFBVjtBQUFjLHFCQUFTLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsR0FBVjtBQUF2QjtBQUFqYjtBQUF4RSxPQUFEO0FBQTlCLEtBRFksQ0FIaEI7QUFNRSxlQUFXLENBQ1Q7QUFDRSxjQUFRLDJDQURWO0FBRUUsY0FBUSxVQUZWO0FBR0UsZUFBUztBQUNQLGswUkFETztBQUVQO0FBRk8sT0FIWDtBQU9FLGVBQVM7QUFDUCxrd1FBRE87QUFFUDtBQUZPLE9BUFg7QUFXRSxrQkFBWTtBQUNWLG1CQUFXO0FBQUUsb0JBQVUsQ0FBQztBQUFFLG9CQUFRLFVBQVY7QUFBc0IsdUJBQVc7QUFBakMsV0FBRCxDQUFaO0FBQXFELHNCQUFZO0FBQWpFLFNBREQ7QUFFVixrQkFBVTtBQUFFLG9CQUFVLENBQUM7QUFBRSxvQkFBUSxTQUFWO0FBQXFCLHVCQUFXLENBQUMsY0FBRDtBQUFoQyxXQUFELEVBQXFEO0FBQUUsb0JBQVEsbUJBQVY7QUFBK0IsdUJBQVcsQ0FBQyxpQkFBRCxFQUFvQix3QkFBcEI7QUFBMUMsV0FBckQsRUFBZ0o7QUFBRSxvQkFBUSxxQkFBVjtBQUFpQyx1QkFBVyxDQUFDLGlCQUFELEVBQW9CLHdCQUFwQjtBQUE1QyxXQUFoSixFQUE2TztBQUFFLG9CQUFRLFlBQVY7QUFBd0IsdUJBQVcsQ0FBQyxpQkFBRCxFQUFvQix5QkFBcEI7QUFBbkMsV0FBN08sRUFBa1U7QUFBRSxvQkFBUSxnQkFBVjtBQUE0Qix1QkFBVyxDQUFDLGlCQUFELEVBQW9CLGNBQXBCO0FBQXZDLFdBQWxVLEVBQWdaO0FBQUUsb0JBQVEsU0FBVjtBQUFxQix1QkFBVyxDQUFDLGlCQUFELEVBQW9CLGVBQXBCO0FBQWhDLFdBQWhaLENBQVo7QUFBcWUsc0JBQVksQ0FBQztBQUFFLG9CQUFRLDBCQUFWO0FBQXNDLHVCQUFXLENBQUMsY0FBRCxFQUFpQiw4QkFBakI7QUFBakQsV0FBRCxFQUFzRztBQUFFLG9CQUFRLHdCQUFWO0FBQW9DLHVCQUFXLENBQUMsY0FBRCxFQUFpQiw0QkFBakI7QUFBL0MsV0FBdEcsRUFBdU07QUFBRSxvQkFBUSx5QkFBVjtBQUFxQyx1QkFBVyxDQUFDLGNBQUQsRUFBaUIsNkJBQWpCO0FBQWhELFdBQXZNLEVBQTBTO0FBQUUsb0JBQVEsaUJBQVY7QUFBNkIsdUJBQVcsQ0FBQyxpQkFBRCxFQUFvQix3QkFBcEI7QUFBeEMsV0FBMVM7QUFBamY7QUFGQSxPQVhkO0FBZUUsaUJBQVcsQ0FDVDtBQUFFLGdCQUFRLGNBQVY7QUFBMEIsZ0JBQVE7QUFBbEMsT0FEUyxFQUVUO0FBQUUsZ0JBQVEsdUJBQVY7QUFBbUMsZ0JBQVEsUUFBM0M7QUFBcUQsaUJBQVMsQ0FBQyxDQUFELEVBQUksQ0FBSjtBQUE5RCxPQUZTLEVBR1Q7QUFBRSxnQkFBUSxzQkFBVjtBQUFrQyxnQkFBUTtBQUExQyxPQUhTLEVBSVQ7QUFBRSxnQkFBUSw4QkFBVjtBQUEwQyxnQkFBUTtBQUFsRCxPQUpTLEVBS1Q7QUFBRSxnQkFBUSw0QkFBVjtBQUF3QyxnQkFBUTtBQUFoRCxPQUxTLEVBTVQ7QUFBRSxnQkFBUSw2QkFBVjtBQUF5QyxnQkFBUTtBQUFqRCxPQU5TLEVBT1Q7QUFBRSxnQkFBUSxpQkFBVjtBQUE2QixnQkFBUTtBQUFyQyxPQVBTLEVBUVQ7QUFBRSxnQkFBUSx3QkFBVjtBQUFvQyxnQkFBUTtBQUE1QyxPQVJTLEVBU1Q7QUFBRSxnQkFBUSxnQkFBVjtBQUE0QixnQkFBUTtBQUFwQyxPQVRTLEVBVVQ7QUFBRSxnQkFBUSwwQkFBVjtBQUFzQyxnQkFBUTtBQUE5QyxPQVZTLEVBV1Q7QUFBRSxnQkFBUSxjQUFWO0FBQTBCLGdCQUFRO0FBQWxDLE9BWFMsRUFZVDtBQUFFLGdCQUFRLGtCQUFWO0FBQThCLGdCQUFRO0FBQXRDLE9BWlMsRUFhVDtBQUFFLGdCQUFRLGFBQVY7QUFBeUIsZ0JBQVE7QUFBakMsT0FiUyxFQWNUO0FBQUUsZ0JBQVEsU0FBVjtBQUFxQixnQkFBUTtBQUE3QixPQWRTLEVBZVQ7QUFBRSxnQkFBUSxZQUFWO0FBQXdCLGdCQUFRO0FBQWhDLE9BZlMsRUFnQlQ7QUFBRSxnQkFBUSxnQkFBVjtBQUE0QixnQkFBUTtBQUFwQyxPQWhCUyxFQWlCVDtBQUFFLGdCQUFRLG9CQUFWO0FBQWdDLGdCQUFRLFFBQXhDO0FBQWtELG1CQUFXLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLEdBQWhCO0FBQTdELE9BakJTLENBZmI7QUFrQ0UsZ0JBQVUsQ0FDUjtBQUFDLGdCQUFRLFdBQVQ7QUFBc0IsbUJBQVcsQ0FBQyxhQUFELENBQWpDO0FBQWtELG1CQUFXLENBQTdEO0FBQWdFLG1CQUFXLENBQ3pFO0FBQUUsa0JBQVEsY0FBVjtBQUEwQixrQkFBUSxFQUFsQztBQUFzQyxtQkFBUztBQUEvQyxTQUR5RTtBQUEzRSxPQURRLEVBSVI7QUFBQyxnQkFBUSxVQUFUO0FBQXFCLG1CQUFXLEVBQWhDO0FBQW9DLG1CQUFXLENBQS9DO0FBQWtELG1CQUFXLENBQzNEO0FBQUUsa0JBQVEsV0FBVjtBQUF1QixrQkFBUSxFQUEvQjtBQUFtQyxtQkFBUztBQUE1QyxTQUQyRCxFQUUzRDtBQUFFLGtCQUFRLHFCQUFWO0FBQWlDLGtCQUFRLEVBQXpDO0FBQTZDLG1CQUFTO0FBQXRELFNBRjJEO0FBQTdELE9BSlEsQ0FsQ1o7QUEyQ0Usa0JBQVksQ0FDVjtBQUFFLGdCQUFRLGFBQVY7QUFBeUIsZ0JBQVEsRUFBakM7QUFBcUMsaUJBQVMsQ0FBOUM7QUFBaUQsbUJBQVcsQ0FBQyxhQUFELENBQTVEO0FBQTZFLG1CQUFXO0FBQXhGLE9BRFUsQ0EzQ2Q7QUE4Q0Usb0JBQWMsQ0FDWjtBQUFFLGdCQUFRLFlBQVY7QUFBd0IsZ0JBQVEsRUFBaEM7QUFBb0MsaUJBQVMsQ0FBN0M7QUFBZ0QsbUJBQVcsRUFBM0Q7QUFBK0Qsa0JBQVUsRUFBekU7QUFBNkUsb0JBQVk7QUFBekYsT0FEWSxFQUVaO0FBQUUsZ0JBQVEsWUFBVjtBQUF3QixnQkFBUSxFQUFoQztBQUFvQyxpQkFBUyxDQUE3QztBQUFnRCxtQkFBVyxDQUFDLGNBQUQsQ0FBM0Q7QUFBNkUsa0JBQVUsRUFBdkY7QUFBMkYsb0JBQVk7QUFBdkcsT0FGWSxFQUdaO0FBQUUsZ0JBQVEsV0FBVjtBQUF1QixnQkFBUSxFQUEvQjtBQUFtQyxpQkFBUyxDQUE1QztBQUErQyxtQkFBVyxDQUFDLGlCQUFELENBQTFEO0FBQStFLGtCQUFVLEVBQXpGO0FBQTZGLG9CQUFZO0FBQXpHLE9BSFksRUFJWjtBQUFFLGdCQUFRLFVBQVY7QUFBc0IsZ0JBQVEsRUFBOUI7QUFBa0MsaUJBQVMsQ0FBM0M7QUFBOEMsbUJBQVcsQ0FBQyxpQkFBRCxDQUF6RDtBQUE4RSxrQkFBVSxFQUF4RjtBQUE0RixvQkFBWTtBQUF4RyxPQUpZLEVBS1o7QUFBRSxnQkFBUSxpQkFBVjtBQUE2QixnQkFBUSxFQUFyQztBQUF5QyxpQkFBUyxDQUFsRDtBQUFxRCxxQkFBYSxRQUFsRTtBQUE0RSxtQkFBVyxDQUFDLGlCQUFELEVBQW9CLHdCQUFwQixFQUE4QyxnQkFBOUMsQ0FBdkY7QUFBd0osa0JBQVUsRUFBbEs7QUFBc0ssdUJBQWUsSUFBckw7QUFBMkwsb0JBQVk7QUFBdk0sT0FMWSxFQU1aO0FBQUUsZ0JBQVEsYUFBVjtBQUF5QixnQkFBUSxFQUFqQztBQUFxQyxpQkFBUyxDQUE5QztBQUFpRCxtQkFBVyxDQUFDLGdCQUFELENBQTVEO0FBQWdGLGtCQUFVLEVBQTFGO0FBQThGLHVCQUFlLElBQTdHO0FBQW1ILG9CQUFZO0FBQS9ILE9BTlksRUFPWjtBQUFFLGdCQUFRLGFBQVY7QUFBeUIsZ0JBQVEsRUFBakM7QUFBcUMsaUJBQVMsQ0FBOUM7QUFBaUQsbUJBQVcsQ0FBQyxnQkFBRCxDQUE1RDtBQUFnRixrQkFBVSxFQUExRjtBQUE4Rix1QkFBZSxJQUE3RztBQUFtSCxvQkFBWTtBQUEvSCxPQVBZLEVBUVo7QUFBRSxnQkFBUSxhQUFWO0FBQXlCLGdCQUFRLEVBQWpDO0FBQXFDLGlCQUFTLENBQTlDO0FBQWlELG1CQUFXLENBQUMsZ0JBQUQsQ0FBNUQ7QUFBZ0Ysa0JBQVUsRUFBMUY7QUFBOEYsdUJBQWUsSUFBN0c7QUFBbUgsb0JBQVk7QUFBL0gsT0FSWSxFQVNaO0FBQUUsZ0JBQVEsZ0JBQVY7QUFBNEIsZ0JBQVEsRUFBcEM7QUFBd0MsaUJBQVMsQ0FBakQ7QUFBb0QsbUJBQVcsQ0FBQyxpQkFBRCxFQUFvQixjQUFwQixDQUEvRDtBQUFvRyxrQkFBVSxFQUE5RztBQUFrSCxvQkFBWTtBQUE5SCxPQVRZLEVBVVo7QUFBRSxnQkFBUSxTQUFWO0FBQXFCLGdCQUFRLEVBQTdCO0FBQWlDLGlCQUFTLENBQTFDO0FBQTZDLG1CQUFXLENBQUMsa0JBQUQsQ0FBeEQ7QUFBOEUsa0JBQVUsRUFBeEY7QUFBNEYsb0JBQVk7QUFBeEcsT0FWWSxFQVdaO0FBQUUsZ0JBQVEsWUFBVjtBQUF3QixnQkFBUSxFQUFoQztBQUFvQyxpQkFBUyxDQUE3QztBQUFnRCxtQkFBVyxDQUFDLGFBQUQsQ0FBM0Q7QUFBNEUsa0JBQVUsRUFBdEY7QUFBMEYsb0JBQVk7QUFBdEcsT0FYWTtBQTlDaEIsS0FEUztBQU5iLEdBOWFhLEVBbWZiO0FBQ0UsWUFBUSx3QkFEVjtBQUVFLGFBQVMsc0NBRlg7QUFHRSxrQkFBYyxDQUNaO0FBQUUsZ0JBQVUsQ0FBQztBQUFFLGlCQUFTLGNBQVg7QUFBMkIsc0JBQWM7QUFBRSxxQkFBVyxDQUFDO0FBQUUscUJBQVMsSUFBWDtBQUFpQix3QkFBWSxDQUE3QjtBQUFnQyx3QkFBWSxDQUE1QztBQUErQyw2QkFBaUI7QUFBaEUsV0FBRDtBQUFiLFNBQXpDO0FBQStILG1CQUFXLG9FQUExSTtBQUFnTiw2QkFBcUI7QUFBRSx1QkFBYSxJQUFmO0FBQXFCLHdCQUFjLEtBQW5DO0FBQTBDLDhCQUFvQixJQUE5RDtBQUFvRSw4QkFBb0IsQ0FBeEY7QUFBMkYsZ0NBQXNCLENBQWpIO0FBQW9ILDRCQUFrQixHQUF0STtBQUEySSw2QkFBbUIsR0FBOUo7QUFBbUssaUNBQXVCLEdBQTFMO0FBQStMLGtDQUF3QixHQUF2TjtBQUE0TixrQ0FBd0IsR0FBcFA7QUFBeVAsbUNBQXlCO0FBQWxSO0FBQXJPLE9BQUQ7QUFBWixLQURZLENBSGhCO0FBTUUsZUFBVyxDQUNUO0FBQ0UsY0FBUSxvRUFEVjtBQUVFLGNBQVEsVUFGVjtBQUdFLGVBQVM7QUFDUCxxa1JBRE87QUFFUDtBQUZPLE9BSFg7QUFPRSxlQUFTO0FBQ1AsdTlQQURPO0FBRVA7QUFGTyxPQVBYO0FBV0Usa0JBQVk7QUFDVixtQkFBVztBQUFFLG9CQUFVLENBQUM7QUFBRSxvQkFBUSxVQUFWO0FBQXNCLHVCQUFXO0FBQWpDLFdBQUQsRUFBd0M7QUFBRSxvQkFBUSxVQUFWO0FBQXNCLHVCQUFXO0FBQWpDLFdBQXhDLENBQVo7QUFBNEYsc0JBQVk7QUFBeEcsU0FERDtBQUVWLGtCQUFVO0FBQUUsb0JBQVUsQ0FBQztBQUFFLG9CQUFRLFNBQVY7QUFBcUIsdUJBQVcsQ0FBQyxjQUFEO0FBQWhDLFdBQUQsRUFBcUQ7QUFBRSxvQkFBUSxtQkFBVjtBQUErQix1QkFBVyxDQUFDLGlCQUFELEVBQW9CLHdCQUFwQjtBQUExQyxXQUFyRCxFQUFnSjtBQUFFLG9CQUFRLHFCQUFWO0FBQWlDLHVCQUFXLENBQUMsaUJBQUQsRUFBb0Isd0JBQXBCO0FBQTVDLFdBQWhKLEVBQTZPO0FBQUUsb0JBQVEsWUFBVjtBQUF3Qix1QkFBVyxDQUFDLGlCQUFELEVBQW9CLHlCQUFwQjtBQUFuQyxXQUE3TyxFQUFrVTtBQUFFLG9CQUFRLGdCQUFWO0FBQTRCLHVCQUFXLENBQUMsaUJBQUQsRUFBb0IsY0FBcEI7QUFBdkMsV0FBbFUsRUFBZ1o7QUFBRSxvQkFBUSxTQUFWO0FBQXFCLHVCQUFXLENBQUMsaUJBQUQsRUFBb0IsZUFBcEI7QUFBaEMsV0FBaFosQ0FBWjtBQUFxZSxzQkFBWSxDQUFDO0FBQUUsb0JBQVEsMEJBQVY7QUFBc0MsdUJBQVcsQ0FBQyxjQUFELEVBQWlCLDhCQUFqQjtBQUFqRCxXQUFELEVBQXNHO0FBQUUsb0JBQVEsd0JBQVY7QUFBb0MsdUJBQVcsQ0FBQyxjQUFELEVBQWlCLDRCQUFqQjtBQUEvQyxXQUF0RyxFQUF1TTtBQUFFLG9CQUFRLHlCQUFWO0FBQXFDLHVCQUFXLENBQUMsY0FBRCxFQUFpQiw2QkFBakI7QUFBaEQsV0FBdk0sRUFBMFM7QUFBRSxvQkFBUSxpQkFBVjtBQUE2Qix1QkFBVyxDQUFDLGlCQUFELEVBQW9CLHdCQUFwQjtBQUF4QyxXQUExUztBQUFqZjtBQUZBLE9BWGQ7QUFlRSxpQkFBVyxDQUNUO0FBQUUsZ0JBQVEsY0FBVjtBQUEwQixnQkFBUTtBQUFsQyxPQURTLEVBRVQ7QUFBRSxnQkFBUSx1QkFBVjtBQUFtQyxnQkFBUSxRQUEzQztBQUFxRCxpQkFBUyxDQUFDLENBQUQsRUFBSSxDQUFKO0FBQTlELE9BRlMsRUFHVDtBQUFFLGdCQUFRLHNCQUFWO0FBQWtDLGdCQUFRO0FBQTFDLE9BSFMsRUFJVDtBQUFFLGdCQUFRLDhCQUFWO0FBQTBDLGdCQUFRO0FBQWxELE9BSlMsRUFLVDtBQUFFLGdCQUFRLDRCQUFWO0FBQXdDLGdCQUFRO0FBQWhELE9BTFMsRUFNVDtBQUFFLGdCQUFRLDZCQUFWO0FBQXlDLGdCQUFRO0FBQWpELE9BTlMsRUFPVDtBQUFFLGdCQUFRLGlCQUFWO0FBQTZCLGdCQUFRO0FBQXJDLE9BUFMsRUFRVDtBQUFFLGdCQUFRLHdCQUFWO0FBQW9DLGdCQUFRO0FBQTVDLE9BUlMsRUFTVDtBQUFFLGdCQUFRLGdCQUFWO0FBQTRCLGdCQUFRO0FBQXBDLE9BVFMsRUFVVDtBQUFFLGdCQUFRLDBCQUFWO0FBQXNDLGdCQUFRO0FBQTlDLE9BVlMsRUFXVDtBQUFFLGdCQUFRLGNBQVY7QUFBMEIsZ0JBQVE7QUFBbEMsT0FYUyxFQVlUO0FBQUUsZ0JBQVEsWUFBVjtBQUF3QixnQkFBUTtBQUFoQyxPQVpTLENBZmI7QUE2QkUsZ0JBQVUsRUE3Qlo7QUE4QkUsa0JBQVksRUE5QmQ7QUErQkUsb0JBQWMsQ0FDWjtBQUFFLGdCQUFRLFlBQVY7QUFBd0IsZ0JBQVEsRUFBaEM7QUFBb0MsaUJBQVMsQ0FBN0M7QUFBZ0QsbUJBQVcsRUFBM0Q7QUFBK0Qsa0JBQVUsRUFBekU7QUFBNkUsb0JBQVk7QUFBekYsT0FEWSxFQUVaO0FBQUUsZ0JBQVEsWUFBVjtBQUF3QixnQkFBUSxFQUFoQztBQUFvQyxpQkFBUyxDQUE3QztBQUFnRCxtQkFBVyxDQUFDLGNBQUQsQ0FBM0Q7QUFBNkUsa0JBQVUsRUFBdkY7QUFBMkYsb0JBQVk7QUFBdkcsT0FGWSxFQUdaO0FBQUUsZ0JBQVEsV0FBVjtBQUF1QixnQkFBUSxFQUEvQjtBQUFtQyxpQkFBUyxDQUE1QztBQUErQyxtQkFBVyxDQUFDLGlCQUFELENBQTFEO0FBQStFLGtCQUFVLEVBQXpGO0FBQTZGLG9CQUFZO0FBQXpHLE9BSFksRUFJWjtBQUFFLGdCQUFRLFVBQVY7QUFBc0IsZ0JBQVEsRUFBOUI7QUFBa0MsaUJBQVMsQ0FBM0M7QUFBOEMsbUJBQVcsQ0FBQyxpQkFBRCxDQUF6RDtBQUE4RSxrQkFBVSxFQUF4RjtBQUE0RixvQkFBWTtBQUF4RyxPQUpZLEVBS1o7QUFBRSxnQkFBUSxpQkFBVjtBQUE2QixnQkFBUSxFQUFyQztBQUF5QyxpQkFBUyxDQUFsRDtBQUFxRCxxQkFBYSxRQUFsRTtBQUE0RSxtQkFBVyxDQUFDLGlCQUFELEVBQW9CLHdCQUFwQixFQUE4QyxnQkFBOUMsQ0FBdkY7QUFBd0osa0JBQVUsRUFBbEs7QUFBc0ssdUJBQWUsSUFBckw7QUFBMkwsb0JBQVk7QUFBdk0sT0FMWSxFQU1aO0FBQUUsZ0JBQVEsYUFBVjtBQUF5QixnQkFBUSxFQUFqQztBQUFxQyxpQkFBUyxDQUE5QztBQUFpRCxtQkFBVyxDQUFDLGdCQUFELENBQTVEO0FBQWdGLGtCQUFVLEVBQTFGO0FBQThGLHVCQUFlLElBQTdHO0FBQW1ILG9CQUFZO0FBQS9ILE9BTlksRUFPWjtBQUFFLGdCQUFRLGFBQVY7QUFBeUIsZ0JBQVEsRUFBakM7QUFBcUMsaUJBQVMsQ0FBOUM7QUFBaUQsbUJBQVcsQ0FBQyxnQkFBRCxDQUE1RDtBQUFnRixrQkFBVSxFQUExRjtBQUE4Rix1QkFBZSxJQUE3RztBQUFtSCxvQkFBWTtBQUEvSCxPQVBZLEVBUVo7QUFBRSxnQkFBUSxhQUFWO0FBQXlCLGdCQUFRLEVBQWpDO0FBQXFDLGlCQUFTLENBQTlDO0FBQWlELG1CQUFXLENBQUMsZ0JBQUQsQ0FBNUQ7QUFBZ0Ysa0JBQVUsRUFBMUY7QUFBOEYsdUJBQWUsSUFBN0c7QUFBbUgsb0JBQVk7QUFBL0gsT0FSWSxFQVNaO0FBQUUsZ0JBQVEsZ0JBQVY7QUFBNEIsZ0JBQVEsRUFBcEM7QUFBd0MsaUJBQVMsQ0FBakQ7QUFBb0QsbUJBQVcsQ0FBQyxpQkFBRCxFQUFvQixjQUFwQixDQUEvRDtBQUFvRyxrQkFBVSxFQUE5RztBQUFrSCxvQkFBWTtBQUE5SCxPQVRZO0FBL0JoQixLQURTO0FBTmIsR0FuZmEsRUF1aUJiO0FBQ0UsWUFBUSxpQkFEVjtBQUVFLGFBQVMsc0NBRlg7QUFHRSxrQkFBYyxDQUNaO0FBQUUsZ0JBQVUsQ0FBQztBQUFFLDJCQUFtQjtBQUFFLHNCQUFZO0FBQWQsU0FBckI7QUFBd0MsbUJBQVcseUNBQW5EO0FBQThGLG9CQUFZLEdBQTFHO0FBQStHLDZCQUFxQjtBQUFFLHVCQUFhLElBQWY7QUFBcUIsd0JBQWM7QUFBbkM7QUFBcEksT0FBRDtBQUFaLEtBRFksQ0FIaEI7QUFNRSxlQUFXLENBQ1Q7QUFDRSxjQUFRLHlDQURWO0FBRUUsY0FBUSxVQUZWO0FBR0UsZUFBUztBQUNQLDhpQ0FETztBQUVQO0FBRk8sT0FIWDtBQU9FLGVBQVM7QUFDUCwwcEJBRE87QUFFUDtBQUZPLE9BUFg7QUFXRSxrQkFBWTtBQUNWLG1CQUFXO0FBQUUsb0JBQVUsQ0FBQztBQUFFLG9CQUFRLFVBQVY7QUFBc0IsdUJBQVc7QUFBakMsV0FBRCxDQUFaO0FBQXFELHNCQUFZLENBQUM7QUFBRSxvQkFBUSxnQkFBVjtBQUE0Qix1QkFBVztBQUF2QyxXQUFEO0FBQWpFLFNBREQ7QUFFVixrQkFBVTtBQUFFLG9CQUFVLEVBQVo7QUFBZ0Isc0JBQVk7QUFBNUI7QUFGQSxPQVhkO0FBZUUsaUJBQVcsQ0FDVDtBQUFFLGdCQUFRLFlBQVY7QUFBd0IsZ0JBQVEsUUFBaEM7QUFBMEMsaUJBQVMsQ0FBQyxDQUFELEVBQUksQ0FBSjtBQUFuRCxPQURTLEVBRVQ7QUFBRSxnQkFBUSxZQUFWO0FBQXdCLGdCQUFRO0FBQWhDLE9BRlMsRUFHVDtBQUFFLGdCQUFRLGtCQUFWO0FBQThCLGdCQUFRO0FBQXRDLE9BSFMsQ0FmYjtBQW9CRSxnQkFBVSxFQXBCWjtBQXFCRSxrQkFBWSxFQXJCZDtBQXNCRSxvQkFBYyxDQUNaO0FBQUUsZ0JBQVEsWUFBVjtBQUF3QixnQkFBUSxFQUFoQztBQUFvQyxpQkFBUyxDQUE3QztBQUFnRCxtQkFBVyxFQUEzRDtBQUErRCxrQkFBVSxFQUF6RTtBQUE2RSxvQkFBWTtBQUF6RixPQURZO0FBdEJoQixLQURTO0FBTmIsR0F2aUJhLEVBMGtCYjtBQUNFLFlBQVEsZUFEVjtBQUVFLGFBQVMsc0NBRlg7QUFHRSxrQkFBYyxDQUNaO0FBQUUsZ0JBQVUsQ0FBQztBQUFFLHNCQUFjO0FBQUUscUJBQVcsQ0FBQztBQUFFLHFCQUFTLElBQVg7QUFBaUIsd0JBQVksQ0FBN0I7QUFBZ0Msd0JBQVksQ0FBNUM7QUFBK0MsNkJBQWlCO0FBQWhFLFdBQUQ7QUFBYixTQUFoQjtBQUFzRywyQkFBbUI7QUFBRSxzQkFBWTtBQUFkLFNBQXpIO0FBQTRJLG1CQUFXLGlEQUF2SjtBQUEwTSw2QkFBcUI7QUFBRSx1QkFBYSxLQUFmO0FBQXNCLHdCQUFjO0FBQXBDO0FBQS9OLE9BQUQ7QUFBWixLQURZLENBSGhCO0FBTUUsZUFBVyxDQUNUO0FBQ0UsY0FBUSxpREFEVjtBQUVFLGNBQVEsVUFGVjtBQUdFLGVBQVM7QUFDUCxrMUNBRE87QUFFUDtBQUZPLE9BSFg7QUFPRSxlQUFTO0FBQ1AsbzFCQURPO0FBRVA7QUFGTyxPQVBYO0FBV0Usa0JBQVk7QUFDVixtQkFBVztBQUFFLG9CQUFVLENBQUM7QUFBRSxvQkFBUSxVQUFWO0FBQXNCLHVCQUFXO0FBQWpDLFdBQUQsQ0FBWjtBQUFxRCxzQkFBWTtBQUFqRSxTQUREO0FBRVYsa0JBQVU7QUFBRSxvQkFBVSxFQUFaO0FBQWdCLHNCQUFZO0FBQTVCO0FBRkEsT0FYZDtBQWVFLGlCQUFXLENBQ1Q7QUFBRSxnQkFBUSxZQUFWO0FBQXdCLGdCQUFRO0FBQWhDLE9BRFMsQ0FmYjtBQWtCRSxnQkFBVSxDQUNSO0FBQUMsZ0JBQVEsV0FBVDtBQUFzQixtQkFBVyxFQUFqQztBQUFxQyxtQkFBVyxDQUFoRDtBQUFtRCxtQkFBVyxDQUM1RDtBQUFFLGtCQUFRLFFBQVY7QUFBb0Isa0JBQVEsRUFBNUI7QUFBZ0MsbUJBQVM7QUFBekMsU0FENEQ7QUFBOUQsT0FEUSxFQUlSO0FBQUMsZ0JBQVEsY0FBVDtBQUF5QixtQkFBVyxFQUFwQztBQUF3QyxtQkFBVyxDQUFuRDtBQUFzRCxtQkFBVyxDQUMvRDtBQUFFLGtCQUFRLFFBQVY7QUFBb0Isa0JBQVEsRUFBNUI7QUFBZ0MsbUJBQVM7QUFBekMsU0FEK0Q7QUFBakUsT0FKUSxDQWxCWjtBQTBCRSxrQkFBWSxDQUNWO0FBQUUsZ0JBQVEsYUFBVjtBQUF5QixnQkFBUSxFQUFqQztBQUFxQyxpQkFBUyxDQUE5QztBQUFpRCxtQkFBVyxFQUE1RDtBQUFnRSxtQkFBVztBQUEzRSxPQURVLENBMUJkO0FBNkJFLG9CQUFjLENBQ1o7QUFBRSxnQkFBUSxZQUFWO0FBQXdCLGdCQUFRLEVBQWhDO0FBQW9DLGlCQUFTLENBQTdDO0FBQWdELG1CQUFXLEVBQTNEO0FBQStELGtCQUFVLEVBQXpFO0FBQTZFLG9CQUFZO0FBQXpGLE9BRFksRUFFWjtBQUFFLGdCQUFRLFNBQVY7QUFBcUIsZ0JBQVEsRUFBN0I7QUFBaUMsaUJBQVMsQ0FBMUM7QUFBNkMsbUJBQVcsRUFBeEQ7QUFBNEQsa0JBQVUsRUFBdEU7QUFBMEUsb0JBQVk7QUFBdEYsT0FGWTtBQTdCaEIsS0FEUztBQU5iLEdBMWtCYSxDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdHNsaW50OmRpc2FibGVcclxuLy8gYWJzb2x1dGUgZXNzZW50aWFsIGVmZmVjdHNcclxuZXhwb3J0IGRlZmF1bHQgW1xyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcImJ1aWx0aW4tYmlsbGJvYXJkXCIsXHJcbiAgICBcIl91dWlkXCI6IFwiNzExZWJlMTEtZjY3My00Y2Q5LTlhODMtNjNjNjBiYTU0YzViXCIsXHJcbiAgICBcInRlY2huaXF1ZXNcIjogW1xyXG4gICAgICB7IFwibmFtZVwiOiBcImFkZFwiLCBcInBhc3Nlc1wiOiBbeyBcInJhc3Rlcml6ZXJTdGF0ZVwiOiB7IFwiY3VsbE1vZGVcIjogMCB9LCBcImJsZW5kU3RhdGVcIjogeyBcInRhcmdldHNcIjogW3sgXCJibGVuZFwiOiB0cnVlLCBcImJsZW5kU3JjXCI6IDIsIFwiYmxlbmREc3RcIjogMSwgXCJibGVuZFNyY0FscGhhXCI6IDIsIFwiYmxlbmREc3RBbHBoYVwiOiAxIH1dIH0sIFwicHJvZ3JhbVwiOiBcImJ1aWx0aW4tYmlsbGJvYXJkfHZlcnQ6dnNfbWFpbnx0aW50ZWQtZnM6YWRkXCIsIFwiZGVwdGhTdGVuY2lsU3RhdGVcIjogeyBcImRlcHRoVGVzdFwiOiB0cnVlLCBcImRlcHRoV3JpdGVcIjogZmFsc2UgfSwgXCJwcm9wZXJ0aWVzXCI6IHsgXCJtYWluVGV4dHVyZVwiOiB7IFwidmFsdWVcIjogXCJncmV5XCIsIFwidHlwZVwiOiAyOCB9LCBcIm1haW5UaWxpbmdfT2Zmc2V0XCI6IHsgXCJ2YWx1ZVwiOiBbMSwgMSwgMCwgMF0sIFwidHlwZVwiOiAxNiB9LCBcInRpbnRDb2xvclwiOiB7IFwidmFsdWVcIjogWzAuNSwgMC41LCAwLjUsIDAuNV0sIFwidHlwZVwiOiAxNiB9IH0gfV0gfVxyXG4gICAgXSxcclxuICAgIFwic2hhZGVyc1wiOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBcIm5hbWVcIjogXCJidWlsdGluLWJpbGxib2FyZHx2ZXJ0OnZzX21haW58dGludGVkLWZzOmFkZFwiLFxyXG4gICAgICAgIFwiaGFzaFwiOiAzMDUyOTgwNTY2LFxyXG4gICAgICAgIFwiZ2xzbDNcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIENvbnN0YW50cyB7XFxuICB2ZWM0IG1haW5UaWxpbmdfT2Zmc2V0O1xcbiAgdmVjNCBmcmFtZVRpbGVfdmVsTGVuU2NhbGU7XFxuICB2ZWM0IHNjYWxlO1xcbn07XFxudW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbn07XFxudW5pZm9ybSBDQ0xvY2FsIHtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkSVQ7XFxuICBoaWdocCB2ZWM0IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG59O1xcbnZlYzQgcXVhdGVybmlvbkZyb21BeGlzICh2ZWMzIHhBeGlzLHZlYzMgeUF4aXMsdmVjMyB6QXhpcyl7XFxuICBtYXQzIG0gPSBtYXQzKHhBeGlzLHlBeGlzLHpBeGlzKTtcXG4gIGZsb2F0IHRyYWNlID0gbVswXVswXSArIG1bMV1bMV0gKyBtWzJdWzJdO1xcbiAgdmVjNCBxdWF0O1xcbiAgaWYgKHRyYWNlID4gMC4pIHtcXG4gICAgZmxvYXQgcyA9IDAuNSAvIHNxcnQodHJhY2UgKyAxLjApO1xcbiAgICBxdWF0LncgPSAwLjI1IC8gcztcXG4gICAgcXVhdC54ID0gKG1bMl1bMV0gLSBtWzFdWzJdKSAqIHM7XFxuICAgIHF1YXQueSA9IChtWzBdWzJdIC0gbVsyXVswXSkgKiBzO1xcbiAgICBxdWF0LnogPSAobVsxXVswXSAtIG1bMF1bMV0pICogcztcXG4gIH0gZWxzZSBpZiAoKG1bMF1bMF0gPiBtWzFdWzFdKSAmJiAobVswXVswXSA+IG1bMl1bMl0pKSB7XFxuICAgIGZsb2F0IHMgPSAyLjAgKiBzcXJ0KDEuMCArIG1bMF1bMF0gLSBtWzFdWzFdIC0gbVsyXVsyXSk7XFxuICAgIHF1YXQudyA9IChtWzJdWzFdIC0gbVsxXVsyXSkgLyBzO1xcbiAgICBxdWF0LnggPSAwLjI1ICogcztcXG4gICAgcXVhdC55ID0gKG1bMF1bMV0gKyBtWzFdWzBdKSAvIHM7XFxuICAgIHF1YXQueiA9IChtWzBdWzJdICsgbVsyXVswXSkgLyBzO1xcbiAgfSBlbHNlIGlmIChtWzFdWzFdID4gbVsyXVsyXSkge1xcbiAgICBmbG9hdCBzID0gMi4wICogc3FydCgxLjAgKyBtWzFdWzFdIC0gbVswXVswXSAtIG1bMl1bMl0pO1xcbiAgICBxdWF0LncgPSAobVswXVsyXSAtIG1bMl1bMF0pIC8gcztcXG4gICAgcXVhdC54ID0gKG1bMF1bMV0gKyBtWzFdWzBdKSAvIHM7XFxuICAgIHF1YXQueSA9IDAuMjUgKiBzO1xcbiAgICBxdWF0LnogPSAobVsxXVsyXSArIG1bMl1bMV0pIC8gcztcXG4gIH0gZWxzZSB7XFxuICAgIGZsb2F0IHMgPSAyLjAgKiBzcXJ0KDEuMCArIG1bMl1bMl0gLSBtWzBdWzBdIC0gbVsxXVsxXSk7XFxuICAgIHF1YXQudyA9IChtWzFdWzBdIC0gbVswXVsxXSkgLyBzO1xcbiAgICBxdWF0LnggPSAobVswXVsyXSArIG1bMl1bMF0pIC8gcztcXG4gICAgcXVhdC55ID0gKG1bMV1bMl0gKyBtWzJdWzFdKSAvIHM7XFxuICAgIHF1YXQueiA9IDAuMjUgKiBzO1xcbiAgfVxcbiAgZmxvYXQgbGVuID0gcXVhdC54ICogcXVhdC54ICsgcXVhdC55ICogcXVhdC55ICsgcXVhdC56ICogcXVhdC56ICsgcXVhdC53ICogcXVhdC53O1xcbiAgaWYgKGxlbiA+IDAuKSB7XFxuICAgIGxlbiA9IDEuIC8gc3FydChsZW4pO1xcbiAgICBxdWF0LnggPSBxdWF0LnggKiBsZW47XFxuICAgIHF1YXQueSA9IHF1YXQueSAqIGxlbjtcXG4gICAgcXVhdC56ID0gcXVhdC56ICogbGVuO1xcbiAgICBxdWF0LncgPSBxdWF0LncgKiBsZW47XFxuICB9XFxuICByZXR1cm4gcXVhdDtcXG59XFxudmVjNCBxdWF0ZXJuaW9uRnJvbUV1bGVyICh2ZWMzIGFuZ2xlKXtcXG4gIGZsb2F0IHggPSBhbmdsZS54IC8gMi47XFxuICBmbG9hdCB5ID0gYW5nbGUueSAvIDIuO1xcbiAgZmxvYXQgeiA9IGFuZ2xlLnogLyAyLjtcXG4gIGZsb2F0IHN4ID0gc2luKHgpO1xcbiAgZmxvYXQgY3ggPSBjb3MoeCk7XFxuICBmbG9hdCBzeSA9IHNpbih5KTtcXG4gIGZsb2F0IGN5ID0gY29zKHkpO1xcbiAgZmxvYXQgc3ogPSBzaW4oeik7XFxuICBmbG9hdCBjeiA9IGNvcyh6KTtcXG4gIHZlYzQgcXVhdCA9IHZlYzQoMCk7XFxuICBxdWF0LnggPSBzeCAqIGN5ICogY3ogKyBjeCAqIHN5ICogc3o7XFxuICBxdWF0LnkgPSBjeCAqIHN5ICogY3ogKyBzeCAqIGN5ICogc3o7XFxuICBxdWF0LnogPSBjeCAqIGN5ICogc3ogLSBzeCAqIHN5ICogY3o7XFxuICBxdWF0LncgPSBjeCAqIGN5ICogY3ogLSBzeCAqIHN5ICogc3o7XFxuICByZXR1cm4gcXVhdDtcXG59XFxudmVjNCBxdWF0TXVsdGlwbHkgKHZlYzQgYSwgdmVjNCBiKXtcXG4gIHZlYzQgcXVhdDtcXG4gIHF1YXQueCA9IGEueCAqIGIudyArIGEudyAqIGIueCArIGEueSAqIGIueiAtIGEueiAqIGIueTtcXG4gIHF1YXQueSA9IGEueSAqIGIudyArIGEudyAqIGIueSArIGEueiAqIGIueCAtIGEueCAqIGIuejtcXG4gIHF1YXQueiA9IGEueiAqIGIudyArIGEudyAqIGIueiArIGEueCAqIGIueSAtIGEueSAqIGIueDtcXG4gIHF1YXQudyA9IGEudyAqIGIudyAtIGEueCAqIGIueCAtIGEueSAqIGIueSAtIGEueiAqIGIuejtcXG4gIHJldHVybiBxdWF0O1xcbn1cXG52b2lkIHJvdGF0ZVZlY0Zyb21RdWF0IChpbm91dCB2ZWMzIHYsIHZlYzQgcSl7XFxuICBmbG9hdCBpeCA9IHEudyAqIHYueCArIHEueSAqIHYueiAtIHEueiAqIHYueTtcXG4gIGZsb2F0IGl5ID0gcS53ICogdi55ICsgcS56ICogdi54IC0gcS54ICogdi56O1xcbiAgZmxvYXQgaXogPSBxLncgKiB2LnogKyBxLnggKiB2LnkgLSBxLnkgKiB2Lng7XFxuICBmbG9hdCBpdyA9IC1xLnggKiB2LnggLSBxLnkgKiB2LnkgLSBxLnogKiB2Lno7XFxuICB2LnggPSBpeCAqIHEudyArIGl3ICogLXEueCArIGl5ICogLXEueiAtIGl6ICogLXEueTtcXG4gIHYueSA9IGl5ICogcS53ICsgaXcgKiAtcS55ICsgaXogKiAtcS54IC0gaXggKiAtcS56O1xcbiAgdi56ID0gaXogKiBxLncgKyBpdyAqIC1xLnogKyBpeCAqIC1xLnkgLSBpeSAqIC1xLng7XFxufVxcbnZlYzMgcm90YXRlSW5Mb2NhbFNwYWNlICh2ZWMzIHBvcywgdmVjMyB4QXhpcywgdmVjMyB5QXhpcywgdmVjMyB6QXhpcywgdmVjNCBxKXtcXG4gIHZlYzQgdmlld1F1YXQgPSBxdWF0ZXJuaW9uRnJvbUF4aXMoeEF4aXMsIHlBeGlzLCB6QXhpcyk7XFxuICB2ZWM0IHJvdFF1YXQgPSBxdWF0TXVsdGlwbHkodmlld1F1YXQsIHEpO1xcbiAgcm90YXRlVmVjRnJvbVF1YXQocG9zLCByb3RRdWF0KTtcXG4gIHJldHVybiBwb3M7XFxufVxcbnZvaWQgcm90YXRlQ29ybmVyIChpbm91dCB2ZWMyIGNvcm5lciwgZmxvYXQgYW5nbGUpe1xcbiAgZmxvYXQgeE9TID0gY29zKGFuZ2xlKSAqIGNvcm5lci54IC0gc2luKGFuZ2xlKSAqIGNvcm5lci55O1xcbiAgZmxvYXQgeU9TID0gc2luKGFuZ2xlKSAqIGNvcm5lci54ICsgY29zKGFuZ2xlKSAqIGNvcm5lci55O1xcbiAgY29ybmVyLnggPSB4T1M7XFxuICBjb3JuZXIueSA9IHlPUztcXG59XFxub3V0IHZlYzIgdXY7XFxub3V0IHZlYzQgY29sb3I7XFxudm9pZCBjb21wdXRlVmVydFBvcyAoaW5vdXQgdmVjNCBwb3MsIHZlYzIgdmVydE9mZnNldCwgdmVjNCBxLCB2ZWMzIHNcXG4gICwgbWF0NCB2aWV3SW52XFxuKSB7XFxuICB2ZWMzIHZpZXdTcGFjZVZlcnQgPSB2ZWMzKHZlcnRPZmZzZXQueCAqIHMueCwgdmVydE9mZnNldC55ICogcy55LCAwLik7XFxuICB2ZWMzIGNhbVggPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzBdLCB2aWV3SW52WzFdWzBdLCB2aWV3SW52WzJdWzBdKSk7XFxuICB2ZWMzIGNhbVkgPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzFdLCB2aWV3SW52WzFdWzFdLCB2aWV3SW52WzJdWzFdKSk7XFxuICB2ZWMzIGNhbVogPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzJdLCB2aWV3SW52WzFdWzJdLCB2aWV3SW52WzJdWzJdKSk7XFxuICBwb3MueHl6ICs9IHJvdGF0ZUluTG9jYWxTcGFjZSh2aWV3U3BhY2VWZXJ0LCBjYW1YLCBjYW1ZLCBjYW1aLCBxKTtcXG59XFxuaW4gdmVjMyBhX3Bvc2l0aW9uO1xcbmluIHZlYzIgYV90ZXhDb29yZDtcXG5pbiB2ZWM0IGFfY29sb3I7XFxudW5pZm9ybSBidWlsdGluIHtcXG4gIHZlYzQgY2Nfc2l6ZV9yb3RhdGlvbjtcXG59O1xcbnZlYzQgdnNfbWFpbigpIHtcXG4gIHZlYzQgcG9zID0gdmVjNChhX3Bvc2l0aW9uLCAxKTtcXG4gIHBvcyA9IGNjX21hdFdvcmxkICogcG9zO1xcbiAgdmVjMiB2ZXJ0T2Zmc2V0ID0gYV90ZXhDb29yZC54eSAtIDAuNTtcXG4gIGNvbXB1dGVWZXJ0UG9zKHBvcywgdmVydE9mZnNldCwgcXVhdGVybmlvbkZyb21FdWxlcih2ZWMzKDAuLCAwLiwgY2Nfc2l6ZV9yb3RhdGlvbi56KSksIHZlYzMoY2Nfc2l6ZV9yb3RhdGlvbi54eSwgMC4pLCBjY19tYXRWaWV3SW52KTtcXG4gIHBvcyA9IGNjX21hdFZpZXdQcm9qICogcG9zO1xcbiAgdXYgPSBhX3RleENvb3JkLnh5O1xcbiAgY29sb3IgPSBhX2NvbG9yO1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZzX21haW4oKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG59O1xcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiBDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIFNSR0JUb0xpbmVhcihjb2xvci5yZ2IpICogY2NfZXhwb3N1cmUudywgdmVjMyhjY19leHBvc3VyZS56KSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxuaW4gdmVjMiB1djtcXG5pbiB2ZWM0IGNvbG9yO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1haW5UZXh0dXJlO1xcbnVuaWZvcm0gRnJhZ0NvbnN0YW50cyB7XFxuICB2ZWM0IHRpbnRDb2xvcjtcXG59O1xcbnZlYzQgYWRkICgpIHtcXG4gIHZlYzQgY29sID0gMi4wICogY29sb3IgKiB0aW50Q29sb3IgKiB0ZXh0dXJlKG1haW5UZXh0dXJlLCB1dik7XFxuICByZXR1cm4gQ0NGcmFnT3V0cHV0KGNvbCk7XFxufVxcbm91dCB2ZWM0IGNjX0ZyYWdDb2xvcjtcXG52b2lkIG1haW4oKSB7IGNjX0ZyYWdDb2xvciA9IGFkZCgpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJnbHNsMVwiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRWaWV3O1xcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRWaWV3SW52O1xcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxudmVjNCBxdWF0ZXJuaW9uRnJvbUF4aXMgKHZlYzMgeEF4aXMsdmVjMyB5QXhpcyx2ZWMzIHpBeGlzKXtcXG4gIG1hdDMgbSA9IG1hdDMoeEF4aXMseUF4aXMsekF4aXMpO1xcbiAgZmxvYXQgdHJhY2UgPSBtWzBdWzBdICsgbVsxXVsxXSArIG1bMl1bMl07XFxuICB2ZWM0IHF1YXQ7XFxuICBpZiAodHJhY2UgPiAwLikge1xcbiAgICBmbG9hdCBzID0gMC41IC8gc3FydCh0cmFjZSArIDEuMCk7XFxuICAgIHF1YXQudyA9IDAuMjUgLyBzO1xcbiAgICBxdWF0LnggPSAobVsyXVsxXSAtIG1bMV1bMl0pICogcztcXG4gICAgcXVhdC55ID0gKG1bMF1bMl0gLSBtWzJdWzBdKSAqIHM7XFxuICAgIHF1YXQueiA9IChtWzFdWzBdIC0gbVswXVsxXSkgKiBzO1xcbiAgfSBlbHNlIGlmICgobVswXVswXSA+IG1bMV1bMV0pICYmIChtWzBdWzBdID4gbVsyXVsyXSkpIHtcXG4gICAgZmxvYXQgcyA9IDIuMCAqIHNxcnQoMS4wICsgbVswXVswXSAtIG1bMV1bMV0gLSBtWzJdWzJdKTtcXG4gICAgcXVhdC53ID0gKG1bMl1bMV0gLSBtWzFdWzJdKSAvIHM7XFxuICAgIHF1YXQueCA9IDAuMjUgKiBzO1xcbiAgICBxdWF0LnkgPSAobVswXVsxXSArIG1bMV1bMF0pIC8gcztcXG4gICAgcXVhdC56ID0gKG1bMF1bMl0gKyBtWzJdWzBdKSAvIHM7XFxuICB9IGVsc2UgaWYgKG1bMV1bMV0gPiBtWzJdWzJdKSB7XFxuICAgIGZsb2F0IHMgPSAyLjAgKiBzcXJ0KDEuMCArIG1bMV1bMV0gLSBtWzBdWzBdIC0gbVsyXVsyXSk7XFxuICAgIHF1YXQudyA9IChtWzBdWzJdIC0gbVsyXVswXSkgLyBzO1xcbiAgICBxdWF0LnggPSAobVswXVsxXSArIG1bMV1bMF0pIC8gcztcXG4gICAgcXVhdC55ID0gMC4yNSAqIHM7XFxuICAgIHF1YXQueiA9IChtWzFdWzJdICsgbVsyXVsxXSkgLyBzO1xcbiAgfSBlbHNlIHtcXG4gICAgZmxvYXQgcyA9IDIuMCAqIHNxcnQoMS4wICsgbVsyXVsyXSAtIG1bMF1bMF0gLSBtWzFdWzFdKTtcXG4gICAgcXVhdC53ID0gKG1bMV1bMF0gLSBtWzBdWzFdKSAvIHM7XFxuICAgIHF1YXQueCA9IChtWzBdWzJdICsgbVsyXVswXSkgLyBzO1xcbiAgICBxdWF0LnkgPSAobVsxXVsyXSArIG1bMl1bMV0pIC8gcztcXG4gICAgcXVhdC56ID0gMC4yNSAqIHM7XFxuICB9XFxuICBmbG9hdCBsZW4gPSBxdWF0LnggKiBxdWF0LnggKyBxdWF0LnkgKiBxdWF0LnkgKyBxdWF0LnogKiBxdWF0LnogKyBxdWF0LncgKiBxdWF0Lnc7XFxuICBpZiAobGVuID4gMC4pIHtcXG4gICAgbGVuID0gMS4gLyBzcXJ0KGxlbik7XFxuICAgIHF1YXQueCA9IHF1YXQueCAqIGxlbjtcXG4gICAgcXVhdC55ID0gcXVhdC55ICogbGVuO1xcbiAgICBxdWF0LnogPSBxdWF0LnogKiBsZW47XFxuICAgIHF1YXQudyA9IHF1YXQudyAqIGxlbjtcXG4gIH1cXG4gIHJldHVybiBxdWF0O1xcbn1cXG52ZWM0IHF1YXRlcm5pb25Gcm9tRXVsZXIgKHZlYzMgYW5nbGUpe1xcbiAgZmxvYXQgeCA9IGFuZ2xlLnggLyAyLjtcXG4gIGZsb2F0IHkgPSBhbmdsZS55IC8gMi47XFxuICBmbG9hdCB6ID0gYW5nbGUueiAvIDIuO1xcbiAgZmxvYXQgc3ggPSBzaW4oeCk7XFxuICBmbG9hdCBjeCA9IGNvcyh4KTtcXG4gIGZsb2F0IHN5ID0gc2luKHkpO1xcbiAgZmxvYXQgY3kgPSBjb3MoeSk7XFxuICBmbG9hdCBzeiA9IHNpbih6KTtcXG4gIGZsb2F0IGN6ID0gY29zKHopO1xcbiAgdmVjNCBxdWF0ID0gdmVjNCgwKTtcXG4gIHF1YXQueCA9IHN4ICogY3kgKiBjeiArIGN4ICogc3kgKiBzejtcXG4gIHF1YXQueSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcXG4gIHF1YXQueiA9IGN4ICogY3kgKiBzeiAtIHN4ICogc3kgKiBjejtcXG4gIHF1YXQudyA9IGN4ICogY3kgKiBjeiAtIHN4ICogc3kgKiBzejtcXG4gIHJldHVybiBxdWF0O1xcbn1cXG52ZWM0IHF1YXRNdWx0aXBseSAodmVjNCBhLCB2ZWM0IGIpe1xcbiAgdmVjNCBxdWF0O1xcbiAgcXVhdC54ID0gYS54ICogYi53ICsgYS53ICogYi54ICsgYS55ICogYi56IC0gYS56ICogYi55O1xcbiAgcXVhdC55ID0gYS55ICogYi53ICsgYS53ICogYi55ICsgYS56ICogYi54IC0gYS54ICogYi56O1xcbiAgcXVhdC56ID0gYS56ICogYi53ICsgYS53ICogYi56ICsgYS54ICogYi55IC0gYS55ICogYi54O1xcbiAgcXVhdC53ID0gYS53ICogYi53IC0gYS54ICogYi54IC0gYS55ICogYi55IC0gYS56ICogYi56O1xcbiAgcmV0dXJuIHF1YXQ7XFxufVxcbnZvaWQgcm90YXRlVmVjRnJvbVF1YXQgKGlub3V0IHZlYzMgdiwgdmVjNCBxKXtcXG4gIGZsb2F0IGl4ID0gcS53ICogdi54ICsgcS55ICogdi56IC0gcS56ICogdi55O1xcbiAgZmxvYXQgaXkgPSBxLncgKiB2LnkgKyBxLnogKiB2LnggLSBxLnggKiB2Lno7XFxuICBmbG9hdCBpeiA9IHEudyAqIHYueiArIHEueCAqIHYueSAtIHEueSAqIHYueDtcXG4gIGZsb2F0IGl3ID0gLXEueCAqIHYueCAtIHEueSAqIHYueSAtIHEueiAqIHYuejtcXG4gIHYueCA9IGl4ICogcS53ICsgaXcgKiAtcS54ICsgaXkgKiAtcS56IC0gaXogKiAtcS55O1xcbiAgdi55ID0gaXkgKiBxLncgKyBpdyAqIC1xLnkgKyBpeiAqIC1xLnggLSBpeCAqIC1xLno7XFxuICB2LnogPSBpeiAqIHEudyArIGl3ICogLXEueiArIGl4ICogLXEueSAtIGl5ICogLXEueDtcXG59XFxudmVjMyByb3RhdGVJbkxvY2FsU3BhY2UgKHZlYzMgcG9zLCB2ZWMzIHhBeGlzLCB2ZWMzIHlBeGlzLCB2ZWMzIHpBeGlzLCB2ZWM0IHEpe1xcbiAgdmVjNCB2aWV3UXVhdCA9IHF1YXRlcm5pb25Gcm9tQXhpcyh4QXhpcywgeUF4aXMsIHpBeGlzKTtcXG4gIHZlYzQgcm90UXVhdCA9IHF1YXRNdWx0aXBseSh2aWV3UXVhdCwgcSk7XFxuICByb3RhdGVWZWNGcm9tUXVhdChwb3MsIHJvdFF1YXQpO1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCByb3RhdGVDb3JuZXIgKGlub3V0IHZlYzIgY29ybmVyLCBmbG9hdCBhbmdsZSl7XFxuICBmbG9hdCB4T1MgPSBjb3MoYW5nbGUpICogY29ybmVyLnggLSBzaW4oYW5nbGUpICogY29ybmVyLnk7XFxuICBmbG9hdCB5T1MgPSBzaW4oYW5nbGUpICogY29ybmVyLnggKyBjb3MoYW5nbGUpICogY29ybmVyLnk7XFxuICBjb3JuZXIueCA9IHhPUztcXG4gIGNvcm5lci55ID0geU9TO1xcbn1cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyB2ZWM0IGNvbG9yO1xcbnZvaWQgY29tcHV0ZVZlcnRQb3MgKGlub3V0IHZlYzQgcG9zLCB2ZWMyIHZlcnRPZmZzZXQsIHZlYzQgcSwgdmVjMyBzXFxuICAsIG1hdDQgdmlld0ludlxcbikge1xcbiAgdmVjMyB2aWV3U3BhY2VWZXJ0ID0gdmVjMyh2ZXJ0T2Zmc2V0LnggKiBzLngsIHZlcnRPZmZzZXQueSAqIHMueSwgMC4pO1xcbiAgdmVjMyBjYW1YID0gbm9ybWFsaXplKHZlYzModmlld0ludlswXVswXSwgdmlld0ludlsxXVswXSwgdmlld0ludlsyXVswXSkpO1xcbiAgdmVjMyBjYW1ZID0gbm9ybWFsaXplKHZlYzModmlld0ludlswXVsxXSwgdmlld0ludlsxXVsxXSwgdmlld0ludlsyXVsxXSkpO1xcbiAgdmVjMyBjYW1aID0gbm9ybWFsaXplKHZlYzModmlld0ludlswXVsyXSwgdmlld0ludlsxXVsyXSwgdmlld0ludlsyXVsyXSkpO1xcbiAgcG9zLnh5eiArPSByb3RhdGVJbkxvY2FsU3BhY2Uodmlld1NwYWNlVmVydCwgY2FtWCwgY2FtWSwgY2FtWiwgcSk7XFxufVxcbmF0dHJpYnV0ZSB2ZWMzIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbnVuaWZvcm0gdmVjNCBjY19zaXplX3JvdGF0aW9uO1xcbnZlYzQgdnNfbWFpbigpIHtcXG4gIHZlYzQgcG9zID0gdmVjNChhX3Bvc2l0aW9uLCAxKTtcXG4gIHBvcyA9IGNjX21hdFdvcmxkICogcG9zO1xcbiAgdmVjMiB2ZXJ0T2Zmc2V0ID0gYV90ZXhDb29yZC54eSAtIDAuNTtcXG4gIGNvbXB1dGVWZXJ0UG9zKHBvcywgdmVydE9mZnNldCwgcXVhdGVybmlvbkZyb21FdWxlcih2ZWMzKDAuLCAwLiwgY2Nfc2l6ZV9yb3RhdGlvbi56KSksIHZlYzMoY2Nfc2l6ZV9yb3RhdGlvbi54eSwgMC4pLCBjY19tYXRWaWV3SW52KTtcXG4gIHBvcyA9IGNjX21hdFZpZXdQcm9qICogcG9zO1xcbiAgdXYgPSBhX3RleENvb3JkLnh5O1xcbiAgY29sb3IgPSBhX2NvbG9yO1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZzX21haW4oKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiBDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIFNSR0JUb0xpbmVhcihjb2xvci5yZ2IpICogY2NfZXhwb3N1cmUudywgdmVjMyhjY19leHBvc3VyZS56KSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgdmVjNCBjb2xvcjtcXG51bmlmb3JtIHNhbXBsZXIyRCBtYWluVGV4dHVyZTtcXG51bmlmb3JtIHZlYzQgdGludENvbG9yO1xcbnZlYzQgYWRkICgpIHtcXG4gIHZlYzQgY29sID0gMi4wICogY29sb3IgKiB0aW50Q29sb3IgKiB0ZXh0dXJlMkQobWFpblRleHR1cmUsIHV2KTtcXG4gIHJldHVybiBDQ0ZyYWdPdXRwdXQoY29sKTtcXG59XFxudm9pZCBtYWluKCkgeyBnbF9GcmFnQ29sb3IgPSBhZGQoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiYnVpbHRpbnNcIjoge1xyXG4gICAgICAgICAgXCJnbG9iYWxzXCI6IHsgXCJibG9ja3NcIjogW3sgXCJuYW1lXCI6IFwiQ0NHbG9iYWxcIiwgXCJkZWZpbmVzXCI6IFtdIH1dLCBcInNhbXBsZXJzXCI6IFtdIH0sXHJcbiAgICAgICAgICBcImxvY2Fsc1wiOiB7IFwiYmxvY2tzXCI6IFt7IFwibmFtZVwiOiBcIkNDTG9jYWxcIiwgXCJkZWZpbmVzXCI6IFtdIH1dLCBcInNhbXBsZXJzXCI6IFtdIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGVmaW5lc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9IRFJcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiYmxvY2tzXCI6IFtcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJDb25zdGFudHNcIiwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMCwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJtYWluVGlsaW5nX09mZnNldFwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcImZyYW1lVGlsZV92ZWxMZW5TY2FsZVwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInNjYWxlXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH1cclxuICAgICAgICAgIF19LFxyXG4gICAgICAgICAge1wibmFtZVwiOiBcImJ1aWx0aW5cIiwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMSwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJjY19zaXplX3JvdGF0aW9uXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH1cclxuICAgICAgICAgIF19LFxyXG4gICAgICAgICAge1wibmFtZVwiOiBcIkZyYWdDb25zdGFudHNcIiwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMiwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJ0aW50Q29sb3JcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfVxyXG4gICAgICAgICAgXX1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwic2FtcGxlcnNcIjogW1xyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJtYWluVGV4dHVyZVwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMzEgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9wb3NpdGlvblwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiAwIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfdGV4Q29vcmRcIiwgXCJ0eXBlXCI6IDE0LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJmb3JtYXRcIjogMjEsIFwibG9jYXRpb25cIjogMSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX2NvbG9yXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwiZm9ybWF0XCI6IDQzLCBcImxvY2F0aW9uXCI6IDIgfVxyXG4gICAgICAgIF1cclxuICAgICAgfVxyXG4gICAgXVxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJuYW1lXCI6IFwiYnVpbHRpbi1wYXJ0aWNsZS1ncHVcIixcclxuICAgIFwiX3V1aWRcIjogXCI5NzFiZGIyMy0zZmY2LTQzZWItYjQyMi0xYzMwMTY1YTM2NjNcIixcclxuICAgIFwidGVjaG5pcXVlc1wiOiBbXHJcbiAgICAgIHsgXCJuYW1lXCI6IFwiYWRkXCIsIFwicGFzc2VzXCI6IFt7IFwicmFzdGVyaXplclN0YXRlXCI6IHsgXCJjdWxsTW9kZVwiOiAwIH0sIFwiYmxlbmRTdGF0ZVwiOiB7IFwidGFyZ2V0c1wiOiBbeyBcImJsZW5kXCI6IHRydWUsIFwiYmxlbmRTcmNcIjogMiwgXCJibGVuZERzdFwiOiAxLCBcImJsZW5kU3JjQWxwaGFcIjogMiwgXCJibGVuZERzdEFscGhhXCI6IDEgfV0gfSwgXCJwcm9ncmFtXCI6IFwiYnVpbHRpbi1wYXJ0aWNsZS1ncHV8cGFydGljbGUtdnMtZ3B1OmdwdnNfbWFpbnx0aW50ZWQtZnM6YWRkXCIsIFwiZGVwdGhTdGVuY2lsU3RhdGVcIjogeyBcImRlcHRoVGVzdFwiOiB0cnVlLCBcImRlcHRoV3JpdGVcIjogZmFsc2UgfSwgXCJwcm9wZXJ0aWVzXCI6IHsgXCJtYWluVGV4dHVyZVwiOiB7IFwidmFsdWVcIjogXCJncmV5XCIsIFwidHlwZVwiOiAyOCB9LCBcIm1haW5UaWxpbmdfT2Zmc2V0XCI6IHsgXCJ2YWx1ZVwiOiBbMSwgMSwgMCwgMF0sIFwidHlwZVwiOiAxNiB9LCBcInRpbnRDb2xvclwiOiB7IFwidmFsdWVcIjogWzAuNSwgMC41LCAwLjUsIDAuNV0sIFwidHlwZVwiOiAxNiB9IH0gfV0gfVxyXG4gICAgXSxcclxuICAgIFwic2hhZGVyc1wiOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBcIm5hbWVcIjogXCJidWlsdGluLXBhcnRpY2xlLWdwdXxwYXJ0aWNsZS12cy1ncHU6Z3B2c19tYWlufHRpbnRlZC1mczphZGRcIixcclxuICAgICAgICBcImhhc2hcIjogNDAwMzYwNTc1MSxcclxuICAgICAgICBcImdsc2wzXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudmVjNCBxdWF0ZXJuaW9uRnJvbUF4aXMgKHZlYzMgeEF4aXMsdmVjMyB5QXhpcyx2ZWMzIHpBeGlzKXtcXG4gIG1hdDMgbSA9IG1hdDMoeEF4aXMseUF4aXMsekF4aXMpO1xcbiAgZmxvYXQgdHJhY2UgPSBtWzBdWzBdICsgbVsxXVsxXSArIG1bMl1bMl07XFxuICB2ZWM0IHF1YXQ7XFxuICBpZiAodHJhY2UgPiAwLikge1xcbiAgICBmbG9hdCBzID0gMC41IC8gc3FydCh0cmFjZSArIDEuMCk7XFxuICAgIHF1YXQudyA9IDAuMjUgLyBzO1xcbiAgICBxdWF0LnggPSAobVsyXVsxXSAtIG1bMV1bMl0pICogcztcXG4gICAgcXVhdC55ID0gKG1bMF1bMl0gLSBtWzJdWzBdKSAqIHM7XFxuICAgIHF1YXQueiA9IChtWzFdWzBdIC0gbVswXVsxXSkgKiBzO1xcbiAgfSBlbHNlIGlmICgobVswXVswXSA+IG1bMV1bMV0pICYmIChtWzBdWzBdID4gbVsyXVsyXSkpIHtcXG4gICAgZmxvYXQgcyA9IDIuMCAqIHNxcnQoMS4wICsgbVswXVswXSAtIG1bMV1bMV0gLSBtWzJdWzJdKTtcXG4gICAgcXVhdC53ID0gKG1bMl1bMV0gLSBtWzFdWzJdKSAvIHM7XFxuICAgIHF1YXQueCA9IDAuMjUgKiBzO1xcbiAgICBxdWF0LnkgPSAobVswXVsxXSArIG1bMV1bMF0pIC8gcztcXG4gICAgcXVhdC56ID0gKG1bMF1bMl0gKyBtWzJdWzBdKSAvIHM7XFxuICB9IGVsc2UgaWYgKG1bMV1bMV0gPiBtWzJdWzJdKSB7XFxuICAgIGZsb2F0IHMgPSAyLjAgKiBzcXJ0KDEuMCArIG1bMV1bMV0gLSBtWzBdWzBdIC0gbVsyXVsyXSk7XFxuICAgIHF1YXQudyA9IChtWzBdWzJdIC0gbVsyXVswXSkgLyBzO1xcbiAgICBxdWF0LnggPSAobVswXVsxXSArIG1bMV1bMF0pIC8gcztcXG4gICAgcXVhdC55ID0gMC4yNSAqIHM7XFxuICAgIHF1YXQueiA9IChtWzFdWzJdICsgbVsyXVsxXSkgLyBzO1xcbiAgfSBlbHNlIHtcXG4gICAgZmxvYXQgcyA9IDIuMCAqIHNxcnQoMS4wICsgbVsyXVsyXSAtIG1bMF1bMF0gLSBtWzFdWzFdKTtcXG4gICAgcXVhdC53ID0gKG1bMV1bMF0gLSBtWzBdWzFdKSAvIHM7XFxuICAgIHF1YXQueCA9IChtWzBdWzJdICsgbVsyXVswXSkgLyBzO1xcbiAgICBxdWF0LnkgPSAobVsxXVsyXSArIG1bMl1bMV0pIC8gcztcXG4gICAgcXVhdC56ID0gMC4yNSAqIHM7XFxuICB9XFxuICBmbG9hdCBsZW4gPSBxdWF0LnggKiBxdWF0LnggKyBxdWF0LnkgKiBxdWF0LnkgKyBxdWF0LnogKiBxdWF0LnogKyBxdWF0LncgKiBxdWF0Lnc7XFxuICBpZiAobGVuID4gMC4pIHtcXG4gICAgbGVuID0gMS4gLyBzcXJ0KGxlbik7XFxuICAgIHF1YXQueCA9IHF1YXQueCAqIGxlbjtcXG4gICAgcXVhdC55ID0gcXVhdC55ICogbGVuO1xcbiAgICBxdWF0LnogPSBxdWF0LnogKiBsZW47XFxuICAgIHF1YXQudyA9IHF1YXQudyAqIGxlbjtcXG4gIH1cXG4gIHJldHVybiBxdWF0O1xcbn1cXG52ZWM0IHF1YXRlcm5pb25Gcm9tRXVsZXIgKHZlYzMgYW5nbGUpe1xcbiAgZmxvYXQgeCA9IGFuZ2xlLnggLyAyLjtcXG4gIGZsb2F0IHkgPSBhbmdsZS55IC8gMi47XFxuICBmbG9hdCB6ID0gYW5nbGUueiAvIDIuO1xcbiAgZmxvYXQgc3ggPSBzaW4oeCk7XFxuICBmbG9hdCBjeCA9IGNvcyh4KTtcXG4gIGZsb2F0IHN5ID0gc2luKHkpO1xcbiAgZmxvYXQgY3kgPSBjb3MoeSk7XFxuICBmbG9hdCBzeiA9IHNpbih6KTtcXG4gIGZsb2F0IGN6ID0gY29zKHopO1xcbiAgdmVjNCBxdWF0ID0gdmVjNCgwKTtcXG4gIHF1YXQueCA9IHN4ICogY3kgKiBjeiArIGN4ICogc3kgKiBzejtcXG4gIHF1YXQueSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcXG4gIHF1YXQueiA9IGN4ICogY3kgKiBzeiAtIHN4ICogc3kgKiBjejtcXG4gIHF1YXQudyA9IGN4ICogY3kgKiBjeiAtIHN4ICogc3kgKiBzejtcXG4gIHJldHVybiBxdWF0O1xcbn1cXG5tYXQ0IG1hdHJpeEZyb21SVCAodmVjNCBxLCB2ZWMzIHApe1xcbiAgZmxvYXQgeDIgPSBxLnggKyBxLng7XFxuICBmbG9hdCB5MiA9IHEueSArIHEueTtcXG4gIGZsb2F0IHoyID0gcS56ICsgcS56O1xcbiAgZmxvYXQgeHggPSBxLnggKiB4MjtcXG4gIGZsb2F0IHh5ID0gcS54ICogeTI7XFxuICBmbG9hdCB4eiA9IHEueCAqIHoyO1xcbiAgZmxvYXQgeXkgPSBxLnkgKiB5MjtcXG4gIGZsb2F0IHl6ID0gcS55ICogejI7XFxuICBmbG9hdCB6eiA9IHEueiAqIHoyO1xcbiAgZmxvYXQgd3ggPSBxLncgKiB4MjtcXG4gIGZsb2F0IHd5ID0gcS53ICogeTI7XFxuICBmbG9hdCB3eiA9IHEudyAqIHoyO1xcbiAgcmV0dXJuIG1hdDQoXFxuICAgIDEuIC0gKHl5ICsgenopLCB4eSArIHd6LCB4eiAtIHd5LCAwLFxcbiAgICB4eSAtIHd6LCAxLiAtICh4eCArIHp6KSwgeXogKyB3eCwgMCxcXG4gICAgeHogKyB3eSwgeXogLSB3eCwgMS4gLSAoeHggKyB5eSksIDAsXFxuICAgIHAueCwgcC55LCBwLnosIDFcXG4gICk7XFxufVxcbm1hdDQgbWF0RnJvbVJUUyAodmVjNCBxLCB2ZWMzIHQsIHZlYzMgcyl7XFxuICBmbG9hdCB4ID0gcS54LCB5ID0gcS55LCB6ID0gcS56LCB3ID0gcS53O1xcbiAgZmxvYXQgeDIgPSB4ICsgeDtcXG4gIGZsb2F0IHkyID0geSArIHk7XFxuICBmbG9hdCB6MiA9IHogKyB6O1xcbiAgZmxvYXQgeHggPSB4ICogeDI7XFxuICBmbG9hdCB4eSA9IHggKiB5MjtcXG4gIGZsb2F0IHh6ID0geCAqIHoyO1xcbiAgZmxvYXQgeXkgPSB5ICogeTI7XFxuICBmbG9hdCB5eiA9IHkgKiB6MjtcXG4gIGZsb2F0IHp6ID0geiAqIHoyO1xcbiAgZmxvYXQgd3ggPSB3ICogeDI7XFxuICBmbG9hdCB3eSA9IHcgKiB5MjtcXG4gIGZsb2F0IHd6ID0gdyAqIHoyO1xcbiAgZmxvYXQgc3ggPSBzLng7XFxuICBmbG9hdCBzeSA9IHMueTtcXG4gIGZsb2F0IHN6ID0gcy56O1xcbiAgcmV0dXJuIG1hdDQoKDEuIC0gKHl5ICsgenopKSAqIHN4LCAoeHkgKyB3eikgKiBzeCwgKHh6IC0gd3kpICogc3gsIDAsXFxuICAgICh4eSAtIHd6KSAqIHN5LCAoMS4gLSAoeHggKyB6eikpICogc3ksICh5eiArIHd4KSAqIHN5LCAwLFxcbiAgICAoeHogKyB3eSkgKiBzeiwgKHl6IC0gd3gpICogc3osICgxLiAtICh4eCArIHl5KSkgKiBzeiwgMCxcXG4gICAgdC54LCB0LnksIHQueiwgMSk7XFxufVxcbnZlYzQgcXVhdE11bHRpcGx5ICh2ZWM0IGEsIHZlYzQgYil7XFxuICB2ZWM0IHF1YXQ7XFxuICBxdWF0LnggPSBhLnggKiBiLncgKyBhLncgKiBiLnggKyBhLnkgKiBiLnogLSBhLnogKiBiLnk7XFxuICBxdWF0LnkgPSBhLnkgKiBiLncgKyBhLncgKiBiLnkgKyBhLnogKiBiLnggLSBhLnggKiBiLno7XFxuICBxdWF0LnogPSBhLnogKiBiLncgKyBhLncgKiBiLnogKyBhLnggKiBiLnkgLSBhLnkgKiBiLng7XFxuICBxdWF0LncgPSBhLncgKiBiLncgLSBhLnggKiBiLnggLSBhLnkgKiBiLnkgLSBhLnogKiBiLno7XFxuICByZXR1cm4gcXVhdDtcXG59XFxudm9pZCByb3RhdGVWZWNGcm9tUXVhdCAoaW5vdXQgdmVjMyB2LCB2ZWM0IHEpe1xcbiAgZmxvYXQgaXggPSBxLncgKiB2LnggKyBxLnkgKiB2LnogLSBxLnogKiB2Lnk7XFxuICBmbG9hdCBpeSA9IHEudyAqIHYueSArIHEueiAqIHYueCAtIHEueCAqIHYuejtcXG4gIGZsb2F0IGl6ID0gcS53ICogdi56ICsgcS54ICogdi55IC0gcS55ICogdi54O1xcbiAgZmxvYXQgaXcgPSAtcS54ICogdi54IC0gcS55ICogdi55IC0gcS56ICogdi56O1xcbiAgdi54ID0gaXggKiBxLncgKyBpdyAqIC1xLnggKyBpeSAqIC1xLnogLSBpeiAqIC1xLnk7XFxuICB2LnkgPSBpeSAqIHEudyArIGl3ICogLXEueSArIGl6ICogLXEueCAtIGl4ICogLXEuejtcXG4gIHYueiA9IGl6ICogcS53ICsgaXcgKiAtcS56ICsgaXggKiAtcS55IC0gaXkgKiAtcS54O1xcbn1cXG52ZWMzIHJvdGF0ZUluTG9jYWxTcGFjZSAodmVjMyBwb3MsIHZlYzMgeEF4aXMsIHZlYzMgeUF4aXMsIHZlYzMgekF4aXMsIHZlYzQgcSl7XFxuICB2ZWM0IHZpZXdRdWF0ID0gcXVhdGVybmlvbkZyb21BeGlzKHhBeGlzLCB5QXhpcywgekF4aXMpO1xcbiAgdmVjNCByb3RRdWF0ID0gcXVhdE11bHRpcGx5KHZpZXdRdWF0LCBxKTtcXG4gIHJvdGF0ZVZlY0Zyb21RdWF0KHBvcywgcm90UXVhdCk7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIHJvdGF0ZUNvcm5lciAoaW5vdXQgdmVjMiBjb3JuZXIsIGZsb2F0IGFuZ2xlKXtcXG4gIGZsb2F0IHhPUyA9IGNvcyhhbmdsZSkgKiBjb3JuZXIueCAtIHNpbihhbmdsZSkgKiBjb3JuZXIueTtcXG4gIGZsb2F0IHlPUyA9IHNpbihhbmdsZSkgKiBjb3JuZXIueCArIGNvcyhhbmdsZSkgKiBjb3JuZXIueTtcXG4gIGNvcm5lci54ID0geE9TO1xcbiAgY29ybmVyLnkgPSB5T1M7XFxufVxcbnVuaWZvcm0gQ29uc3RhbnRzIHtcXG4gIHZlYzQgbWFpblRpbGluZ19PZmZzZXQ7XFxuICB2ZWM0IGZyYW1lVGlsZV92ZWxMZW5TY2FsZTtcXG4gIHZlYzQgc2NhbGU7XFxufTtcXG51bmlmb3JtIENDR2xvYmFsIHtcXG4gIGhpZ2hwICAgdmVjNCBjY190aW1lO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2NhbGU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbmF0aXZlU2l6ZTtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qSW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qSW52O1xcbiAgaGlnaHAgICB2ZWM0IGNjX2NhbWVyYVBvcztcXG4gIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0RGlyO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXRDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50U2t5O1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRHcm91bmQ7XFxufTtcXG51bmlmb3JtIENDTG9jYWwge1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRJVDtcXG4gIGhpZ2hwIHZlYzQgY2NfbGlnaHRpbmdNYXBVVlBhcmFtO1xcbn07XFxub3V0IHZlYzIgdXY7XFxub3V0IHZlYzQgY29sb3I7XFxudm9pZCBjb21wdXRlVmVydFBvcyAoaW5vdXQgdmVjNCBwb3MsIHZlYzIgdmVydE9mZnNldCwgdmVjNCBxLCB2ZWMzIHNcXG4jaWYgQ0NfUkVOREVSX01PREUgPT0gMCB8fCBDQ19SRU5ERVJfTU9ERSA9PSAzXFxuICAsIG1hdDQgdmlld0ludlxcbiNlbmRpZlxcbiNpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICAsIHZlYzMgZXllXFxuICAsIHZlYzQgdmVsb2NpdHlcXG4gICwgZmxvYXQgdmVsb2NpdHlTY2FsZVxcbiAgLCBmbG9hdCBsZW5ndGhTY2FsZVxcbiAgLCBmbG9hdCB4SW5kZXhcXG4jZW5kaWZcXG4pIHtcXG4jaWYgQ0NfUkVOREVSX01PREUgPT0gMFxcbiAgdmVjMyB2aWV3U3BhY2VWZXJ0ID0gdmVjMyh2ZXJ0T2Zmc2V0LnggKiBzLngsIHZlcnRPZmZzZXQueSAqIHMueSwgMC4pO1xcbiAgdmVjMyBjYW1YID0gbm9ybWFsaXplKHZlYzModmlld0ludlswXVswXSwgdmlld0ludlsxXVswXSwgdmlld0ludlsyXVswXSkpO1xcbiAgdmVjMyBjYW1ZID0gbm9ybWFsaXplKHZlYzModmlld0ludlswXVsxXSwgdmlld0ludlsxXVsxXSwgdmlld0ludlsyXVsxXSkpO1xcbiAgdmVjMyBjYW1aID0gbm9ybWFsaXplKHZlYzModmlld0ludlswXVsyXSwgdmlld0ludlsxXVsyXSwgdmlld0ludlsyXVsyXSkpO1xcbiAgcG9zLnh5eiArPSByb3RhdGVJbkxvY2FsU3BhY2Uodmlld1NwYWNlVmVydCwgY2FtWCwgY2FtWSwgY2FtWiwgcSk7XFxuI2VsaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgdmVjMyBjYW1SaWdodCA9IG5vcm1hbGl6ZShjcm9zcyhwb3MueHl6IC0gZXllLCB2ZWxvY2l0eS54eXopKSAqIHMueDtcXG4gIHZlYzMgY2FtVXAgPSB2ZWxvY2l0eS54eXogKiB2ZWxvY2l0eVNjYWxlICsgbm9ybWFsaXplKHZlbG9jaXR5Lnh5eikgKiBsZW5ndGhTY2FsZSAqIHMueTtcXG4gIHBvcy54eXogKz0gKGNhbVJpZ2h0ICogYWJzKHZlcnRPZmZzZXQueCkgKiBzaWduKHZlcnRPZmZzZXQueSkpIC0gY2FtVXAgKiB4SW5kZXg7XFxuI2VsaWYgQ0NfUkVOREVSX01PREUgPT0gMlxcbiAgdmVjMyB2aWV3U3BhY2VWZXJ0ID0gdmVjMyh2ZXJ0T2Zmc2V0LnggKiBzLngsIHZlcnRPZmZzZXQueSAqIHMueSwgMC4pO1xcbiAgdmVjMyBjYW1YID0gdmVjMygxLCAwLCAwKTtcXG4gIHZlYzMgY2FtWSA9IHZlYzMoMCwgMCwgLTEpO1xcbiAgcG9zLnh5eiArPSByb3RhdGVJbkxvY2FsU3BhY2Uodmlld1NwYWNlVmVydCwgY2FtWCwgY2FtWSwgY3Jvc3MoY2FtWCwgY2FtWSksIHEpO1xcbiNlbGlmIENDX1JFTkRFUl9NT0RFID09IDNcXG4gIHZlYzIgdmlld1NwYWNlVmVydCA9IHZlYzIodmVydE9mZnNldC54ICogcy54LCB2ZXJ0T2Zmc2V0LnkgKiBzLnkpO1xcbiAgcm90YXRlQ29ybmVyKHZpZXdTcGFjZVZlcnQsIHEueik7XFxuICB2ZWMzIGNhbVggPSBub3JtYWxpemUodmVjMyhjY19tYXRWaWV3WzBdWzBdLCBjY19tYXRWaWV3WzFdWzBdLCBjY19tYXRWaWV3WzJdWzBdKSk7XFxuICB2ZWMzIGNhbVkgPSB2ZWMzKDAsIDEsIDApO1xcbiAgdmVjMyBvZmZzZXQgPSBjYW1YICogdmlld1NwYWNlVmVydC54ICsgY2FtWSAqIHZpZXdTcGFjZVZlcnQueTtcXG4gIHBvcy54eXogKz0gb2Zmc2V0O1xcbiNlbHNlXFxuICBwb3MueCArPSB2ZXJ0T2Zmc2V0Lng7XFxuICBwb3MueSArPSB2ZXJ0T2Zmc2V0Lnk7XFxuI2VuZGlmXFxufVxcbnZlYzIgY29tcHV0ZVVWIChmbG9hdCBmcmFtZUluZGV4LCB2ZWMyIHZlcnRJbmRleCwgdmVjMiBmcmFtZVRpbGUpe1xcbiAgdmVjMiBhbmlVViA9IHZlYzIoMCwgZmxvb3IoZnJhbWVJbmRleCAqIGZyYW1lVGlsZS55KSk7XFxuICBhbmlVVi54ID0gZmxvb3IoZnJhbWVJbmRleCAqIGZyYW1lVGlsZS54ICogZnJhbWVUaWxlLnkgLSBhbmlVVi55ICogZnJhbWVUaWxlLngpO1xcbiNpZiBDQ19SRU5ERVJfTU9ERSAhPSA0XFxuICB2ZXJ0SW5kZXgueSA9IDEuIC0gdmVydEluZGV4Lnk7XFxuI2VuZGlmXFxuICByZXR1cm4gKGFuaVVWLnh5ICsgdmVydEluZGV4KSAvIHZlYzIoZnJhbWVUaWxlLngsIGZyYW1lVGlsZS55KTtcXG59XFxudW5pZm9ybSBTYW1wbGVDb25zdGFudHMge1xcbiAgdmVjNCB1X3NhbXBsZUluZm87XFxufTtcXG51bmlmb3JtIFRpY2tDb25zdGFudHMge1xcbiAgdmVjNCB1X3dvcmxkUm90O1xcbiAgdmVjNCB1X3RpbWVEZWx0YTtcXG59O1xcbmluIHZlYzQgYV9wb3NpdGlvbl9zdGFydHRpbWU7XFxuaW4gdmVjNCBhX3NpemVfdXY7XFxuaW4gdmVjNCBhX3JvdGF0aW9uX3V2O1xcbmluIHZlYzQgYV9jb2xvcjtcXG5pbiB2ZWM0IGFfZGlyX2xpZmU7XFxuaW4gZmxvYXQgYV9ybmRTZWVkO1xcbiNpZiBDQ19SRU5ERVJfTU9ERSA9PSA0XFxuICBpbiB2ZWMzIGFfdGV4Q29vcmQ7XFxuICBpbiB2ZWMzIGFfdGV4Q29vcmQzO1xcbiAgaW4gdmVjMyBhX25vcm1hbDtcXG4gIGluIHZlYzQgYV9jb2xvcjE7XFxuI2VuZGlmXFxudmVjMyB1bnBhY2tDdXJ2ZURhdGEgKHNhbXBsZXIyRCB0ZXgsIHZlYzIgY29vcmQpIHtcXG4gICAgdmVjNCBhID0gdGV4dHVyZSh0ZXgsIGNvb3JkKTtcXG4gICAgdmVjNCBiID0gdGV4dHVyZSh0ZXgsIGNvb3JkICsgdV9zYW1wbGVJbmZvLnkpO1xcbiAgICBmbG9hdCBjID0gZnJhY3QoY29vcmQueCAqIHVfc2FtcGxlSW5mby54KTtcXG4gICAgcmV0dXJuIG1peChhLnh5eiwgYi54eXosIGMpO1xcbn1cXG52ZWMzIHVucGFja0N1cnZlRGF0YSAoc2FtcGxlcjJEIHRleCwgdmVjMiBjb29yZCwgb3V0IGZsb2F0IHcpIHtcXG4gICAgdmVjNCBhID0gdGV4dHVyZSh0ZXgsIGNvb3JkKTtcXG4gICAgdmVjNCBiID0gdGV4dHVyZSh0ZXgsIGNvb3JkICsgdV9zYW1wbGVJbmZvLnkpO1xcbiAgICBmbG9hdCBjID0gZnJhY3QoY29vcmQueCAqIHVfc2FtcGxlSW5mby54KTtcXG4gICAgdyA9IG1peChhLncsIGIudywgYyk7XFxuICAgIHJldHVybiBtaXgoYS54eXosIGIueHl6LCBjKTtcXG59XFxuZmxvYXQgcHNldWRvUmFuZG9tIChmbG9hdCBzZWVkKSB7XFxuICBzZWVkID0gbW9kKHNlZWQsIDIzMzI4MC4pO1xcbiAgZmxvYXQgcSA9IChzZWVkICogOTMwMS4gKyA0OTI5Ny4pIC8gMjMzMjgwLjtcXG4gIHJldHVybiBmcmFjdChxKTtcXG59XFxuI2lmIENPTE9SX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICB1bmlmb3JtIHNhbXBsZXIyRCBjb2xvcl9vdmVyX3RpbWVfdGV4MDtcXG4gIHVuaWZvcm0gQ29sb3JDb25zdGFudCB7XFxuICAgIGludCB1X2NvbG9yX21vZGU7XFxuICB9O1xcbiNlbmRpZlxcbiNpZiBST1RBVElPTl9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgcm90YXRpb25fb3Zlcl90aW1lX3RleDA7XFxuICB1bmlmb3JtIFJvdGF0aW9uQ29uc3RhbnQge1xcbiAgICBpbnQgdV9yb3RhdGlvbl9tb2RlO1xcbiAgfTtcXG4jZW5kaWZcXG4jaWYgU0laRV9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgc2l6ZV9vdmVyX3RpbWVfdGV4MDtcXG4gIHVuaWZvcm0gU2l6ZUNvbnN0YW50IHtcXG4gICAgaW50IHVfc2l6ZV9tb2RlO1xcbiAgfTtcXG4jZW5kaWZcXG4jaWYgRk9SQ0VfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGZvcmNlX292ZXJfdGltZV90ZXgwO1xcbiAgdW5pZm9ybSBGb3JjZUNvbnN0YW50IHtcXG4gICAgaW50IHVfZm9yY2VfbW9kZTtcXG4gICAgaW50IHVfZm9yY2Vfc3BhY2U7XFxuICB9O1xcbiNlbmRpZlxcbiNpZiBWRUxPQ0lUWV9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdmVsb2NpdHlfb3Zlcl90aW1lX3RleDA7XFxuICB1bmlmb3JtIFZlbG9jaXR5Q29uc3RhbnQge1xcbiAgICBpbnQgdV92ZWxvY2l0eV9tb2RlO1xcbiAgICBpbnQgdV92ZWxvY2l0eV9zcGFjZTtcXG4gIH07XFxuI2VuZGlmXFxuI2lmIFRFWFRVUkVfQU5JTUFUSU9OX01PRFVMRV9FTkFCTEVcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVfYW5pbWF0aW9uX3RleDA7XFxuICB1bmlmb3JtIEFuaW1hdGlvbkNvbnN0YW50IHtcXG4gICAgdmVjNCB1X2FuaW1faW5mbztcXG4gIH07XFxuI2VuZGlmXFxuZmxvYXQgcmVwZWF0IChmbG9hdCB0LCBmbG9hdCBsZW5ndGgpIHtcXG4gIHJldHVybiB0IC0gZmxvb3IodCAvIGxlbmd0aCkgKiBsZW5ndGg7XFxufVxcbnZlYzQgcm90YXRlUXVhdCAodmVjNCBwLCB2ZWM0IHEpIHtcXG4gIHZlYzMgaXYgPSBjcm9zcyhxLnh5eiwgcC54eXopICsgcS53ICogcC54eXo7XFxuICB2ZWMzIHJlcyA9IHAueHl6ICsgMi4wICogY3Jvc3MocS54eXosIGl2KTtcXG4gIHJldHVybiB2ZWM0KHJlcy54eXosIHAudyk7XFxufVxcbnZlYzQgZ3B2c19tYWluICgpIHtcXG4gIGZsb2F0IGFjdGl2ZVRpbWUgPSB1X3RpbWVEZWx0YS54IC0gYV9wb3NpdGlvbl9zdGFydHRpbWUudztcXG4gIGZsb2F0IG5vcm1hbGl6ZWRUaW1lID0gY2xhbXAoYWN0aXZlVGltZSAvIGFfZGlyX2xpZmUudywgMC4wLCAxLjApO1xcbiAgdmVjMiB0aW1lQ29vcmQwID0gdmVjMihub3JtYWxpemVkVGltZSwgMC4pO1xcbiAgdmVjMiB0aW1lQ29vcmQxID0gdmVjMihub3JtYWxpemVkVGltZSwgMS4pO1xcbiAgI2lmIENDX1JFTkRFUl9NT0RFID09IDRcXG4gICAgdmVjMiB2ZXJ0SWR4ID0gdmVjMihhX3RleENvb3JkLngsIGFfdGV4Q29vcmQueSk7XFxuICAjZWxzZVxcbiAgICB2ZWMyIHZlcnRJZHggPSB2ZWMyKGFfc2l6ZV91di53LCBhX3JvdGF0aW9uX3V2LncpO1xcbiAgI2VuZGlmXFxuICB2ZWM0IHZlbG9jaXR5ID0gdmVjNChhX2Rpcl9saWZlLnh5eiwgMC4pO1xcbiAgdmVjNCBwb3MgPSB2ZWM0KGFfcG9zaXRpb25fc3RhcnR0aW1lLnh5eiwgMS4pO1xcbiAgdmVjMyBzaXplID0gYV9zaXplX3V2Lnh5ejtcXG4gICNpZiBTSVpFX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICAgIGlmICh1X3NpemVfbW9kZSA9PSAxKSB7XFxuICAgICAgc2l6ZSAqPSB1bnBhY2tDdXJ2ZURhdGEoc2l6ZV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmVjMyBzaXplXzAgPSB1bnBhY2tDdXJ2ZURhdGEoc2l6ZV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgICAgdmVjMyBzaXplXzEgPSB1bnBhY2tDdXJ2ZURhdGEoc2l6ZV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMSk7XFxuICAgICAgZmxvYXQgZmFjdG9yX3MgPSBwc2V1ZG9SYW5kb20oYV9ybmRTZWVkICsgMzk4MjUuKTtcXG4gICAgICBzaXplICo9IG1peChzaXplXzAsIHNpemVfMSwgZmFjdG9yX3MpO1xcbiAgICB9XFxuICAjZW5kaWZcXG4gIHZlYzMgY29tcFNjYWxlID0gc2NhbGUueHl6ICogc2l6ZTtcXG4gICNpZiBGT1JDRV9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVxcbiAgICB2ZWMzIGZvcmNlQW5pbSA9IHZlYzMoMC4pO1xcbiAgICBpZiAodV9mb3JjZV9tb2RlID09IDEpIHtcXG4gICAgICBmb3JjZUFuaW0gPSB1bnBhY2tDdXJ2ZURhdGEoZm9yY2Vfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZlYzMgZm9yY2VfMCA9IHVucGFja0N1cnZlRGF0YShmb3JjZV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgICAgdmVjMyBmb3JjZV8xID0gdW5wYWNrQ3VydmVEYXRhKGZvcmNlX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQxKTtcXG4gICAgICBmbG9hdCBmYWN0b3JfZiA9ICBwc2V1ZG9SYW5kb20oYV9ybmRTZWVkICsgMjEyMTY1Lik7XFxuICAgICAgZm9yY2VBbmltID0gbWl4KGZvcmNlXzAsIGZvcmNlXzEsIGZhY3Rvcl9mKTtcXG4gICAgfVxcbiAgICB2ZWM0IGZvcmNlVHJhY2sgPSB2ZWM0KGZvcmNlQW5pbSwgMC4pO1xcbiAgICBpZiAodV9mb3JjZV9zcGFjZSA9PSAwKSB7XFxuICAgICAgZm9yY2VUcmFjayA9IHJvdGF0ZVF1YXQoZm9yY2VUcmFjaywgdV93b3JsZFJvdCk7XFxuICAgIH1cXG4gICAgdmVsb2NpdHkueHl6ICs9IGZvcmNlVHJhY2sueHl6O1xcbiAgI2VuZGlmXFxuICAjaWYgVkVMT0NJVFlfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcXG4gICAgZmxvYXQgc3BlZWRNb2RpZmllcjAgPSAxLjtcXG4gICAgZmxvYXQgc3BlZWRNb2RpZmllcjEgPSAxLjtcXG4gICAgdmVjMyB2ZWxvY2l0eUFuaW0gPSB2ZWMzKDAuKTtcXG4gICAgaWYgKHVfdmVsb2NpdHlfbW9kZSA9PSAxKSB7XFxuICAgICAgdmVsb2NpdHlBbmltID0gdW5wYWNrQ3VydmVEYXRhKHZlbG9jaXR5X292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQwLCBzcGVlZE1vZGlmaWVyMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmVjMyB2ZWN0b3J5XzAgPSB1bnBhY2tDdXJ2ZURhdGEodmVsb2NpdHlfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDAsIHNwZWVkTW9kaWZpZXIwKTtcXG4gICAgICB2ZWMzIHZlY3RvcnlfMSA9IHVucGFja0N1cnZlRGF0YSh2ZWxvY2l0eV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMSwgc3BlZWRNb2RpZmllcjEpO1xcbiAgICAgIGZsb2F0IGZhY3Rvcl92ID0gcHNldWRvUmFuZG9tKGFfcm5kU2VlZCArIDE5Nzg2Ni4pO1xcbiAgICAgIHZlbG9jaXR5QW5pbSA9IG1peCh2ZWN0b3J5XzAsIHZlY3RvcnlfMSwgZmFjdG9yX3YpO1xcbiAgICAgIHNwZWVkTW9kaWZpZXIwID0gbWl4KHNwZWVkTW9kaWZpZXIwLCBzcGVlZE1vZGlmaWVyMSwgZmFjdG9yX3YpO1xcbiAgICB9XFxuICAgIHZlYzQgdmVsb2NpdHlUcmFjayA9IHZlYzQodmVsb2NpdHlBbmltLCAwLik7XFxuICAgIGlmICh1X3ZlbG9jaXR5X3NwYWNlID09IDApIHtcXG4gICAgICB2ZWxvY2l0eVRyYWNrID0gcm90YXRlUXVhdCh2ZWxvY2l0eVRyYWNrLCB1X3dvcmxkUm90KTtcXG4gICAgfVxcbiAgICB2ZWxvY2l0eS54eXogKz0gdmVsb2NpdHlUcmFjay54eXo7XFxuICAgIHZlbG9jaXR5Lnh5eiAqPSBzcGVlZE1vZGlmaWVyMDtcXG4gICNlbmRpZlxcbiAgcG9zLnh5eiArPSB2ZWxvY2l0eS54eXogKiBub3JtYWxpemVkVGltZSAqIGFfZGlyX2xpZmUudztcXG4gICNpZiAhQ0NfVVNFX1dPUkxEX1NQQUNFXFxuICAgIHBvcyA9IGNjX21hdFdvcmxkICogcG9zO1xcbiAgICAjaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgICAgIHZlbG9jaXR5ID0gcm90YXRlUXVhdCh2ZWxvY2l0eSwgdV93b3JsZFJvdCk7XFxuICAgICNlbmRpZlxcbiAgI2VuZGlmXFxuICB2ZWMzIHJvdGF0aW9uID0gYV9yb3RhdGlvbl91di54eXo7XFxuICAjaWYgUk9UQVRJT05fT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcXG4gICAgaWYgKHVfcm90YXRpb25fbW9kZSA9PSAxKSB7XFxuICAgICAgcm90YXRpb24gKz0gdW5wYWNrQ3VydmVEYXRhKHJvdGF0aW9uX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQwKSAqIG5vcm1hbGl6ZWRUaW1lICogYV9kaXJfbGlmZS53O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZlYzMgcm90YXRpb25fMCA9IHVucGFja0N1cnZlRGF0YShyb3RhdGlvbl9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgICAgdmVjMyByb3RhdGlvbl8xID0gdW5wYWNrQ3VydmVEYXRhKHJvdGF0aW9uX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQxKTtcXG4gICAgICBmbG9hdCBmYWN0b3JfciA9IHBzZXVkb1JhbmRvbShhX3JuZFNlZWQgKyAxMjUyOTIuKTtcXG4gICAgICByb3RhdGlvbiArPSBtaXgocm90YXRpb25fMCwgcm90YXRpb25fMSwgZmFjdG9yX3IpICogbm9ybWFsaXplZFRpbWUgKiBhX2Rpcl9saWZlLnc7XFxuICAgIH1cXG4gICNlbmRpZlxcbiAgI2lmIENPTE9SX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICAgIGlmICh1X2NvbG9yX21vZGUgPT0gMSkge1xcbiAgICAgIGNvbG9yID0gYV9jb2xvciAqIHRleHR1cmUoY29sb3Jfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZlYzQgY29sb3JfMCA9IHRleHR1cmUoY29sb3Jfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDApO1xcbiAgICAgIHZlYzQgY29sb3JfMSA9IHRleHR1cmUoY29sb3Jfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDEpO1xcbiAgICAgIGZsb2F0IGZhY3Rvcl9jID0gcHNldWRvUmFuZG9tKGFfcm5kU2VlZCArIDkxMDQxLik7XFxuICAgICAgY29sb3IgPSBhX2NvbG9yICogbWl4KGNvbG9yXzAsIGNvbG9yXzEsIGZhY3Rvcl9jKTtcXG4gICAgfVxcbiAgI2Vsc2VcXG4gICAgY29sb3IgPSBhX2NvbG9yO1xcbiAgI2VuZGlmXFxuICAjaWYgQ0NfUkVOREVSX01PREUgIT0gNFxcbiAgICB2ZWMyIGNvcm5lck9mZnNldCA9IHZlYzIoKHZlcnRJZHggLSAwLjUpKTtcXG4gICAgI2lmIENDX1JFTkRFUl9NT0RFID09IDBcXG4gICAgICB2ZWMzIHJvdEV1bGVyID0gcm90YXRpb24ueHl6O1xcbiAgICAjZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICAgICAgdmVjMyByb3RFdWxlciA9IHZlYzMoMC4pO1xcbiAgICAjZWxzZVxcbiAgICAgIHZlYzMgcm90RXVsZXIgPSB2ZWMzKDAuLCAwLiwgcm90YXRpb24ueik7XFxuICAgICNlbmRpZlxcbiAgICBjb21wdXRlVmVydFBvcyhwb3MsIGNvcm5lck9mZnNldCwgcXVhdGVybmlvbkZyb21FdWxlcihyb3RFdWxlciksIGNvbXBTY2FsZVxcbiAgICAgICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwIHx8IENDX1JFTkRFUl9NT0RFID09IDNcXG4gICAgICAgICwgY2NfbWF0Vmlld0ludlxcbiAgICAgICNlbmRpZlxcbiAgICAgICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICAgICAgICAsIGNjX2NhbWVyYVBvcy54eXpcXG4gICAgICAgICwgdmVsb2NpdHlcXG4gICAgICAgICwgZnJhbWVUaWxlX3ZlbExlblNjYWxlLnpcXG4gICAgICAgICwgZnJhbWVUaWxlX3ZlbExlblNjYWxlLndcXG4gICAgICAgICwgYV9zaXplX3V2LndcXG4gICAgICAjZW5kaWZcXG4gICAgKTtcXG4gICNlbHNlXFxuICAgIG1hdDQgeGZvcm1Ob1NjYWxlID0gbWF0cml4RnJvbVJUKHF1YXRlcm5pb25Gcm9tRXVsZXIocm90YXRpb24pLCBwb3MueHl6KTtcXG4gICAgbWF0NCB4Zm9ybSA9IG1hdEZyb21SVFMocXVhdGVybmlvbkZyb21FdWxlcihyb3RhdGlvbiksIHBvcy54eXosIGNvbXBTY2FsZSk7XFxuICAgIHBvcyA9IHhmb3JtICogdmVjNChhX3RleENvb3JkMywgMSk7XFxuICAgIHZlYzQgbm9ybWFsID0geGZvcm1Ob1NjYWxlICogdmVjNChhX25vcm1hbCwgMCk7XFxuICAgIGNvbG9yICo9IGFfY29sb3IxO1xcbiAgI2VuZGlmXFxuICBwb3MgPSBjY19tYXRWaWV3UHJvaiAqIHBvcztcXG4gIGZsb2F0IGZyYW1lSW5kZXggPSAwLjtcXG4gICNpZiBURVhUVVJFX0FOSU1BVElPTl9NT0RVTEVfRU5BQkxFXFxuICAgIGZsb2F0IHN0YXJ0RnJhbWUgPSAwLjtcXG4gICAgdmVjMyBmcmFtZUluZm8gPSB2ZWMzKDAuKTtcXG4gICAgaWYgKGludCh1X2FuaW1faW5mby54KSA9PSAxKSB7XFxuICAgICAgZnJhbWVJbmZvID0gdW5wYWNrQ3VydmVEYXRhKHRleHR1cmVfYW5pbWF0aW9uX3RleDAsIHRpbWVDb29yZDApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZlYzMgZnJhbWVJbmZvMCA9IHVucGFja0N1cnZlRGF0YSh0ZXh0dXJlX2FuaW1hdGlvbl90ZXgwLCB0aW1lQ29vcmQwKTtcXG4gICAgICB2ZWMzIGZyYW1lSW5mbzEgPSB1bnBhY2tDdXJ2ZURhdGEodGV4dHVyZV9hbmltYXRpb25fdGV4MCwgdGltZUNvb3JkMSk7XFxuICAgICAgZmxvYXQgZmFjdG9yX3QgPSBwc2V1ZG9SYW5kb20oYV9ybmRTZWVkICsgOTA3OTQuKTtcXG4gICAgICBmcmFtZUluZm8gPSBtaXgoZnJhbWVJbmZvMCwgZnJhbWVJbmZvMSwgZmFjdG9yX3QpO1xcbiAgICB9XFxuICAgIHN0YXJ0RnJhbWUgPSBmcmFtZUluZm8ueCAvIHVfYW5pbV9pbmZvLnk7XFxuICAgIGZyYW1lSW5kZXggPSByZXBlYXQodV9hbmltX2luZm8ueiAqIChmcmFtZUluZm8ueSArIHN0YXJ0RnJhbWUpLCAxLik7XFxuICAjZW5kaWZcXG4gIHV2ID0gY29tcHV0ZVVWKGZyYW1lSW5kZXgsIHZlcnRJZHgsIGZyYW1lVGlsZV92ZWxMZW5TY2FsZS54eSkgKiBtYWluVGlsaW5nX09mZnNldC54eSArIG1haW5UaWxpbmdfT2Zmc2V0Lnp3O1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IGdwdnNfbWFpbigpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbn07XFxudmVjMyBTUkdCVG9MaW5lYXIgKHZlYzMgZ2FtbWEpIHtcXG4gIHJldHVybiBnYW1tYSAqIGdhbW1hO1xcbn1cXG52ZWM0IENDRnJhZ091dHB1dCAodmVjNCBjb2xvcikge1xcbiAgI2lmIENDX1VTRV9IRFJcXG4gICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgU1JHQlRvTGluZWFyKGNvbG9yLnJnYikgKiBjY19leHBvc3VyZS53LCB2ZWMzKGNjX2V4cG9zdXJlLnopKTtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIGNvbG9yO1xcbn1cXG5pbiB2ZWMyIHV2O1xcbmluIHZlYzQgY29sb3I7XFxudW5pZm9ybSBzYW1wbGVyMkQgbWFpblRleHR1cmU7XFxudW5pZm9ybSBGcmFnQ29uc3RhbnRzIHtcXG4gIHZlYzQgdGludENvbG9yO1xcbn07XFxudmVjNCBhZGQgKCkge1xcbiAgdmVjNCBjb2wgPSAyLjAgKiBjb2xvciAqIHRpbnRDb2xvciAqIHRleHR1cmUobWFpblRleHR1cmUsIHV2KTtcXG4gIHJldHVybiBDQ0ZyYWdPdXRwdXQoY29sKTtcXG59XFxub3V0IHZlYzQgY2NfRnJhZ0NvbG9yO1xcbnZvaWQgbWFpbigpIHsgY2NfRnJhZ0NvbG9yID0gYWRkKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImdsc2wxXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudmVjNCBxdWF0ZXJuaW9uRnJvbUF4aXMgKHZlYzMgeEF4aXMsdmVjMyB5QXhpcyx2ZWMzIHpBeGlzKXtcXG4gIG1hdDMgbSA9IG1hdDMoeEF4aXMseUF4aXMsekF4aXMpO1xcbiAgZmxvYXQgdHJhY2UgPSBtWzBdWzBdICsgbVsxXVsxXSArIG1bMl1bMl07XFxuICB2ZWM0IHF1YXQ7XFxuICBpZiAodHJhY2UgPiAwLikge1xcbiAgICBmbG9hdCBzID0gMC41IC8gc3FydCh0cmFjZSArIDEuMCk7XFxuICAgIHF1YXQudyA9IDAuMjUgLyBzO1xcbiAgICBxdWF0LnggPSAobVsyXVsxXSAtIG1bMV1bMl0pICogcztcXG4gICAgcXVhdC55ID0gKG1bMF1bMl0gLSBtWzJdWzBdKSAqIHM7XFxuICAgIHF1YXQueiA9IChtWzFdWzBdIC0gbVswXVsxXSkgKiBzO1xcbiAgfSBlbHNlIGlmICgobVswXVswXSA+IG1bMV1bMV0pICYmIChtWzBdWzBdID4gbVsyXVsyXSkpIHtcXG4gICAgZmxvYXQgcyA9IDIuMCAqIHNxcnQoMS4wICsgbVswXVswXSAtIG1bMV1bMV0gLSBtWzJdWzJdKTtcXG4gICAgcXVhdC53ID0gKG1bMl1bMV0gLSBtWzFdWzJdKSAvIHM7XFxuICAgIHF1YXQueCA9IDAuMjUgKiBzO1xcbiAgICBxdWF0LnkgPSAobVswXVsxXSArIG1bMV1bMF0pIC8gcztcXG4gICAgcXVhdC56ID0gKG1bMF1bMl0gKyBtWzJdWzBdKSAvIHM7XFxuICB9IGVsc2UgaWYgKG1bMV1bMV0gPiBtWzJdWzJdKSB7XFxuICAgIGZsb2F0IHMgPSAyLjAgKiBzcXJ0KDEuMCArIG1bMV1bMV0gLSBtWzBdWzBdIC0gbVsyXVsyXSk7XFxuICAgIHF1YXQudyA9IChtWzBdWzJdIC0gbVsyXVswXSkgLyBzO1xcbiAgICBxdWF0LnggPSAobVswXVsxXSArIG1bMV1bMF0pIC8gcztcXG4gICAgcXVhdC55ID0gMC4yNSAqIHM7XFxuICAgIHF1YXQueiA9IChtWzFdWzJdICsgbVsyXVsxXSkgLyBzO1xcbiAgfSBlbHNlIHtcXG4gICAgZmxvYXQgcyA9IDIuMCAqIHNxcnQoMS4wICsgbVsyXVsyXSAtIG1bMF1bMF0gLSBtWzFdWzFdKTtcXG4gICAgcXVhdC53ID0gKG1bMV1bMF0gLSBtWzBdWzFdKSAvIHM7XFxuICAgIHF1YXQueCA9IChtWzBdWzJdICsgbVsyXVswXSkgLyBzO1xcbiAgICBxdWF0LnkgPSAobVsxXVsyXSArIG1bMl1bMV0pIC8gcztcXG4gICAgcXVhdC56ID0gMC4yNSAqIHM7XFxuICB9XFxuICBmbG9hdCBsZW4gPSBxdWF0LnggKiBxdWF0LnggKyBxdWF0LnkgKiBxdWF0LnkgKyBxdWF0LnogKiBxdWF0LnogKyBxdWF0LncgKiBxdWF0Lnc7XFxuICBpZiAobGVuID4gMC4pIHtcXG4gICAgbGVuID0gMS4gLyBzcXJ0KGxlbik7XFxuICAgIHF1YXQueCA9IHF1YXQueCAqIGxlbjtcXG4gICAgcXVhdC55ID0gcXVhdC55ICogbGVuO1xcbiAgICBxdWF0LnogPSBxdWF0LnogKiBsZW47XFxuICAgIHF1YXQudyA9IHF1YXQudyAqIGxlbjtcXG4gIH1cXG4gIHJldHVybiBxdWF0O1xcbn1cXG52ZWM0IHF1YXRlcm5pb25Gcm9tRXVsZXIgKHZlYzMgYW5nbGUpe1xcbiAgZmxvYXQgeCA9IGFuZ2xlLnggLyAyLjtcXG4gIGZsb2F0IHkgPSBhbmdsZS55IC8gMi47XFxuICBmbG9hdCB6ID0gYW5nbGUueiAvIDIuO1xcbiAgZmxvYXQgc3ggPSBzaW4oeCk7XFxuICBmbG9hdCBjeCA9IGNvcyh4KTtcXG4gIGZsb2F0IHN5ID0gc2luKHkpO1xcbiAgZmxvYXQgY3kgPSBjb3MoeSk7XFxuICBmbG9hdCBzeiA9IHNpbih6KTtcXG4gIGZsb2F0IGN6ID0gY29zKHopO1xcbiAgdmVjNCBxdWF0ID0gdmVjNCgwKTtcXG4gIHF1YXQueCA9IHN4ICogY3kgKiBjeiArIGN4ICogc3kgKiBzejtcXG4gIHF1YXQueSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcXG4gIHF1YXQueiA9IGN4ICogY3kgKiBzeiAtIHN4ICogc3kgKiBjejtcXG4gIHF1YXQudyA9IGN4ICogY3kgKiBjeiAtIHN4ICogc3kgKiBzejtcXG4gIHJldHVybiBxdWF0O1xcbn1cXG5tYXQ0IG1hdHJpeEZyb21SVCAodmVjNCBxLCB2ZWMzIHApe1xcbiAgZmxvYXQgeDIgPSBxLnggKyBxLng7XFxuICBmbG9hdCB5MiA9IHEueSArIHEueTtcXG4gIGZsb2F0IHoyID0gcS56ICsgcS56O1xcbiAgZmxvYXQgeHggPSBxLnggKiB4MjtcXG4gIGZsb2F0IHh5ID0gcS54ICogeTI7XFxuICBmbG9hdCB4eiA9IHEueCAqIHoyO1xcbiAgZmxvYXQgeXkgPSBxLnkgKiB5MjtcXG4gIGZsb2F0IHl6ID0gcS55ICogejI7XFxuICBmbG9hdCB6eiA9IHEueiAqIHoyO1xcbiAgZmxvYXQgd3ggPSBxLncgKiB4MjtcXG4gIGZsb2F0IHd5ID0gcS53ICogeTI7XFxuICBmbG9hdCB3eiA9IHEudyAqIHoyO1xcbiAgcmV0dXJuIG1hdDQoXFxuICAgIDEuIC0gKHl5ICsgenopLCB4eSArIHd6LCB4eiAtIHd5LCAwLFxcbiAgICB4eSAtIHd6LCAxLiAtICh4eCArIHp6KSwgeXogKyB3eCwgMCxcXG4gICAgeHogKyB3eSwgeXogLSB3eCwgMS4gLSAoeHggKyB5eSksIDAsXFxuICAgIHAueCwgcC55LCBwLnosIDFcXG4gICk7XFxufVxcbm1hdDQgbWF0RnJvbVJUUyAodmVjNCBxLCB2ZWMzIHQsIHZlYzMgcyl7XFxuICBmbG9hdCB4ID0gcS54LCB5ID0gcS55LCB6ID0gcS56LCB3ID0gcS53O1xcbiAgZmxvYXQgeDIgPSB4ICsgeDtcXG4gIGZsb2F0IHkyID0geSArIHk7XFxuICBmbG9hdCB6MiA9IHogKyB6O1xcbiAgZmxvYXQgeHggPSB4ICogeDI7XFxuICBmbG9hdCB4eSA9IHggKiB5MjtcXG4gIGZsb2F0IHh6ID0geCAqIHoyO1xcbiAgZmxvYXQgeXkgPSB5ICogeTI7XFxuICBmbG9hdCB5eiA9IHkgKiB6MjtcXG4gIGZsb2F0IHp6ID0geiAqIHoyO1xcbiAgZmxvYXQgd3ggPSB3ICogeDI7XFxuICBmbG9hdCB3eSA9IHcgKiB5MjtcXG4gIGZsb2F0IHd6ID0gdyAqIHoyO1xcbiAgZmxvYXQgc3ggPSBzLng7XFxuICBmbG9hdCBzeSA9IHMueTtcXG4gIGZsb2F0IHN6ID0gcy56O1xcbiAgcmV0dXJuIG1hdDQoKDEuIC0gKHl5ICsgenopKSAqIHN4LCAoeHkgKyB3eikgKiBzeCwgKHh6IC0gd3kpICogc3gsIDAsXFxuICAgICh4eSAtIHd6KSAqIHN5LCAoMS4gLSAoeHggKyB6eikpICogc3ksICh5eiArIHd4KSAqIHN5LCAwLFxcbiAgICAoeHogKyB3eSkgKiBzeiwgKHl6IC0gd3gpICogc3osICgxLiAtICh4eCArIHl5KSkgKiBzeiwgMCxcXG4gICAgdC54LCB0LnksIHQueiwgMSk7XFxufVxcbnZlYzQgcXVhdE11bHRpcGx5ICh2ZWM0IGEsIHZlYzQgYil7XFxuICB2ZWM0IHF1YXQ7XFxuICBxdWF0LnggPSBhLnggKiBiLncgKyBhLncgKiBiLnggKyBhLnkgKiBiLnogLSBhLnogKiBiLnk7XFxuICBxdWF0LnkgPSBhLnkgKiBiLncgKyBhLncgKiBiLnkgKyBhLnogKiBiLnggLSBhLnggKiBiLno7XFxuICBxdWF0LnogPSBhLnogKiBiLncgKyBhLncgKiBiLnogKyBhLnggKiBiLnkgLSBhLnkgKiBiLng7XFxuICBxdWF0LncgPSBhLncgKiBiLncgLSBhLnggKiBiLnggLSBhLnkgKiBiLnkgLSBhLnogKiBiLno7XFxuICByZXR1cm4gcXVhdDtcXG59XFxudm9pZCByb3RhdGVWZWNGcm9tUXVhdCAoaW5vdXQgdmVjMyB2LCB2ZWM0IHEpe1xcbiAgZmxvYXQgaXggPSBxLncgKiB2LnggKyBxLnkgKiB2LnogLSBxLnogKiB2Lnk7XFxuICBmbG9hdCBpeSA9IHEudyAqIHYueSArIHEueiAqIHYueCAtIHEueCAqIHYuejtcXG4gIGZsb2F0IGl6ID0gcS53ICogdi56ICsgcS54ICogdi55IC0gcS55ICogdi54O1xcbiAgZmxvYXQgaXcgPSAtcS54ICogdi54IC0gcS55ICogdi55IC0gcS56ICogdi56O1xcbiAgdi54ID0gaXggKiBxLncgKyBpdyAqIC1xLnggKyBpeSAqIC1xLnogLSBpeiAqIC1xLnk7XFxuICB2LnkgPSBpeSAqIHEudyArIGl3ICogLXEueSArIGl6ICogLXEueCAtIGl4ICogLXEuejtcXG4gIHYueiA9IGl6ICogcS53ICsgaXcgKiAtcS56ICsgaXggKiAtcS55IC0gaXkgKiAtcS54O1xcbn1cXG52ZWMzIHJvdGF0ZUluTG9jYWxTcGFjZSAodmVjMyBwb3MsIHZlYzMgeEF4aXMsIHZlYzMgeUF4aXMsIHZlYzMgekF4aXMsIHZlYzQgcSl7XFxuICB2ZWM0IHZpZXdRdWF0ID0gcXVhdGVybmlvbkZyb21BeGlzKHhBeGlzLCB5QXhpcywgekF4aXMpO1xcbiAgdmVjNCByb3RRdWF0ID0gcXVhdE11bHRpcGx5KHZpZXdRdWF0LCBxKTtcXG4gIHJvdGF0ZVZlY0Zyb21RdWF0KHBvcywgcm90UXVhdCk7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIHJvdGF0ZUNvcm5lciAoaW5vdXQgdmVjMiBjb3JuZXIsIGZsb2F0IGFuZ2xlKXtcXG4gIGZsb2F0IHhPUyA9IGNvcyhhbmdsZSkgKiBjb3JuZXIueCAtIHNpbihhbmdsZSkgKiBjb3JuZXIueTtcXG4gIGZsb2F0IHlPUyA9IHNpbihhbmdsZSkgKiBjb3JuZXIueCArIGNvcyhhbmdsZSkgKiBjb3JuZXIueTtcXG4gIGNvcm5lci54ID0geE9TO1xcbiAgY29ybmVyLnkgPSB5T1M7XFxufVxcbnVuaWZvcm0gdmVjNCBtYWluVGlsaW5nX09mZnNldDtcXG51bmlmb3JtIHZlYzQgZnJhbWVUaWxlX3ZlbExlblNjYWxlO1xcbnVuaWZvcm0gdmVjNCBzY2FsZTtcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0VmlldztcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0Vmlld0ludjtcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxudW5pZm9ybSBoaWdocCB2ZWM0IGNjX2NhbWVyYVBvcztcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgdmVjNCBjb2xvcjtcXG52b2lkIGNvbXB1dGVWZXJ0UG9zIChpbm91dCB2ZWM0IHBvcywgdmVjMiB2ZXJ0T2Zmc2V0LCB2ZWM0IHEsIHZlYzMgc1xcbiNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwIHx8IENDX1JFTkRFUl9NT0RFID09IDNcXG4gICwgbWF0NCB2aWV3SW52XFxuI2VuZGlmXFxuI2lmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gICwgdmVjMyBleWVcXG4gICwgdmVjNCB2ZWxvY2l0eVxcbiAgLCBmbG9hdCB2ZWxvY2l0eVNjYWxlXFxuICAsIGZsb2F0IGxlbmd0aFNjYWxlXFxuICAsIGZsb2F0IHhJbmRleFxcbiNlbmRpZlxcbikge1xcbiNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwXFxuICB2ZWMzIHZpZXdTcGFjZVZlcnQgPSB2ZWMzKHZlcnRPZmZzZXQueCAqIHMueCwgdmVydE9mZnNldC55ICogcy55LCAwLik7XFxuICB2ZWMzIGNhbVggPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzBdLCB2aWV3SW52WzFdWzBdLCB2aWV3SW52WzJdWzBdKSk7XFxuICB2ZWMzIGNhbVkgPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzFdLCB2aWV3SW52WzFdWzFdLCB2aWV3SW52WzJdWzFdKSk7XFxuICB2ZWMzIGNhbVogPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzJdLCB2aWV3SW52WzFdWzJdLCB2aWV3SW52WzJdWzJdKSk7XFxuICBwb3MueHl6ICs9IHJvdGF0ZUluTG9jYWxTcGFjZSh2aWV3U3BhY2VWZXJ0LCBjYW1YLCBjYW1ZLCBjYW1aLCBxKTtcXG4jZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICB2ZWMzIGNhbVJpZ2h0ID0gbm9ybWFsaXplKGNyb3NzKHBvcy54eXogLSBleWUsIHZlbG9jaXR5Lnh5eikpICogcy54O1xcbiAgdmVjMyBjYW1VcCA9IHZlbG9jaXR5Lnh5eiAqIHZlbG9jaXR5U2NhbGUgKyBub3JtYWxpemUodmVsb2NpdHkueHl6KSAqIGxlbmd0aFNjYWxlICogcy55O1xcbiAgcG9zLnh5eiArPSAoY2FtUmlnaHQgKiBhYnModmVydE9mZnNldC54KSAqIHNpZ24odmVydE9mZnNldC55KSkgLSBjYW1VcCAqIHhJbmRleDtcXG4jZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAyXFxuICB2ZWMzIHZpZXdTcGFjZVZlcnQgPSB2ZWMzKHZlcnRPZmZzZXQueCAqIHMueCwgdmVydE9mZnNldC55ICogcy55LCAwLik7XFxuICB2ZWMzIGNhbVggPSB2ZWMzKDEsIDAsIDApO1xcbiAgdmVjMyBjYW1ZID0gdmVjMygwLCAwLCAtMSk7XFxuICBwb3MueHl6ICs9IHJvdGF0ZUluTG9jYWxTcGFjZSh2aWV3U3BhY2VWZXJ0LCBjYW1YLCBjYW1ZLCBjcm9zcyhjYW1YLCBjYW1ZKSwgcSk7XFxuI2VsaWYgQ0NfUkVOREVSX01PREUgPT0gM1xcbiAgdmVjMiB2aWV3U3BhY2VWZXJ0ID0gdmVjMih2ZXJ0T2Zmc2V0LnggKiBzLngsIHZlcnRPZmZzZXQueSAqIHMueSk7XFxuICByb3RhdGVDb3JuZXIodmlld1NwYWNlVmVydCwgcS56KTtcXG4gIHZlYzMgY2FtWCA9IG5vcm1hbGl6ZSh2ZWMzKGNjX21hdFZpZXdbMF1bMF0sIGNjX21hdFZpZXdbMV1bMF0sIGNjX21hdFZpZXdbMl1bMF0pKTtcXG4gIHZlYzMgY2FtWSA9IHZlYzMoMCwgMSwgMCk7XFxuICB2ZWMzIG9mZnNldCA9IGNhbVggKiB2aWV3U3BhY2VWZXJ0LnggKyBjYW1ZICogdmlld1NwYWNlVmVydC55O1xcbiAgcG9zLnh5eiArPSBvZmZzZXQ7XFxuI2Vsc2VcXG4gIHBvcy54ICs9IHZlcnRPZmZzZXQueDtcXG4gIHBvcy55ICs9IHZlcnRPZmZzZXQueTtcXG4jZW5kaWZcXG59XFxudmVjMiBjb21wdXRlVVYgKGZsb2F0IGZyYW1lSW5kZXgsIHZlYzIgdmVydEluZGV4LCB2ZWMyIGZyYW1lVGlsZSl7XFxuICB2ZWMyIGFuaVVWID0gdmVjMigwLCBmbG9vcihmcmFtZUluZGV4ICogZnJhbWVUaWxlLnkpKTtcXG4gIGFuaVVWLnggPSBmbG9vcihmcmFtZUluZGV4ICogZnJhbWVUaWxlLnggKiBmcmFtZVRpbGUueSAtIGFuaVVWLnkgKiBmcmFtZVRpbGUueCk7XFxuI2lmIENDX1JFTkRFUl9NT0RFICE9IDRcXG4gIHZlcnRJbmRleC55ID0gMS4gLSB2ZXJ0SW5kZXgueTtcXG4jZW5kaWZcXG4gIHJldHVybiAoYW5pVVYueHkgKyB2ZXJ0SW5kZXgpIC8gdmVjMihmcmFtZVRpbGUueCwgZnJhbWVUaWxlLnkpO1xcbn1cXG51bmlmb3JtIHZlYzQgdV9zYW1wbGVJbmZvO1xcbnVuaWZvcm0gdmVjNCB1X3dvcmxkUm90O1xcbnVuaWZvcm0gdmVjNCB1X3RpbWVEZWx0YTtcXG5hdHRyaWJ1dGUgdmVjNCBhX3Bvc2l0aW9uX3N0YXJ0dGltZTtcXG5hdHRyaWJ1dGUgdmVjNCBhX3NpemVfdXY7XFxuYXR0cmlidXRlIHZlYzQgYV9yb3RhdGlvbl91djtcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfZGlyX2xpZmU7XFxuYXR0cmlidXRlIGZsb2F0IGFfcm5kU2VlZDtcXG4jaWYgQ0NfUkVOREVSX01PREUgPT0gNFxcbiAgYXR0cmlidXRlIHZlYzMgYV90ZXhDb29yZDtcXG4gIGF0dHJpYnV0ZSB2ZWMzIGFfdGV4Q29vcmQzO1xcbiAgYXR0cmlidXRlIHZlYzMgYV9ub3JtYWw7XFxuICBhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yMTtcXG4jZW5kaWZcXG52ZWMzIHVucGFja0N1cnZlRGF0YSAoc2FtcGxlcjJEIHRleCwgdmVjMiBjb29yZCkge1xcbiAgICB2ZWM0IGEgPSB0ZXh0dXJlMkQodGV4LCBjb29yZCk7XFxuICAgIHZlYzQgYiA9IHRleHR1cmUyRCh0ZXgsIGNvb3JkICsgdV9zYW1wbGVJbmZvLnkpO1xcbiAgICBmbG9hdCBjID0gZnJhY3QoY29vcmQueCAqIHVfc2FtcGxlSW5mby54KTtcXG4gICAgcmV0dXJuIG1peChhLnh5eiwgYi54eXosIGMpO1xcbn1cXG52ZWMzIHVucGFja0N1cnZlRGF0YSAoc2FtcGxlcjJEIHRleCwgdmVjMiBjb29yZCwgb3V0IGZsb2F0IHcpIHtcXG4gICAgdmVjNCBhID0gdGV4dHVyZTJEKHRleCwgY29vcmQpO1xcbiAgICB2ZWM0IGIgPSB0ZXh0dXJlMkQodGV4LCBjb29yZCArIHVfc2FtcGxlSW5mby55KTtcXG4gICAgZmxvYXQgYyA9IGZyYWN0KGNvb3JkLnggKiB1X3NhbXBsZUluZm8ueCk7XFxuICAgIHcgPSBtaXgoYS53LCBiLncsIGMpO1xcbiAgICByZXR1cm4gbWl4KGEueHl6LCBiLnh5eiwgYyk7XFxufVxcbmZsb2F0IHBzZXVkb1JhbmRvbSAoZmxvYXQgc2VlZCkge1xcbiAgc2VlZCA9IG1vZChzZWVkLCAyMzMyODAuKTtcXG4gIGZsb2F0IHEgPSAoc2VlZCAqIDkzMDEuICsgNDkyOTcuKSAvIDIzMzI4MC47XFxuICByZXR1cm4gZnJhY3QocSk7XFxufVxcbiNpZiBDT0xPUl9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgY29sb3Jfb3Zlcl90aW1lX3RleDA7XFxuICB1bmlmb3JtIGludCB1X2NvbG9yX21vZGU7XFxuI2VuZGlmXFxuI2lmIFJPVEFUSU9OX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICB1bmlmb3JtIHNhbXBsZXIyRCByb3RhdGlvbl9vdmVyX3RpbWVfdGV4MDtcXG4gIHVuaWZvcm0gaW50IHVfcm90YXRpb25fbW9kZTtcXG4jZW5kaWZcXG4jaWYgU0laRV9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgc2l6ZV9vdmVyX3RpbWVfdGV4MDtcXG4gIHVuaWZvcm0gaW50IHVfc2l6ZV9tb2RlO1xcbiNlbmRpZlxcbiNpZiBGT1JDRV9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgZm9yY2Vfb3Zlcl90aW1lX3RleDA7XFxuICB1bmlmb3JtIGludCB1X2ZvcmNlX21vZGU7XFxudW5pZm9ybSBpbnQgdV9mb3JjZV9zcGFjZTtcXG4jZW5kaWZcXG4jaWYgVkVMT0NJVFlfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHZlbG9jaXR5X292ZXJfdGltZV90ZXgwO1xcbiAgdW5pZm9ybSBpbnQgdV92ZWxvY2l0eV9tb2RlO1xcbnVuaWZvcm0gaW50IHVfdmVsb2NpdHlfc3BhY2U7XFxuI2VuZGlmXFxuI2lmIFRFWFRVUkVfQU5JTUFUSU9OX01PRFVMRV9FTkFCTEVcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVfYW5pbWF0aW9uX3RleDA7XFxuICB1bmlmb3JtIHZlYzQgdV9hbmltX2luZm87XFxuI2VuZGlmXFxuZmxvYXQgcmVwZWF0IChmbG9hdCB0LCBmbG9hdCBsZW5ndGgpIHtcXG4gIHJldHVybiB0IC0gZmxvb3IodCAvIGxlbmd0aCkgKiBsZW5ndGg7XFxufVxcbnZlYzQgcm90YXRlUXVhdCAodmVjNCBwLCB2ZWM0IHEpIHtcXG4gIHZlYzMgaXYgPSBjcm9zcyhxLnh5eiwgcC54eXopICsgcS53ICogcC54eXo7XFxuICB2ZWMzIHJlcyA9IHAueHl6ICsgMi4wICogY3Jvc3MocS54eXosIGl2KTtcXG4gIHJldHVybiB2ZWM0KHJlcy54eXosIHAudyk7XFxufVxcbnZlYzQgZ3B2c19tYWluICgpIHtcXG4gIGZsb2F0IGFjdGl2ZVRpbWUgPSB1X3RpbWVEZWx0YS54IC0gYV9wb3NpdGlvbl9zdGFydHRpbWUudztcXG4gIGZsb2F0IG5vcm1hbGl6ZWRUaW1lID0gY2xhbXAoYWN0aXZlVGltZSAvIGFfZGlyX2xpZmUudywgMC4wLCAxLjApO1xcbiAgdmVjMiB0aW1lQ29vcmQwID0gdmVjMihub3JtYWxpemVkVGltZSwgMC4pO1xcbiAgdmVjMiB0aW1lQ29vcmQxID0gdmVjMihub3JtYWxpemVkVGltZSwgMS4pO1xcbiAgI2lmIENDX1JFTkRFUl9NT0RFID09IDRcXG4gICAgdmVjMiB2ZXJ0SWR4ID0gdmVjMihhX3RleENvb3JkLngsIGFfdGV4Q29vcmQueSk7XFxuICAjZWxzZVxcbiAgICB2ZWMyIHZlcnRJZHggPSB2ZWMyKGFfc2l6ZV91di53LCBhX3JvdGF0aW9uX3V2LncpO1xcbiAgI2VuZGlmXFxuICB2ZWM0IHZlbG9jaXR5ID0gdmVjNChhX2Rpcl9saWZlLnh5eiwgMC4pO1xcbiAgdmVjNCBwb3MgPSB2ZWM0KGFfcG9zaXRpb25fc3RhcnR0aW1lLnh5eiwgMS4pO1xcbiAgdmVjMyBzaXplID0gYV9zaXplX3V2Lnh5ejtcXG4gICNpZiBTSVpFX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICAgIGlmICh1X3NpemVfbW9kZSA9PSAxKSB7XFxuICAgICAgc2l6ZSAqPSB1bnBhY2tDdXJ2ZURhdGEoc2l6ZV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmVjMyBzaXplXzAgPSB1bnBhY2tDdXJ2ZURhdGEoc2l6ZV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgICAgdmVjMyBzaXplXzEgPSB1bnBhY2tDdXJ2ZURhdGEoc2l6ZV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMSk7XFxuICAgICAgZmxvYXQgZmFjdG9yX3MgPSBwc2V1ZG9SYW5kb20oYV9ybmRTZWVkICsgMzk4MjUuKTtcXG4gICAgICBzaXplICo9IG1peChzaXplXzAsIHNpemVfMSwgZmFjdG9yX3MpO1xcbiAgICB9XFxuICAjZW5kaWZcXG4gIHZlYzMgY29tcFNjYWxlID0gc2NhbGUueHl6ICogc2l6ZTtcXG4gICNpZiBGT1JDRV9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVxcbiAgICB2ZWMzIGZvcmNlQW5pbSA9IHZlYzMoMC4pO1xcbiAgICBpZiAodV9mb3JjZV9tb2RlID09IDEpIHtcXG4gICAgICBmb3JjZUFuaW0gPSB1bnBhY2tDdXJ2ZURhdGEoZm9yY2Vfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZlYzMgZm9yY2VfMCA9IHVucGFja0N1cnZlRGF0YShmb3JjZV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgICAgdmVjMyBmb3JjZV8xID0gdW5wYWNrQ3VydmVEYXRhKGZvcmNlX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQxKTtcXG4gICAgICBmbG9hdCBmYWN0b3JfZiA9ICBwc2V1ZG9SYW5kb20oYV9ybmRTZWVkICsgMjEyMTY1Lik7XFxuICAgICAgZm9yY2VBbmltID0gbWl4KGZvcmNlXzAsIGZvcmNlXzEsIGZhY3Rvcl9mKTtcXG4gICAgfVxcbiAgICB2ZWM0IGZvcmNlVHJhY2sgPSB2ZWM0KGZvcmNlQW5pbSwgMC4pO1xcbiAgICBpZiAodV9mb3JjZV9zcGFjZSA9PSAwKSB7XFxuICAgICAgZm9yY2VUcmFjayA9IHJvdGF0ZVF1YXQoZm9yY2VUcmFjaywgdV93b3JsZFJvdCk7XFxuICAgIH1cXG4gICAgdmVsb2NpdHkueHl6ICs9IGZvcmNlVHJhY2sueHl6O1xcbiAgI2VuZGlmXFxuICAjaWYgVkVMT0NJVFlfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcXG4gICAgZmxvYXQgc3BlZWRNb2RpZmllcjAgPSAxLjtcXG4gICAgZmxvYXQgc3BlZWRNb2RpZmllcjEgPSAxLjtcXG4gICAgdmVjMyB2ZWxvY2l0eUFuaW0gPSB2ZWMzKDAuKTtcXG4gICAgaWYgKHVfdmVsb2NpdHlfbW9kZSA9PSAxKSB7XFxuICAgICAgdmVsb2NpdHlBbmltID0gdW5wYWNrQ3VydmVEYXRhKHZlbG9jaXR5X292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQwLCBzcGVlZE1vZGlmaWVyMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmVjMyB2ZWN0b3J5XzAgPSB1bnBhY2tDdXJ2ZURhdGEodmVsb2NpdHlfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDAsIHNwZWVkTW9kaWZpZXIwKTtcXG4gICAgICB2ZWMzIHZlY3RvcnlfMSA9IHVucGFja0N1cnZlRGF0YSh2ZWxvY2l0eV9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMSwgc3BlZWRNb2RpZmllcjEpO1xcbiAgICAgIGZsb2F0IGZhY3Rvcl92ID0gcHNldWRvUmFuZG9tKGFfcm5kU2VlZCArIDE5Nzg2Ni4pO1xcbiAgICAgIHZlbG9jaXR5QW5pbSA9IG1peCh2ZWN0b3J5XzAsIHZlY3RvcnlfMSwgZmFjdG9yX3YpO1xcbiAgICAgIHNwZWVkTW9kaWZpZXIwID0gbWl4KHNwZWVkTW9kaWZpZXIwLCBzcGVlZE1vZGlmaWVyMSwgZmFjdG9yX3YpO1xcbiAgICB9XFxuICAgIHZlYzQgdmVsb2NpdHlUcmFjayA9IHZlYzQodmVsb2NpdHlBbmltLCAwLik7XFxuICAgIGlmICh1X3ZlbG9jaXR5X3NwYWNlID09IDApIHtcXG4gICAgICB2ZWxvY2l0eVRyYWNrID0gcm90YXRlUXVhdCh2ZWxvY2l0eVRyYWNrLCB1X3dvcmxkUm90KTtcXG4gICAgfVxcbiAgICB2ZWxvY2l0eS54eXogKz0gdmVsb2NpdHlUcmFjay54eXo7XFxuICAgIHZlbG9jaXR5Lnh5eiAqPSBzcGVlZE1vZGlmaWVyMDtcXG4gICNlbmRpZlxcbiAgcG9zLnh5eiArPSB2ZWxvY2l0eS54eXogKiBub3JtYWxpemVkVGltZSAqIGFfZGlyX2xpZmUudztcXG4gICNpZiAhQ0NfVVNFX1dPUkxEX1NQQUNFXFxuICAgIHBvcyA9IGNjX21hdFdvcmxkICogcG9zO1xcbiAgICAjaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgICAgIHZlbG9jaXR5ID0gcm90YXRlUXVhdCh2ZWxvY2l0eSwgdV93b3JsZFJvdCk7XFxuICAgICNlbmRpZlxcbiAgI2VuZGlmXFxuICB2ZWMzIHJvdGF0aW9uID0gYV9yb3RhdGlvbl91di54eXo7XFxuICAjaWYgUk9UQVRJT05fT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcXG4gICAgaWYgKHVfcm90YXRpb25fbW9kZSA9PSAxKSB7XFxuICAgICAgcm90YXRpb24gKz0gdW5wYWNrQ3VydmVEYXRhKHJvdGF0aW9uX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQwKSAqIG5vcm1hbGl6ZWRUaW1lICogYV9kaXJfbGlmZS53O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZlYzMgcm90YXRpb25fMCA9IHVucGFja0N1cnZlRGF0YShyb3RhdGlvbl9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgICAgdmVjMyByb3RhdGlvbl8xID0gdW5wYWNrQ3VydmVEYXRhKHJvdGF0aW9uX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQxKTtcXG4gICAgICBmbG9hdCBmYWN0b3JfciA9IHBzZXVkb1JhbmRvbShhX3JuZFNlZWQgKyAxMjUyOTIuKTtcXG4gICAgICByb3RhdGlvbiArPSBtaXgocm90YXRpb25fMCwgcm90YXRpb25fMSwgZmFjdG9yX3IpICogbm9ybWFsaXplZFRpbWUgKiBhX2Rpcl9saWZlLnc7XFxuICAgIH1cXG4gICNlbmRpZlxcbiAgI2lmIENPTE9SX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXFxuICAgIGlmICh1X2NvbG9yX21vZGUgPT0gMSkge1xcbiAgICAgIGNvbG9yID0gYV9jb2xvciAqIHRleHR1cmUyRChjb2xvcl9vdmVyX3RpbWVfdGV4MCwgdGltZUNvb3JkMCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmVjNCBjb2xvcl8wID0gdGV4dHVyZTJEKGNvbG9yX292ZXJfdGltZV90ZXgwLCB0aW1lQ29vcmQwKTtcXG4gICAgICB2ZWM0IGNvbG9yXzEgPSB0ZXh0dXJlMkQoY29sb3Jfb3Zlcl90aW1lX3RleDAsIHRpbWVDb29yZDEpO1xcbiAgICAgIGZsb2F0IGZhY3Rvcl9jID0gcHNldWRvUmFuZG9tKGFfcm5kU2VlZCArIDkxMDQxLik7XFxuICAgICAgY29sb3IgPSBhX2NvbG9yICogbWl4KGNvbG9yXzAsIGNvbG9yXzEsIGZhY3Rvcl9jKTtcXG4gICAgfVxcbiAgI2Vsc2VcXG4gICAgY29sb3IgPSBhX2NvbG9yO1xcbiAgI2VuZGlmXFxuICAjaWYgQ0NfUkVOREVSX01PREUgIT0gNFxcbiAgICB2ZWMyIGNvcm5lck9mZnNldCA9IHZlYzIoKHZlcnRJZHggLSAwLjUpKTtcXG4gICAgI2lmIENDX1JFTkRFUl9NT0RFID09IDBcXG4gICAgICB2ZWMzIHJvdEV1bGVyID0gcm90YXRpb24ueHl6O1xcbiAgICAjZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICAgICAgdmVjMyByb3RFdWxlciA9IHZlYzMoMC4pO1xcbiAgICAjZWxzZVxcbiAgICAgIHZlYzMgcm90RXVsZXIgPSB2ZWMzKDAuLCAwLiwgcm90YXRpb24ueik7XFxuICAgICNlbmRpZlxcbiAgICBjb21wdXRlVmVydFBvcyhwb3MsIGNvcm5lck9mZnNldCwgcXVhdGVybmlvbkZyb21FdWxlcihyb3RFdWxlciksIGNvbXBTY2FsZVxcbiAgICAgICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwIHx8IENDX1JFTkRFUl9NT0RFID09IDNcXG4gICAgICAgICwgY2NfbWF0Vmlld0ludlxcbiAgICAgICNlbmRpZlxcbiAgICAgICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICAgICAgICAsIGNjX2NhbWVyYVBvcy54eXpcXG4gICAgICAgICwgdmVsb2NpdHlcXG4gICAgICAgICwgZnJhbWVUaWxlX3ZlbExlblNjYWxlLnpcXG4gICAgICAgICwgZnJhbWVUaWxlX3ZlbExlblNjYWxlLndcXG4gICAgICAgICwgYV9zaXplX3V2LndcXG4gICAgICAjZW5kaWZcXG4gICAgKTtcXG4gICNlbHNlXFxuICAgIG1hdDQgeGZvcm1Ob1NjYWxlID0gbWF0cml4RnJvbVJUKHF1YXRlcm5pb25Gcm9tRXVsZXIocm90YXRpb24pLCBwb3MueHl6KTtcXG4gICAgbWF0NCB4Zm9ybSA9IG1hdEZyb21SVFMocXVhdGVybmlvbkZyb21FdWxlcihyb3RhdGlvbiksIHBvcy54eXosIGNvbXBTY2FsZSk7XFxuICAgIHBvcyA9IHhmb3JtICogdmVjNChhX3RleENvb3JkMywgMSk7XFxuICAgIHZlYzQgbm9ybWFsID0geGZvcm1Ob1NjYWxlICogdmVjNChhX25vcm1hbCwgMCk7XFxuICAgIGNvbG9yICo9IGFfY29sb3IxO1xcbiAgI2VuZGlmXFxuICBwb3MgPSBjY19tYXRWaWV3UHJvaiAqIHBvcztcXG4gIGZsb2F0IGZyYW1lSW5kZXggPSAwLjtcXG4gICNpZiBURVhUVVJFX0FOSU1BVElPTl9NT0RVTEVfRU5BQkxFXFxuICAgIGZsb2F0IHN0YXJ0RnJhbWUgPSAwLjtcXG4gICAgdmVjMyBmcmFtZUluZm8gPSB2ZWMzKDAuKTtcXG4gICAgaWYgKGludCh1X2FuaW1faW5mby54KSA9PSAxKSB7XFxuICAgICAgZnJhbWVJbmZvID0gdW5wYWNrQ3VydmVEYXRhKHRleHR1cmVfYW5pbWF0aW9uX3RleDAsIHRpbWVDb29yZDApO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZlYzMgZnJhbWVJbmZvMCA9IHVucGFja0N1cnZlRGF0YSh0ZXh0dXJlX2FuaW1hdGlvbl90ZXgwLCB0aW1lQ29vcmQwKTtcXG4gICAgICB2ZWMzIGZyYW1lSW5mbzEgPSB1bnBhY2tDdXJ2ZURhdGEodGV4dHVyZV9hbmltYXRpb25fdGV4MCwgdGltZUNvb3JkMSk7XFxuICAgICAgZmxvYXQgZmFjdG9yX3QgPSBwc2V1ZG9SYW5kb20oYV9ybmRTZWVkICsgOTA3OTQuKTtcXG4gICAgICBmcmFtZUluZm8gPSBtaXgoZnJhbWVJbmZvMCwgZnJhbWVJbmZvMSwgZmFjdG9yX3QpO1xcbiAgICB9XFxuICAgIHN0YXJ0RnJhbWUgPSBmcmFtZUluZm8ueCAvIHVfYW5pbV9pbmZvLnk7XFxuICAgIGZyYW1lSW5kZXggPSByZXBlYXQodV9hbmltX2luZm8ueiAqIChmcmFtZUluZm8ueSArIHN0YXJ0RnJhbWUpLCAxLik7XFxuICAjZW5kaWZcXG4gIHV2ID0gY29tcHV0ZVVWKGZyYW1lSW5kZXgsIHZlcnRJZHgsIGZyYW1lVGlsZV92ZWxMZW5TY2FsZS54eSkgKiBtYWluVGlsaW5nX09mZnNldC54eSArIG1haW5UaWxpbmdfT2Zmc2V0Lnp3O1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IGdwdnNfbWFpbigpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxudmVjMyBTUkdCVG9MaW5lYXIgKHZlYzMgZ2FtbWEpIHtcXG4gIHJldHVybiBnYW1tYSAqIGdhbW1hO1xcbn1cXG52ZWM0IENDRnJhZ091dHB1dCAodmVjNCBjb2xvcikge1xcbiAgI2lmIENDX1VTRV9IRFJcXG4gICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgU1JHQlRvTGluZWFyKGNvbG9yLnJnYikgKiBjY19leHBvc3VyZS53LCB2ZWMzKGNjX2V4cG9zdXJlLnopKTtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIGNvbG9yO1xcbn1cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyB2ZWM0IGNvbG9yO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1haW5UZXh0dXJlO1xcbnVuaWZvcm0gdmVjNCB0aW50Q29sb3I7XFxudmVjNCBhZGQgKCkge1xcbiAgdmVjNCBjb2wgPSAyLjAgKiBjb2xvciAqIHRpbnRDb2xvciAqIHRleHR1cmUyRChtYWluVGV4dHVyZSwgdXYpO1xcbiAgcmV0dXJuIENDRnJhZ091dHB1dChjb2wpO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX0ZyYWdDb2xvciA9IGFkZCgpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJidWlsdGluc1wiOiB7XHJcbiAgICAgICAgICBcImdsb2JhbHNcIjogeyBcImJsb2Nrc1wiOiBbeyBcIm5hbWVcIjogXCJDQ0dsb2JhbFwiLCBcImRlZmluZXNcIjogW10gfV0sIFwic2FtcGxlcnNcIjogW10gfSxcclxuICAgICAgICAgIFwibG9jYWxzXCI6IHsgXCJibG9ja3NcIjogW3sgXCJuYW1lXCI6IFwiQ0NMb2NhbFwiLCBcImRlZmluZXNcIjogW10gfV0sIFwic2FtcGxlcnNcIjogW10gfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkZWZpbmVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfUkVOREVSX01PREVcIiwgXCJ0eXBlXCI6IFwibnVtYmVyXCIsIFwicmFuZ2VcIjogWzAsIDRdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNPTE9SX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJST1RBVElPTl9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiU0laRV9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiRk9SQ0VfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlZFTE9DSVRZX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJURVhUVVJFX0FOSU1BVElPTl9NT0RVTEVfRU5BQkxFXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19VU0VfV09STERfU1BBQ0VcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9IRFJcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiYmxvY2tzXCI6IFtcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJDb25zdGFudHNcIiwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMCwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJtYWluVGlsaW5nX09mZnNldFwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcImZyYW1lVGlsZV92ZWxMZW5TY2FsZVwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInNjYWxlXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH1cclxuICAgICAgICAgIF19LFxyXG4gICAgICAgICAge1wibmFtZVwiOiBcIlNhbXBsZUNvbnN0YW50c1wiLCBcImRlZmluZXNcIjogW10sIFwiYmluZGluZ1wiOiAxLCBcIm1lbWJlcnNcIjogW1xyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInVfc2FtcGxlSW5mb1wiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9XHJcbiAgICAgICAgICBdfSxcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJUaWNrQ29uc3RhbnRzXCIsIFwiZGVmaW5lc1wiOiBbXSwgXCJiaW5kaW5nXCI6IDIsIFwibWVtYmVyc1wiOiBbXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwidV93b3JsZFJvdFwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInVfdGltZURlbHRhXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH1cclxuICAgICAgICAgIF19LFxyXG4gICAgICAgICAge1wibmFtZVwiOiBcIkNvbG9yQ29uc3RhbnRcIiwgXCJkZWZpbmVzXCI6IFtcIkNPTE9SX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXCJdLCBcImJpbmRpbmdcIjogMywgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJ1X2NvbG9yX21vZGVcIiwgXCJ0eXBlXCI6IDUsIFwiY291bnRcIjogMSB9XHJcbiAgICAgICAgICBdfSxcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJSb3RhdGlvbkNvbnN0YW50XCIsIFwiZGVmaW5lc1wiOiBbXCJST1RBVElPTl9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVwiXSwgXCJiaW5kaW5nXCI6IDQsIFwibWVtYmVyc1wiOiBbXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwidV9yb3RhdGlvbl9tb2RlXCIsIFwidHlwZVwiOiA1LCBcImNvdW50XCI6IDEgfVxyXG4gICAgICAgICAgXX0sXHJcbiAgICAgICAgICB7XCJuYW1lXCI6IFwiU2l6ZUNvbnN0YW50XCIsIFwiZGVmaW5lc1wiOiBbXCJTSVpFX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXCJdLCBcImJpbmRpbmdcIjogNSwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJ1X3NpemVfbW9kZVwiLCBcInR5cGVcIjogNSwgXCJjb3VudFwiOiAxIH1cclxuICAgICAgICAgIF19LFxyXG4gICAgICAgICAge1wibmFtZVwiOiBcIkZvcmNlQ29uc3RhbnRcIiwgXCJkZWZpbmVzXCI6IFtcIkZPUkNFX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXCJdLCBcImJpbmRpbmdcIjogNiwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJ1X2ZvcmNlX21vZGVcIiwgXCJ0eXBlXCI6IDUsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInVfZm9yY2Vfc3BhY2VcIiwgXCJ0eXBlXCI6IDUsIFwiY291bnRcIjogMSB9XHJcbiAgICAgICAgICBdfSxcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJWZWxvY2l0eUNvbnN0YW50XCIsIFwiZGVmaW5lc1wiOiBbXCJWRUxPQ0lUWV9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVwiXSwgXCJiaW5kaW5nXCI6IDcsIFwibWVtYmVyc1wiOiBbXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwidV92ZWxvY2l0eV9tb2RlXCIsIFwidHlwZVwiOiA1LCBcImNvdW50XCI6IDEgfSxcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJ1X3ZlbG9jaXR5X3NwYWNlXCIsIFwidHlwZVwiOiA1LCBcImNvdW50XCI6IDEgfVxyXG4gICAgICAgICAgXX0sXHJcbiAgICAgICAgICB7XCJuYW1lXCI6IFwiQW5pbWF0aW9uQ29uc3RhbnRcIiwgXCJkZWZpbmVzXCI6IFtcIlRFWFRVUkVfQU5JTUFUSU9OX01PRFVMRV9FTkFCTEVcIl0sIFwiYmluZGluZ1wiOiA4LCBcIm1lbWJlcnNcIjogW1xyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInVfYW5pbV9pbmZvXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH1cclxuICAgICAgICAgIF19LFxyXG4gICAgICAgICAge1wibmFtZVwiOiBcIkZyYWdDb25zdGFudHNcIiwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogOSwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJ0aW50Q29sb3JcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfVxyXG4gICAgICAgICAgXX1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwic2FtcGxlcnNcIjogW1xyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJjb2xvcl9vdmVyX3RpbWVfdGV4MFwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIkNPTE9SX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXCJdLCBcImJpbmRpbmdcIjogMzEgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwicm90YXRpb25fb3Zlcl90aW1lX3RleDBcIiwgXCJ0eXBlXCI6IDI4LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJST1RBVElPTl9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVwiXSwgXCJiaW5kaW5nXCI6IDMyIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcInNpemVfb3Zlcl90aW1lX3RleDBcIiwgXCJ0eXBlXCI6IDI4LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJTSVpFX09WRVJfVElNRV9NT0RVTEVfRU5BQkxFXCJdLCBcImJpbmRpbmdcIjogMzMgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZm9yY2Vfb3Zlcl90aW1lX3RleDBcIiwgXCJ0eXBlXCI6IDI4LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJGT1JDRV9PVkVSX1RJTUVfTU9EVUxFX0VOQUJMRVwiXSwgXCJiaW5kaW5nXCI6IDM0IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcInZlbG9jaXR5X292ZXJfdGltZV90ZXgwXCIsIFwidHlwZVwiOiAyOCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVkVMT0NJVFlfT1ZFUl9USU1FX01PRFVMRV9FTkFCTEVcIl0sIFwiYmluZGluZ1wiOiAzNSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJ0ZXh0dXJlX2FuaW1hdGlvbl90ZXgwXCIsIFwidHlwZVwiOiAyOCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVEVYVFVSRV9BTklNQVRJT05fTU9EVUxFX0VOQUJMRVwiXSwgXCJiaW5kaW5nXCI6IDM2IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIm1haW5UZXh0dXJlXCIsIFwidHlwZVwiOiAyOCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwiYmluZGluZ1wiOiAzNyB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcImF0dHJpYnV0ZXNcIjogW1xyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3Bvc2l0aW9uX3N0YXJ0dGltZVwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImZvcm1hdFwiOiA0MywgXCJsb2NhdGlvblwiOiAwIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfc2l6ZV91dlwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImZvcm1hdFwiOiA0MywgXCJsb2NhdGlvblwiOiAxIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfcm90YXRpb25fdXZcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJmb3JtYXRcIjogNDMsIFwibG9jYXRpb25cIjogMiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX2NvbG9yXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwiZm9ybWF0XCI6IDQzLCBcImxvY2F0aW9uXCI6IDMgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9kaXJfbGlmZVwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImZvcm1hdFwiOiA0MywgXCJsb2NhdGlvblwiOiA0IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfcm5kU2VlZFwiLCBcInR5cGVcIjogMTMsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImZvcm1hdFwiOiAxMSwgXCJsb2NhdGlvblwiOiA1IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfdGV4Q29vcmRcIiwgXCJ0eXBlXCI6IDE1LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJDQ19SRU5ERVJfTU9ERVwiXSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogNiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3RleENvb3JkM1wiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIkNDX1JFTkRFUl9NT0RFXCJdLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiA3IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfbm9ybWFsXCIsIFwidHlwZVwiOiAxNSwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfUkVOREVSX01PREVcIl0sIFwiZm9ybWF0XCI6IDMyLCBcImxvY2F0aW9uXCI6IDggfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9jb2xvcjFcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJDQ19SRU5ERVJfTU9ERVwiXSwgXCJmb3JtYXRcIjogNDMsIFwibG9jYXRpb25cIjogOSB9XHJcbiAgICAgICAgXVxyXG4gICAgICB9XHJcbiAgICBdXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm5hbWVcIjogXCJidWlsdGluLXBhcnRpY2xlLXRyYWlsXCIsXHJcbiAgICBcIl91dWlkXCI6IFwiMTdkZWJjYzMtMGE2Yi00YjhhLWIwMGItZGM1OGI4ODU1ODFlXCIsXHJcbiAgICBcInRlY2huaXF1ZXNcIjogW1xyXG4gICAgICB7IFwibmFtZVwiOiBcImFkZFwiLCBcInBhc3Nlc1wiOiBbeyBcInJhc3Rlcml6ZXJTdGF0ZVwiOiB7IFwiY3VsbE1vZGVcIjogMCB9LCBcImJsZW5kU3RhdGVcIjogeyBcInRhcmdldHNcIjogW3sgXCJibGVuZFwiOiB0cnVlLCBcImJsZW5kU3JjXCI6IDIsIFwiYmxlbmREc3RcIjogMSwgXCJibGVuZFNyY0FscGhhXCI6IDIsIFwiYmxlbmREc3RBbHBoYVwiOiAxIH1dIH0sIFwicHJvZ3JhbVwiOiBcImJ1aWx0aW4tcGFydGljbGUtdHJhaWx8cGFydGljbGUtdHJhaWw6dnNfbWFpbnx0aW50ZWQtZnM6YWRkXCIsIFwiZGVwdGhTdGVuY2lsU3RhdGVcIjogeyBcImRlcHRoVGVzdFwiOiB0cnVlLCBcImRlcHRoV3JpdGVcIjogZmFsc2UgfSwgXCJwcm9wZXJ0aWVzXCI6IHsgXCJtYWluVGV4dHVyZVwiOiB7IFwidmFsdWVcIjogXCJncmV5XCIsIFwidHlwZVwiOiAyOCB9LCBcIm1haW5UaWxpbmdfT2Zmc2V0XCI6IHsgXCJ2YWx1ZVwiOiBbMSwgMSwgMCwgMF0sIFwidHlwZVwiOiAxNiB9LCBcImZyYW1lVGlsZV92ZWxMZW5TY2FsZVwiOiB7IFwidmFsdWVcIjogWzEsIDEsIDAsIDBdLCBcInR5cGVcIjogMTYgfSwgXCJ0aW50Q29sb3JcIjogeyBcInZhbHVlXCI6IFswLjUsIDAuNSwgMC41LCAwLjVdLCBcInR5cGVcIjogMTYgfSB9IH1dIH1cclxuICAgIF0sXHJcbiAgICBcInNoYWRlcnNcIjogW1xyXG4gICAgICB7XHJcbiAgICAgICAgXCJuYW1lXCI6IFwiYnVpbHRpbi1wYXJ0aWNsZS10cmFpbHxwYXJ0aWNsZS10cmFpbDp2c19tYWlufHRpbnRlZC1mczphZGRcIixcclxuICAgICAgICBcImhhc2hcIjogNTM1NTIzNTQ3LFxyXG4gICAgICAgIFwiZ2xzbDNcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIENvbnN0YW50cyB7XFxuICB2ZWM0IG1haW5UaWxpbmdfT2Zmc2V0O1xcbiAgdmVjNCBmcmFtZVRpbGVfdmVsTGVuU2NhbGU7XFxuICB2ZWM0IHNjYWxlO1xcbn07XFxudW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbn07XFxudW5pZm9ybSBDQ0xvY2FsIHtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkSVQ7XFxuICBoaWdocCB2ZWM0IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG59O1xcbm91dCB2ZWMyIHV2O1xcbm91dCB2ZWM0IGNvbG9yO1xcbmluIHZlYzMgYV9wb3NpdGlvbjtcXG5pbiB2ZWM0IGFfdGV4Q29vcmQ7XFxuaW4gdmVjMyBhX3RleENvb3JkMTtcXG5pbiB2ZWMzIGFfdGV4Q29vcmQyO1xcbmluIHZlYzQgYV9jb2xvcjtcXG4jaWYgQ0NfRFJBV19XSVJFX0ZSQU1FXFxuICBvdXQgdmVjMyB2QmFyeWNlbnRyaWM7XFxuI2VuZGlmXFxudmVjNCB2c19tYWluKCkge1xcbiAgaGlnaHAgdmVjNCBwb3MgPSB2ZWM0KGFfcG9zaXRpb24sIDEpO1xcbiAgdmVjNCB2ZWxvY2l0eSA9IHZlYzQoYV90ZXhDb29yZDEueHl6LCAwKTtcXG4gICNpZiAhQ0NfVVNFX1dPUkxEX1NQQUNFXFxuICAgIHBvcyA9IGNjX21hdFdvcmxkICogcG9zO1xcbiAgICB2ZWxvY2l0eSA9IGNjX21hdFdvcmxkICogdmVsb2NpdHk7XFxuICAjZW5kaWZcXG4gIGZsb2F0IHZlcnRPZmZzZXQgPSAoYV90ZXhDb29yZC54IC0gMC41KSAqIGFfdGV4Q29vcmQueTtcXG4gIHZlYzMgY2FtVXAgPSBub3JtYWxpemUoY3Jvc3MocG9zLnh5eiAtIGNjX2NhbWVyYVBvcy54eXosIHZlbG9jaXR5Lnh5eikpO1xcbiAgcG9zLnh5eiArPSBjYW1VcCAqIHZlcnRPZmZzZXQ7XFxuICBwb3MgPSBjY19tYXRWaWV3UHJvaiAqIHBvcztcXG4gIHV2ID0gYV90ZXhDb29yZC56dyAqIG1haW5UaWxpbmdfT2Zmc2V0Lnh5ICsgbWFpblRpbGluZ19PZmZzZXQuenc7O1xcbiAgY29sb3IgPSBhX2NvbG9yO1xcbiAgI2lmIENDX0RSQVdfV0lSRV9GUkFNRVxcbiAgICB2QmFyeWNlbnRyaWMgPSBhX3RleENvb3JkMjtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZzX21haW4oKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbiAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbn07XFxudmVjMyBTUkdCVG9MaW5lYXIgKHZlYzMgZ2FtbWEpIHtcXG4gIHJldHVybiBnYW1tYSAqIGdhbW1hO1xcbn1cXG52ZWM0IENDRnJhZ091dHB1dCAodmVjNCBjb2xvcikge1xcbiAgI2lmIENDX1VTRV9IRFJcXG4gICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgU1JHQlRvTGluZWFyKGNvbG9yLnJnYikgKiBjY19leHBvc3VyZS53LCB2ZWMzKGNjX2V4cG9zdXJlLnopKTtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIGNvbG9yO1xcbn1cXG4gIGluIHZlYzIgdXY7XFxuICBpbiB2ZWM0IGNvbG9yO1xcbiAgI2lmIENDX0RSQVdfV0lSRV9GUkFNRVxcbiAgICBpbiB2ZWMzIHZCYXJ5Y2VudHJpYztcXG4gICNlbmRpZlxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgbWFpblRleHR1cmU7XFxuICB1bmlmb3JtIEZyYWdDb25zdGFudHMge1xcbiAgICB2ZWM0IHRpbnRDb2xvcjtcXG4gIH07XFxuICB2ZWM0IGFkZCAoKSB7XFxuICAgIHZlYzQgY29sID0gMi4wICogY29sb3IgKiB0aW50Q29sb3IgKiB0ZXh0dXJlKG1haW5UZXh0dXJlLCB1dik7XFxuI2lmIENDX0RSQVdfV0lSRV9GUkFNRVxcbiAgICBpZiAoYW55KGxlc3NUaGFuKHZCYXJ5Y2VudHJpYywgdmVjMygwLjAyKSkpKSB7XFxuICAgICAgICBjb2wgPSB2ZWM0KDAuLCAxLiwgMS4sIDEuKTtcXG4gICAgfVxcbiNlbmRpZlxcbiAgICByZXR1cm4gQ0NGcmFnT3V0cHV0KGNvbCk7XFxuICB9XFxub3V0IHZlYzQgY2NfRnJhZ0NvbG9yO1xcbnZvaWQgbWFpbigpIHsgY2NfRnJhZ0NvbG9yID0gYWRkKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImdsc2wxXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSB2ZWM0IG1haW5UaWxpbmdfT2Zmc2V0O1xcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG51bmlmb3JtIGhpZ2hwIHZlYzQgY2NfY2FtZXJhUG9zO1xcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyB2ZWM0IGNvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzQgYV90ZXhDb29yZDtcXG5hdHRyaWJ1dGUgdmVjMyBhX3RleENvb3JkMTtcXG5hdHRyaWJ1dGUgdmVjMyBhX3RleENvb3JkMjtcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbiNpZiBDQ19EUkFXX1dJUkVfRlJBTUVcXG4gIHZhcnlpbmcgdmVjMyB2QmFyeWNlbnRyaWM7XFxuI2VuZGlmXFxudmVjNCB2c19tYWluKCkge1xcbiAgaGlnaHAgdmVjNCBwb3MgPSB2ZWM0KGFfcG9zaXRpb24sIDEpO1xcbiAgdmVjNCB2ZWxvY2l0eSA9IHZlYzQoYV90ZXhDb29yZDEueHl6LCAwKTtcXG4gICNpZiAhQ0NfVVNFX1dPUkxEX1NQQUNFXFxuICAgIHBvcyA9IGNjX21hdFdvcmxkICogcG9zO1xcbiAgICB2ZWxvY2l0eSA9IGNjX21hdFdvcmxkICogdmVsb2NpdHk7XFxuICAjZW5kaWZcXG4gIGZsb2F0IHZlcnRPZmZzZXQgPSAoYV90ZXhDb29yZC54IC0gMC41KSAqIGFfdGV4Q29vcmQueTtcXG4gIHZlYzMgY2FtVXAgPSBub3JtYWxpemUoY3Jvc3MocG9zLnh5eiAtIGNjX2NhbWVyYVBvcy54eXosIHZlbG9jaXR5Lnh5eikpO1xcbiAgcG9zLnh5eiArPSBjYW1VcCAqIHZlcnRPZmZzZXQ7XFxuICBwb3MgPSBjY19tYXRWaWV3UHJvaiAqIHBvcztcXG4gIHV2ID0gYV90ZXhDb29yZC56dyAqIG1haW5UaWxpbmdfT2Zmc2V0Lnh5ICsgbWFpblRpbGluZ19PZmZzZXQuenc7O1xcbiAgY29sb3IgPSBhX2NvbG9yO1xcbiAgI2lmIENDX0RSQVdfV0lSRV9GUkFNRVxcbiAgICB2QmFyeWNlbnRyaWMgPSBhX3RleENvb3JkMjtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZzX21haW4oKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbiAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxudmVjMyBTUkdCVG9MaW5lYXIgKHZlYzMgZ2FtbWEpIHtcXG4gIHJldHVybiBnYW1tYSAqIGdhbW1hO1xcbn1cXG52ZWM0IENDRnJhZ091dHB1dCAodmVjNCBjb2xvcikge1xcbiAgI2lmIENDX1VTRV9IRFJcXG4gICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgU1JHQlRvTGluZWFyKGNvbG9yLnJnYikgKiBjY19leHBvc3VyZS53LCB2ZWMzKGNjX2V4cG9zdXJlLnopKTtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIGNvbG9yO1xcbn1cXG4gIHZhcnlpbmcgdmVjMiB1djtcXG4gIHZhcnlpbmcgdmVjNCBjb2xvcjtcXG4gICNpZiBDQ19EUkFXX1dJUkVfRlJBTUVcXG4gICAgdmFyeWluZyB2ZWMzIHZCYXJ5Y2VudHJpYztcXG4gICNlbmRpZlxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgbWFpblRleHR1cmU7XFxuICB1bmlmb3JtIHZlYzQgdGludENvbG9yO1xcbiAgdmVjNCBhZGQgKCkge1xcbiAgICB2ZWM0IGNvbCA9IDIuMCAqIGNvbG9yICogdGludENvbG9yICogdGV4dHVyZTJEKG1haW5UZXh0dXJlLCB1dik7XFxuI2lmIENDX0RSQVdfV0lSRV9GUkFNRVxcbiAgICBpZiAoYW55KGxlc3NUaGFuKHZCYXJ5Y2VudHJpYywgdmVjMygwLjAyKSkpKSB7XFxuICAgICAgICBjb2wgPSB2ZWM0KDAuLCAxLiwgMS4sIDEuKTtcXG4gICAgfVxcbiNlbmRpZlxcbiAgICByZXR1cm4gQ0NGcmFnT3V0cHV0KGNvbCk7XFxuICB9XFxudm9pZCBtYWluKCkgeyBnbF9GcmFnQ29sb3IgPSBhZGQoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiYnVpbHRpbnNcIjoge1xyXG4gICAgICAgICAgXCJnbG9iYWxzXCI6IHsgXCJibG9ja3NcIjogW3sgXCJuYW1lXCI6IFwiQ0NHbG9iYWxcIiwgXCJkZWZpbmVzXCI6IFtdIH1dLCBcInNhbXBsZXJzXCI6IFtdIH0sXHJcbiAgICAgICAgICBcImxvY2Fsc1wiOiB7IFwiYmxvY2tzXCI6IFt7IFwibmFtZVwiOiBcIkNDTG9jYWxcIiwgXCJkZWZpbmVzXCI6IFtdIH1dLCBcInNhbXBsZXJzXCI6IFtdIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGVmaW5lc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1JFTkRFUl9NT0RFXCIsIFwidHlwZVwiOiBcIm51bWJlclwiLCBcInJhbmdlXCI6IFswLCA0XSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19EUkFXX1dJUkVfRlJBTUVcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9XT1JMRF9TUEFDRVwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX0hEUlwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJibG9ja3NcIjogW1xyXG4gICAgICAgICAge1wibmFtZVwiOiBcIkNvbnN0YW50c1wiLCBcImRlZmluZXNcIjogW10sIFwiYmluZGluZ1wiOiAwLCBcIm1lbWJlcnNcIjogW1xyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcIm1haW5UaWxpbmdfT2Zmc2V0XCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH0sXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZnJhbWVUaWxlX3ZlbExlblNjYWxlXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH0sXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwic2NhbGVcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfVxyXG4gICAgICAgICAgXX0sXHJcbiAgICAgICAgICB7XCJuYW1lXCI6IFwiRnJhZ0NvbnN0YW50c1wiLCBcImRlZmluZXNcIjogW10sIFwiYmluZGluZ1wiOiAxLCBcIm1lbWJlcnNcIjogW1xyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInRpbnRDb2xvclwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9XHJcbiAgICAgICAgICBdfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJzYW1wbGVyc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIm1haW5UZXh0dXJlXCIsIFwidHlwZVwiOiAyOCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwiYmluZGluZ1wiOiAzMSB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcImF0dHJpYnV0ZXNcIjogW1xyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3Bvc2l0aW9uXCIsIFwidHlwZVwiOiAxNSwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwiZm9ybWF0XCI6IDMyLCBcImxvY2F0aW9uXCI6IDAgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV90ZXhDb29yZFwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImZvcm1hdFwiOiA0MywgXCJsb2NhdGlvblwiOiAxIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfdGV4Q29vcmQxXCIsIFwidHlwZVwiOiAxNSwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwiZm9ybWF0XCI6IDMyLCBcImxvY2F0aW9uXCI6IDIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV90ZXhDb29yZDJcIiwgXCJ0eXBlXCI6IDE1LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMyB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX2NvbG9yXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwiZm9ybWF0XCI6IDQzLCBcImxvY2F0aW9uXCI6IDQgfVxyXG4gICAgICAgIF1cclxuICAgICAgfVxyXG4gICAgXVxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJuYW1lXCI6IFwiYnVpbHRpbi1wYXJ0aWNsZVwiLFxyXG4gICAgXCJfdXVpZFwiOiBcImQxMzQ2NDM2LWFjOTYtNDI3MS1iODYzLTFmNGZkZWFkOTViMFwiLFxyXG4gICAgXCJ0ZWNobmlxdWVzXCI6IFtcclxuICAgICAgeyBcIm5hbWVcIjogXCJhZGRcIiwgXCJwYXNzZXNcIjogW3sgXCJyYXN0ZXJpemVyU3RhdGVcIjogeyBcImN1bGxNb2RlXCI6IDAgfSwgXCJibGVuZFN0YXRlXCI6IHsgXCJ0YXJnZXRzXCI6IFt7IFwiYmxlbmRcIjogdHJ1ZSwgXCJibGVuZFNyY1wiOiAyLCBcImJsZW5kRHN0XCI6IDEsIFwiYmxlbmRTcmNBbHBoYVwiOiAyLCBcImJsZW5kRHN0QWxwaGFcIjogMSB9XSB9LCBcInByb2dyYW1cIjogXCJidWlsdGluLXBhcnRpY2xlfHBhcnRpY2xlLXZzLWxlZ2FjeTpscHZzX21haW58dGludGVkLWZzOmFkZFwiLCBcImRlcHRoU3RlbmNpbFN0YXRlXCI6IHsgXCJkZXB0aFRlc3RcIjogdHJ1ZSwgXCJkZXB0aFdyaXRlXCI6IGZhbHNlIH0sIFwicHJvcGVydGllc1wiOiB7IFwibWFpblRleHR1cmVcIjogeyBcInZhbHVlXCI6IFwiZ3JleVwiLCBcInR5cGVcIjogMjggfSwgXCJtYWluVGlsaW5nX09mZnNldFwiOiB7IFwidmFsdWVcIjogWzEsIDEsIDAsIDBdLCBcInR5cGVcIjogMTYgfSwgXCJ0aW50Q29sb3JcIjogeyBcInZhbHVlXCI6IFswLjUsIDAuNSwgMC41LCAwLjVdLCBcInR5cGVcIjogMTYgfSB9IH1dIH1cclxuICAgIF0sXHJcbiAgICBcInNoYWRlcnNcIjogW1xyXG4gICAgICB7XHJcbiAgICAgICAgXCJuYW1lXCI6IFwiYnVpbHRpbi1wYXJ0aWNsZXxwYXJ0aWNsZS12cy1sZWdhY3k6bHB2c19tYWlufHRpbnRlZC1mczphZGRcIixcclxuICAgICAgICBcImhhc2hcIjogMjE3MTE2MTIyMSxcclxuICAgICAgICBcImdsc2wzXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbnZlYzQgcXVhdGVybmlvbkZyb21BeGlzICh2ZWMzIHhBeGlzLHZlYzMgeUF4aXMsdmVjMyB6QXhpcyl7XFxuICBtYXQzIG0gPSBtYXQzKHhBeGlzLHlBeGlzLHpBeGlzKTtcXG4gIGZsb2F0IHRyYWNlID0gbVswXVswXSArIG1bMV1bMV0gKyBtWzJdWzJdO1xcbiAgdmVjNCBxdWF0O1xcbiAgaWYgKHRyYWNlID4gMC4pIHtcXG4gICAgZmxvYXQgcyA9IDAuNSAvIHNxcnQodHJhY2UgKyAxLjApO1xcbiAgICBxdWF0LncgPSAwLjI1IC8gcztcXG4gICAgcXVhdC54ID0gKG1bMl1bMV0gLSBtWzFdWzJdKSAqIHM7XFxuICAgIHF1YXQueSA9IChtWzBdWzJdIC0gbVsyXVswXSkgKiBzO1xcbiAgICBxdWF0LnogPSAobVsxXVswXSAtIG1bMF1bMV0pICogcztcXG4gIH0gZWxzZSBpZiAoKG1bMF1bMF0gPiBtWzFdWzFdKSAmJiAobVswXVswXSA+IG1bMl1bMl0pKSB7XFxuICAgIGZsb2F0IHMgPSAyLjAgKiBzcXJ0KDEuMCArIG1bMF1bMF0gLSBtWzFdWzFdIC0gbVsyXVsyXSk7XFxuICAgIHF1YXQudyA9IChtWzJdWzFdIC0gbVsxXVsyXSkgLyBzO1xcbiAgICBxdWF0LnggPSAwLjI1ICogcztcXG4gICAgcXVhdC55ID0gKG1bMF1bMV0gKyBtWzFdWzBdKSAvIHM7XFxuICAgIHF1YXQueiA9IChtWzBdWzJdICsgbVsyXVswXSkgLyBzO1xcbiAgfSBlbHNlIGlmIChtWzFdWzFdID4gbVsyXVsyXSkge1xcbiAgICBmbG9hdCBzID0gMi4wICogc3FydCgxLjAgKyBtWzFdWzFdIC0gbVswXVswXSAtIG1bMl1bMl0pO1xcbiAgICBxdWF0LncgPSAobVswXVsyXSAtIG1bMl1bMF0pIC8gcztcXG4gICAgcXVhdC54ID0gKG1bMF1bMV0gKyBtWzFdWzBdKSAvIHM7XFxuICAgIHF1YXQueSA9IDAuMjUgKiBzO1xcbiAgICBxdWF0LnogPSAobVsxXVsyXSArIG1bMl1bMV0pIC8gcztcXG4gIH0gZWxzZSB7XFxuICAgIGZsb2F0IHMgPSAyLjAgKiBzcXJ0KDEuMCArIG1bMl1bMl0gLSBtWzBdWzBdIC0gbVsxXVsxXSk7XFxuICAgIHF1YXQudyA9IChtWzFdWzBdIC0gbVswXVsxXSkgLyBzO1xcbiAgICBxdWF0LnggPSAobVswXVsyXSArIG1bMl1bMF0pIC8gcztcXG4gICAgcXVhdC55ID0gKG1bMV1bMl0gKyBtWzJdWzFdKSAvIHM7XFxuICAgIHF1YXQueiA9IDAuMjUgKiBzO1xcbiAgfVxcbiAgZmxvYXQgbGVuID0gcXVhdC54ICogcXVhdC54ICsgcXVhdC55ICogcXVhdC55ICsgcXVhdC56ICogcXVhdC56ICsgcXVhdC53ICogcXVhdC53O1xcbiAgaWYgKGxlbiA+IDAuKSB7XFxuICAgIGxlbiA9IDEuIC8gc3FydChsZW4pO1xcbiAgICBxdWF0LnggPSBxdWF0LnggKiBsZW47XFxuICAgIHF1YXQueSA9IHF1YXQueSAqIGxlbjtcXG4gICAgcXVhdC56ID0gcXVhdC56ICogbGVuO1xcbiAgICBxdWF0LncgPSBxdWF0LncgKiBsZW47XFxuICB9XFxuICByZXR1cm4gcXVhdDtcXG59XFxudmVjNCBxdWF0ZXJuaW9uRnJvbUV1bGVyICh2ZWMzIGFuZ2xlKXtcXG4gIGZsb2F0IHggPSBhbmdsZS54IC8gMi47XFxuICBmbG9hdCB5ID0gYW5nbGUueSAvIDIuO1xcbiAgZmxvYXQgeiA9IGFuZ2xlLnogLyAyLjtcXG4gIGZsb2F0IHN4ID0gc2luKHgpO1xcbiAgZmxvYXQgY3ggPSBjb3MoeCk7XFxuICBmbG9hdCBzeSA9IHNpbih5KTtcXG4gIGZsb2F0IGN5ID0gY29zKHkpO1xcbiAgZmxvYXQgc3ogPSBzaW4oeik7XFxuICBmbG9hdCBjeiA9IGNvcyh6KTtcXG4gIHZlYzQgcXVhdCA9IHZlYzQoMCk7XFxuICBxdWF0LnggPSBzeCAqIGN5ICogY3ogKyBjeCAqIHN5ICogc3o7XFxuICBxdWF0LnkgPSBjeCAqIHN5ICogY3ogKyBzeCAqIGN5ICogc3o7XFxuICBxdWF0LnogPSBjeCAqIGN5ICogc3ogLSBzeCAqIHN5ICogY3o7XFxuICBxdWF0LncgPSBjeCAqIGN5ICogY3ogLSBzeCAqIHN5ICogc3o7XFxuICByZXR1cm4gcXVhdDtcXG59XFxubWF0NCBtYXRyaXhGcm9tUlQgKHZlYzQgcSwgdmVjMyBwKXtcXG4gIGZsb2F0IHgyID0gcS54ICsgcS54O1xcbiAgZmxvYXQgeTIgPSBxLnkgKyBxLnk7XFxuICBmbG9hdCB6MiA9IHEueiArIHEuejtcXG4gIGZsb2F0IHh4ID0gcS54ICogeDI7XFxuICBmbG9hdCB4eSA9IHEueCAqIHkyO1xcbiAgZmxvYXQgeHogPSBxLnggKiB6MjtcXG4gIGZsb2F0IHl5ID0gcS55ICogeTI7XFxuICBmbG9hdCB5eiA9IHEueSAqIHoyO1xcbiAgZmxvYXQgenogPSBxLnogKiB6MjtcXG4gIGZsb2F0IHd4ID0gcS53ICogeDI7XFxuICBmbG9hdCB3eSA9IHEudyAqIHkyO1xcbiAgZmxvYXQgd3ogPSBxLncgKiB6MjtcXG4gIHJldHVybiBtYXQ0KFxcbiAgICAxLiAtICh5eSArIHp6KSwgeHkgKyB3eiwgeHogLSB3eSwgMCxcXG4gICAgeHkgLSB3eiwgMS4gLSAoeHggKyB6eiksIHl6ICsgd3gsIDAsXFxuICAgIHh6ICsgd3ksIHl6IC0gd3gsIDEuIC0gKHh4ICsgeXkpLCAwLFxcbiAgICBwLngsIHAueSwgcC56LCAxXFxuICApO1xcbn1cXG5tYXQ0IG1hdEZyb21SVFMgKHZlYzQgcSwgdmVjMyB0LCB2ZWMzIHMpe1xcbiAgZmxvYXQgeCA9IHEueCwgeSA9IHEueSwgeiA9IHEueiwgdyA9IHEudztcXG4gIGZsb2F0IHgyID0geCArIHg7XFxuICBmbG9hdCB5MiA9IHkgKyB5O1xcbiAgZmxvYXQgejIgPSB6ICsgejtcXG4gIGZsb2F0IHh4ID0geCAqIHgyO1xcbiAgZmxvYXQgeHkgPSB4ICogeTI7XFxuICBmbG9hdCB4eiA9IHggKiB6MjtcXG4gIGZsb2F0IHl5ID0geSAqIHkyO1xcbiAgZmxvYXQgeXogPSB5ICogejI7XFxuICBmbG9hdCB6eiA9IHogKiB6MjtcXG4gIGZsb2F0IHd4ID0gdyAqIHgyO1xcbiAgZmxvYXQgd3kgPSB3ICogeTI7XFxuICBmbG9hdCB3eiA9IHcgKiB6MjtcXG4gIGZsb2F0IHN4ID0gcy54O1xcbiAgZmxvYXQgc3kgPSBzLnk7XFxuICBmbG9hdCBzeiA9IHMuejtcXG4gIHJldHVybiBtYXQ0KCgxLiAtICh5eSArIHp6KSkgKiBzeCwgKHh5ICsgd3opICogc3gsICh4eiAtIHd5KSAqIHN4LCAwLFxcbiAgICAoeHkgLSB3eikgKiBzeSwgKDEuIC0gKHh4ICsgenopKSAqIHN5LCAoeXogKyB3eCkgKiBzeSwgMCxcXG4gICAgKHh6ICsgd3kpICogc3osICh5eiAtIHd4KSAqIHN6LCAoMS4gLSAoeHggKyB5eSkpICogc3osIDAsXFxuICAgIHQueCwgdC55LCB0LnosIDEpO1xcbn1cXG52ZWM0IHF1YXRNdWx0aXBseSAodmVjNCBhLCB2ZWM0IGIpe1xcbiAgdmVjNCBxdWF0O1xcbiAgcXVhdC54ID0gYS54ICogYi53ICsgYS53ICogYi54ICsgYS55ICogYi56IC0gYS56ICogYi55O1xcbiAgcXVhdC55ID0gYS55ICogYi53ICsgYS53ICogYi55ICsgYS56ICogYi54IC0gYS54ICogYi56O1xcbiAgcXVhdC56ID0gYS56ICogYi53ICsgYS53ICogYi56ICsgYS54ICogYi55IC0gYS55ICogYi54O1xcbiAgcXVhdC53ID0gYS53ICogYi53IC0gYS54ICogYi54IC0gYS55ICogYi55IC0gYS56ICogYi56O1xcbiAgcmV0dXJuIHF1YXQ7XFxufVxcbnZvaWQgcm90YXRlVmVjRnJvbVF1YXQgKGlub3V0IHZlYzMgdiwgdmVjNCBxKXtcXG4gIGZsb2F0IGl4ID0gcS53ICogdi54ICsgcS55ICogdi56IC0gcS56ICogdi55O1xcbiAgZmxvYXQgaXkgPSBxLncgKiB2LnkgKyBxLnogKiB2LnggLSBxLnggKiB2Lno7XFxuICBmbG9hdCBpeiA9IHEudyAqIHYueiArIHEueCAqIHYueSAtIHEueSAqIHYueDtcXG4gIGZsb2F0IGl3ID0gLXEueCAqIHYueCAtIHEueSAqIHYueSAtIHEueiAqIHYuejtcXG4gIHYueCA9IGl4ICogcS53ICsgaXcgKiAtcS54ICsgaXkgKiAtcS56IC0gaXogKiAtcS55O1xcbiAgdi55ID0gaXkgKiBxLncgKyBpdyAqIC1xLnkgKyBpeiAqIC1xLnggLSBpeCAqIC1xLno7XFxuICB2LnogPSBpeiAqIHEudyArIGl3ICogLXEueiArIGl4ICogLXEueSAtIGl5ICogLXEueDtcXG59XFxudmVjMyByb3RhdGVJbkxvY2FsU3BhY2UgKHZlYzMgcG9zLCB2ZWMzIHhBeGlzLCB2ZWMzIHlBeGlzLCB2ZWMzIHpBeGlzLCB2ZWM0IHEpe1xcbiAgdmVjNCB2aWV3UXVhdCA9IHF1YXRlcm5pb25Gcm9tQXhpcyh4QXhpcywgeUF4aXMsIHpBeGlzKTtcXG4gIHZlYzQgcm90UXVhdCA9IHF1YXRNdWx0aXBseSh2aWV3UXVhdCwgcSk7XFxuICByb3RhdGVWZWNGcm9tUXVhdChwb3MsIHJvdFF1YXQpO1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCByb3RhdGVDb3JuZXIgKGlub3V0IHZlYzIgY29ybmVyLCBmbG9hdCBhbmdsZSl7XFxuICBmbG9hdCB4T1MgPSBjb3MoYW5nbGUpICogY29ybmVyLnggLSBzaW4oYW5nbGUpICogY29ybmVyLnk7XFxuICBmbG9hdCB5T1MgPSBzaW4oYW5nbGUpICogY29ybmVyLnggKyBjb3MoYW5nbGUpICogY29ybmVyLnk7XFxuICBjb3JuZXIueCA9IHhPUztcXG4gIGNvcm5lci55ID0geU9TO1xcbn1cXG51bmlmb3JtIENvbnN0YW50cyB7XFxuICB2ZWM0IG1haW5UaWxpbmdfT2Zmc2V0O1xcbiAgdmVjNCBmcmFtZVRpbGVfdmVsTGVuU2NhbGU7XFxuICB2ZWM0IHNjYWxlO1xcbn07XFxudW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbn07XFxudW5pZm9ybSBDQ0xvY2FsIHtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkSVQ7XFxuICBoaWdocCB2ZWM0IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG59O1xcbm91dCB2ZWMyIHV2O1xcbm91dCB2ZWM0IGNvbG9yO1xcbnZvaWQgY29tcHV0ZVZlcnRQb3MgKGlub3V0IHZlYzQgcG9zLCB2ZWMyIHZlcnRPZmZzZXQsIHZlYzQgcSwgdmVjMyBzXFxuI2lmIENDX1JFTkRFUl9NT0RFID09IDAgfHwgQ0NfUkVOREVSX01PREUgPT0gM1xcbiAgLCBtYXQ0IHZpZXdJbnZcXG4jZW5kaWZcXG4jaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgLCB2ZWMzIGV5ZVxcbiAgLCB2ZWM0IHZlbG9jaXR5XFxuICAsIGZsb2F0IHZlbG9jaXR5U2NhbGVcXG4gICwgZmxvYXQgbGVuZ3RoU2NhbGVcXG4gICwgZmxvYXQgeEluZGV4XFxuI2VuZGlmXFxuKSB7XFxuI2lmIENDX1JFTkRFUl9NT0RFID09IDBcXG4gIHZlYzMgdmlld1NwYWNlVmVydCA9IHZlYzModmVydE9mZnNldC54ICogcy54LCB2ZXJ0T2Zmc2V0LnkgKiBzLnksIDAuKTtcXG4gIHZlYzMgY2FtWCA9IG5vcm1hbGl6ZSh2ZWMzKHZpZXdJbnZbMF1bMF0sIHZpZXdJbnZbMV1bMF0sIHZpZXdJbnZbMl1bMF0pKTtcXG4gIHZlYzMgY2FtWSA9IG5vcm1hbGl6ZSh2ZWMzKHZpZXdJbnZbMF1bMV0sIHZpZXdJbnZbMV1bMV0sIHZpZXdJbnZbMl1bMV0pKTtcXG4gIHZlYzMgY2FtWiA9IG5vcm1hbGl6ZSh2ZWMzKHZpZXdJbnZbMF1bMl0sIHZpZXdJbnZbMV1bMl0sIHZpZXdJbnZbMl1bMl0pKTtcXG4gIHBvcy54eXogKz0gcm90YXRlSW5Mb2NhbFNwYWNlKHZpZXdTcGFjZVZlcnQsIGNhbVgsIGNhbVksIGNhbVosIHEpO1xcbiNlbGlmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gIHZlYzMgY2FtUmlnaHQgPSBub3JtYWxpemUoY3Jvc3MocG9zLnh5eiAtIGV5ZSwgdmVsb2NpdHkueHl6KSkgKiBzLng7XFxuICB2ZWMzIGNhbVVwID0gdmVsb2NpdHkueHl6ICogdmVsb2NpdHlTY2FsZSArIG5vcm1hbGl6ZSh2ZWxvY2l0eS54eXopICogbGVuZ3RoU2NhbGUgKiBzLnk7XFxuICBwb3MueHl6ICs9IChjYW1SaWdodCAqIGFicyh2ZXJ0T2Zmc2V0LngpICogc2lnbih2ZXJ0T2Zmc2V0LnkpKSAtIGNhbVVwICogeEluZGV4O1xcbiNlbGlmIENDX1JFTkRFUl9NT0RFID09IDJcXG4gIHZlYzMgdmlld1NwYWNlVmVydCA9IHZlYzModmVydE9mZnNldC54ICogcy54LCB2ZXJ0T2Zmc2V0LnkgKiBzLnksIDAuKTtcXG4gIHZlYzMgY2FtWCA9IHZlYzMoMSwgMCwgMCk7XFxuICB2ZWMzIGNhbVkgPSB2ZWMzKDAsIDAsIC0xKTtcXG4gIHBvcy54eXogKz0gcm90YXRlSW5Mb2NhbFNwYWNlKHZpZXdTcGFjZVZlcnQsIGNhbVgsIGNhbVksIGNyb3NzKGNhbVgsIGNhbVkpLCBxKTtcXG4jZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAzXFxuICB2ZWMyIHZpZXdTcGFjZVZlcnQgPSB2ZWMyKHZlcnRPZmZzZXQueCAqIHMueCwgdmVydE9mZnNldC55ICogcy55KTtcXG4gIHJvdGF0ZUNvcm5lcih2aWV3U3BhY2VWZXJ0LCBxLnopO1xcbiAgdmVjMyBjYW1YID0gbm9ybWFsaXplKHZlYzMoY2NfbWF0Vmlld1swXVswXSwgY2NfbWF0Vmlld1sxXVswXSwgY2NfbWF0Vmlld1syXVswXSkpO1xcbiAgdmVjMyBjYW1ZID0gdmVjMygwLCAxLCAwKTtcXG4gIHZlYzMgb2Zmc2V0ID0gY2FtWCAqIHZpZXdTcGFjZVZlcnQueCArIGNhbVkgKiB2aWV3U3BhY2VWZXJ0Lnk7XFxuICBwb3MueHl6ICs9IG9mZnNldDtcXG4jZWxzZVxcbiAgcG9zLnggKz0gdmVydE9mZnNldC54O1xcbiAgcG9zLnkgKz0gdmVydE9mZnNldC55O1xcbiNlbmRpZlxcbn1cXG52ZWMyIGNvbXB1dGVVViAoZmxvYXQgZnJhbWVJbmRleCwgdmVjMiB2ZXJ0SW5kZXgsIHZlYzIgZnJhbWVUaWxlKXtcXG4gIHZlYzIgYW5pVVYgPSB2ZWMyKDAsIGZsb29yKGZyYW1lSW5kZXggKiBmcmFtZVRpbGUueSkpO1xcbiAgYW5pVVYueCA9IGZsb29yKGZyYW1lSW5kZXggKiBmcmFtZVRpbGUueCAqIGZyYW1lVGlsZS55IC0gYW5pVVYueSAqIGZyYW1lVGlsZS54KTtcXG4jaWYgQ0NfUkVOREVSX01PREUgIT0gNFxcbiAgdmVydEluZGV4LnkgPSAxLiAtIHZlcnRJbmRleC55O1xcbiNlbmRpZlxcbiAgcmV0dXJuIChhbmlVVi54eSArIHZlcnRJbmRleCkgLyB2ZWMyKGZyYW1lVGlsZS54LCBmcmFtZVRpbGUueSk7XFxufVxcbmluIHZlYzMgYV9wb3NpdGlvbjtcXG5pbiB2ZWMzIGFfdGV4Q29vcmQ7XFxuaW4gdmVjMyBhX3RleENvb3JkMTtcXG5pbiB2ZWMzIGFfdGV4Q29vcmQyO1xcbmluIHZlYzQgYV9jb2xvcjtcXG4jaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgaW4gdmVjMyBhX2NvbG9yMTtcXG4jZW5kaWZcXG4jaWYgQ0NfUkVOREVSX01PREUgPT0gNFxcbiAgaW4gdmVjMyBhX3RleENvb3JkMztcXG4gIGluIHZlYzMgYV9ub3JtYWw7XFxuICBpbiB2ZWM0IGFfY29sb3IxO1xcbiNlbmRpZlxcbnZlYzQgbHB2c19tYWluICgpIHtcXG4gIHZlYzMgY29tcFNjYWxlID0gc2NhbGUueHl6ICogYV90ZXhDb29yZDE7XFxuICB2ZWM0IHBvcyA9IHZlYzQoYV9wb3NpdGlvbiwgMSk7XFxuICAjaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgICB2ZWM0IHZlbG9jaXR5ID0gdmVjNChhX2NvbG9yMS54eXosIDApO1xcbiAgI2VuZGlmXFxuICAjaWYgIUNDX1VTRV9XT1JMRF9TUEFDRVxcbiAgICBwb3MgPSBjY19tYXRXb3JsZCAqIHBvcztcXG4gICAgI2lmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gICAgICB2ZWxvY2l0eSA9IGNjX21hdFdvcmxkICogdmVsb2NpdHk7XFxuICAgICNlbmRpZlxcbiAgI2VuZGlmXFxuICAjaWYgQ0NfUkVOREVSX01PREUgIT0gNFxcbiAgICB2ZWMyIGNvcm5lck9mZnNldCA9IHZlYzIoKGFfdGV4Q29vcmQueHkgLSAwLjUpKTtcXG4gICAgI2lmIENDX1JFTkRFUl9NT0RFID09IDBcXG4gICAgICB2ZWMzIHJvdEV1bGVyID0gYV90ZXhDb29yZDI7XFxuICAgICNlbGlmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gICAgICB2ZWMzIHJvdEV1bGVyID0gdmVjMygwLik7XFxuICAgICNlbHNlXFxuICAgICAgdmVjMyByb3RFdWxlciA9IHZlYzMoMC4sIDAuLCBhX3RleENvb3JkMi56KTtcXG4gICAgI2VuZGlmXFxuICAgIGNvbXB1dGVWZXJ0UG9zKHBvcywgY29ybmVyT2Zmc2V0LCBxdWF0ZXJuaW9uRnJvbUV1bGVyKHJvdEV1bGVyKSwgY29tcFNjYWxlXFxuICAgICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwIHx8IENDX1JFTkRFUl9NT0RFID09IDNcXG4gICAgICAsIGNjX21hdFZpZXdJbnZcXG4gICAgI2VuZGlmXFxuICAgICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICAgICAgLCBjY19jYW1lcmFQb3MueHl6XFxuICAgICAgLCB2ZWxvY2l0eVxcbiAgICAgICwgZnJhbWVUaWxlX3ZlbExlblNjYWxlLnpcXG4gICAgICAsIGZyYW1lVGlsZV92ZWxMZW5TY2FsZS53XFxuICAgICAgLCBhX3RleENvb3JkLnhcXG4gICAgI2VuZGlmXFxuICAgICk7XFxuICAgIGNvbG9yID0gYV9jb2xvcjtcXG4gICNlbHNlXFxuICAgIG1hdDQgeGZvcm1Ob1NjYWxlID0gbWF0cml4RnJvbVJUKHF1YXRlcm5pb25Gcm9tRXVsZXIoYV90ZXhDb29yZDIpLCBwb3MueHl6KTtcXG4gICAgbWF0NCB4Zm9ybSA9IG1hdEZyb21SVFMocXVhdGVybmlvbkZyb21FdWxlcihhX3RleENvb3JkMiksIHBvcy54eXosIGNvbXBTY2FsZSk7XFxuICAgIHBvcyA9IHhmb3JtICogdmVjNChhX3RleENvb3JkMywgMSk7XFxuICAgIHZlYzQgbm9ybWFsID0geGZvcm1Ob1NjYWxlICogdmVjNChhX25vcm1hbCwgMCk7XFxuICAgIGNvbG9yID0gYV9jb2xvciAqIGFfY29sb3IxO1xcbiAgI2VuZGlmXFxuICB1diA9IGNvbXB1dGVVVihhX3RleENvb3JkLnosIGFfdGV4Q29vcmQueHksIGZyYW1lVGlsZV92ZWxMZW5TY2FsZS54eSkgKiBtYWluVGlsaW5nX09mZnNldC54eSArIG1haW5UaWxpbmdfT2Zmc2V0Lnp3O1xcbiAgcG9zID0gY2NfbWF0Vmlld1Byb2ogKiBwb3M7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gbHB2c19tYWluKCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIENDR2xvYmFsIHtcXG4gIGhpZ2hwICAgdmVjNCBjY190aW1lO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2NhbGU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbmF0aXZlU2l6ZTtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qSW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qSW52O1xcbiAgaGlnaHAgICB2ZWM0IGNjX2NhbWVyYVBvcztcXG4gIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0RGlyO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXRDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50U2t5O1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRHcm91bmQ7XFxufTtcXG52ZWMzIFNSR0JUb0xpbmVhciAodmVjMyBnYW1tYSkge1xcbiAgcmV0dXJuIGdhbW1hICogZ2FtbWE7XFxufVxcbnZlYzQgQ0NGcmFnT3V0cHV0ICh2ZWM0IGNvbG9yKSB7XFxuICAjaWYgQ0NfVVNFX0hEUlxcbiAgICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCBTUkdCVG9MaW5lYXIoY29sb3IucmdiKSAqIGNjX2V4cG9zdXJlLncsIHZlYzMoY2NfZXhwb3N1cmUueikpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY29sb3I7XFxufVxcbmluIHZlYzIgdXY7XFxuaW4gdmVjNCBjb2xvcjtcXG51bmlmb3JtIHNhbXBsZXIyRCBtYWluVGV4dHVyZTtcXG51bmlmb3JtIEZyYWdDb25zdGFudHMge1xcbiAgdmVjNCB0aW50Q29sb3I7XFxufTtcXG52ZWM0IGFkZCAoKSB7XFxuICB2ZWM0IGNvbCA9IDIuMCAqIGNvbG9yICogdGludENvbG9yICogdGV4dHVyZShtYWluVGV4dHVyZSwgdXYpO1xcbiAgcmV0dXJuIENDRnJhZ091dHB1dChjb2wpO1xcbn1cXG5vdXQgdmVjNCBjY19GcmFnQ29sb3I7XFxudm9pZCBtYWluKCkgeyBjY19GcmFnQ29sb3IgPSBhZGQoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZ2xzbDFcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxudmVjNCBxdWF0ZXJuaW9uRnJvbUF4aXMgKHZlYzMgeEF4aXMsdmVjMyB5QXhpcyx2ZWMzIHpBeGlzKXtcXG4gIG1hdDMgbSA9IG1hdDMoeEF4aXMseUF4aXMsekF4aXMpO1xcbiAgZmxvYXQgdHJhY2UgPSBtWzBdWzBdICsgbVsxXVsxXSArIG1bMl1bMl07XFxuICB2ZWM0IHF1YXQ7XFxuICBpZiAodHJhY2UgPiAwLikge1xcbiAgICBmbG9hdCBzID0gMC41IC8gc3FydCh0cmFjZSArIDEuMCk7XFxuICAgIHF1YXQudyA9IDAuMjUgLyBzO1xcbiAgICBxdWF0LnggPSAobVsyXVsxXSAtIG1bMV1bMl0pICogcztcXG4gICAgcXVhdC55ID0gKG1bMF1bMl0gLSBtWzJdWzBdKSAqIHM7XFxuICAgIHF1YXQueiA9IChtWzFdWzBdIC0gbVswXVsxXSkgKiBzO1xcbiAgfSBlbHNlIGlmICgobVswXVswXSA+IG1bMV1bMV0pICYmIChtWzBdWzBdID4gbVsyXVsyXSkpIHtcXG4gICAgZmxvYXQgcyA9IDIuMCAqIHNxcnQoMS4wICsgbVswXVswXSAtIG1bMV1bMV0gLSBtWzJdWzJdKTtcXG4gICAgcXVhdC53ID0gKG1bMl1bMV0gLSBtWzFdWzJdKSAvIHM7XFxuICAgIHF1YXQueCA9IDAuMjUgKiBzO1xcbiAgICBxdWF0LnkgPSAobVswXVsxXSArIG1bMV1bMF0pIC8gcztcXG4gICAgcXVhdC56ID0gKG1bMF1bMl0gKyBtWzJdWzBdKSAvIHM7XFxuICB9IGVsc2UgaWYgKG1bMV1bMV0gPiBtWzJdWzJdKSB7XFxuICAgIGZsb2F0IHMgPSAyLjAgKiBzcXJ0KDEuMCArIG1bMV1bMV0gLSBtWzBdWzBdIC0gbVsyXVsyXSk7XFxuICAgIHF1YXQudyA9IChtWzBdWzJdIC0gbVsyXVswXSkgLyBzO1xcbiAgICBxdWF0LnggPSAobVswXVsxXSArIG1bMV1bMF0pIC8gcztcXG4gICAgcXVhdC55ID0gMC4yNSAqIHM7XFxuICAgIHF1YXQueiA9IChtWzFdWzJdICsgbVsyXVsxXSkgLyBzO1xcbiAgfSBlbHNlIHtcXG4gICAgZmxvYXQgcyA9IDIuMCAqIHNxcnQoMS4wICsgbVsyXVsyXSAtIG1bMF1bMF0gLSBtWzFdWzFdKTtcXG4gICAgcXVhdC53ID0gKG1bMV1bMF0gLSBtWzBdWzFdKSAvIHM7XFxuICAgIHF1YXQueCA9IChtWzBdWzJdICsgbVsyXVswXSkgLyBzO1xcbiAgICBxdWF0LnkgPSAobVsxXVsyXSArIG1bMl1bMV0pIC8gcztcXG4gICAgcXVhdC56ID0gMC4yNSAqIHM7XFxuICB9XFxuICBmbG9hdCBsZW4gPSBxdWF0LnggKiBxdWF0LnggKyBxdWF0LnkgKiBxdWF0LnkgKyBxdWF0LnogKiBxdWF0LnogKyBxdWF0LncgKiBxdWF0Lnc7XFxuICBpZiAobGVuID4gMC4pIHtcXG4gICAgbGVuID0gMS4gLyBzcXJ0KGxlbik7XFxuICAgIHF1YXQueCA9IHF1YXQueCAqIGxlbjtcXG4gICAgcXVhdC55ID0gcXVhdC55ICogbGVuO1xcbiAgICBxdWF0LnogPSBxdWF0LnogKiBsZW47XFxuICAgIHF1YXQudyA9IHF1YXQudyAqIGxlbjtcXG4gIH1cXG4gIHJldHVybiBxdWF0O1xcbn1cXG52ZWM0IHF1YXRlcm5pb25Gcm9tRXVsZXIgKHZlYzMgYW5nbGUpe1xcbiAgZmxvYXQgeCA9IGFuZ2xlLnggLyAyLjtcXG4gIGZsb2F0IHkgPSBhbmdsZS55IC8gMi47XFxuICBmbG9hdCB6ID0gYW5nbGUueiAvIDIuO1xcbiAgZmxvYXQgc3ggPSBzaW4oeCk7XFxuICBmbG9hdCBjeCA9IGNvcyh4KTtcXG4gIGZsb2F0IHN5ID0gc2luKHkpO1xcbiAgZmxvYXQgY3kgPSBjb3MoeSk7XFxuICBmbG9hdCBzeiA9IHNpbih6KTtcXG4gIGZsb2F0IGN6ID0gY29zKHopO1xcbiAgdmVjNCBxdWF0ID0gdmVjNCgwKTtcXG4gIHF1YXQueCA9IHN4ICogY3kgKiBjeiArIGN4ICogc3kgKiBzejtcXG4gIHF1YXQueSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcXG4gIHF1YXQueiA9IGN4ICogY3kgKiBzeiAtIHN4ICogc3kgKiBjejtcXG4gIHF1YXQudyA9IGN4ICogY3kgKiBjeiAtIHN4ICogc3kgKiBzejtcXG4gIHJldHVybiBxdWF0O1xcbn1cXG5tYXQ0IG1hdHJpeEZyb21SVCAodmVjNCBxLCB2ZWMzIHApe1xcbiAgZmxvYXQgeDIgPSBxLnggKyBxLng7XFxuICBmbG9hdCB5MiA9IHEueSArIHEueTtcXG4gIGZsb2F0IHoyID0gcS56ICsgcS56O1xcbiAgZmxvYXQgeHggPSBxLnggKiB4MjtcXG4gIGZsb2F0IHh5ID0gcS54ICogeTI7XFxuICBmbG9hdCB4eiA9IHEueCAqIHoyO1xcbiAgZmxvYXQgeXkgPSBxLnkgKiB5MjtcXG4gIGZsb2F0IHl6ID0gcS55ICogejI7XFxuICBmbG9hdCB6eiA9IHEueiAqIHoyO1xcbiAgZmxvYXQgd3ggPSBxLncgKiB4MjtcXG4gIGZsb2F0IHd5ID0gcS53ICogeTI7XFxuICBmbG9hdCB3eiA9IHEudyAqIHoyO1xcbiAgcmV0dXJuIG1hdDQoXFxuICAgIDEuIC0gKHl5ICsgenopLCB4eSArIHd6LCB4eiAtIHd5LCAwLFxcbiAgICB4eSAtIHd6LCAxLiAtICh4eCArIHp6KSwgeXogKyB3eCwgMCxcXG4gICAgeHogKyB3eSwgeXogLSB3eCwgMS4gLSAoeHggKyB5eSksIDAsXFxuICAgIHAueCwgcC55LCBwLnosIDFcXG4gICk7XFxufVxcbm1hdDQgbWF0RnJvbVJUUyAodmVjNCBxLCB2ZWMzIHQsIHZlYzMgcyl7XFxuICBmbG9hdCB4ID0gcS54LCB5ID0gcS55LCB6ID0gcS56LCB3ID0gcS53O1xcbiAgZmxvYXQgeDIgPSB4ICsgeDtcXG4gIGZsb2F0IHkyID0geSArIHk7XFxuICBmbG9hdCB6MiA9IHogKyB6O1xcbiAgZmxvYXQgeHggPSB4ICogeDI7XFxuICBmbG9hdCB4eSA9IHggKiB5MjtcXG4gIGZsb2F0IHh6ID0geCAqIHoyO1xcbiAgZmxvYXQgeXkgPSB5ICogeTI7XFxuICBmbG9hdCB5eiA9IHkgKiB6MjtcXG4gIGZsb2F0IHp6ID0geiAqIHoyO1xcbiAgZmxvYXQgd3ggPSB3ICogeDI7XFxuICBmbG9hdCB3eSA9IHcgKiB5MjtcXG4gIGZsb2F0IHd6ID0gdyAqIHoyO1xcbiAgZmxvYXQgc3ggPSBzLng7XFxuICBmbG9hdCBzeSA9IHMueTtcXG4gIGZsb2F0IHN6ID0gcy56O1xcbiAgcmV0dXJuIG1hdDQoKDEuIC0gKHl5ICsgenopKSAqIHN4LCAoeHkgKyB3eikgKiBzeCwgKHh6IC0gd3kpICogc3gsIDAsXFxuICAgICh4eSAtIHd6KSAqIHN5LCAoMS4gLSAoeHggKyB6eikpICogc3ksICh5eiArIHd4KSAqIHN5LCAwLFxcbiAgICAoeHogKyB3eSkgKiBzeiwgKHl6IC0gd3gpICogc3osICgxLiAtICh4eCArIHl5KSkgKiBzeiwgMCxcXG4gICAgdC54LCB0LnksIHQueiwgMSk7XFxufVxcbnZlYzQgcXVhdE11bHRpcGx5ICh2ZWM0IGEsIHZlYzQgYil7XFxuICB2ZWM0IHF1YXQ7XFxuICBxdWF0LnggPSBhLnggKiBiLncgKyBhLncgKiBiLnggKyBhLnkgKiBiLnogLSBhLnogKiBiLnk7XFxuICBxdWF0LnkgPSBhLnkgKiBiLncgKyBhLncgKiBiLnkgKyBhLnogKiBiLnggLSBhLnggKiBiLno7XFxuICBxdWF0LnogPSBhLnogKiBiLncgKyBhLncgKiBiLnogKyBhLnggKiBiLnkgLSBhLnkgKiBiLng7XFxuICBxdWF0LncgPSBhLncgKiBiLncgLSBhLnggKiBiLnggLSBhLnkgKiBiLnkgLSBhLnogKiBiLno7XFxuICByZXR1cm4gcXVhdDtcXG59XFxudm9pZCByb3RhdGVWZWNGcm9tUXVhdCAoaW5vdXQgdmVjMyB2LCB2ZWM0IHEpe1xcbiAgZmxvYXQgaXggPSBxLncgKiB2LnggKyBxLnkgKiB2LnogLSBxLnogKiB2Lnk7XFxuICBmbG9hdCBpeSA9IHEudyAqIHYueSArIHEueiAqIHYueCAtIHEueCAqIHYuejtcXG4gIGZsb2F0IGl6ID0gcS53ICogdi56ICsgcS54ICogdi55IC0gcS55ICogdi54O1xcbiAgZmxvYXQgaXcgPSAtcS54ICogdi54IC0gcS55ICogdi55IC0gcS56ICogdi56O1xcbiAgdi54ID0gaXggKiBxLncgKyBpdyAqIC1xLnggKyBpeSAqIC1xLnogLSBpeiAqIC1xLnk7XFxuICB2LnkgPSBpeSAqIHEudyArIGl3ICogLXEueSArIGl6ICogLXEueCAtIGl4ICogLXEuejtcXG4gIHYueiA9IGl6ICogcS53ICsgaXcgKiAtcS56ICsgaXggKiAtcS55IC0gaXkgKiAtcS54O1xcbn1cXG52ZWMzIHJvdGF0ZUluTG9jYWxTcGFjZSAodmVjMyBwb3MsIHZlYzMgeEF4aXMsIHZlYzMgeUF4aXMsIHZlYzMgekF4aXMsIHZlYzQgcSl7XFxuICB2ZWM0IHZpZXdRdWF0ID0gcXVhdGVybmlvbkZyb21BeGlzKHhBeGlzLCB5QXhpcywgekF4aXMpO1xcbiAgdmVjNCByb3RRdWF0ID0gcXVhdE11bHRpcGx5KHZpZXdRdWF0LCBxKTtcXG4gIHJvdGF0ZVZlY0Zyb21RdWF0KHBvcywgcm90UXVhdCk7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIHJvdGF0ZUNvcm5lciAoaW5vdXQgdmVjMiBjb3JuZXIsIGZsb2F0IGFuZ2xlKXtcXG4gIGZsb2F0IHhPUyA9IGNvcyhhbmdsZSkgKiBjb3JuZXIueCAtIHNpbihhbmdsZSkgKiBjb3JuZXIueTtcXG4gIGZsb2F0IHlPUyA9IHNpbihhbmdsZSkgKiBjb3JuZXIueCArIGNvcyhhbmdsZSkgKiBjb3JuZXIueTtcXG4gIGNvcm5lci54ID0geE9TO1xcbiAgY29ybmVyLnkgPSB5T1M7XFxufVxcbnVuaWZvcm0gdmVjNCBtYWluVGlsaW5nX09mZnNldDtcXG51bmlmb3JtIHZlYzQgZnJhbWVUaWxlX3ZlbExlblNjYWxlO1xcbnVuaWZvcm0gdmVjNCBzY2FsZTtcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0VmlldztcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0Vmlld0ludjtcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxudW5pZm9ybSBoaWdocCB2ZWM0IGNjX2NhbWVyYVBvcztcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxudmFyeWluZyB2ZWMyIHV2O1xcbnZhcnlpbmcgdmVjNCBjb2xvcjtcXG52b2lkIGNvbXB1dGVWZXJ0UG9zIChpbm91dCB2ZWM0IHBvcywgdmVjMiB2ZXJ0T2Zmc2V0LCB2ZWM0IHEsIHZlYzMgc1xcbiNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwIHx8IENDX1JFTkRFUl9NT0RFID09IDNcXG4gICwgbWF0NCB2aWV3SW52XFxuI2VuZGlmXFxuI2lmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gICwgdmVjMyBleWVcXG4gICwgdmVjNCB2ZWxvY2l0eVxcbiAgLCBmbG9hdCB2ZWxvY2l0eVNjYWxlXFxuICAsIGZsb2F0IGxlbmd0aFNjYWxlXFxuICAsIGZsb2F0IHhJbmRleFxcbiNlbmRpZlxcbikge1xcbiNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwXFxuICB2ZWMzIHZpZXdTcGFjZVZlcnQgPSB2ZWMzKHZlcnRPZmZzZXQueCAqIHMueCwgdmVydE9mZnNldC55ICogcy55LCAwLik7XFxuICB2ZWMzIGNhbVggPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzBdLCB2aWV3SW52WzFdWzBdLCB2aWV3SW52WzJdWzBdKSk7XFxuICB2ZWMzIGNhbVkgPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzFdLCB2aWV3SW52WzFdWzFdLCB2aWV3SW52WzJdWzFdKSk7XFxuICB2ZWMzIGNhbVogPSBub3JtYWxpemUodmVjMyh2aWV3SW52WzBdWzJdLCB2aWV3SW52WzFdWzJdLCB2aWV3SW52WzJdWzJdKSk7XFxuICBwb3MueHl6ICs9IHJvdGF0ZUluTG9jYWxTcGFjZSh2aWV3U3BhY2VWZXJ0LCBjYW1YLCBjYW1ZLCBjYW1aLCBxKTtcXG4jZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICB2ZWMzIGNhbVJpZ2h0ID0gbm9ybWFsaXplKGNyb3NzKHBvcy54eXogLSBleWUsIHZlbG9jaXR5Lnh5eikpICogcy54O1xcbiAgdmVjMyBjYW1VcCA9IHZlbG9jaXR5Lnh5eiAqIHZlbG9jaXR5U2NhbGUgKyBub3JtYWxpemUodmVsb2NpdHkueHl6KSAqIGxlbmd0aFNjYWxlICogcy55O1xcbiAgcG9zLnh5eiArPSAoY2FtUmlnaHQgKiBhYnModmVydE9mZnNldC54KSAqIHNpZ24odmVydE9mZnNldC55KSkgLSBjYW1VcCAqIHhJbmRleDtcXG4jZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAyXFxuICB2ZWMzIHZpZXdTcGFjZVZlcnQgPSB2ZWMzKHZlcnRPZmZzZXQueCAqIHMueCwgdmVydE9mZnNldC55ICogcy55LCAwLik7XFxuICB2ZWMzIGNhbVggPSB2ZWMzKDEsIDAsIDApO1xcbiAgdmVjMyBjYW1ZID0gdmVjMygwLCAwLCAtMSk7XFxuICBwb3MueHl6ICs9IHJvdGF0ZUluTG9jYWxTcGFjZSh2aWV3U3BhY2VWZXJ0LCBjYW1YLCBjYW1ZLCBjcm9zcyhjYW1YLCBjYW1ZKSwgcSk7XFxuI2VsaWYgQ0NfUkVOREVSX01PREUgPT0gM1xcbiAgdmVjMiB2aWV3U3BhY2VWZXJ0ID0gdmVjMih2ZXJ0T2Zmc2V0LnggKiBzLngsIHZlcnRPZmZzZXQueSAqIHMueSk7XFxuICByb3RhdGVDb3JuZXIodmlld1NwYWNlVmVydCwgcS56KTtcXG4gIHZlYzMgY2FtWCA9IG5vcm1hbGl6ZSh2ZWMzKGNjX21hdFZpZXdbMF1bMF0sIGNjX21hdFZpZXdbMV1bMF0sIGNjX21hdFZpZXdbMl1bMF0pKTtcXG4gIHZlYzMgY2FtWSA9IHZlYzMoMCwgMSwgMCk7XFxuICB2ZWMzIG9mZnNldCA9IGNhbVggKiB2aWV3U3BhY2VWZXJ0LnggKyBjYW1ZICogdmlld1NwYWNlVmVydC55O1xcbiAgcG9zLnh5eiArPSBvZmZzZXQ7XFxuI2Vsc2VcXG4gIHBvcy54ICs9IHZlcnRPZmZzZXQueDtcXG4gIHBvcy55ICs9IHZlcnRPZmZzZXQueTtcXG4jZW5kaWZcXG59XFxudmVjMiBjb21wdXRlVVYgKGZsb2F0IGZyYW1lSW5kZXgsIHZlYzIgdmVydEluZGV4LCB2ZWMyIGZyYW1lVGlsZSl7XFxuICB2ZWMyIGFuaVVWID0gdmVjMigwLCBmbG9vcihmcmFtZUluZGV4ICogZnJhbWVUaWxlLnkpKTtcXG4gIGFuaVVWLnggPSBmbG9vcihmcmFtZUluZGV4ICogZnJhbWVUaWxlLnggKiBmcmFtZVRpbGUueSAtIGFuaVVWLnkgKiBmcmFtZVRpbGUueCk7XFxuI2lmIENDX1JFTkRFUl9NT0RFICE9IDRcXG4gIHZlcnRJbmRleC55ID0gMS4gLSB2ZXJ0SW5kZXgueTtcXG4jZW5kaWZcXG4gIHJldHVybiAoYW5pVVYueHkgKyB2ZXJ0SW5kZXgpIC8gdmVjMihmcmFtZVRpbGUueCwgZnJhbWVUaWxlLnkpO1xcbn1cXG5hdHRyaWJ1dGUgdmVjMyBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfdGV4Q29vcmQ7XFxuYXR0cmlidXRlIHZlYzMgYV90ZXhDb29yZDE7XFxuYXR0cmlidXRlIHZlYzMgYV90ZXhDb29yZDI7XFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG4jaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgYXR0cmlidXRlIHZlYzMgYV9jb2xvcjE7XFxuI2VuZGlmXFxuI2lmIENDX1JFTkRFUl9NT0RFID09IDRcXG4gIGF0dHJpYnV0ZSB2ZWMzIGFfdGV4Q29vcmQzO1xcbiAgYXR0cmlidXRlIHZlYzMgYV9ub3JtYWw7XFxuICBhdHRyaWJ1dGUgdmVjNCBhX2NvbG9yMTtcXG4jZW5kaWZcXG52ZWM0IGxwdnNfbWFpbiAoKSB7XFxuICB2ZWMzIGNvbXBTY2FsZSA9IHNjYWxlLnh5eiAqIGFfdGV4Q29vcmQxO1xcbiAgdmVjNCBwb3MgPSB2ZWM0KGFfcG9zaXRpb24sIDEpO1xcbiAgI2lmIENDX1JFTkRFUl9NT0RFID09IDFcXG4gICAgdmVjNCB2ZWxvY2l0eSA9IHZlYzQoYV9jb2xvcjEueHl6LCAwKTtcXG4gICNlbmRpZlxcbiAgI2lmICFDQ19VU0VfV09STERfU1BBQ0VcXG4gICAgcG9zID0gY2NfbWF0V29ybGQgKiBwb3M7XFxuICAgICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICAgICAgdmVsb2NpdHkgPSBjY19tYXRXb3JsZCAqIHZlbG9jaXR5O1xcbiAgICAjZW5kaWZcXG4gICNlbmRpZlxcbiAgI2lmIENDX1JFTkRFUl9NT0RFICE9IDRcXG4gICAgdmVjMiBjb3JuZXJPZmZzZXQgPSB2ZWMyKChhX3RleENvb3JkLnh5IC0gMC41KSk7XFxuICAgICNpZiBDQ19SRU5ERVJfTU9ERSA9PSAwXFxuICAgICAgdmVjMyByb3RFdWxlciA9IGFfdGV4Q29vcmQyO1xcbiAgICAjZWxpZiBDQ19SRU5ERVJfTU9ERSA9PSAxXFxuICAgICAgdmVjMyByb3RFdWxlciA9IHZlYzMoMC4pO1xcbiAgICAjZWxzZVxcbiAgICAgIHZlYzMgcm90RXVsZXIgPSB2ZWMzKDAuLCAwLiwgYV90ZXhDb29yZDIueik7XFxuICAgICNlbmRpZlxcbiAgICBjb21wdXRlVmVydFBvcyhwb3MsIGNvcm5lck9mZnNldCwgcXVhdGVybmlvbkZyb21FdWxlcihyb3RFdWxlciksIGNvbXBTY2FsZVxcbiAgICAjaWYgQ0NfUkVOREVSX01PREUgPT0gMCB8fCBDQ19SRU5ERVJfTU9ERSA9PSAzXFxuICAgICAgLCBjY19tYXRWaWV3SW52XFxuICAgICNlbmRpZlxcbiAgICAjaWYgQ0NfUkVOREVSX01PREUgPT0gMVxcbiAgICAgICwgY2NfY2FtZXJhUG9zLnh5elxcbiAgICAgICwgdmVsb2NpdHlcXG4gICAgICAsIGZyYW1lVGlsZV92ZWxMZW5TY2FsZS56XFxuICAgICAgLCBmcmFtZVRpbGVfdmVsTGVuU2NhbGUud1xcbiAgICAgICwgYV90ZXhDb29yZC54XFxuICAgICNlbmRpZlxcbiAgICApO1xcbiAgICBjb2xvciA9IGFfY29sb3I7XFxuICAjZWxzZVxcbiAgICBtYXQ0IHhmb3JtTm9TY2FsZSA9IG1hdHJpeEZyb21SVChxdWF0ZXJuaW9uRnJvbUV1bGVyKGFfdGV4Q29vcmQyKSwgcG9zLnh5eik7XFxuICAgIG1hdDQgeGZvcm0gPSBtYXRGcm9tUlRTKHF1YXRlcm5pb25Gcm9tRXVsZXIoYV90ZXhDb29yZDIpLCBwb3MueHl6LCBjb21wU2NhbGUpO1xcbiAgICBwb3MgPSB4Zm9ybSAqIHZlYzQoYV90ZXhDb29yZDMsIDEpO1xcbiAgICB2ZWM0IG5vcm1hbCA9IHhmb3JtTm9TY2FsZSAqIHZlYzQoYV9ub3JtYWwsIDApO1xcbiAgICBjb2xvciA9IGFfY29sb3IgKiBhX2NvbG9yMTtcXG4gICNlbmRpZlxcbiAgdXYgPSBjb21wdXRlVVYoYV90ZXhDb29yZC56LCBhX3RleENvb3JkLnh5LCBmcmFtZVRpbGVfdmVsTGVuU2NhbGUueHkpICogbWFpblRpbGluZ19PZmZzZXQueHkgKyBtYWluVGlsaW5nX09mZnNldC56dztcXG4gIHBvcyA9IGNjX21hdFZpZXdQcm9qICogcG9zO1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IGxwdnNfbWFpbigpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxudmVjMyBTUkdCVG9MaW5lYXIgKHZlYzMgZ2FtbWEpIHtcXG4gIHJldHVybiBnYW1tYSAqIGdhbW1hO1xcbn1cXG52ZWM0IENDRnJhZ091dHB1dCAodmVjNCBjb2xvcikge1xcbiAgI2lmIENDX1VTRV9IRFJcXG4gICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgU1JHQlRvTGluZWFyKGNvbG9yLnJnYikgKiBjY19leHBvc3VyZS53LCB2ZWMzKGNjX2V4cG9zdXJlLnopKTtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIGNvbG9yO1xcbn1cXG52YXJ5aW5nIHZlYzIgdXY7XFxudmFyeWluZyB2ZWM0IGNvbG9yO1xcbnVuaWZvcm0gc2FtcGxlcjJEIG1haW5UZXh0dXJlO1xcbnVuaWZvcm0gdmVjNCB0aW50Q29sb3I7XFxudmVjNCBhZGQgKCkge1xcbiAgdmVjNCBjb2wgPSAyLjAgKiBjb2xvciAqIHRpbnRDb2xvciAqIHRleHR1cmUyRChtYWluVGV4dHVyZSwgdXYpO1xcbiAgcmV0dXJuIENDRnJhZ091dHB1dChjb2wpO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX0ZyYWdDb2xvciA9IGFkZCgpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJidWlsdGluc1wiOiB7XHJcbiAgICAgICAgICBcImdsb2JhbHNcIjogeyBcImJsb2Nrc1wiOiBbeyBcIm5hbWVcIjogXCJDQ0dsb2JhbFwiLCBcImRlZmluZXNcIjogW10gfV0sIFwic2FtcGxlcnNcIjogW10gfSxcclxuICAgICAgICAgIFwibG9jYWxzXCI6IHsgXCJibG9ja3NcIjogW3sgXCJuYW1lXCI6IFwiQ0NMb2NhbFwiLCBcImRlZmluZXNcIjogW10gfV0sIFwic2FtcGxlcnNcIjogW10gfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkZWZpbmVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfUkVOREVSX01PREVcIiwgXCJ0eXBlXCI6IFwibnVtYmVyXCIsIFwicmFuZ2VcIjogWzAsIDRdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9XT1JMRF9TUEFDRVwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX0hEUlwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJibG9ja3NcIjogW1xyXG4gICAgICAgICAge1wibmFtZVwiOiBcIkNvbnN0YW50c1wiLCBcImRlZmluZXNcIjogW10sIFwiYmluZGluZ1wiOiAwLCBcIm1lbWJlcnNcIjogW1xyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcIm1haW5UaWxpbmdfT2Zmc2V0XCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH0sXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZnJhbWVUaWxlX3ZlbExlblNjYWxlXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH0sXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwic2NhbGVcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfVxyXG4gICAgICAgICAgXX0sXHJcbiAgICAgICAgICB7XCJuYW1lXCI6IFwiRnJhZ0NvbnN0YW50c1wiLCBcImRlZmluZXNcIjogW10sIFwiYmluZGluZ1wiOiAxLCBcIm1lbWJlcnNcIjogW1xyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInRpbnRDb2xvclwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9XHJcbiAgICAgICAgICBdfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJzYW1wbGVyc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIm1haW5UZXh0dXJlXCIsIFwidHlwZVwiOiAyOCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwiYmluZGluZ1wiOiAzMSB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcImF0dHJpYnV0ZXNcIjogW1xyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3Bvc2l0aW9uXCIsIFwidHlwZVwiOiAxNSwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwiZm9ybWF0XCI6IDMyLCBcImxvY2F0aW9uXCI6IDAgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV90ZXhDb29yZFwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiAxIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfdGV4Q29vcmQxXCIsIFwidHlwZVwiOiAxNSwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwiZm9ybWF0XCI6IDMyLCBcImxvY2F0aW9uXCI6IDIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV90ZXhDb29yZDJcIiwgXCJ0eXBlXCI6IDE1LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMyB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX2NvbG9yXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwiZm9ybWF0XCI6IDQzLCBcImxvY2F0aW9uXCI6IDQgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9jb2xvcjFcIiwgXCJ0eXBlXCI6IDE1LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJDQ19SRU5ERVJfTU9ERVwiXSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogNSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3RleENvb3JkM1wiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIkNDX1JFTkRFUl9NT0RFXCJdLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiA2IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfbm9ybWFsXCIsIFwidHlwZVwiOiAxNSwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfUkVOREVSX01PREVcIl0sIFwiZm9ybWF0XCI6IDMyLCBcImxvY2F0aW9uXCI6IDcgfVxyXG4gICAgICAgIF1cclxuICAgICAgfVxyXG4gICAgXVxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJuYW1lXCI6IFwiYnVpbHRpbi1zcHJpdGVcIixcclxuICAgIFwiX3V1aWRcIjogXCI2MGY3MTk1Yy1lYzJhLTQ1ZWItYmE5NC04OTU1ZjYwZTgxZDBcIixcclxuICAgIFwidGVjaG5pcXVlc1wiOiBbXHJcbiAgICAgIHsgXCJwYXNzZXNcIjogW3sgXCJibGVuZFN0YXRlXCI6IHsgXCJ0YXJnZXRzXCI6IFt7IFwiYmxlbmRcIjogdHJ1ZSwgXCJibGVuZFNyY1wiOiAyLCBcImJsZW5kRHN0XCI6IDQsIFwiYmxlbmREc3RBbHBoYVwiOiA0IH1dIH0sIFwicmFzdGVyaXplclN0YXRlXCI6IHsgXCJjdWxsTW9kZVwiOiAwIH0sIFwicHJvZ3JhbVwiOiBcImJ1aWx0aW4tc3ByaXRlfHNwcml0ZS12czp2ZXJ0fHNwcml0ZS1mczpmcmFnXCIsIFwicHJpb3JpdHlcIjogMjQ0LCBcImRlcHRoU3RlbmNpbFN0YXRlXCI6IHsgXCJkZXB0aFRlc3RcIjogZmFsc2UsIFwiZGVwdGhXcml0ZVwiOiBmYWxzZSB9LCBcInByb3BlcnRpZXNcIjogeyBcIm1haW5UZXh0dXJlXCI6IHsgXCJ2YWx1ZVwiOiBcIndoaXRlXCIsIFwidHlwZVwiOiAyOCB9IH0gfV0gfVxyXG4gICAgXSxcclxuICAgIFwic2hhZGVyc1wiOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBcIm5hbWVcIjogXCJidWlsdGluLXNwcml0ZXxzcHJpdGUtdnM6dmVydHxzcHJpdGUtZnM6ZnJhZ1wiLFxyXG4gICAgICAgIFwiaGFzaFwiOiA0NDc1OTg5NTUsXHJcbiAgICAgICAgXCJnbHNsM1wiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG51bmlmb3JtIENDR2xvYmFsIHtcXG4gIGhpZ2hwICAgdmVjNCBjY190aW1lO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2NhbGU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbmF0aXZlU2l6ZTtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qSW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qSW52O1xcbiAgaGlnaHAgICB2ZWM0IGNjX2NhbWVyYVBvcztcXG4gIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0RGlyO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXRDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50U2t5O1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRHcm91bmQ7XFxufTtcXG4jaWYgVVNFX0xPQ0FMXFxudW5pZm9ybSBDQ0xvY2FsIHtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkSVQ7XFxuICBoaWdocCB2ZWM0IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG59O1xcbiNlbmRpZlxcbmluIHZlYzMgYV9wb3NpdGlvbjtcXG5pbiB2ZWM0IGFfY29sb3I7XFxub3V0IHZlYzQgY29sb3I7XFxuaW4gdmVjMiBhX3RleENvb3JkO1xcbm91dCB2ZWMyIHV2MDtcXG52ZWM0IHZlcnQgKCkge1xcbiAgdmVjNCBwb3MgPSB2ZWM0KGFfcG9zaXRpb24sIDEpO1xcbiAgI2lmIFVTRV9MT0NBTFxcbiAgICBwb3MgPSBjY19tYXRWaWV3UHJvaiAqIGNjX21hdFdvcmxkICogcG9zO1xcbiAgI2Vsc2VcXG4gICAgcG9zID0gY2NfbWF0Vmlld1Byb2ogKiBwb3M7XFxuICAjZW5kaWZcXG4gIHV2MCA9IGFfdGV4Q29vcmQ7XFxuICBjb2xvciA9IGFfY29sb3I7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdmVydCgpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbmluIHZlYzQgY29sb3I7XFxuI2lmIFVTRV9URVhUVVJFXFxuICBpbiB2ZWMyIHV2MDtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIG1haW5UZXh0dXJlO1xcbiNlbmRpZlxcbnZlYzQgZnJhZyAoKSB7XFxuICB2ZWM0IG8gPSB2ZWM0KDEsIDEsIDEsIDEpO1xcbiAgI2lmIFVTRV9URVhUVVJFXFxuICAgIG8gKj0gdGV4dHVyZShtYWluVGV4dHVyZSwgdXYwKTtcXG4gICAgI2lmIElTX0dSQVlcXG4gICAgICBmbG9hdCBncmF5ICA9IDAuMjEyNiAqIG8uciArIDAuNzE1MiAqIG8uZyArIDAuMDcyMiAqIG8uYjtcXG4gICAgICBvLnIgPSBvLmcgPSBvLmIgPSBncmF5O1xcbiAgICAjZW5kaWZcXG4gICNlbmRpZlxcbiAgbyAqPSBjb2xvcjtcXG4gIHJldHVybiBvO1xcbn1cXG5vdXQgdmVjNCBjY19GcmFnQ29sb3I7XFxudm9pZCBtYWluKCkgeyBjY19GcmFnQ29sb3IgPSBmcmFnKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImdsc2wxXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4jaWYgVVNFX0xPQ0FMXFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFdvcmxkO1xcbiNlbmRpZlxcbmF0dHJpYnV0ZSB2ZWMzIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG52YXJ5aW5nIHZlYzQgY29sb3I7XFxuYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcXG52YXJ5aW5nIHZlYzIgdXYwO1xcbnZlYzQgdmVydCAoKSB7XFxuICB2ZWM0IHBvcyA9IHZlYzQoYV9wb3NpdGlvbiwgMSk7XFxuICAjaWYgVVNFX0xPQ0FMXFxuICAgIHBvcyA9IGNjX21hdFZpZXdQcm9qICogY2NfbWF0V29ybGQgKiBwb3M7XFxuICAjZWxzZVxcbiAgICBwb3MgPSBjY19tYXRWaWV3UHJvaiAqIHBvcztcXG4gICNlbmRpZlxcbiAgdXYwID0gYV90ZXhDb29yZDtcXG4gIGNvbG9yID0gYV9jb2xvcjtcXG4gIHJldHVybiBwb3M7XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSB2ZXJ0KCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxudmFyeWluZyB2ZWM0IGNvbG9yO1xcbiNpZiBVU0VfVEVYVFVSRVxcbiAgdmFyeWluZyB2ZWMyIHV2MDtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIG1haW5UZXh0dXJlO1xcbiNlbmRpZlxcbnZlYzQgZnJhZyAoKSB7XFxuICB2ZWM0IG8gPSB2ZWM0KDEsIDEsIDEsIDEpO1xcbiAgI2lmIFVTRV9URVhUVVJFXFxuICAgIG8gKj0gdGV4dHVyZTJEKG1haW5UZXh0dXJlLCB1djApO1xcbiAgICAjaWYgSVNfR1JBWVxcbiAgICAgIGZsb2F0IGdyYXkgID0gMC4yMTI2ICogby5yICsgMC43MTUyICogby5nICsgMC4wNzIyICogby5iO1xcbiAgICAgIG8uciA9IG8uZyA9IG8uYiA9IGdyYXk7XFxuICAgICNlbmRpZlxcbiAgI2VuZGlmXFxuICBvICo9IGNvbG9yO1xcbiAgcmV0dXJuIG87XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJidWlsdGluc1wiOiB7XHJcbiAgICAgICAgICBcImdsb2JhbHNcIjogeyBcImJsb2Nrc1wiOiBbeyBcIm5hbWVcIjogXCJDQ0dsb2JhbFwiLCBcImRlZmluZXNcIjogW10gfV0sIFwic2FtcGxlcnNcIjogW10gfSxcclxuICAgICAgICAgIFwibG9jYWxzXCI6IHsgXCJibG9ja3NcIjogW3sgXCJuYW1lXCI6IFwiQ0NMb2NhbFwiLCBcImRlZmluZXNcIjogW1wiVVNFX0xPQ0FMXCJdIH1dLCBcInNhbXBsZXJzXCI6IFtdIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGVmaW5lc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9MT0NBTFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiVVNFX1RFWFRVUkVcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIklTX0dSQVlcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiYmxvY2tzXCI6IFtdLFxyXG4gICAgICAgIFwic2FtcGxlcnNcIjogW1xyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJtYWluVGV4dHVyZVwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIlVTRV9URVhUVVJFXCJdLCBcImJpbmRpbmdcIjogMzEgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9wb3NpdGlvblwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiAwIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfY29sb3JcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJmb3JtYXRcIjogNDMsIFwibG9jYXRpb25cIjogMSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3RleENvb3JkXCIsIFwidHlwZVwiOiAxNCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwiZm9ybWF0XCI6IDIxLCBcImxvY2F0aW9uXCI6IDIgfVxyXG4gICAgICAgIF1cclxuICAgICAgfVxyXG4gICAgXVxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJuYW1lXCI6IFwiYnVpbHRpbi1zdGFuZGFyZFwiLFxyXG4gICAgXCJfdXVpZFwiOiBcIjFiYWYwZmM5LWJlZmEtNDU5Yy04YmRkLWFmMWE0NTBhMDMxOVwiLFxyXG4gICAgXCJ0ZWNobmlxdWVzXCI6IFtcclxuICAgICAgeyBcIm5hbWVcIjogXCJvcGFxdWVcIiwgXCJwYXNzZXNcIjogW3sgXCJwcm9ncmFtXCI6IFwiYnVpbHRpbi1zdGFuZGFyZHxzdGFuZGFyZC12czp2ZXJ0fHN0YW5kYXJkLWZzOmZyYWdcIiwgXCJwcm9wZXJ0aWVzXCI6IHsgXCJ0aWxpbmdPZmZzZXRcIjogeyBcInZhbHVlXCI6IFsxLCAxLCAwLCAwXSwgXCJ0eXBlXCI6IDE2IH0sIFwibWFpbkNvbG9yXCI6IHsgXCJ2YWx1ZVwiOiBbMSwgMSwgMSwgMV0sIFwidHlwZVwiOiAxNiwgXCJoYW5kbGVJbmZvXCI6IFtcImFsYmVkb1wiLCAwLCAxNl0gfSwgXCJhbGJlZG9TY2FsZVwiOiB7IFwidmFsdWVcIjogWzEsIDEsIDFdLCBcInR5cGVcIjogMTUsIFwiaGFuZGxlSW5mb1wiOiBbXCJhbGJlZG9TY2FsZUFuZEN1dG9mZlwiLCAwLCAxNV0gfSwgXCJhbHBoYVRocmVzaG9sZFwiOiB7IFwidmFsdWVcIjogWzAuNV0sIFwidHlwZVwiOiAxMywgXCJoYW5kbGVJbmZvXCI6IFtcImFsYmVkb1NjYWxlQW5kQ3V0b2ZmXCIsIDMsIDEzXSB9LCBcIm9jY2x1c2lvblwiOiB7IFwidmFsdWVcIjogWzFdLCBcInR5cGVcIjogMTMsIFwiaGFuZGxlSW5mb1wiOiBbXCJwYnJQYXJhbXNcIiwgMCwgMTNdIH0sIFwicm91Z2huZXNzXCI6IHsgXCJ2YWx1ZVwiOiBbMC44XSwgXCJ0eXBlXCI6IDEzLCBcImhhbmRsZUluZm9cIjogW1wicGJyUGFyYW1zXCIsIDEsIDEzXSB9LCBcIm1ldGFsbGljXCI6IHsgXCJ2YWx1ZVwiOiBbMC42XSwgXCJ0eXBlXCI6IDEzLCBcImhhbmRsZUluZm9cIjogW1wicGJyUGFyYW1zXCIsIDIsIDEzXSB9LCBcIm5vcm1hbFN0cmVudGhcIjogeyBcInZhbHVlXCI6IFsxXSwgXCJ0eXBlXCI6IDEzLCBcImhhbmRsZUluZm9cIjogW1wicGJyUGFyYW1zXCIsIDMsIDEzXSB9LCBcImVtaXNzaXZlXCI6IHsgXCJ2YWx1ZVwiOiBbMCwgMCwgMCwgMV0sIFwidHlwZVwiOiAxNiB9LCBcImVtaXNzaXZlU2NhbGVcIjogeyBcInZhbHVlXCI6IFsxLCAxLCAxXSwgXCJ0eXBlXCI6IDE1LCBcImhhbmRsZUluZm9cIjogW1wiZW1pc3NpdmVTY2FsZVBhcmFtXCIsIDAsIDE1XSB9LCBcIm1haW5UZXh0dXJlXCI6IHsgXCJ2YWx1ZVwiOiBcImdyZXlcIiwgXCJ0eXBlXCI6IDI4LCBcImhhbmRsZUluZm9cIjogW1wiYWxiZWRvTWFwXCIsIDAsIDI4XSB9LCBcIm5vcm1hbE1hcFwiOiB7IFwidmFsdWVcIjogXCJub3JtYWxcIiwgXCJ0eXBlXCI6IDI4IH0sIFwicGJyTWFwXCI6IHsgXCJ2YWx1ZVwiOiBcImdyZXlcIiwgXCJ0eXBlXCI6IDI4IH0sIFwibWV0YWxsaWNSb3VnaG5lc3NNYXBcIjogeyBcInZhbHVlXCI6IFwiZ3JleVwiLCBcInR5cGVcIjogMjggfSwgXCJvY2NsdXNpb25NYXBcIjogeyBcInZhbHVlXCI6IFwid2hpdGVcIiwgXCJ0eXBlXCI6IDI4IH0sIFwiZW1pc3NpdmVNYXBcIjogeyBcInZhbHVlXCI6IFwiZ3JleVwiLCBcInR5cGVcIjogMjggfSwgXCJhbGJlZG9cIjogeyBcInR5cGVcIjogMTYsIFwidmFsdWVcIjogWzEsIDEsIDEsIDFdIH0sIFwiYWxiZWRvU2NhbGVBbmRDdXRvZmZcIjogeyBcInR5cGVcIjogMTYsIFwidmFsdWVcIjogWzEsIDEsIDEsIDAuNV0gfSwgXCJwYnJQYXJhbXNcIjogeyBcInR5cGVcIjogMTYsIFwidmFsdWVcIjogWzEsIDAuOCwgMC42LCAxXSB9LCBcImVtaXNzaXZlU2NhbGVQYXJhbVwiOiB7IFwidHlwZVwiOiAxNiwgXCJ2YWx1ZVwiOiBbMSwgMSwgMSwgMF0gfSwgXCJhbGJlZG9NYXBcIjogeyBcInR5cGVcIjogMjgsIFwidmFsdWVcIjogXCJncmV5XCIgfSB9IH1dIH1cclxuICAgIF0sXHJcbiAgICBcInNoYWRlcnNcIjogW1xyXG4gICAgICB7XHJcbiAgICAgICAgXCJuYW1lXCI6IFwiYnVpbHRpbi1zdGFuZGFyZHxzdGFuZGFyZC12czp2ZXJ0fHN0YW5kYXJkLWZzOmZyYWdcIixcclxuICAgICAgICBcImhhc2hcIjogMzI4NDkyMTk2MSxcclxuICAgICAgICBcImdsc2wzXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbnN0cnVjdCBTdGFuZGFyZFZlcnRJbnB1dCB7XFxuICBoaWdocCB2ZWM0IHBvc2l0aW9uO1xcbiAgdmVjMyBub3JtYWw7XFxuICB2ZWM0IHRhbmdlbnQ7XFxufTtcXG5pbiB2ZWMzIGFfcG9zaXRpb247XFxuaW4gdmVjMyBhX25vcm1hbDtcXG5pbiB2ZWM0IGFfdGFuZ2VudDtcXG4jaWYgQ0NfVVNFX01PUlBIXFxuICAgIGluIGZsb2F0IGFfdmVydGV4SWQ7XFxuICAgIGludCBnZXRWZXJ0ZXhJZCgpIHtcXG4gICAgICAgIHJldHVybiBpbnQoYV92ZXJ0ZXhJZCk7XFxuICAgIH1cXG51bmlmb3JtIENDTW9ycGgge1xcbiAgICB2ZWM0IGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbMTVdO1xcbiAgICB2ZWM0IGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvO1xcbn07XFxuICAgIHZlYzQgZmV0Y2hGbGF0UGl4ZWwoc2FtcGxlcjJEIHRleCwgaW50IHBpeGVsSW5kZXgpIHtcXG4gICAgICAgIGZsb2F0IHBpeGVsSW5kZXhGID0gZmxvYXQocGl4ZWxJbmRleCk7XFxuICAgICAgICB2ZWMyIHRleHR1cmVSZXNvbHV0aW9uID0gdmVjMihmbG9hdChjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54KSwgZmxvYXQoY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueSkpO1xcbiAgICAgICAgZmxvYXQgcGl4ZWxYID0gbW9kKHBpeGVsSW5kZXhGLCB0ZXh0dXJlUmVzb2x1dGlvbi54KTtcXG4gICAgICAgIGZsb2F0IHBpeGVsWSA9IGZsb29yKHBpeGVsSW5kZXhGIC8gdGV4dHVyZVJlc29sdXRpb24ueCk7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIocGl4ZWxYLCBwaXhlbFkpICsgLjUpIC8gdGV4dHVyZVJlc29sdXRpb247XFxuICAgICAgICByZXR1cm4gdGV4dHVyZSh0ZXgsIHV2KTtcXG4gICAgfVxcbmZsb2F0IGdldERpc3BsYWNlbWVudFdlaWdodChpbnQgaW5kZXgpIHtcXG4gICAgZmxvYXQgbSA9IG1vZChmbG9hdChpbmRleCksIDQuMCk7XFxuICAgIGlmIChtIDwgMS4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLng7XFxuICAgIH0gZWxzZSBpZiAobSA8IDIuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS55O1xcbiAgICB9IGVsc2UgaWYgKG0gPCAzLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0uejtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0udztcXG4gICAgfVxcbn1cXG52ZWMzIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShzYW1wbGVyMkQgdGV4LCBpbnQgdmVydGV4SW5kZXgpIHtcXG4jaWYgQ0NfTU9SUEhfUFJFQ09NUFVURURcXG4gICAgcmV0dXJuIGZldGNoRmxhdFBpeGVsKHRleCwgdmVydGV4SW5kZXgpLnJnYjtcXG4jZWxzZVxcbiAgICB2ZWMzIHJlc3VsdCA9IHZlYzMoMCwgMCwgMCk7XFxuICAgIGZvciAoaW50IGlUYXJnZXQgPSAwOyBpVGFyZ2V0IDwgQ0NfTU9SUEhfVEFSR0VUX0NPVU5UOyArK2lUYXJnZXQpIHtcXG4gICAgICAgIGludCBkYXRhUGl4ZWxTdGFydCA9IGludChmZXRjaEZsYXRQaXhlbCh0ZXgsIGlUYXJnZXQpLnIpO1xcbiAgICAgICAgcmVzdWx0ICs9IChmZXRjaEZsYXRQaXhlbCh0ZXgsIGRhdGFQaXhlbFN0YXJ0ICsgdmVydGV4SW5kZXgpLnJnYiAqIGdldERpc3BsYWNlbWVudFdlaWdodChpVGFyZ2V0KSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3VsdDtcXG4jZW5kaWZcXG59XFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfUG9zaXRpb25EaXNwbGFjZW1lbnRzO1xcbiAgICB2ZWMzIGdldFBvc2l0aW9uRGlzcGxhY2VtZW50KGludCB2ZXJ0ZXhJZCkge1xcbiAgICAgICAgcmV0dXJuIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShjY19Qb3NpdGlvbkRpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX05PUk1BTFxcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBjY19Ob3JtYWxEaXNwbGFjZW1lbnRzO1xcbiAgICB2ZWMzIGdldE5vcm1hbERpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfTm9ybWFsRGlzcGxhY2VtZW50cywgdmVydGV4SWQpO1xcbiAgICB9XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfVEFOR0VOVFxcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBjY19UYW5nZW50RGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXRUYW5nZW50RGlzcGxhY2VtZW50KGludCB2ZXJ0ZXhJZCkge1xcbiAgICAgICAgcmV0dXJuIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShjY19UYW5nZW50RGlzcGxhY2VtZW50cywgdmVydGV4SWQpO1xcbiAgICB9XFxuI2VuZGlmXFxudm9pZCBhcHBseU1vcnBoIChpbm91dCBTdGFuZGFyZFZlcnRJbnB1dCBhdHRyKSB7XFxuICAgIGludCB2ZXJ0ZXhJZCA9IGdldFZlcnRleElkKCk7XFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cXG4gICAgYXR0ci5wb3NpdGlvbi54eXogPSBhdHRyLnBvc2l0aW9uLnh5eiArIGdldFBvc2l0aW9uRGlzcGxhY2VtZW50KHZlcnRleElkKTtcXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19OT1JNQUxcXG4gICAgYXR0ci5ub3JtYWwueHl6ID0gYXR0ci5ub3JtYWwueHl6ICsgZ2V0Tm9ybWFsRGlzcGxhY2VtZW50KHZlcnRleElkKTtcXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19UQU5HRU5UXFxuICAgIGF0dHIudGFuZ2VudC54eXogPSBhdHRyLnRhbmdlbnQueHl6ICsgZ2V0VGFuZ2VudERpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxufVxcbnZvaWQgYXBwbHlNb3JwaCAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIHBvc2l0aW9uLnh5eiA9IHBvc2l0aW9uLnh5eiArIGdldFBvc2l0aW9uRGlzcGxhY2VtZW50KGdldFZlcnRleElkKCkpO1xcbiNlbmRpZlxcbn1cXG4jZW5kaWZcXG4jaWYgQ0NfVVNFX1NLSU5OSU5HXFxuaW4gdmVjNCBhX3dlaWdodHM7XFxuaW4gdmVjNCBhX2pvaW50cztcXG4jaWYgQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlxcbiAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgIGluIGhpZ2hwIHZlYzQgYV9qb2ludEFuaW1JbmZvO1xcbiAgI2VuZGlmXFxuICB1bmlmb3JtIENDU2tpbm5pbmdUZXh0dXJlIHtcXG4gICAgaGlnaHAgdmVjNCBjY19qb2ludFRleHR1cmVJbmZvO1xcbiAgfTtcXG4gIHVuaWZvcm0gQ0NTa2lubmluZ0FuaW1hdGlvbiB7XFxuICAgIGhpZ2hwIHZlYzQgY2Nfam9pbnRBbmltSW5mbztcXG4gIH07XFxuICB1bmlmb3JtIHNhbXBsZXIyRCBjY19qb2ludFRleHR1cmU7XFxuICAgICNpZiAhQ0NfU1VQUE9SVF9GTE9BVF9URVhUVVJFXFxuICAgIGhpZ2hwIGZsb2F0IGRlY29kZTMyIChoaWdocCB2ZWM0IHJnYmEpIHtcXG4gICAgICByZ2JhID0gcmdiYSAqIDI1NS4wO1xcbiAgICAgIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyOC4wLCByZ2JhWzNdKSAqIDIuMDtcXG4gICAgICBoaWdocCBmbG9hdCBFeHBvbmVudCA9IDIuMCAqIG1vZChyZ2JhWzNdLCAxMjguMCkgKyBzdGVwKDEyOC4wLCByZ2JhWzJdKSAtIDEyNy4wO1xcbiAgICAgIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMl0sIDEyOC4wKSAqIDY1NTM2LjAgKyByZ2JhWzFdICogMjU2LjAgKyByZ2JhWzBdICsgODM4ODYwOC4wO1xcbiAgICAgIHJldHVybiBTaWduICogZXhwMihFeHBvbmVudCAtIDIzLjApICogTWFudGlzc2E7XFxuICAgIH1cXG4gICNlbmRpZlxcbiNlbHNlXFxuICB1bmlmb3JtIENDU2tpbm5pbmcge1xcbiAgICBoaWdocCB2ZWM0IGNjX2pvaW50c1szMCAqIDNdO1xcbiAgfTtcXG4jZW5kaWZcXG4jaWYgQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlxcbiAgI2lmIENDX1NVUFBPUlRfRkxPQVRfVEVYVFVSRVxcbiAgICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAzLjAgKiAoYV9qb2ludEFuaW1JbmZvLnggKiBhX2pvaW50QW5pbUluZm8ueSArIGkpICsgYV9qb2ludEFuaW1JbmZvLno7XFxuICAgICNlbHNlXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDMuMCAqIChjY19qb2ludEFuaW1JbmZvLnggKiBjY19qb2ludFRleHR1cmVJbmZvLnkgKyBpKSArIGNjX2pvaW50VGV4dHVyZUluZm8uejtcXG4gICAgI2VuZGlmXFxuICAgIGhpZ2hwIGZsb2F0IGludlNpemUgPSBjY19qb2ludFRleHR1cmVJbmZvLnc7XFxuICAgIGhpZ2hwIGZsb2F0IHkgPSBmbG9vcihqICogaW52U2l6ZSk7XFxuICAgIGhpZ2hwIGZsb2F0IHggPSBqIC0geSAqIGNjX2pvaW50VGV4dHVyZUluZm8ueDtcXG4gICAgeSA9ICh5ICsgMC41KSAqIGludlNpemU7XFxuICAgICAgdmVjNCB2MSA9IHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMC41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICB2ZWM0IHYyID0gdGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHZlYzQgdjMgPSB0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDIuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gICAgfVxcbiAgI2Vsc2VcXG4gICAgbWF0NCBnZXRKb2ludE1hdHJpeCAoZmxvYXQgaSkge1xcbiAgICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMTIuMCAqIChhX2pvaW50QW5pbUluZm8ueCAqIGFfam9pbnRBbmltSW5mby55ICsgaSkgKyBhX2pvaW50QW5pbUluZm8uejtcXG4gICAgI2Vsc2VcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMTIuMCAqIChjY19qb2ludEFuaW1JbmZvLnggKiBjY19qb2ludFRleHR1cmVJbmZvLnkgKyBpKSArIGNjX2pvaW50VGV4dHVyZUluZm8uejtcXG4gICAgI2VuZGlmXFxuICAgIGhpZ2hwIGZsb2F0IGludlNpemUgPSBjY19qb2ludFRleHR1cmVJbmZvLnc7XFxuICAgIGhpZ2hwIGZsb2F0IHkgPSBmbG9vcihqICogaW52U2l6ZSk7XFxuICAgIGhpZ2hwIGZsb2F0IHggPSBqIC0geSAqIGNjX2pvaW50VGV4dHVyZUluZm8ueDtcXG4gICAgeSA9ICh5ICsgMC41KSAqIGludlNpemU7XFxuICAgICAgdmVjNCB2MSA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDAuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMi41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDMuNSkgKiBpbnZTaXplLCB5KSkpXFxuICAgICAgKTtcXG4gICAgICB2ZWM0IHYyID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDUuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA2LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNy41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHZlYzQgdjMgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA4LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgOS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEwLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMTEuNSkgKiBpbnZTaXplLCB5KSkpXFxuICAgICAgKTtcXG4gICAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgICB9XFxuICAjZW5kaWZcXG4jZWxzZVxcbiAgbWF0NCBnZXRKb2ludE1hdHJpeCAoZmxvYXQgaSkge1xcbiAgICBpbnQgaWR4ID0gaW50KGkpO1xcbiAgICB2ZWM0IHYxID0gY2Nfam9pbnRzW2lkeCAqIDNdO1xcbiAgICB2ZWM0IHYyID0gY2Nfam9pbnRzW2lkeCAqIDMgKyAxXTtcXG4gICAgdmVjNCB2MyA9IGNjX2pvaW50c1tpZHggKiAzICsgMl07XFxuICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICB9XFxuI2VuZGlmXFxubWF0NCBza2luTWF0cml4ICgpIHtcXG4gIHJldHVybiBnZXRKb2ludE1hdHJpeChhX2pvaW50cy54KSAqIGFfd2VpZ2h0cy54XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueSkgKiBhX3dlaWdodHMueVxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLnopICogYV93ZWlnaHRzLnpcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy53KSAqIGFfd2VpZ2h0cy53O1xcbn1cXG52b2lkIENDU2tpbiAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xcbiAgbWF0NCBtID0gc2tpbk1hdHJpeCgpO1xcbiAgcG9zaXRpb24gPSBtICogcG9zaXRpb247XFxufVxcbnZvaWQgQ0NTa2luIChpbm91dCBTdGFuZGFyZFZlcnRJbnB1dCBhdHRyKSB7XFxuICBtYXQ0IG0gPSBza2luTWF0cml4KCk7XFxuICBhdHRyLnBvc2l0aW9uID0gbSAqIGF0dHIucG9zaXRpb247XFxuICBhdHRyLm5vcm1hbCA9IChtICogdmVjNChhdHRyLm5vcm1hbCwgMC4wKSkueHl6O1xcbiAgYXR0ci50YW5nZW50Lnh5eiA9IChtICogdmVjNChhdHRyLnRhbmdlbnQueHl6LCAwLjApKS54eXo7XFxufVxcbiNlbmRpZlxcbnVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG59O1xcbiNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgaW4gdmVjNCBhX21hdFdvcmxkMDtcXG4gIGluIHZlYzQgYV9tYXRXb3JsZDE7XFxuICBpbiB2ZWM0IGFfbWF0V29ybGQyO1xcbiNlbGlmIFVTRV9CQVRDSElOR1xcbiAgaW4gZmxvYXQgYV9keW5fYmF0Y2hfaWQ7XFxuICB1bmlmb3JtIENDTG9jYWxCYXRjaGVkIHtcXG4gICAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZHNbMTBdO1xcbiAgfTtcXG4jZWxzZVxcbnVuaWZvcm0gQ0NMb2NhbCB7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkO1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZElUO1xcbiAgaGlnaHAgdmVjNCBjY19saWdodGluZ01hcFVWUGFyYW07XFxufTtcXG4jZW5kaWZcXG51bmlmb3JtIENvbnN0YW50cyB7XFxuICB2ZWM0IHRpbGluZ09mZnNldDtcXG4gIHZlYzQgYWxiZWRvO1xcbiAgdmVjNCBhbGJlZG9TY2FsZUFuZEN1dG9mZjtcXG4gIHZlYzQgcGJyUGFyYW1zO1xcbiAgdmVjNCBlbWlzc2l2ZTtcXG4gIHZlYzQgZW1pc3NpdmVTY2FsZVBhcmFtO1xcbn07XFxuI2lmIFVTRV9WRVJURVhfQ09MT1JcXG4gIGluIHZlYzMgYV9jb2xvcjtcXG4gIG91dCB2ZWMzIHZfY29sb3I7XFxuI2VuZGlmXFxub3V0IHZlYzMgdl9wb3NpdGlvbjtcXG5vdXQgdmVjMyB2X25vcm1hbDtcXG4jaWYgVVNFX05PUk1BTF9NQVBcXG4gIG91dCB2ZWMzIHZfdGFuZ2VudDtcXG4gIG91dCB2ZWMzIHZfYml0YW5nZW50O1xcbiNlbmRpZlxcbmluIHZlYzIgYV90ZXhDb29yZDtcXG5vdXQgdmVjMiB2X3V2O1xcbmluIHZlYzIgYV90ZXhDb29yZDE7XFxub3V0IHZlYzIgdl91djE7XFxuI2lmIFVTRV9MSUdIVE1BUCAmJiAhVVNFX0JBVENISU5HICYmICFVU0VfSU5TVEFOQ0lOR1xcbiAgb3V0IHZlYzIgdl9sdXY7XFxuI2VuZGlmXFxudmVjNCB2ZXJ0ICgpIHtcXG4gIFN0YW5kYXJkVmVydElucHV0IEluO1xcbiAgSW4ucG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XFxuICBJbi5ub3JtYWwgPSBhX25vcm1hbDtcXG4gIEluLnRhbmdlbnQgPSBhX3RhbmdlbnQ7XFxuICAjaWYgQ0NfVVNFX01PUlBIXFxuICAgIGFwcGx5TW9ycGgoSW4pO1xcbiAgI2VuZGlmXFxuICAjaWYgQ0NfVVNFX1NLSU5OSU5HXFxuICAgIENDU2tpbihJbik7XFxuICAjZW5kaWZcXG4gIG1hdDQgbWF0V29ybGQsIG1hdFdvcmxkSVQ7XFxuICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgbWF0V29ybGQgPSBtYXQ0KFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDAueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDEueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDIueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDAudywgYV9tYXRXb3JsZDEudywgYV9tYXRXb3JsZDIudywgMS4wKVxcbiAgICApO1xcbiAgICBtYXRXb3JsZElUID0gbWF0V29ybGQ7XFxuICAjZWxpZiBVU0VfQkFUQ0hJTkdcXG4gICAgbWF0V29ybGQgPSBjY19tYXRXb3JsZHNbaW50KGFfZHluX2JhdGNoX2lkKV07XFxuICAgIG1hdFdvcmxkSVQgPSBtYXRXb3JsZDtcXG4gICNlbHNlXFxuICAgIG1hdFdvcmxkID0gY2NfbWF0V29ybGQ7XFxuICAgIG1hdFdvcmxkSVQgPSBjY19tYXRXb3JsZElUO1xcbiAgI2VuZGlmXFxuICB2ZWM0IHBvcyA9IG1hdFdvcmxkICogSW4ucG9zaXRpb247XFxuICB2X3Bvc2l0aW9uID0gcG9zLnh5ejtcXG4gIHZfbm9ybWFsID0gbm9ybWFsaXplKChtYXRXb3JsZElUICogdmVjNChJbi5ub3JtYWwsIDAuMCkpLnh5eik7XFxuICAjaWYgVVNFX05PUk1BTF9NQVBcXG4gICAgdl90YW5nZW50ID0gbm9ybWFsaXplKChtYXRXb3JsZCAqIHZlYzQoSW4udGFuZ2VudC54eXosIDAuMCkpLnh5eik7XFxuICAgIHZfYml0YW5nZW50ID0gY3Jvc3Modl9ub3JtYWwsIHZfdGFuZ2VudCkgKiBJbi50YW5nZW50Lnc7XFxuICAjZW5kaWZcXG4gIHZfdXYgPSBhX3RleENvb3JkICogdGlsaW5nT2Zmc2V0Lnh5ICsgdGlsaW5nT2Zmc2V0Lnp3O1xcbiAgI2lmIEhBU19TRUNPTkRfVVZcXG4gICAgdl91djEgPSBhX3RleENvb3JkMSAqIHRpbGluZ09mZnNldC54eSArIHRpbGluZ09mZnNldC56dztcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9WRVJURVhfQ09MT1JcXG4gICAgdl9jb2xvciA9IGFfY29sb3I7XFxuICAjZW5kaWZcXG4gICNpZiBVU0VfTElHSFRNQVAgJiYgSEFTX1NFQ09ORF9VViAmJiAhVVNFX0JBVENISU5HICYmICFVU0VfSU5TVEFOQ0lOR1xcbiAgICB2X2x1diA9IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbS54eSArIGFfdGV4Q29vcmQxICogY2NfbGlnaHRpbmdNYXBVVlBhcmFtLnp3O1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY2NfbWF0UHJvaiAqIChjY19tYXRWaWV3ICogbWF0V29ybGQpICogSW4ucG9zaXRpb247XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSB2ZXJ0KCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxudW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbn07XFxuI2lmIENDX1VTRV9JQkxcXG51bmlmb3JtIHNhbXBsZXJDdWJlIGNjX2Vudmlyb25tZW50O1xcbnZlYzMgdW5wYWNrUkdCRSAodmVjNCByZ2JlKSB7XFxuICByZXR1cm4gcmdiZS5yZ2IgKiBwb3coMi4wLCByZ2JlLmEgKiAyNTUuMCAtIDEyOC4wKTtcXG59XFxudmVjNCBmcmFnVGV4dHVyZUxvZCAoc2FtcGxlcjJEIHRleCwgdmVjMiBjb29yZCwgZmxvYXQgbG9kKSB7XFxuICAgIHJldHVybiB0ZXh0dXJlTG9kKHRleCwgY29vcmQsIGxvZCk7XFxufVxcbnZlYzQgZnJhZ1RleHR1cmVMb2QgKHNhbXBsZXJDdWJlIHRleCwgdmVjMyBjb29yZCwgZmxvYXQgbG9kKSB7XFxuICAgIHJldHVybiB0ZXh0dXJlTG9kKHRleCwgY29vcmQsIGxvZCk7XFxufVxcbiNlbmRpZlxcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudW5pZm9ybSBDQ0ZvcndhcmRMaWdodCB7XFxuICBoaWdocCB2ZWM0IGNjX3NwaGVyZUxpdFBvc1syXTtcXG4gIHZlYzQgY2Nfc3BoZXJlTGl0U2l6ZVJhbmdlWzJdO1xcbiAgdmVjNCBjY19zcGhlcmVMaXRDb2xvclsyXTtcXG4gIGhpZ2hwIHZlYzQgY2Nfc3BvdExpdFBvc1syXTtcXG4gIHZlYzQgY2Nfc3BvdExpdFNpemVSYW5nZUFuZ2xlWzJdO1xcbiAgdmVjNCBjY19zcG90TGl0RGlyWzJdO1xcbiAgdmVjNCBjY19zcG90TGl0Q29sb3JbMl07XFxufTtcXG5mbG9hdCBTbW9vdGhEaXN0QXR0IChmbG9hdCBkaXN0U3FyLCBmbG9hdCBpbnZTcXJBdHRSYWRpdXMpIHtcXG4gIGZsb2F0IGZhY3RvciA9IGRpc3RTcXIgKiBpbnZTcXJBdHRSYWRpdXM7XFxuICBmbG9hdCBzbW9vdGhGYWN0b3IgPSBjbGFtcCgxLjAgLSBmYWN0b3IgKiBmYWN0b3IsIDAuMCwgMS4wKTtcXG4gIHJldHVybiBzbW9vdGhGYWN0b3IgKiBzbW9vdGhGYWN0b3I7XFxufVxcbmZsb2F0IEdldERpc3RBdHQgKGZsb2F0IGRpc3RTcXIsIGZsb2F0IGludlNxckF0dFJhZGl1cykge1xcbiAgZmxvYXQgYXR0ZW51YXRpb24gPSAxLjAgLyBtYXgoZGlzdFNxciwgMC4wMSowLjAxKTtcXG4gIGF0dGVudWF0aW9uICo9IFNtb290aERpc3RBdHQoZGlzdFNxciAsIGludlNxckF0dFJhZGl1cyk7XFxuICByZXR1cm4gYXR0ZW51YXRpb247XFxufVxcbmZsb2F0IEdldEFuZ2xlQXR0ICh2ZWMzIEwsIHZlYzMgbGl0RGlyLCBmbG9hdCBsaXRBbmdsZVNjYWxlLCBmbG9hdCBsaXRBbmdsZU9mZnNldCkge1xcbiAgZmxvYXQgY2QgPSBkb3QobGl0RGlyLCBMKTtcXG4gIGZsb2F0IGF0dGVudWF0aW9uID0gY2xhbXAoY2QgKiBsaXRBbmdsZVNjYWxlICsgbGl0QW5nbGVPZmZzZXQsIDAuMCwgMS4wKTtcXG4gIHJldHVybiAoYXR0ZW51YXRpb24gKiBhdHRlbnVhdGlvbik7XFxufVxcbmZsb2F0IEdHWE1vYmlsZSAoZmxvYXQgcm91Z2huZXNzLCBmbG9hdCBOb0gsIHZlYzMgSCwgdmVjMyBOKSB7XFxuICB2ZWMzIE54SCA9IGNyb3NzKE4sIEgpO1xcbiAgZmxvYXQgT25lTWludXNOb0hTcXIgPSBkb3QoTnhILCBOeEgpO1xcbiAgZmxvYXQgYSA9IHJvdWdobmVzcyAqIHJvdWdobmVzcztcXG4gIGZsb2F0IG4gPSBOb0ggKiBhO1xcbiAgZmxvYXQgcCA9IGEgLyAoT25lTWludXNOb0hTcXIgKyBuICogbik7XFxuICByZXR1cm4gcCAqIHA7XFxufVxcbmZsb2F0IENhbGNTcGVjdWxhciAoZmxvYXQgcm91Z2huZXNzLCBmbG9hdCBOb0gsIHZlYzMgSCwgdmVjMyBOKSB7XFxuICByZXR1cm4gKHJvdWdobmVzcyowLjI1ICsgMC4yNSkgKiBHR1hNb2JpbGUocm91Z2huZXNzLCBOb0gsIEgsIE4pO1xcbn1cXG52ZWMzIEJSREZBcHByb3ggKHZlYzMgc3BlY3VsYXIsIGZsb2F0IHJvdWdobmVzcywgZmxvYXQgTm9WKSB7XFxuICBjb25zdCB2ZWM0IGMwID0gdmVjNCgtMS4wLCAtMC4wMjc1LCAtMC41NzIsIDAuMDIyKTtcXG4gIGNvbnN0IHZlYzQgYzEgPSB2ZWM0KDEuMCwgMC4wNDI1LCAxLjA0LCAtMC4wNCk7XFxuICB2ZWM0IHIgPSByb3VnaG5lc3MgKiBjMCArIGMxO1xcbiAgZmxvYXQgYTAwNCA9IG1pbiggci54ICogci54LCBleHAyKCAtOS4yOCAqIE5vViApICkgKiByLnggKyByLnk7XFxuICB2ZWMyIEFCID0gdmVjMiggLTEuMDQsIDEuMDQgKSAqIGEwMDQgKyByLnp3O1xcbiAgQUIueSAqPSBjbGFtcCg1MC4wICogc3BlY3VsYXIuZywgMC4wLCAxLjApO1xcbiAgcmV0dXJuIHNwZWN1bGFyICogQUIueCArIEFCLnk7XFxufVxcbnZlYzMgQ2FsY0R5bmFtaWNMaWdodGluZyAodmVjMyB3b3JsZFBvcywgdmVjMyBOLCB2ZWMzIFYsIHZlYzMgZGlmZnVzZSwgdmVjMyBzcGVjdWxhciwgZmxvYXQgcm91Z2huZXNzKSB7XFxuICB2ZWMzIGxpZ2h0aW5nID0gdmVjMygwLjApO1xcbiAgdmVjMyBkaWZmdXNlQ29udHJpYiA9IGRpZmZ1c2UgLyAzLjE0MTU5MjY1MzU5O1xcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCAyOyBpKyspIHtcXG4gICAgdmVjMyBQTFUgPSBjY19zcGhlcmVMaXRQb3NbaV0ueHl6IC0gd29ybGRQb3M7XFxuICAgIHZlYzMgUEwgPSBub3JtYWxpemUoUExVKTtcXG4gICAgdmVjMyBQSCA9IG5vcm1hbGl6ZShQTCArIFYpO1xcbiAgICBmbG9hdCBQTkwgPSBtYXgoZG90KE4sIFBMKSwgMC4wMDEpO1xcbiAgICBmbG9hdCBQTkggPSBtYXgoZG90KE4sIFBIKSwgMC4wKTtcXG4gICAgZmxvYXQgZGlzdFNxciA9IGRvdChQTFUsIFBMVSk7XFxuICAgIGZsb2F0IGxpdFJhZGl1cyA9IGNjX3NwaGVyZUxpdFNpemVSYW5nZVtpXS54O1xcbiAgICBmbG9hdCBsaXRSYWRpdXNTcXIgPSBsaXRSYWRpdXMgKiBsaXRSYWRpdXM7XFxuICAgIGZsb2F0IGlsbHVtID0gMy4xNDE1OTI2NTM1OSAqIChsaXRSYWRpdXNTcXIgLyBtYXgobGl0UmFkaXVzU3FyICwgZGlzdFNxcikpO1xcbiAgICBmbG9hdCBhdHRSYWRpdXNTcXJJbnYgPSAxLjAgLyBtYXgoY2Nfc3BoZXJlTGl0U2l6ZVJhbmdlW2ldLnksIDAuMDEpO1xcbiAgICBhdHRSYWRpdXNTcXJJbnYgKj0gYXR0UmFkaXVzU3FySW52O1xcbiAgICBmbG9hdCBhdHQgPSBHZXREaXN0QXR0KGRpc3RTcXIsIGF0dFJhZGl1c1Nxckludik7XFxuICAgIHZlYzMgbHNwZWMgPSBzcGVjdWxhciAqIENhbGNTcGVjdWxhcihyb3VnaG5lc3MsIFBOSCwgUEgsIE4pO1xcbiAgICBsaWdodGluZyArPSBQTkwgKiBjY19zcGhlcmVMaXRDb2xvcltpXS5yZ2IgKiBjY19zcGhlcmVMaXRDb2xvcltpXS53ICogaWxsdW0gKiBhdHQgKiAoZGlmZnVzZUNvbnRyaWIgKyBsc3BlYyk7XFxuICB9XFxuICBmb3IgKGludCBpID0gMDsgaSA8IDI7IGkrKykge1xcbiAgICB2ZWMzIFNMVSA9IGNjX3Nwb3RMaXRQb3NbaV0ueHl6IC0gd29ybGRQb3M7XFxuICAgIHZlYzMgU0wgPSBub3JtYWxpemUoU0xVKTtcXG4gICAgdmVjMyBTSCA9IG5vcm1hbGl6ZShTTCArIFYpO1xcbiAgICBmbG9hdCBTTkwgPSBtYXgoZG90KE4sIFNMKSwgMC4wMDEpO1xcbiAgICBmbG9hdCBTTkggPSBtYXgoZG90KE4sIFNIKSwgMC4wKTtcXG4gICAgZmxvYXQgZGlzdFNxciA9IGRvdChTTFUsIFNMVSk7XFxuICAgIGZsb2F0IGxpdFJhZGl1cyA9IGNjX3Nwb3RMaXRTaXplUmFuZ2VBbmdsZVtpXS54O1xcbiAgICBmbG9hdCBsaXRSYWRpdXNTcXIgPSBsaXRSYWRpdXMgKiBsaXRSYWRpdXM7XFxuICAgIGZsb2F0IGlsbHVtID0gMy4xNDE1OTI2NTM1OSAqIChsaXRSYWRpdXNTcXIgLyBtYXgobGl0UmFkaXVzU3FyICwgZGlzdFNxcikpO1xcbiAgICBmbG9hdCBhdHRSYWRpdXNTcXJJbnYgPSAxLjAgLyBtYXgoY2Nfc3BvdExpdFNpemVSYW5nZUFuZ2xlW2ldLnksIDAuMDEpO1xcbiAgICBhdHRSYWRpdXNTcXJJbnYgKj0gYXR0UmFkaXVzU3FySW52O1xcbiAgICBmbG9hdCBjb3NJbm5lciA9IG1heChkb3QoLWNjX3Nwb3RMaXREaXJbaV0ueHl6LCBTTCksIDAuMDEpO1xcbiAgICBmbG9hdCBjb3NPdXRlciA9IGNjX3Nwb3RMaXRTaXplUmFuZ2VBbmdsZVtpXS56O1xcbiAgICBmbG9hdCBsaXRBbmdsZVNjYWxlID0gMS4wIC8gbWF4KDAuMDAxLCBjb3NJbm5lciAtIGNvc091dGVyKTtcXG4gICAgZmxvYXQgbGl0QW5nbGVPZmZzZXQgPSAtY29zT3V0ZXIgKiBsaXRBbmdsZVNjYWxlO1xcbiAgICBmbG9hdCBhdHQgPSBHZXREaXN0QXR0KGRpc3RTcXIsIGF0dFJhZGl1c1Nxckludik7XFxuICAgIGF0dCAqPSBHZXRBbmdsZUF0dChTTCwgLWNjX3Nwb3RMaXREaXJbaV0ueHl6LCBsaXRBbmdsZVNjYWxlLCBsaXRBbmdsZU9mZnNldCk7XFxuICAgIHZlYzMgbHNwZWMgPSBzcGVjdWxhciAqIENhbGNTcGVjdWxhcihyb3VnaG5lc3MsIFNOSCwgU0gsIE4pO1xcbiAgICBsaWdodGluZyArPSBTTkwgKiBjY19zcG90TGl0Q29sb3JbaV0ucmdiICogY2Nfc3BvdExpdENvbG9yW2ldLncgKiBpbGx1bSAqIGF0dCAqIChkaWZmdXNlQ29udHJpYiArIGxzcGVjKTtcXG4gIH1cXG4gIHJldHVybiBsaWdodGluZztcXG59XFxuc3RydWN0IFN0YW5kYXJkU3VyZmFjZSB7XFxuICB2ZWM0IGFsYmVkbztcXG4gIHZlYzMgcG9zaXRpb247XFxuICB2ZWMzIG5vcm1hbDtcXG4gIHZlYzMgZW1pc3NpdmU7XFxuICBmbG9hdCByb3VnaG5lc3M7XFxuICBmbG9hdCBtZXRhbGxpYztcXG4gIGZsb2F0IG9jY2x1c2lvbjtcXG59O1xcbnZlYzQgQ0NTdGFuZGFyZFNoYWRpbmcgKFN0YW5kYXJkU3VyZmFjZSBzKSB7XFxuICB2ZWMzIGRpZmZ1c2UgPSBzLmFsYmVkby5yZ2IgKiAoMS4wIC0gcy5tZXRhbGxpYyk7XFxuICB2ZWMzIHNwZWN1bGFyID0gbWl4KHZlYzMoMC4wNCksIHMuYWxiZWRvLnJnYiwgcy5tZXRhbGxpYyk7XFxuICB2ZWMzIE4gPSBub3JtYWxpemUocy5ub3JtYWwpO1xcbiAgdmVjMyBWID0gbm9ybWFsaXplKGNjX2NhbWVyYVBvcy54eXogLSBzLnBvc2l0aW9uKTtcXG4gIHZlYzMgTCA9IG5vcm1hbGl6ZSgtY2NfbWFpbkxpdERpci54eXopO1xcbiAgdmVjMyBIID0gbm9ybWFsaXplKEwrVik7XFxuICBmbG9hdCBOViA9IG1heChhYnMoZG90KE4sIFYpKSwgMC4wMDEpO1xcbiAgZmxvYXQgTkwgPSBtYXgoZG90KE4sIEwpLCAwLjAwMSk7XFxuICBmbG9hdCBOSCA9IG1heChkb3QoTiwgSCksIDAuMCk7XFxuICBzcGVjdWxhciA9IEJSREZBcHByb3goc3BlY3VsYXIsIHMucm91Z2huZXNzLCBOVik7XFxuICB2ZWMzIGRpZmZ1c2VDb250cmliID0gZGlmZnVzZSAvIDMuMTQxNTkyNjUzNTk7XFxuICB2ZWMzIHNwZWN1bGFyQ29udHJpYiA9IHNwZWN1bGFyICogQ2FsY1NwZWN1bGFyKHMucm91Z2huZXNzLCBOSCwgSCwgTik7XFxuICB2ZWMzIGZpbmFsQ29sb3IgPSBOTCAqIGNjX21haW5MaXRDb2xvci5yZ2IgKiBjY19tYWluTGl0Q29sb3IudyAqIChkaWZmdXNlQ29udHJpYiArIHNwZWN1bGFyQ29udHJpYik7XFxuICBmaW5hbENvbG9yICs9IENhbGNEeW5hbWljTGlnaHRpbmcocy5wb3NpdGlvbiwgTiwgViwgZGlmZnVzZSwgc3BlY3VsYXIsIHMucm91Z2huZXNzKTtcXG4gIGZsb2F0IGZBbWIgPSAwLjUgLSBOLnkgKiAwLjU7XFxuICB2ZWMzIGFtYkRpZmYgPSBtaXgoY2NfYW1iaWVudFNreS5yZ2IsIGNjX2FtYmllbnRHcm91bmQucmdiLCBmQW1iKSAqIGNjX2FtYmllbnRTa3kudztcXG4gIGZpbmFsQ29sb3IgKz0gKGFtYkRpZmYucmdiICogZGlmZnVzZSk7XFxuICAjaWYgQ0NfVVNFX0lCTFxcbiAgICB2ZWMzIFIgPSBub3JtYWxpemUocmVmbGVjdCgtViwgTikpO1xcbiAgICB2ZWM0IGVudm1hcCA9IGZyYWdUZXh0dXJlTG9kKGNjX2Vudmlyb25tZW50LCBSLCBzLnJvdWdobmVzcyAqIGNjX2FtYmllbnRHcm91bmQudyk7XFxuICAgICNpZiBDQ19VU0VfSUJMID09IDJcXG4gICAgICB2ZWMzIGVudiA9IHVucGFja1JHQkUoZW52bWFwKTtcXG4gICAgI2Vsc2VcXG4gICAgICB2ZWMzIGVudiA9IFNSR0JUb0xpbmVhcihlbnZtYXAucmdiKTtcXG4gICAgI2VuZGlmXFxuICAgIGZpbmFsQ29sb3IgKz0gZW52ICogY2NfYW1iaWVudFNreS53ICogc3BlY3VsYXI7XFxuICAjZW5kaWZcXG4gIGZpbmFsQ29sb3IgPSBmaW5hbENvbG9yICogcy5vY2NsdXNpb247XFxuICAjaWYgQ0NfVVNFX0hEUlxcbiAgICBzLmVtaXNzaXZlICo9IGNjX2V4cG9zdXJlLnc7XFxuICAjZW5kaWZcXG4gIGZpbmFsQ29sb3IgKz0gcy5lbWlzc2l2ZTtcXG4gIHJldHVybiB2ZWM0KGZpbmFsQ29sb3IsIHMuYWxiZWRvLmEpO1xcbn1cXG52ZWMzIEFDRVNUb25lTWFwICh2ZWMzIGNvbG9yKSB7XFxuICBjb2xvciA9IG1pbihjb2xvciwgdmVjMyg4LjApKTtcXG4gIGNvbnN0IGZsb2F0IEEgPSAyLjUxO1xcbiAgY29uc3QgZmxvYXQgQiA9IDAuMDM7XFxuICBjb25zdCBmbG9hdCBDID0gMi40MztcXG4gIGNvbnN0IGZsb2F0IEQgPSAwLjU5O1xcbiAgY29uc3QgZmxvYXQgRSA9IDAuMTQ7XFxuICByZXR1cm4gKGNvbG9yICogKEEgKiBjb2xvciArIEIpKSAvIChjb2xvciAqIChDICogY29sb3IgKyBEKSArIEUpO1xcbn1cXG52ZWM0IENDRnJhZ091dHB1dCAodmVjNCBjb2xvcikge1xcbiAgI2lmICFDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IHNxcnQoQUNFU1RvbmVNYXAoY29sb3IucmdiKSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxudW5pZm9ybSBDb25zdGFudHMge1xcbiAgdmVjNCB0aWxpbmdPZmZzZXQ7XFxuICB2ZWM0IGFsYmVkbztcXG4gIHZlYzQgYWxiZWRvU2NhbGVBbmRDdXRvZmY7XFxuICB2ZWM0IHBiclBhcmFtcztcXG4gIHZlYzQgZW1pc3NpdmU7XFxuICB2ZWM0IGVtaXNzaXZlU2NhbGVQYXJhbTtcXG59O1xcbmluIHZlYzMgdl9wb3NpdGlvbjtcXG5pbiB2ZWMyIHZfdXY7XFxuaW4gdmVjMiB2X3V2MTtcXG5pbiB2ZWMzIHZfbm9ybWFsO1xcbiNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICBpbiB2ZWMzIHZfY29sb3I7XFxuI2VuZGlmXFxuI2lmIFVTRV9BTEJFRE9fTUFQXFxuICB1bmlmb3JtIHNhbXBsZXIyRCBhbGJlZG9NYXA7XFxuI2VuZGlmXFxuI2lmIFVTRV9OT1JNQUxfTUFQXFxuICBpbiB2ZWMzIHZfdGFuZ2VudDtcXG4gIGluIHZlYzMgdl9iaXRhbmdlbnQ7XFxuICB1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuI2VuZGlmXFxuI2lmIFVTRV9QQlJfTUFQXFxuICB1bmlmb3JtIHNhbXBsZXIyRCBwYnJNYXA7XFxuI2VuZGlmXFxuI2lmIFVTRV9NRVRBTExJQ19ST1VHSE5FU1NfTUFQXFxuICB1bmlmb3JtIHNhbXBsZXIyRCBtZXRhbGxpY1JvdWdobmVzc01hcDtcXG4jZW5kaWZcXG4jaWYgVVNFX09DQ0xVU0lPTl9NQVBcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIG9jY2x1c2lvbk1hcDtcXG4jZW5kaWZcXG4jaWYgVVNFX0VNSVNTSVZFX01BUFxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVNYXA7XFxuI2VuZGlmXFxuI2lmIFVTRV9MSUdIVE1BUFxcbiAgaW4gdmVjMiB2X2x1djtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGNjX2xpZ2h0aW5nTWFwO1xcbiNlbmRpZlxcbiNpZiBVU0VfQUxQSEFfVEVTVFxcbiNlbmRpZlxcbnZvaWQgc3VyZiAob3V0IFN0YW5kYXJkU3VyZmFjZSBzKSB7XFxuICB2ZWM0IGJhc2VDb2xvciA9IGFsYmVkbztcXG4gICNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICAgIGJhc2VDb2xvci5yZ2IgKj0gdl9jb2xvcjtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9BTEJFRE9fTUFQXFxuICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlKGFsYmVkb01hcCwgQUxCRURPX1VWKTtcXG4gICAgdGV4Q29sb3IucmdiID0gU1JHQlRvTGluZWFyKHRleENvbG9yLnJnYik7XFxuICAgIGJhc2VDb2xvciAqPSB0ZXhDb2xvcjtcXG4gICNlbmRpZlxcbiAgcy5hbGJlZG8gPSBiYXNlQ29sb3I7XFxuICBzLmFsYmVkby5yZ2IgKj0gYWxiZWRvU2NhbGVBbmRDdXRvZmYueHl6O1xcbiAgI2lmIFVTRV9BTFBIQV9URVNUXFxuICAgIGlmIChzLmFsYmVkby5BTFBIQV9URVNUX0NIQU5ORUwgPCBhbGJlZG9TY2FsZUFuZEN1dG9mZi53KSBkaXNjYXJkO1xcbiAgI2VuZGlmXFxuICBzLm5vcm1hbCA9IHZfbm9ybWFsO1xcbiAgI2lmIFVTRV9OT1JNQUxfTUFQXFxuICAgIHZlYzMgbm1tcCA9IHRleHR1cmUobm9ybWFsTWFwLCBOT1JNQUxfVVYpLnh5eiAtIHZlYzMoMC41KTtcXG4gICAgcy5ub3JtYWwgPVxcbiAgICAgIChubW1wLnggKiBwYnJQYXJhbXMudykgKiBub3JtYWxpemUodl90YW5nZW50KSArXFxuICAgICAgKG5tbXAueSAqIHBiclBhcmFtcy53KSAqIG5vcm1hbGl6ZSh2X2JpdGFuZ2VudCkgK1xcbiAgICAgIG5tbXAueiAqIG5vcm1hbGl6ZShzLm5vcm1hbCk7XFxuICAjZW5kaWZcXG4gIHMucG9zaXRpb24gPSB2X3Bvc2l0aW9uO1xcbiAgdmVjNCBwYnIgPSBwYnJQYXJhbXM7XFxuICAjaWYgVVNFX1BCUl9NQVBcXG4gICAgdmVjNCByZXMgPSB0ZXh0dXJlKHBick1hcCwgUEJSX1VWKTtcXG4gICAgcGJyLnggKj0gcmVzLk9DQ0xVU0lPTl9DSEFOTkVMO1xcbiAgICBwYnIueSAqPSByZXMuUk9VR0hORVNTX0NIQU5ORUw7XFxuICAgIHBici56ICo9IHJlcy5NRVRBTExJQ19DSEFOTkVMO1xcbiAgI2VuZGlmXFxuICAjaWYgVVNFX01FVEFMTElDX1JPVUdITkVTU19NQVBcXG4gICAgdmVjNCBtZXRhbGxpY1JvdWdobmVzcyA9IHRleHR1cmUobWV0YWxsaWNSb3VnaG5lc3NNYXAsIE1FVEFMTElDX1JPVUdITkVTU19VVik7XFxuICAgIHBici56ICo9IG1ldGFsbGljUm91Z2huZXNzLk1FVEFMTElDX0NIQU5ORUw7XFxuICAgIHBici55ICo9IG1ldGFsbGljUm91Z2huZXNzLlJPVUdITkVTU19DSEFOTkVMO1xcbiAgI2VuZGlmXFxuICAjaWYgVVNFX09DQ0xVU0lPTl9NQVBcXG4gICAgcGJyLnggKj0gdGV4dHVyZShvY2NsdXNpb25NYXAsIE9DQ0xVU0lPTl9VVikuT0NDTFVTSU9OX0NIQU5ORUw7XFxuICAjZW5kaWZcXG4gIHMub2NjbHVzaW9uID0gY2xhbXAocGJyLngsIDAuMCwgMC45Nik7XFxuICBzLnJvdWdobmVzcyA9IGNsYW1wKHBici55LCAwLjA0LCAxLjApO1xcbiAgcy5tZXRhbGxpYyA9IHBici56O1xcbiAgcy5lbWlzc2l2ZSA9IGVtaXNzaXZlLnJnYiAqIGVtaXNzaXZlU2NhbGVQYXJhbS54eXo7XFxuICAjaWYgVVNFX0VNSVNTSVZFX01BUFxcbiAgICBzLmVtaXNzaXZlICo9IFNSR0JUb0xpbmVhcih0ZXh0dXJlKGVtaXNzaXZlTWFwLCBFTUlTU0lWRV9VVikucmdiKTtcXG4gICNlbmRpZlxcbn1cXG52ZWM0IGZyYWcgKCkge1xcbiAgU3RhbmRhcmRTdXJmYWNlIHM7IHN1cmYocyk7XFxuICB2ZWM0IGNvbG9yID0gQ0NTdGFuZGFyZFNoYWRpbmcocyk7XFxuICAjaWYgVVNFX0xJR0hUTUFQICYmICFVU0VfQkFUQ0hJTkcgJiYgIVVTRV9JTlNUQU5DSU5HXFxuICAgIHZlYzQgbGlnaHRpbmcgPSB0ZXh0dXJlKGNjX2xpZ2h0aW5nTWFwLCB2X2x1dik7XFxuICAgIGZsb2F0IGZBbWIgPSAwLjUgLSBzLm5vcm1hbC55ICogMC41O1xcbiAgICB2ZWMzIGFtYkRpZmYgPSBtaXgoY2NfYW1iaWVudFNreS5yZ2IsIGNjX2FtYmllbnRHcm91bmQucmdiLCBmQW1iKSAqIGNjX2FtYmllbnRTa3kudztcXG4gICAgdmVjMyBmaW5hbENvbG9yID0gKGFtYkRpZmYucmdiICogcy5hbGJlZG8ucmdiKTtcXG4gICAgZmluYWxDb2xvciArPSBsaWdodGluZy5yZ2IgKiAgcy5hbGJlZG8ucmdiO1xcbiAgICBmaW5hbENvbG9yID0gZmluYWxDb2xvciAqIHMub2NjbHVzaW9uO1xcbiAgICBmaW5hbENvbG9yICs9IHMuZW1pc3NpdmU7XFxuICAgIGNvbG9yLnJnYiA9IGxpZ2h0aW5nLmEgKiBmaW5hbENvbG9yICsgKDEuMCAtIGxpZ2h0aW5nLmEpICogY29sb3IucmdiO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gQ0NGcmFnT3V0cHV0KGNvbG9yKTtcXG59XFxub3V0IHZlYzQgY2NfRnJhZ0NvbG9yO1xcbnZvaWQgbWFpbigpIHsgY2NfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJnbHNsMVwiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5zdHJ1Y3QgU3RhbmRhcmRWZXJ0SW5wdXQge1xcbiAgaGlnaHAgdmVjNCBwb3NpdGlvbjtcXG4gIHZlYzMgbm9ybWFsO1xcbiAgdmVjNCB0YW5nZW50O1xcbn07XFxuYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMyBhX25vcm1hbDtcXG5hdHRyaWJ1dGUgdmVjNCBhX3RhbmdlbnQ7XFxuI2lmIENDX1VTRV9NT1JQSFxcbiAgICBhdHRyaWJ1dGUgZmxvYXQgYV92ZXJ0ZXhJZDtcXG4gICAgaW50IGdldFZlcnRleElkKCkge1xcbiAgICAgICAgcmV0dXJuIGludChhX3ZlcnRleElkKTtcXG4gICAgfVxcbnVuaWZvcm0gdmVjNCBjY19kaXNwbGFjZW1lbnRXZWlnaHRzWzE1XTtcXG51bmlmb3JtIHZlYzQgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm87XFxuICAgIHZlYzQgZmV0Y2hGbGF0UGl4ZWwoc2FtcGxlcjJEIHRleCwgaW50IHBpeGVsSW5kZXgpIHtcXG4gICAgICAgIGZsb2F0IHBpeGVsSW5kZXhGID0gZmxvYXQocGl4ZWxJbmRleCk7XFxuICAgICAgICB2ZWMyIHRleHR1cmVSZXNvbHV0aW9uID0gdmVjMihmbG9hdChjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby54KSwgZmxvYXQoY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueSkpO1xcbiAgICAgICAgZmxvYXQgcGl4ZWxYID0gbW9kKHBpeGVsSW5kZXhGLCB0ZXh0dXJlUmVzb2x1dGlvbi54KTtcXG4gICAgICAgIGZsb2F0IHBpeGVsWSA9IGZsb29yKHBpeGVsSW5kZXhGIC8gdGV4dHVyZVJlc29sdXRpb24ueCk7XFxuICAgICAgICB2ZWMyIHV2ID0gKHZlYzIocGl4ZWxYLCBwaXhlbFkpICsgLjUpIC8gdGV4dHVyZVJlc29sdXRpb247XFxuICAgICAgICByZXR1cm4gdGV4dHVyZTJEKHRleCwgdXYpO1xcbiAgICB9XFxuZmxvYXQgZ2V0RGlzcGxhY2VtZW50V2VpZ2h0KGludCBpbmRleCkge1xcbiAgICBmbG9hdCBtID0gbW9kKGZsb2F0KGluZGV4KSwgNC4wKTtcXG4gICAgaWYgKG0gPCAxLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0ueDtcXG4gICAgfSBlbHNlIGlmIChtIDwgMi4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLnk7XFxuICAgIH0gZWxzZSBpZiAobSA8IDMuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS56O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS53O1xcbiAgICB9XFxufVxcbnZlYzMgZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKHNhbXBsZXIyRCB0ZXgsIGludCB2ZXJ0ZXhJbmRleCkge1xcbiNpZiBDQ19NT1JQSF9QUkVDT01QVVRFRFxcbiAgICByZXR1cm4gZmV0Y2hGbGF0UGl4ZWwodGV4LCB2ZXJ0ZXhJbmRleCkucmdiO1xcbiNlbHNlXFxuICAgIHZlYzMgcmVzdWx0ID0gdmVjMygwLCAwLCAwKTtcXG4gICAgZm9yIChpbnQgaVRhcmdldCA9IDA7IGlUYXJnZXQgPCBDQ19NT1JQSF9UQVJHRVRfQ09VTlQ7ICsraVRhcmdldCkge1xcbiAgICAgICAgaW50IGRhdGFQaXhlbFN0YXJ0ID0gaW50KGZldGNoRmxhdFBpeGVsKHRleCwgaVRhcmdldCkucik7XFxuICAgICAgICByZXN1bHQgKz0gKGZldGNoRmxhdFBpeGVsKHRleCwgZGF0YVBpeGVsU3RhcnQgKyB2ZXJ0ZXhJbmRleCkucmdiICogZ2V0RGlzcGxhY2VtZW50V2VpZ2h0KGlUYXJnZXQpKTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbiNlbmRpZlxcbn1cXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlxcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBjY19Qb3NpdGlvbkRpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0UG9zaXRpb25EaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX1Bvc2l0aW9uRGlzcGxhY2VtZW50cywgdmVydGV4SWQpO1xcbiAgICB9XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGNjX05vcm1hbERpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0Tm9ybWFsRGlzcGxhY2VtZW50KGludCB2ZXJ0ZXhJZCkge1xcbiAgICAgICAgcmV0dXJuIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShjY19Ob3JtYWxEaXNwbGFjZW1lbnRzLCB2ZXJ0ZXhJZCk7XFxuICAgIH1cXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19UQU5HRU5UXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGNjX1RhbmdlbnREaXNwbGFjZW1lbnRzO1xcbiAgICB2ZWMzIGdldFRhbmdlbnREaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX1RhbmdlbnREaXNwbGFjZW1lbnRzLCB2ZXJ0ZXhJZCk7XFxuICAgIH1cXG4jZW5kaWZcXG52b2lkIGFwcGx5TW9ycGggKGlub3V0IFN0YW5kYXJkVmVydElucHV0IGF0dHIpIHtcXG4gICAgaW50IHZlcnRleElkID0gZ2V0VmVydGV4SWQoKTtcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlxcbiAgICBhdHRyLnBvc2l0aW9uLnh5eiA9IGF0dHIucG9zaXRpb24ueHl6ICsgZ2V0UG9zaXRpb25EaXNwbGFjZW1lbnQodmVydGV4SWQpO1xcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX05PUk1BTFxcbiAgICBhdHRyLm5vcm1hbC54eXogPSBhdHRyLm5vcm1hbC54eXogKyBnZXROb3JtYWxEaXNwbGFjZW1lbnQodmVydGV4SWQpO1xcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcXG4gICAgYXR0ci50YW5nZW50Lnh5eiA9IGF0dHIudGFuZ2VudC54eXogKyBnZXRUYW5nZW50RGlzcGxhY2VtZW50KHZlcnRleElkKTtcXG4jZW5kaWZcXG59XFxudm9pZCBhcHBseU1vcnBoIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cXG4gICAgcG9zaXRpb24ueHl6ID0gcG9zaXRpb24ueHl6ICsgZ2V0UG9zaXRpb25EaXNwbGFjZW1lbnQoZ2V0VmVydGV4SWQoKSk7XFxuI2VuZGlmXFxufVxcbiNlbmRpZlxcbiNpZiBDQ19VU0VfU0tJTk5JTkdcXG5hdHRyaWJ1dGUgdmVjNCBhX3dlaWdodHM7XFxuYXR0cmlidXRlIHZlYzQgYV9qb2ludHM7XFxuI2lmIENDX1VTRV9CQUtFRF9BTklNQVRJT05cXG4gICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICBhdHRyaWJ1dGUgaGlnaHAgdmVjNCBhX2pvaW50QW5pbUluZm87XFxuICAjZW5kaWZcXG4gIHVuaWZvcm0gaGlnaHAgdmVjNCBjY19qb2ludFRleHR1cmVJbmZvO1xcbiAgdW5pZm9ybSBoaWdocCB2ZWM0IGNjX2pvaW50QW5pbUluZm87XFxuICB1bmlmb3JtIHNhbXBsZXIyRCBjY19qb2ludFRleHR1cmU7XFxuICAgICNpZiAhQ0NfU1VQUE9SVF9GTE9BVF9URVhUVVJFXFxuICAgIGhpZ2hwIGZsb2F0IGRlY29kZTMyIChoaWdocCB2ZWM0IHJnYmEpIHtcXG4gICAgICByZ2JhID0gcmdiYSAqIDI1NS4wO1xcbiAgICAgIGhpZ2hwIGZsb2F0IFNpZ24gPSAxLjAgLSBzdGVwKDEyOC4wLCByZ2JhWzNdKSAqIDIuMDtcXG4gICAgICBoaWdocCBmbG9hdCBFeHBvbmVudCA9IDIuMCAqIG1vZChyZ2JhWzNdLCAxMjguMCkgKyBzdGVwKDEyOC4wLCByZ2JhWzJdKSAtIDEyNy4wO1xcbiAgICAgIGhpZ2hwIGZsb2F0IE1hbnRpc3NhID0gbW9kKHJnYmFbMl0sIDEyOC4wKSAqIDY1NTM2LjAgKyByZ2JhWzFdICogMjU2LjAgKyByZ2JhWzBdICsgODM4ODYwOC4wO1xcbiAgICAgIHJldHVybiBTaWduICogZXhwMihFeHBvbmVudCAtIDIzLjApICogTWFudGlzc2E7XFxuICAgIH1cXG4gICNlbmRpZlxcbiNlbHNlXFxuICB1bmlmb3JtIGhpZ2hwIHZlYzQgY2Nfam9pbnRzWzkwXTtcXG4jZW5kaWZcXG4jaWYgQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlxcbiAgI2lmIENDX1NVUFBPUlRfRkxPQVRfVEVYVFVSRVxcbiAgICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAzLjAgKiAoYV9qb2ludEFuaW1JbmZvLnggKiBhX2pvaW50QW5pbUluZm8ueSArIGkpICsgYV9qb2ludEFuaW1JbmZvLno7XFxuICAgICNlbHNlXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDMuMCAqIChjY19qb2ludEFuaW1JbmZvLnggKiBjY19qb2ludFRleHR1cmVJbmZvLnkgKyBpKSArIGNjX2pvaW50VGV4dHVyZUluZm8uejtcXG4gICAgI2VuZGlmXFxuICAgIGhpZ2hwIGZsb2F0IGludlNpemUgPSBjY19qb2ludFRleHR1cmVJbmZvLnc7XFxuICAgIGhpZ2hwIGZsb2F0IHkgPSBmbG9vcihqICogaW52U2l6ZSk7XFxuICAgIGhpZ2hwIGZsb2F0IHggPSBqIC0geSAqIGNjX2pvaW50VGV4dHVyZUluZm8ueDtcXG4gICAgeSA9ICh5ICsgMC41KSAqIGludlNpemU7XFxuICAgICAgdmVjNCB2MSA9IHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAwLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHZlYzQgdjIgPSB0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMS41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICB2ZWM0IHYzID0gdGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDIuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gICAgfVxcbiAgI2Vsc2VcXG4gICAgbWF0NCBnZXRKb2ludE1hdHJpeCAoZmxvYXQgaSkge1xcbiAgICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMTIuMCAqIChhX2pvaW50QW5pbUluZm8ueCAqIGFfam9pbnRBbmltSW5mby55ICsgaSkgKyBhX2pvaW50QW5pbUluZm8uejtcXG4gICAgI2Vsc2VcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMTIuMCAqIChjY19qb2ludEFuaW1JbmZvLnggKiBjY19qb2ludFRleHR1cmVJbmZvLnkgKyBpKSArIGNjX2pvaW50VGV4dHVyZUluZm8uejtcXG4gICAgI2VuZGlmXFxuICAgIGhpZ2hwIGZsb2F0IGludlNpemUgPSBjY19qb2ludFRleHR1cmVJbmZvLnc7XFxuICAgIGhpZ2hwIGZsb2F0IHkgPSBmbG9vcihqICogaW52U2l6ZSk7XFxuICAgIGhpZ2hwIGZsb2F0IHggPSBqIC0geSAqIGNjX2pvaW50VGV4dHVyZUluZm8ueDtcXG4gICAgeSA9ICh5ICsgMC41KSAqIGludlNpemU7XFxuICAgICAgdmVjNCB2MSA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMi41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMy41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHZlYzQgdjIgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDQuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDUuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDYuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDcuNSkgKiBpbnZTaXplLCB5KSkpXFxuICAgICAgKTtcXG4gICAgICB2ZWM0IHYzID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA4LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA5LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxMC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMTEuNSkgKiBpbnZTaXplLCB5KSkpXFxuICAgICAgKTtcXG4gICAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgICB9XFxuICAjZW5kaWZcXG4jZWxzZVxcbiAgbWF0NCBnZXRKb2ludE1hdHJpeCAoZmxvYXQgaSkge1xcbiAgICBpbnQgaWR4ID0gaW50KGkpO1xcbiAgICB2ZWM0IHYxID0gY2Nfam9pbnRzW2lkeCAqIDNdO1xcbiAgICB2ZWM0IHYyID0gY2Nfam9pbnRzW2lkeCAqIDMgKyAxXTtcXG4gICAgdmVjNCB2MyA9IGNjX2pvaW50c1tpZHggKiAzICsgMl07XFxuICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICB9XFxuI2VuZGlmXFxubWF0NCBza2luTWF0cml4ICgpIHtcXG4gIHJldHVybiBnZXRKb2ludE1hdHJpeChhX2pvaW50cy54KSAqIGFfd2VpZ2h0cy54XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueSkgKiBhX3dlaWdodHMueVxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLnopICogYV93ZWlnaHRzLnpcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy53KSAqIGFfd2VpZ2h0cy53O1xcbn1cXG52b2lkIENDU2tpbiAoaW5vdXQgdmVjNCBwb3NpdGlvbikge1xcbiAgbWF0NCBtID0gc2tpbk1hdHJpeCgpO1xcbiAgcG9zaXRpb24gPSBtICogcG9zaXRpb247XFxufVxcbnZvaWQgQ0NTa2luIChpbm91dCBTdGFuZGFyZFZlcnRJbnB1dCBhdHRyKSB7XFxuICBtYXQ0IG0gPSBza2luTWF0cml4KCk7XFxuICBhdHRyLnBvc2l0aW9uID0gbSAqIGF0dHIucG9zaXRpb247XFxuICBhdHRyLm5vcm1hbCA9IChtICogdmVjNChhdHRyLm5vcm1hbCwgMC4wKSkueHl6O1xcbiAgYXR0ci50YW5nZW50Lnh5eiA9IChtICogdmVjNChhdHRyLnRhbmdlbnQueHl6LCAwLjApKS54eXo7XFxufVxcbiNlbmRpZlxcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRWaWV3O1xcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRQcm9qO1xcbiNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgYXR0cmlidXRlIHZlYzQgYV9tYXRXb3JsZDA7XFxuICBhdHRyaWJ1dGUgdmVjNCBhX21hdFdvcmxkMTtcXG4gIGF0dHJpYnV0ZSB2ZWM0IGFfbWF0V29ybGQyO1xcbiNlbGlmIFVTRV9CQVRDSElOR1xcbiAgYXR0cmlidXRlIGZsb2F0IGFfZHluX2JhdGNoX2lkO1xcbiAgdW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFdvcmxkc1sxMF07XFxuI2Vsc2VcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFdvcmxkSVQ7XFxudW5pZm9ybSBoaWdocCB2ZWM0IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG4jZW5kaWZcXG51bmlmb3JtIHZlYzQgdGlsaW5nT2Zmc2V0O1xcbiNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICBhdHRyaWJ1dGUgdmVjMyBhX2NvbG9yO1xcbiAgdmFyeWluZyB2ZWMzIHZfY29sb3I7XFxuI2VuZGlmXFxudmFyeWluZyB2ZWMzIHZfcG9zaXRpb247XFxudmFyeWluZyB2ZWMzIHZfbm9ybWFsO1xcbiNpZiBVU0VfTk9STUFMX01BUFxcbiAgdmFyeWluZyB2ZWMzIHZfdGFuZ2VudDtcXG4gIHZhcnlpbmcgdmVjMyB2X2JpdGFuZ2VudDtcXG4jZW5kaWZcXG5hdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkO1xcbnZhcnlpbmcgdmVjMiB2X3V2O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQxO1xcbnZhcnlpbmcgdmVjMiB2X3V2MTtcXG4jaWYgVVNFX0xJR0hUTUFQICYmICFVU0VfQkFUQ0hJTkcgJiYgIVVTRV9JTlNUQU5DSU5HXFxuICB2YXJ5aW5nIHZlYzIgdl9sdXY7XFxuI2VuZGlmXFxudmVjNCB2ZXJ0ICgpIHtcXG4gIFN0YW5kYXJkVmVydElucHV0IEluO1xcbiAgSW4ucG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XFxuICBJbi5ub3JtYWwgPSBhX25vcm1hbDtcXG4gIEluLnRhbmdlbnQgPSBhX3RhbmdlbnQ7XFxuICAjaWYgQ0NfVVNFX01PUlBIXFxuICAgIGFwcGx5TW9ycGgoSW4pO1xcbiAgI2VuZGlmXFxuICAjaWYgQ0NfVVNFX1NLSU5OSU5HXFxuICAgIENDU2tpbihJbik7XFxuICAjZW5kaWZcXG4gIG1hdDQgbWF0V29ybGQsIG1hdFdvcmxkSVQ7XFxuICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgbWF0V29ybGQgPSBtYXQ0KFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDAueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDEueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDIueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDAudywgYV9tYXRXb3JsZDEudywgYV9tYXRXb3JsZDIudywgMS4wKVxcbiAgICApO1xcbiAgICBtYXRXb3JsZElUID0gbWF0V29ybGQ7XFxuICAjZWxpZiBVU0VfQkFUQ0hJTkdcXG4gICAgbWF0V29ybGQgPSBjY19tYXRXb3JsZHNbaW50KGFfZHluX2JhdGNoX2lkKV07XFxuICAgIG1hdFdvcmxkSVQgPSBtYXRXb3JsZDtcXG4gICNlbHNlXFxuICAgIG1hdFdvcmxkID0gY2NfbWF0V29ybGQ7XFxuICAgIG1hdFdvcmxkSVQgPSBjY19tYXRXb3JsZElUO1xcbiAgI2VuZGlmXFxuICB2ZWM0IHBvcyA9IG1hdFdvcmxkICogSW4ucG9zaXRpb247XFxuICB2X3Bvc2l0aW9uID0gcG9zLnh5ejtcXG4gIHZfbm9ybWFsID0gbm9ybWFsaXplKChtYXRXb3JsZElUICogdmVjNChJbi5ub3JtYWwsIDAuMCkpLnh5eik7XFxuICAjaWYgVVNFX05PUk1BTF9NQVBcXG4gICAgdl90YW5nZW50ID0gbm9ybWFsaXplKChtYXRXb3JsZCAqIHZlYzQoSW4udGFuZ2VudC54eXosIDAuMCkpLnh5eik7XFxuICAgIHZfYml0YW5nZW50ID0gY3Jvc3Modl9ub3JtYWwsIHZfdGFuZ2VudCkgKiBJbi50YW5nZW50Lnc7XFxuICAjZW5kaWZcXG4gIHZfdXYgPSBhX3RleENvb3JkICogdGlsaW5nT2Zmc2V0Lnh5ICsgdGlsaW5nT2Zmc2V0Lnp3O1xcbiAgI2lmIEhBU19TRUNPTkRfVVZcXG4gICAgdl91djEgPSBhX3RleENvb3JkMSAqIHRpbGluZ09mZnNldC54eSArIHRpbGluZ09mZnNldC56dztcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9WRVJURVhfQ09MT1JcXG4gICAgdl9jb2xvciA9IGFfY29sb3I7XFxuICAjZW5kaWZcXG4gICNpZiBVU0VfTElHSFRNQVAgJiYgSEFTX1NFQ09ORF9VViAmJiAhVVNFX0JBVENISU5HICYmICFVU0VfSU5TVEFOQ0lOR1xcbiAgICB2X2x1diA9IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbS54eSArIGFfdGV4Q29vcmQxICogY2NfbGlnaHRpbmdNYXBVVlBhcmFtLnp3O1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY2NfbWF0UHJvaiAqIChjY19tYXRWaWV3ICogbWF0V29ybGQpICogSW4ucG9zaXRpb247XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSB2ZXJ0KCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG4gICNpZmRlZiBHTF9FWFRfc2hhZGVyX3RleHR1cmVfbG9kXFxuICAgICNleHRlbnNpb24gR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCA6IGVuYWJsZVxcbiAgI2VuZGlmXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbnVuaWZvcm0gaGlnaHAgdmVjNCBjY19jYW1lcmFQb3M7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG51bmlmb3JtIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG51bmlmb3JtIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbiNpZiBDQ19VU0VfSUJMXFxudW5pZm9ybSBzYW1wbGVyQ3ViZSBjY19lbnZpcm9ubWVudDtcXG52ZWMzIHVucGFja1JHQkUgKHZlYzQgcmdiZSkge1xcbiAgcmV0dXJuIHJnYmUucmdiICogcG93KDIuMCwgcmdiZS5hICogMjU1LjAgLSAxMjguMCk7XFxufVxcbnZlYzQgZnJhZ1RleHR1cmVMb2QgKHNhbXBsZXIyRCB0ZXgsIHZlYzIgY29vcmQsIGZsb2F0IGxvZCkge1xcbiAgICAjaWZkZWYgR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZFxcbiAgICAgIHJldHVybiB0ZXh0dXJlMkRMb2RFWFQodGV4LCBjb29yZCwgbG9kKTtcXG4gICAgI2Vsc2VcXG4gICAgICByZXR1cm4gdGV4dHVyZTJEKHRleCwgY29vcmQsIGxvZCk7XFxuICAgICNlbmRpZlxcbn1cXG52ZWM0IGZyYWdUZXh0dXJlTG9kIChzYW1wbGVyQ3ViZSB0ZXgsIHZlYzMgY29vcmQsIGZsb2F0IGxvZCkge1xcbiAgICAjaWZkZWYgR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZFxcbiAgICAgIHJldHVybiB0ZXh0dXJlQ3ViZUxvZEVYVCh0ZXgsIGNvb3JkLCBsb2QpO1xcbiAgICAjZWxzZVxcbiAgICAgIHJldHVybiB0ZXh0dXJlQ3ViZSh0ZXgsIGNvb3JkLCBsb2QpO1xcbiAgICAjZW5kaWZcXG59XFxuI2VuZGlmXFxudmVjMyBTUkdCVG9MaW5lYXIgKHZlYzMgZ2FtbWEpIHtcXG4gIHJldHVybiBnYW1tYSAqIGdhbW1hO1xcbn1cXG51bmlmb3JtIGhpZ2hwIHZlYzQgY2Nfc3BoZXJlTGl0UG9zWzJdO1xcbnVuaWZvcm0gdmVjNCBjY19zcGhlcmVMaXRTaXplUmFuZ2VbMl07XFxudW5pZm9ybSB2ZWM0IGNjX3NwaGVyZUxpdENvbG9yWzJdO1xcbnVuaWZvcm0gaGlnaHAgdmVjNCBjY19zcG90TGl0UG9zWzJdO1xcbnVuaWZvcm0gdmVjNCBjY19zcG90TGl0U2l6ZVJhbmdlQW5nbGVbMl07XFxudW5pZm9ybSB2ZWM0IGNjX3Nwb3RMaXREaXJbMl07XFxudW5pZm9ybSB2ZWM0IGNjX3Nwb3RMaXRDb2xvclsyXTtcXG5mbG9hdCBTbW9vdGhEaXN0QXR0IChmbG9hdCBkaXN0U3FyLCBmbG9hdCBpbnZTcXJBdHRSYWRpdXMpIHtcXG4gIGZsb2F0IGZhY3RvciA9IGRpc3RTcXIgKiBpbnZTcXJBdHRSYWRpdXM7XFxuICBmbG9hdCBzbW9vdGhGYWN0b3IgPSBjbGFtcCgxLjAgLSBmYWN0b3IgKiBmYWN0b3IsIDAuMCwgMS4wKTtcXG4gIHJldHVybiBzbW9vdGhGYWN0b3IgKiBzbW9vdGhGYWN0b3I7XFxufVxcbmZsb2F0IEdldERpc3RBdHQgKGZsb2F0IGRpc3RTcXIsIGZsb2F0IGludlNxckF0dFJhZGl1cykge1xcbiAgZmxvYXQgYXR0ZW51YXRpb24gPSAxLjAgLyBtYXgoZGlzdFNxciwgMC4wMSowLjAxKTtcXG4gIGF0dGVudWF0aW9uICo9IFNtb290aERpc3RBdHQoZGlzdFNxciAsIGludlNxckF0dFJhZGl1cyk7XFxuICByZXR1cm4gYXR0ZW51YXRpb247XFxufVxcbmZsb2F0IEdldEFuZ2xlQXR0ICh2ZWMzIEwsIHZlYzMgbGl0RGlyLCBmbG9hdCBsaXRBbmdsZVNjYWxlLCBmbG9hdCBsaXRBbmdsZU9mZnNldCkge1xcbiAgZmxvYXQgY2QgPSBkb3QobGl0RGlyLCBMKTtcXG4gIGZsb2F0IGF0dGVudWF0aW9uID0gY2xhbXAoY2QgKiBsaXRBbmdsZVNjYWxlICsgbGl0QW5nbGVPZmZzZXQsIDAuMCwgMS4wKTtcXG4gIHJldHVybiAoYXR0ZW51YXRpb24gKiBhdHRlbnVhdGlvbik7XFxufVxcbmZsb2F0IEdHWE1vYmlsZSAoZmxvYXQgcm91Z2huZXNzLCBmbG9hdCBOb0gsIHZlYzMgSCwgdmVjMyBOKSB7XFxuICB2ZWMzIE54SCA9IGNyb3NzKE4sIEgpO1xcbiAgZmxvYXQgT25lTWludXNOb0hTcXIgPSBkb3QoTnhILCBOeEgpO1xcbiAgZmxvYXQgYSA9IHJvdWdobmVzcyAqIHJvdWdobmVzcztcXG4gIGZsb2F0IG4gPSBOb0ggKiBhO1xcbiAgZmxvYXQgcCA9IGEgLyAoT25lTWludXNOb0hTcXIgKyBuICogbik7XFxuICByZXR1cm4gcCAqIHA7XFxufVxcbmZsb2F0IENhbGNTcGVjdWxhciAoZmxvYXQgcm91Z2huZXNzLCBmbG9hdCBOb0gsIHZlYzMgSCwgdmVjMyBOKSB7XFxuICByZXR1cm4gKHJvdWdobmVzcyowLjI1ICsgMC4yNSkgKiBHR1hNb2JpbGUocm91Z2huZXNzLCBOb0gsIEgsIE4pO1xcbn1cXG52ZWMzIEJSREZBcHByb3ggKHZlYzMgc3BlY3VsYXIsIGZsb2F0IHJvdWdobmVzcywgZmxvYXQgTm9WKSB7XFxuICBjb25zdCB2ZWM0IGMwID0gdmVjNCgtMS4wLCAtMC4wMjc1LCAtMC41NzIsIDAuMDIyKTtcXG4gIGNvbnN0IHZlYzQgYzEgPSB2ZWM0KDEuMCwgMC4wNDI1LCAxLjA0LCAtMC4wNCk7XFxuICB2ZWM0IHIgPSByb3VnaG5lc3MgKiBjMCArIGMxO1xcbiAgZmxvYXQgYTAwNCA9IG1pbiggci54ICogci54LCBleHAyKCAtOS4yOCAqIE5vViApICkgKiByLnggKyByLnk7XFxuICB2ZWMyIEFCID0gdmVjMiggLTEuMDQsIDEuMDQgKSAqIGEwMDQgKyByLnp3O1xcbiAgQUIueSAqPSBjbGFtcCg1MC4wICogc3BlY3VsYXIuZywgMC4wLCAxLjApO1xcbiAgcmV0dXJuIHNwZWN1bGFyICogQUIueCArIEFCLnk7XFxufVxcbnZlYzMgQ2FsY0R5bmFtaWNMaWdodGluZyAodmVjMyB3b3JsZFBvcywgdmVjMyBOLCB2ZWMzIFYsIHZlYzMgZGlmZnVzZSwgdmVjMyBzcGVjdWxhciwgZmxvYXQgcm91Z2huZXNzKSB7XFxuICB2ZWMzIGxpZ2h0aW5nID0gdmVjMygwLjApO1xcbiAgdmVjMyBkaWZmdXNlQ29udHJpYiA9IGRpZmZ1c2UgLyAzLjE0MTU5MjY1MzU5O1xcbiAgZm9yIChpbnQgaSA9IDA7IGkgPCAyOyBpKyspIHtcXG4gICAgdmVjMyBQTFUgPSBjY19zcGhlcmVMaXRQb3NbaV0ueHl6IC0gd29ybGRQb3M7XFxuICAgIHZlYzMgUEwgPSBub3JtYWxpemUoUExVKTtcXG4gICAgdmVjMyBQSCA9IG5vcm1hbGl6ZShQTCArIFYpO1xcbiAgICBmbG9hdCBQTkwgPSBtYXgoZG90KE4sIFBMKSwgMC4wMDEpO1xcbiAgICBmbG9hdCBQTkggPSBtYXgoZG90KE4sIFBIKSwgMC4wKTtcXG4gICAgZmxvYXQgZGlzdFNxciA9IGRvdChQTFUsIFBMVSk7XFxuICAgIGZsb2F0IGxpdFJhZGl1cyA9IGNjX3NwaGVyZUxpdFNpemVSYW5nZVtpXS54O1xcbiAgICBmbG9hdCBsaXRSYWRpdXNTcXIgPSBsaXRSYWRpdXMgKiBsaXRSYWRpdXM7XFxuICAgIGZsb2F0IGlsbHVtID0gMy4xNDE1OTI2NTM1OSAqIChsaXRSYWRpdXNTcXIgLyBtYXgobGl0UmFkaXVzU3FyICwgZGlzdFNxcikpO1xcbiAgICBmbG9hdCBhdHRSYWRpdXNTcXJJbnYgPSAxLjAgLyBtYXgoY2Nfc3BoZXJlTGl0U2l6ZVJhbmdlW2ldLnksIDAuMDEpO1xcbiAgICBhdHRSYWRpdXNTcXJJbnYgKj0gYXR0UmFkaXVzU3FySW52O1xcbiAgICBmbG9hdCBhdHQgPSBHZXREaXN0QXR0KGRpc3RTcXIsIGF0dFJhZGl1c1Nxckludik7XFxuICAgIHZlYzMgbHNwZWMgPSBzcGVjdWxhciAqIENhbGNTcGVjdWxhcihyb3VnaG5lc3MsIFBOSCwgUEgsIE4pO1xcbiAgICBsaWdodGluZyArPSBQTkwgKiBjY19zcGhlcmVMaXRDb2xvcltpXS5yZ2IgKiBjY19zcGhlcmVMaXRDb2xvcltpXS53ICogaWxsdW0gKiBhdHQgKiAoZGlmZnVzZUNvbnRyaWIgKyBsc3BlYyk7XFxuICB9XFxuICBmb3IgKGludCBpID0gMDsgaSA8IDI7IGkrKykge1xcbiAgICB2ZWMzIFNMVSA9IGNjX3Nwb3RMaXRQb3NbaV0ueHl6IC0gd29ybGRQb3M7XFxuICAgIHZlYzMgU0wgPSBub3JtYWxpemUoU0xVKTtcXG4gICAgdmVjMyBTSCA9IG5vcm1hbGl6ZShTTCArIFYpO1xcbiAgICBmbG9hdCBTTkwgPSBtYXgoZG90KE4sIFNMKSwgMC4wMDEpO1xcbiAgICBmbG9hdCBTTkggPSBtYXgoZG90KE4sIFNIKSwgMC4wKTtcXG4gICAgZmxvYXQgZGlzdFNxciA9IGRvdChTTFUsIFNMVSk7XFxuICAgIGZsb2F0IGxpdFJhZGl1cyA9IGNjX3Nwb3RMaXRTaXplUmFuZ2VBbmdsZVtpXS54O1xcbiAgICBmbG9hdCBsaXRSYWRpdXNTcXIgPSBsaXRSYWRpdXMgKiBsaXRSYWRpdXM7XFxuICAgIGZsb2F0IGlsbHVtID0gMy4xNDE1OTI2NTM1OSAqIChsaXRSYWRpdXNTcXIgLyBtYXgobGl0UmFkaXVzU3FyICwgZGlzdFNxcikpO1xcbiAgICBmbG9hdCBhdHRSYWRpdXNTcXJJbnYgPSAxLjAgLyBtYXgoY2Nfc3BvdExpdFNpemVSYW5nZUFuZ2xlW2ldLnksIDAuMDEpO1xcbiAgICBhdHRSYWRpdXNTcXJJbnYgKj0gYXR0UmFkaXVzU3FySW52O1xcbiAgICBmbG9hdCBjb3NJbm5lciA9IG1heChkb3QoLWNjX3Nwb3RMaXREaXJbaV0ueHl6LCBTTCksIDAuMDEpO1xcbiAgICBmbG9hdCBjb3NPdXRlciA9IGNjX3Nwb3RMaXRTaXplUmFuZ2VBbmdsZVtpXS56O1xcbiAgICBmbG9hdCBsaXRBbmdsZVNjYWxlID0gMS4wIC8gbWF4KDAuMDAxLCBjb3NJbm5lciAtIGNvc091dGVyKTtcXG4gICAgZmxvYXQgbGl0QW5nbGVPZmZzZXQgPSAtY29zT3V0ZXIgKiBsaXRBbmdsZVNjYWxlO1xcbiAgICBmbG9hdCBhdHQgPSBHZXREaXN0QXR0KGRpc3RTcXIsIGF0dFJhZGl1c1Nxckludik7XFxuICAgIGF0dCAqPSBHZXRBbmdsZUF0dChTTCwgLWNjX3Nwb3RMaXREaXJbaV0ueHl6LCBsaXRBbmdsZVNjYWxlLCBsaXRBbmdsZU9mZnNldCk7XFxuICAgIHZlYzMgbHNwZWMgPSBzcGVjdWxhciAqIENhbGNTcGVjdWxhcihyb3VnaG5lc3MsIFNOSCwgU0gsIE4pO1xcbiAgICBsaWdodGluZyArPSBTTkwgKiBjY19zcG90TGl0Q29sb3JbaV0ucmdiICogY2Nfc3BvdExpdENvbG9yW2ldLncgKiBpbGx1bSAqIGF0dCAqIChkaWZmdXNlQ29udHJpYiArIGxzcGVjKTtcXG4gIH1cXG4gIHJldHVybiBsaWdodGluZztcXG59XFxuc3RydWN0IFN0YW5kYXJkU3VyZmFjZSB7XFxuICB2ZWM0IGFsYmVkbztcXG4gIHZlYzMgcG9zaXRpb247XFxuICB2ZWMzIG5vcm1hbDtcXG4gIHZlYzMgZW1pc3NpdmU7XFxuICBmbG9hdCByb3VnaG5lc3M7XFxuICBmbG9hdCBtZXRhbGxpYztcXG4gIGZsb2F0IG9jY2x1c2lvbjtcXG59O1xcbnZlYzQgQ0NTdGFuZGFyZFNoYWRpbmcgKFN0YW5kYXJkU3VyZmFjZSBzKSB7XFxuICB2ZWMzIGRpZmZ1c2UgPSBzLmFsYmVkby5yZ2IgKiAoMS4wIC0gcy5tZXRhbGxpYyk7XFxuICB2ZWMzIHNwZWN1bGFyID0gbWl4KHZlYzMoMC4wNCksIHMuYWxiZWRvLnJnYiwgcy5tZXRhbGxpYyk7XFxuICB2ZWMzIE4gPSBub3JtYWxpemUocy5ub3JtYWwpO1xcbiAgdmVjMyBWID0gbm9ybWFsaXplKGNjX2NhbWVyYVBvcy54eXogLSBzLnBvc2l0aW9uKTtcXG4gIHZlYzMgTCA9IG5vcm1hbGl6ZSgtY2NfbWFpbkxpdERpci54eXopO1xcbiAgdmVjMyBIID0gbm9ybWFsaXplKEwrVik7XFxuICBmbG9hdCBOViA9IG1heChhYnMoZG90KE4sIFYpKSwgMC4wMDEpO1xcbiAgZmxvYXQgTkwgPSBtYXgoZG90KE4sIEwpLCAwLjAwMSk7XFxuICBmbG9hdCBOSCA9IG1heChkb3QoTiwgSCksIDAuMCk7XFxuICBzcGVjdWxhciA9IEJSREZBcHByb3goc3BlY3VsYXIsIHMucm91Z2huZXNzLCBOVik7XFxuICB2ZWMzIGRpZmZ1c2VDb250cmliID0gZGlmZnVzZSAvIDMuMTQxNTkyNjUzNTk7XFxuICB2ZWMzIHNwZWN1bGFyQ29udHJpYiA9IHNwZWN1bGFyICogQ2FsY1NwZWN1bGFyKHMucm91Z2huZXNzLCBOSCwgSCwgTik7XFxuICB2ZWMzIGZpbmFsQ29sb3IgPSBOTCAqIGNjX21haW5MaXRDb2xvci5yZ2IgKiBjY19tYWluTGl0Q29sb3IudyAqIChkaWZmdXNlQ29udHJpYiArIHNwZWN1bGFyQ29udHJpYik7XFxuICBmaW5hbENvbG9yICs9IENhbGNEeW5hbWljTGlnaHRpbmcocy5wb3NpdGlvbiwgTiwgViwgZGlmZnVzZSwgc3BlY3VsYXIsIHMucm91Z2huZXNzKTtcXG4gIGZsb2F0IGZBbWIgPSAwLjUgLSBOLnkgKiAwLjU7XFxuICB2ZWMzIGFtYkRpZmYgPSBtaXgoY2NfYW1iaWVudFNreS5yZ2IsIGNjX2FtYmllbnRHcm91bmQucmdiLCBmQW1iKSAqIGNjX2FtYmllbnRTa3kudztcXG4gIGZpbmFsQ29sb3IgKz0gKGFtYkRpZmYucmdiICogZGlmZnVzZSk7XFxuICAjaWYgQ0NfVVNFX0lCTFxcbiAgICB2ZWMzIFIgPSBub3JtYWxpemUocmVmbGVjdCgtViwgTikpO1xcbiAgICB2ZWM0IGVudm1hcCA9IGZyYWdUZXh0dXJlTG9kKGNjX2Vudmlyb25tZW50LCBSLCBzLnJvdWdobmVzcyAqIGNjX2FtYmllbnRHcm91bmQudyk7XFxuICAgICNpZiBDQ19VU0VfSUJMID09IDJcXG4gICAgICB2ZWMzIGVudiA9IHVucGFja1JHQkUoZW52bWFwKTtcXG4gICAgI2Vsc2VcXG4gICAgICB2ZWMzIGVudiA9IFNSR0JUb0xpbmVhcihlbnZtYXAucmdiKTtcXG4gICAgI2VuZGlmXFxuICAgIGZpbmFsQ29sb3IgKz0gZW52ICogY2NfYW1iaWVudFNreS53ICogc3BlY3VsYXI7XFxuICAjZW5kaWZcXG4gIGZpbmFsQ29sb3IgPSBmaW5hbENvbG9yICogcy5vY2NsdXNpb247XFxuICAjaWYgQ0NfVVNFX0hEUlxcbiAgICBzLmVtaXNzaXZlICo9IGNjX2V4cG9zdXJlLnc7XFxuICAjZW5kaWZcXG4gIGZpbmFsQ29sb3IgKz0gcy5lbWlzc2l2ZTtcXG4gIHJldHVybiB2ZWM0KGZpbmFsQ29sb3IsIHMuYWxiZWRvLmEpO1xcbn1cXG52ZWMzIEFDRVNUb25lTWFwICh2ZWMzIGNvbG9yKSB7XFxuICBjb2xvciA9IG1pbihjb2xvciwgdmVjMyg4LjApKTtcXG4gIGNvbnN0IGZsb2F0IEEgPSAyLjUxO1xcbiAgY29uc3QgZmxvYXQgQiA9IDAuMDM7XFxuICBjb25zdCBmbG9hdCBDID0gMi40MztcXG4gIGNvbnN0IGZsb2F0IEQgPSAwLjU5O1xcbiAgY29uc3QgZmxvYXQgRSA9IDAuMTQ7XFxuICByZXR1cm4gKGNvbG9yICogKEEgKiBjb2xvciArIEIpKSAvIChjb2xvciAqIChDICogY29sb3IgKyBEKSArIEUpO1xcbn1cXG52ZWM0IENDRnJhZ091dHB1dCAodmVjNCBjb2xvcikge1xcbiAgI2lmICFDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IHNxcnQoQUNFU1RvbmVNYXAoY29sb3IucmdiKSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxudW5pZm9ybSB2ZWM0IGFsYmVkbztcXG51bmlmb3JtIHZlYzQgYWxiZWRvU2NhbGVBbmRDdXRvZmY7XFxudW5pZm9ybSB2ZWM0IHBiclBhcmFtcztcXG51bmlmb3JtIHZlYzQgZW1pc3NpdmU7XFxudW5pZm9ybSB2ZWM0IGVtaXNzaXZlU2NhbGVQYXJhbTtcXG52YXJ5aW5nIHZlYzMgdl9wb3NpdGlvbjtcXG52YXJ5aW5nIHZlYzIgdl91djtcXG52YXJ5aW5nIHZlYzIgdl91djE7XFxudmFyeWluZyB2ZWMzIHZfbm9ybWFsO1xcbiNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICB2YXJ5aW5nIHZlYzMgdl9jb2xvcjtcXG4jZW5kaWZcXG4jaWYgVVNFX0FMQkVET19NQVBcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGFsYmVkb01hcDtcXG4jZW5kaWZcXG4jaWYgVVNFX05PUk1BTF9NQVBcXG4gIHZhcnlpbmcgdmVjMyB2X3RhbmdlbnQ7XFxuICB2YXJ5aW5nIHZlYzMgdl9iaXRhbmdlbnQ7XFxuICB1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuI2VuZGlmXFxuI2lmIFVTRV9QQlJfTUFQXFxuICB1bmlmb3JtIHNhbXBsZXIyRCBwYnJNYXA7XFxuI2VuZGlmXFxuI2lmIFVTRV9NRVRBTExJQ19ST1VHSE5FU1NfTUFQXFxuICB1bmlmb3JtIHNhbXBsZXIyRCBtZXRhbGxpY1JvdWdobmVzc01hcDtcXG4jZW5kaWZcXG4jaWYgVVNFX09DQ0xVU0lPTl9NQVBcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIG9jY2x1c2lvbk1hcDtcXG4jZW5kaWZcXG4jaWYgVVNFX0VNSVNTSVZFX01BUFxcbiAgdW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVNYXA7XFxuI2VuZGlmXFxuI2lmIFVTRV9MSUdIVE1BUFxcbiAgdmFyeWluZyB2ZWMyIHZfbHV2O1xcbiAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfbGlnaHRpbmdNYXA7XFxuI2VuZGlmXFxuI2lmIFVTRV9BTFBIQV9URVNUXFxuI2VuZGlmXFxudm9pZCBzdXJmIChvdXQgU3RhbmRhcmRTdXJmYWNlIHMpIHtcXG4gIHZlYzQgYmFzZUNvbG9yID0gYWxiZWRvO1xcbiAgI2lmIFVTRV9WRVJURVhfQ09MT1JcXG4gICAgYmFzZUNvbG9yLnJnYiAqPSB2X2NvbG9yO1xcbiAgI2VuZGlmXFxuICAjaWYgVVNFX0FMQkVET19NQVBcXG4gICAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRChhbGJlZG9NYXAsIEFMQkVET19VVik7XFxuICAgIHRleENvbG9yLnJnYiA9IFNSR0JUb0xpbmVhcih0ZXhDb2xvci5yZ2IpO1xcbiAgICBiYXNlQ29sb3IgKj0gdGV4Q29sb3I7XFxuICAjZW5kaWZcXG4gIHMuYWxiZWRvID0gYmFzZUNvbG9yO1xcbiAgcy5hbGJlZG8ucmdiICo9IGFsYmVkb1NjYWxlQW5kQ3V0b2ZmLnh5ejtcXG4gICNpZiBVU0VfQUxQSEFfVEVTVFxcbiAgICBpZiAocy5hbGJlZG8uQUxQSEFfVEVTVF9DSEFOTkVMIDwgYWxiZWRvU2NhbGVBbmRDdXRvZmYudykgZGlzY2FyZDtcXG4gICNlbmRpZlxcbiAgcy5ub3JtYWwgPSB2X25vcm1hbDtcXG4gICNpZiBVU0VfTk9STUFMX01BUFxcbiAgICB2ZWMzIG5tbXAgPSB0ZXh0dXJlMkQobm9ybWFsTWFwLCBOT1JNQUxfVVYpLnh5eiAtIHZlYzMoMC41KTtcXG4gICAgcy5ub3JtYWwgPVxcbiAgICAgIChubW1wLnggKiBwYnJQYXJhbXMudykgKiBub3JtYWxpemUodl90YW5nZW50KSArXFxuICAgICAgKG5tbXAueSAqIHBiclBhcmFtcy53KSAqIG5vcm1hbGl6ZSh2X2JpdGFuZ2VudCkgK1xcbiAgICAgIG5tbXAueiAqIG5vcm1hbGl6ZShzLm5vcm1hbCk7XFxuICAjZW5kaWZcXG4gIHMucG9zaXRpb24gPSB2X3Bvc2l0aW9uO1xcbiAgdmVjNCBwYnIgPSBwYnJQYXJhbXM7XFxuICAjaWYgVVNFX1BCUl9NQVBcXG4gICAgdmVjNCByZXMgPSB0ZXh0dXJlMkQocGJyTWFwLCBQQlJfVVYpO1xcbiAgICBwYnIueCAqPSByZXMuT0NDTFVTSU9OX0NIQU5ORUw7XFxuICAgIHBici55ICo9IHJlcy5ST1VHSE5FU1NfQ0hBTk5FTDtcXG4gICAgcGJyLnogKj0gcmVzLk1FVEFMTElDX0NIQU5ORUw7XFxuICAjZW5kaWZcXG4gICNpZiBVU0VfTUVUQUxMSUNfUk9VR0hORVNTX01BUFxcbiAgICB2ZWM0IG1ldGFsbGljUm91Z2huZXNzID0gdGV4dHVyZTJEKG1ldGFsbGljUm91Z2huZXNzTWFwLCBNRVRBTExJQ19ST1VHSE5FU1NfVVYpO1xcbiAgICBwYnIueiAqPSBtZXRhbGxpY1JvdWdobmVzcy5NRVRBTExJQ19DSEFOTkVMO1xcbiAgICBwYnIueSAqPSBtZXRhbGxpY1JvdWdobmVzcy5ST1VHSE5FU1NfQ0hBTk5FTDtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9PQ0NMVVNJT05fTUFQXFxuICAgIHBici54ICo9IHRleHR1cmUyRChvY2NsdXNpb25NYXAsIE9DQ0xVU0lPTl9VVikuT0NDTFVTSU9OX0NIQU5ORUw7XFxuICAjZW5kaWZcXG4gIHMub2NjbHVzaW9uID0gY2xhbXAocGJyLngsIDAuMCwgMC45Nik7XFxuICBzLnJvdWdobmVzcyA9IGNsYW1wKHBici55LCAwLjA0LCAxLjApO1xcbiAgcy5tZXRhbGxpYyA9IHBici56O1xcbiAgcy5lbWlzc2l2ZSA9IGVtaXNzaXZlLnJnYiAqIGVtaXNzaXZlU2NhbGVQYXJhbS54eXo7XFxuICAjaWYgVVNFX0VNSVNTSVZFX01BUFxcbiAgICBzLmVtaXNzaXZlICo9IFNSR0JUb0xpbmVhcih0ZXh0dXJlMkQoZW1pc3NpdmVNYXAsIEVNSVNTSVZFX1VWKS5yZ2IpO1xcbiAgI2VuZGlmXFxufVxcbnZlYzQgZnJhZyAoKSB7XFxuICBTdGFuZGFyZFN1cmZhY2Ugczsgc3VyZihzKTtcXG4gIHZlYzQgY29sb3IgPSBDQ1N0YW5kYXJkU2hhZGluZyhzKTtcXG4gICNpZiBVU0VfTElHSFRNQVAgJiYgIVVTRV9CQVRDSElORyAmJiAhVVNFX0lOU1RBTkNJTkdcXG4gICAgdmVjNCBsaWdodGluZyA9IHRleHR1cmUyRChjY19saWdodGluZ01hcCwgdl9sdXYpO1xcbiAgICBmbG9hdCBmQW1iID0gMC41IC0gcy5ub3JtYWwueSAqIDAuNTtcXG4gICAgdmVjMyBhbWJEaWZmID0gbWl4KGNjX2FtYmllbnRTa3kucmdiLCBjY19hbWJpZW50R3JvdW5kLnJnYiwgZkFtYikgKiBjY19hbWJpZW50U2t5Lnc7XFxuICAgIHZlYzMgZmluYWxDb2xvciA9IChhbWJEaWZmLnJnYiAqIHMuYWxiZWRvLnJnYik7XFxuICAgIGZpbmFsQ29sb3IgKz0gbGlnaHRpbmcucmdiICogIHMuYWxiZWRvLnJnYjtcXG4gICAgZmluYWxDb2xvciA9IGZpbmFsQ29sb3IgKiBzLm9jY2x1c2lvbjtcXG4gICAgZmluYWxDb2xvciArPSBzLmVtaXNzaXZlO1xcbiAgICBjb2xvci5yZ2IgPSBsaWdodGluZy5hICogZmluYWxDb2xvciArICgxLjAgLSBsaWdodGluZy5hKSAqIGNvbG9yLnJnYjtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIENDRnJhZ091dHB1dChjb2xvcik7XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJidWlsdGluc1wiOiB7XHJcbiAgICAgICAgICBcImdsb2JhbHNcIjogeyBcImJsb2Nrc1wiOiBbeyBcIm5hbWVcIjogXCJDQ0dsb2JhbFwiLCBcImRlZmluZXNcIjogW10gfV0sIFwic2FtcGxlcnNcIjogW3sgXCJuYW1lXCI6IFwiY2NfZW52aXJvbm1lbnRcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9JQkxcIl0gfV0gfSxcclxuICAgICAgICAgIFwibG9jYWxzXCI6IHsgXCJibG9ja3NcIjogW3sgXCJuYW1lXCI6IFwiQ0NNb3JwaFwiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX01PUlBIXCJdIH0sIHsgXCJuYW1lXCI6IFwiQ0NTa2lubmluZ1RleHR1cmVcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9TS0lOTklOR1wiLCBcIkNDX1VTRV9CQUtFRF9BTklNQVRJT05cIl0gfSwgeyBcIm5hbWVcIjogXCJDQ1NraW5uaW5nQW5pbWF0aW9uXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfU0tJTk5JTkdcIiwgXCJDQ19VU0VfQkFLRURfQU5JTUFUSU9OXCJdIH0sIHsgXCJuYW1lXCI6IFwiQ0NTa2lubmluZ1wiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCIsIFwiIUNDX1VTRV9CQUtFRF9BTklNQVRJT05cIl0gfSwgeyBcIm5hbWVcIjogXCJDQ0xvY2FsQmF0Y2hlZFwiLCBcImRlZmluZXNcIjogW1wiIVVTRV9JTlNUQU5DSU5HXCIsIFwiVVNFX0JBVENISU5HXCJdIH0sIHsgXCJuYW1lXCI6IFwiQ0NMb2NhbFwiLCBcImRlZmluZXNcIjogW1wiIVVTRV9JTlNUQU5DSU5HXCIsIFwiIVVTRV9CQVRDSElOR1wiXSB9LCB7IFwibmFtZVwiOiBcIkNDRm9yd2FyZExpZ2h0XCIsIFwiZGVmaW5lc1wiOiBbXSB9XSwgXCJzYW1wbGVyc1wiOiBbeyBcIm5hbWVcIjogXCJjY19Qb3NpdGlvbkRpc3BsYWNlbWVudHNcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9NT1JQSFwiLCBcIkNDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cIl0gfSwgeyBcIm5hbWVcIjogXCJjY19Ob3JtYWxEaXNwbGFjZW1lbnRzXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfTU9SUEhcIiwgXCJDQ19NT1JQSF9UQVJHRVRfSEFTX05PUk1BTFwiXSB9LCB7IFwibmFtZVwiOiBcImNjX1RhbmdlbnREaXNwbGFjZW1lbnRzXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfTU9SUEhcIiwgXCJDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcIl0gfSwgeyBcIm5hbWVcIjogXCJjY19qb2ludFRleHR1cmVcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9TS0lOTklOR1wiLCBcIkNDX1VTRV9CQUtFRF9BTklNQVRJT05cIl0gfSwgeyBcIm5hbWVcIjogXCJjY19saWdodGluZ01hcFwiLCBcImRlZmluZXNcIjogW1wiVVNFX0xJR0hUTUFQXCJdIH1dIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGVmaW5lc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9NT1JQSFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfTU9SUEhfVEFSR0VUX0NPVU5UXCIsIFwidHlwZVwiOiBcIm51bWJlclwiLCBcInJhbmdlXCI6IFsyLCA4XSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19NT1JQSF9QUkVDT01QVVRFRFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfTU9SUEhfVEFSR0VUX0hBU19OT1JNQUxcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX01PUlBIX1RBUkdFVF9IQVNfVEFOR0VOVFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX1NLSU5OSU5HXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19VU0VfQkFLRURfQU5JTUFUSU9OXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJVU0VfSU5TVEFOQ0lOR1wiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfU1VQUE9SVF9GTE9BVF9URVhUVVJFXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJVU0VfQkFUQ0hJTkdcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9WRVJURVhfQ09MT1JcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9OT1JNQUxfTUFQXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJVU0VfTElHSFRNQVBcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkhBU19TRUNPTkRfVVZcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9JQkxcIiwgXCJ0eXBlXCI6IFwibnVtYmVyXCIsIFwicmFuZ2VcIjogWzAsIDJdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9IRFJcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9BTEJFRE9fTUFQXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJBTEJFRE9fVVZcIiwgXCJ0eXBlXCI6IFwic3RyaW5nXCIsIFwib3B0aW9uc1wiOiBbXCJ2X3V2XCIsIFwidl91djFcIl0gfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiTk9STUFMX1VWXCIsIFwidHlwZVwiOiBcInN0cmluZ1wiLCBcIm9wdGlvbnNcIjogW1widl91dlwiLCBcInZfdXYxXCJdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9QQlJfTUFQXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJQQlJfVVZcIiwgXCJ0eXBlXCI6IFwic3RyaW5nXCIsIFwib3B0aW9uc1wiOiBbXCJ2X3V2XCIsIFwidl91djFcIl0gfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiVVNFX01FVEFMTElDX1JPVUdITkVTU19NQVBcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIk1FVEFMTElDX1JPVUdITkVTU19VVlwiLCBcInR5cGVcIjogXCJzdHJpbmdcIiwgXCJvcHRpb25zXCI6IFtcInZfdXZcIiwgXCJ2X3V2MVwiXSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJVU0VfT0NDTFVTSU9OX01BUFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiT0NDTFVTSU9OX1VWXCIsIFwidHlwZVwiOiBcInN0cmluZ1wiLCBcIm9wdGlvbnNcIjogW1widl91dlwiLCBcInZfdXYxXCJdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9FTUlTU0lWRV9NQVBcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkVNSVNTSVZFX1VWXCIsIFwidHlwZVwiOiBcInN0cmluZ1wiLCBcIm9wdGlvbnNcIjogW1widl91dlwiLCBcInZfdXYxXCJdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIk9DQ0xVU0lPTl9DSEFOTkVMXCIsIFwidHlwZVwiOiBcInN0cmluZ1wiLCBcIm9wdGlvbnNcIjogW1wiclwiLCBcImdcIiwgXCJiXCJdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlJPVUdITkVTU19DSEFOTkVMXCIsIFwidHlwZVwiOiBcInN0cmluZ1wiLCBcIm9wdGlvbnNcIjogW1wiZ1wiLCBcImJcIiwgXCJyXCJdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIk1FVEFMTElDX0NIQU5ORUxcIiwgXCJ0eXBlXCI6IFwic3RyaW5nXCIsIFwib3B0aW9uc1wiOiBbXCJiXCIsIFwiclwiLCBcImdcIl0gfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiVVNFX0FMUEhBX1RFU1RcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkFMUEhBX1RFU1RfQ0hBTk5FTFwiLCBcInR5cGVcIjogXCJzdHJpbmdcIiwgXCJvcHRpb25zXCI6IFtcImFcIiwgXCJyXCJdIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiYmxvY2tzXCI6IFtcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJDb25zdGFudHNcIiwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMCwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJ0aWxpbmdPZmZzZXRcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfSxcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJhbGJlZG9cIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfSxcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJhbGJlZG9TY2FsZUFuZEN1dG9mZlwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInBiclBhcmFtc1wiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcImVtaXNzaXZlXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH0sXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZW1pc3NpdmVTY2FsZVBhcmFtXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxIH1cclxuICAgICAgICAgIF19XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcInNhbXBsZXJzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYWxiZWRvTWFwXCIsIFwidHlwZVwiOiAyOCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVVNFX0FMQkVET19NQVBcIl0sIFwiYmluZGluZ1wiOiAzMSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJub3JtYWxNYXBcIiwgXCJ0eXBlXCI6IDI4LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJVU0VfTk9STUFMX01BUFwiXSwgXCJiaW5kaW5nXCI6IDMyIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcInBick1hcFwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIlVTRV9QQlJfTUFQXCJdLCBcImJpbmRpbmdcIjogMzMgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwibWV0YWxsaWNSb3VnaG5lc3NNYXBcIiwgXCJ0eXBlXCI6IDI4LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJVU0VfTUVUQUxMSUNfUk9VR0hORVNTX01BUFwiXSwgXCJiaW5kaW5nXCI6IDM0IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIm9jY2x1c2lvbk1hcFwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIlVTRV9PQ0NMVVNJT05fTUFQXCJdLCBcImJpbmRpbmdcIjogMzUgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZW1pc3NpdmVNYXBcIiwgXCJ0eXBlXCI6IDI4LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJVU0VfRU1JU1NJVkVfTUFQXCJdLCBcImJpbmRpbmdcIjogMzYgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9wb3NpdGlvblwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiAwIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfbm9ybWFsXCIsIFwidHlwZVwiOiAxNSwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwiZm9ybWF0XCI6IDMyLCBcImxvY2F0aW9uXCI6IDEgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV90YW5nZW50XCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwiZm9ybWF0XCI6IDQzLCBcImxvY2F0aW9uXCI6IDIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV92ZXJ0ZXhJZFwiLCBcInR5cGVcIjogMTMsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9NT1JQSFwiXSwgXCJmb3JtYXRcIjogMTEsIFwibG9jYXRpb25cIjogMyB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3dlaWdodHNcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfU0tJTk5JTkdcIl0sIFwiZm9ybWF0XCI6IDQzLCBcImxvY2F0aW9uXCI6IDQgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9qb2ludHNcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfU0tJTk5JTkdcIl0sIFwiZm9ybWF0XCI6IDQzLCBcImxvY2F0aW9uXCI6IDUgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9qb2ludEFuaW1JbmZvXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcInByZWNpc2lvblwiOiBcImhpZ2hwIFwiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCIsIFwiQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlwiLCBcIlVTRV9JTlNUQU5DSU5HXCJdLCBcImZvcm1hdFwiOiA0MywgXCJpc0luc3RhbmNlZFwiOiB0cnVlLCBcImxvY2F0aW9uXCI6IDYgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9tYXRXb3JsZDBcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJVU0VfSU5TVEFOQ0lOR1wiXSwgXCJmb3JtYXRcIjogNDMsIFwiaXNJbnN0YW5jZWRcIjogdHJ1ZSwgXCJsb2NhdGlvblwiOiA3IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfbWF0V29ybGQxXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVVNFX0lOU1RBTkNJTkdcIl0sIFwiZm9ybWF0XCI6IDQzLCBcImlzSW5zdGFuY2VkXCI6IHRydWUsIFwibG9jYXRpb25cIjogOCB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX21hdFdvcmxkMlwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIlVTRV9JTlNUQU5DSU5HXCJdLCBcImZvcm1hdFwiOiA0MywgXCJpc0luc3RhbmNlZFwiOiB0cnVlLCBcImxvY2F0aW9uXCI6IDkgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9keW5fYmF0Y2hfaWRcIiwgXCJ0eXBlXCI6IDEzLCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCIhVVNFX0lOU1RBTkNJTkdcIiwgXCJVU0VfQkFUQ0hJTkdcIl0sIFwiZm9ybWF0XCI6IDExLCBcImxvY2F0aW9uXCI6IDEwIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfY29sb3JcIiwgXCJ0eXBlXCI6IDE1LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJVU0VfVkVSVEVYX0NPTE9SXCJdLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiAxMSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX3RleENvb3JkXCIsIFwidHlwZVwiOiAxNCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwiZm9ybWF0XCI6IDIxLCBcImxvY2F0aW9uXCI6IDEyIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfdGV4Q29vcmQxXCIsIFwidHlwZVwiOiAxNCwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwiZm9ybWF0XCI6IDIxLCBcImxvY2F0aW9uXCI6IDEzIH1cclxuICAgICAgICBdXHJcbiAgICAgIH1cclxuICAgIF1cclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcImJ1aWx0aW4tdGVycmFpblwiLFxyXG4gICAgXCJfdXVpZFwiOiBcIjFkMDhlZjYyLWE1MDMtNGNlMi04YjlhLTQ2YzkwODczZjdkM1wiLFxyXG4gICAgXCJ0ZWNobmlxdWVzXCI6IFtcclxuICAgICAgeyBcIm5hbWVcIjogXCJvcGFxdWVcIiwgXCJwYXNzZXNcIjogW3sgXCJwcm9ncmFtXCI6IFwiYnVpbHRpbi10ZXJyYWlufHRlcnJhaW4tdnM6dmVydHx0ZXJyYWluLWZzOmZyYWdcIiwgXCJwcm9wZXJ0aWVzXCI6IHsgXCJVVlNjYWxlXCI6IHsgXCJ2YWx1ZVwiOiBbMSwgMSwgMSwgMV0sIFwidHlwZVwiOiAxNiB9LCBcImxpZ2h0TWFwVVZQYXJhbVwiOiB7IFwidmFsdWVcIjogWzAsIDAsIDAsIDBdLCBcInR5cGVcIjogMTYgfSwgXCJ3ZWlnaHRNYXBcIjogeyBcInZhbHVlXCI6IFwiYmxhY2tcIiwgXCJ0eXBlXCI6IDI4IH0sIFwiZGV0YWlsTWFwMFwiOiB7IFwidmFsdWVcIjogXCJncmV5XCIsIFwidHlwZVwiOiAyOCB9LCBcImRldGFpbE1hcDFcIjogeyBcInZhbHVlXCI6IFwiZ3JleVwiLCBcInR5cGVcIjogMjggfSwgXCJkZXRhaWxNYXAyXCI6IHsgXCJ2YWx1ZVwiOiBcImdyZXlcIiwgXCJ0eXBlXCI6IDI4IH0sIFwiZGV0YWlsTWFwM1wiOiB7IFwidmFsdWVcIjogXCJncmV5XCIsIFwidHlwZVwiOiAyOCB9LCBcImxpZ2h0TWFwXCI6IHsgXCJ2YWx1ZVwiOiBcImdyZXlcIiwgXCJ0eXBlXCI6IDI4IH0gfSB9XSB9XHJcbiAgICBdLFxyXG4gICAgXCJzaGFkZXJzXCI6IFtcclxuICAgICAge1xyXG4gICAgICAgIFwibmFtZVwiOiBcImJ1aWx0aW4tdGVycmFpbnx0ZXJyYWluLXZzOnZlcnR8dGVycmFpbi1mczpmcmFnXCIsXHJcbiAgICAgICAgXCJoYXNoXCI6IDI5NDkzODUxLFxyXG4gICAgICAgIFwiZ2xzbDNcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG4gIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG59O1xcbnVuaWZvcm0gQ0NMb2NhbCB7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkO1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZElUO1xcbiAgaGlnaHAgdmVjNCBjY19saWdodGluZ01hcFVWUGFyYW07XFxufTtcXG4gIGluIHZlYzMgYV9wb3NpdGlvbjtcXG4gIGluIHZlYzMgYV9ub3JtYWw7XFxuICBpbiB2ZWMyIGFfdGV4Q29vcmQ7XFxuICBvdXQgdmVjMiB1dnc7XFxuICBvdXQgdmVjMiB1djA7XFxuICBvdXQgdmVjMiB1djE7XFxuICBvdXQgdmVjMiB1djI7XFxuICBvdXQgdmVjMiB1djM7XFxuICBvdXQgdmVjMiBsdXY7XFxuICBvdXQgdmVjMyBkaWZmdXNlO1xcbiAgdW5pZm9ybSBUZXhDb29yZHMge1xcbiAgICB2ZWM0IFVWU2NhbGU7XFxuICAgIHZlYzQgbGlnaHRNYXBVVlBhcmFtO1xcbiAgfTtcXG4gIHZlYzQgdmVydCAoKSB7XFxuICAgIHZlYzMgd29ybGRQb3M7XFxuICAgIHdvcmxkUG9zLnggPSBjY19tYXRXb3JsZFszXVswXSArIGFfcG9zaXRpb24ueDtcXG4gICAgd29ybGRQb3MueSA9IGNjX21hdFdvcmxkWzNdWzFdICsgYV9wb3NpdGlvbi55O1xcbiAgICB3b3JsZFBvcy56ID0gY2NfbWF0V29ybGRbM11bMl0gKyBhX3Bvc2l0aW9uLno7XFxuICAgIHZlYzQgcG9zID0gdmVjNCh3b3JsZFBvcywgMSk7XFxuICAgIHBvcyA9IGNjX21hdFZpZXdQcm9qICogcG9zO1xcbiAgICB1dncgPSBhX3RleENvb3JkO1xcbiAgICB1djAgPSBhX3Bvc2l0aW9uLnh6ICogVVZTY2FsZS54O1xcbiAgICB1djEgPSBhX3Bvc2l0aW9uLnh6ICogVVZTY2FsZS55O1xcbiAgICB1djIgPSBhX3Bvc2l0aW9uLnh6ICogVVZTY2FsZS56O1xcbiAgICB1djMgPSBhX3Bvc2l0aW9uLnh6ICogVVZTY2FsZS53O1xcbiAgICBmbG9hdCBmQW1iID0gZG90KGFfbm9ybWFsLCB2ZWMzKDAuMCwgLTEuMCwgMC4wKSkgKiAwLjUgKyAwLjU7XFxuICAgIHZlYzMgYW1iRGlmZiA9IG1peChjY19hbWJpZW50U2t5LnJnYiwgY2NfYW1iaWVudEdyb3VuZC5yZ2IsIGZBbWIpICogY2NfYW1iaWVudFNreS53O1xcbiNpZiBMSUdIVF9NQVAgPT0gMFxcbiAgICB2ZWMzIEwgPSBub3JtYWxpemUoLWNjX21haW5MaXREaXIueHl6KTtcXG4gICAgdmVjMyBOID0gYV9ub3JtYWw7XFxuICAgIGRpZmZ1c2UgPSBhbWJEaWZmICsgdmVjMyhkb3QoTiwgTCkpICogY2NfbWFpbkxpdENvbG9yLnJnYjtcXG4jZWxzZVxcbiAgICBkaWZmdXNlID0gYW1iRGlmZjtcXG4gICAgbHV2ID0gbGlnaHRNYXBVVlBhcmFtLnh5ICsgYV90ZXhDb29yZCAqIGxpZ2h0TWFwVVZQYXJhbS56dztcXG4jZW5kaWZcXG4gICAgcmV0dXJuIHBvcztcXG4gIH1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdmVydCgpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbn07XFxudmVjMyBTUkdCVG9MaW5lYXIgKHZlYzMgZ2FtbWEpIHtcXG4gIHJldHVybiBnYW1tYSAqIGdhbW1hO1xcbn1cXG52ZWM0IENDRnJhZ091dHB1dCAodmVjNCBjb2xvcikge1xcbiAgI2lmIENDX1VTRV9IRFJcXG4gICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgU1JHQlRvTGluZWFyKGNvbG9yLnJnYikgKiBjY19leHBvc3VyZS53LCB2ZWMzKGNjX2V4cG9zdXJlLnopKTtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIGNvbG9yO1xcbn1cXG4gIGluIHZlYzIgdXZ3O1xcbiAgaW4gdmVjMiB1djA7XFxuICBpbiB2ZWMyIHV2MTtcXG4gIGluIHZlYzIgdXYyO1xcbiAgaW4gdmVjMiB1djM7XFxuICBpbiB2ZWMzIGRpZmZ1c2U7XFxuICBpbiB2ZWMyIGx1djtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHdlaWdodE1hcDtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGRldGFpbE1hcDA7XFxuICB1bmlmb3JtIHNhbXBsZXIyRCBkZXRhaWxNYXAxO1xcbiAgdW5pZm9ybSBzYW1wbGVyMkQgZGV0YWlsTWFwMjtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGRldGFpbE1hcDM7XFxuICB1bmlmb3JtIHNhbXBsZXIyRCBsaWdodE1hcDtcXG52ZWM0IGZyYWcgKCkge1xcbiAgdmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuICAjaWYgTEFZRVJTID09IDFcXG4gICAgY29sb3IgPSB0ZXh0dXJlKGRldGFpbE1hcDAsIHV2MCk7XFxuICAjZWxpZiBMQVlFUlMgPT0gMlxcbiAgICB2ZWM0IHcgPSB0ZXh0dXJlKHdlaWdodE1hcCwgdXZ3KTtcXG4gICAgY29sb3IgKz0gdGV4dHVyZShkZXRhaWxNYXAwLCB1djApICogdy5yO1xcbiAgICBjb2xvciArPSB0ZXh0dXJlKGRldGFpbE1hcDEsIHV2MSkgKiB3Lmc7XFxuICAjZWxpZiBMQVlFUlMgPT0gM1xcbiAgICB2ZWM0IHcgPSB0ZXh0dXJlKHdlaWdodE1hcCwgdXZ3KTtcXG4gICAgY29sb3IgKz0gdGV4dHVyZShkZXRhaWxNYXAwLCB1djApICogdy5yO1xcbiAgICBjb2xvciArPSB0ZXh0dXJlKGRldGFpbE1hcDEsIHV2MSkgKiB3Lmc7XFxuICAgIGNvbG9yICs9IHRleHR1cmUoZGV0YWlsTWFwMiwgdXYyKSAqIHcuYjtcXG4gICNlbGlmIExBWUVSUyA9PSA0XFxuICAgIHZlYzQgdyA9IHRleHR1cmUod2VpZ2h0TWFwLCB1dncpO1xcbiAgICBjb2xvciArPSB0ZXh0dXJlKGRldGFpbE1hcDAsIHV2MCkgKiB3LnI7XFxuICAgIGNvbG9yICs9IHRleHR1cmUoZGV0YWlsTWFwMSwgdXYxKSAqIHcuZztcXG4gICAgY29sb3IgKz0gdGV4dHVyZShkZXRhaWxNYXAyLCB1djIpICogdy5iO1xcbiAgICBjb2xvciArPSB0ZXh0dXJlKGRldGFpbE1hcDMsIHV2MykgKiB3LmE7XFxuICAjZWxzZVxcbiAgICBjb2xvciA9IHRleHR1cmUoZGV0YWlsTWFwMCwgdXYwKTtcXG4gICNlbmRpZlxcbiAgdmVjMyBsaWdodGluZyA9IGRpZmZ1c2U7XFxuICAjaWYgTElHSFRfTUFQID09IDFcXG4gICAgbGlnaHRpbmcgKz0gdGV4dHVyZShsaWdodE1hcCwgbHV2KS5yZ2I7XFxuICAjZW5kaWZcXG4gIGNvbG9yLnJnYiAqPSBsaWdodGluZztcXG4gIHJldHVybiBDQ0ZyYWdPdXRwdXQoY29sb3IpO1xcbn1cXG5vdXQgdmVjNCBjY19GcmFnQ29sb3I7XFxudm9pZCBtYWluKCkgeyBjY19GcmFnQ29sb3IgPSBmcmFnKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImdsc2wxXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxuICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG51bmlmb3JtIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG51bmlmb3JtIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG4gIGF0dHJpYnV0ZSB2ZWMzIGFfcG9zaXRpb247XFxuICBhdHRyaWJ1dGUgdmVjMyBhX25vcm1hbDtcXG4gIGF0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7XFxuICB2YXJ5aW5nIHZlYzIgdXZ3O1xcbiAgdmFyeWluZyB2ZWMyIHV2MDtcXG4gIHZhcnlpbmcgdmVjMiB1djE7XFxuICB2YXJ5aW5nIHZlYzIgdXYyO1xcbiAgdmFyeWluZyB2ZWMyIHV2MztcXG4gIHZhcnlpbmcgdmVjMiBsdXY7XFxuICB2YXJ5aW5nIHZlYzMgZGlmZnVzZTtcXG4gIHVuaWZvcm0gdmVjNCBVVlNjYWxlO1xcbnVuaWZvcm0gdmVjNCBsaWdodE1hcFVWUGFyYW07XFxuICB2ZWM0IHZlcnQgKCkge1xcbiAgICB2ZWMzIHdvcmxkUG9zO1xcbiAgICB3b3JsZFBvcy54ID0gY2NfbWF0V29ybGRbM11bMF0gKyBhX3Bvc2l0aW9uLng7XFxuICAgIHdvcmxkUG9zLnkgPSBjY19tYXRXb3JsZFszXVsxXSArIGFfcG9zaXRpb24ueTtcXG4gICAgd29ybGRQb3MueiA9IGNjX21hdFdvcmxkWzNdWzJdICsgYV9wb3NpdGlvbi56O1xcbiAgICB2ZWM0IHBvcyA9IHZlYzQod29ybGRQb3MsIDEpO1xcbiAgICBwb3MgPSBjY19tYXRWaWV3UHJvaiAqIHBvcztcXG4gICAgdXZ3ID0gYV90ZXhDb29yZDtcXG4gICAgdXYwID0gYV9wb3NpdGlvbi54eiAqIFVWU2NhbGUueDtcXG4gICAgdXYxID0gYV9wb3NpdGlvbi54eiAqIFVWU2NhbGUueTtcXG4gICAgdXYyID0gYV9wb3NpdGlvbi54eiAqIFVWU2NhbGUuejtcXG4gICAgdXYzID0gYV9wb3NpdGlvbi54eiAqIFVWU2NhbGUudztcXG4gICAgZmxvYXQgZkFtYiA9IGRvdChhX25vcm1hbCwgdmVjMygwLjAsIC0xLjAsIDAuMCkpICogMC41ICsgMC41O1xcbiAgICB2ZWMzIGFtYkRpZmYgPSBtaXgoY2NfYW1iaWVudFNreS5yZ2IsIGNjX2FtYmllbnRHcm91bmQucmdiLCBmQW1iKSAqIGNjX2FtYmllbnRTa3kudztcXG4jaWYgTElHSFRfTUFQID09IDBcXG4gICAgdmVjMyBMID0gbm9ybWFsaXplKC1jY19tYWluTGl0RGlyLnh5eik7XFxuICAgIHZlYzMgTiA9IGFfbm9ybWFsO1xcbiAgICBkaWZmdXNlID0gYW1iRGlmZiArIHZlYzMoZG90KE4sIEwpKSAqIGNjX21haW5MaXRDb2xvci5yZ2I7XFxuI2Vsc2VcXG4gICAgZGlmZnVzZSA9IGFtYkRpZmY7XFxuICAgIGx1diA9IGxpZ2h0TWFwVVZQYXJhbS54eSArIGFfdGV4Q29vcmQgKiBsaWdodE1hcFVWUGFyYW0uenc7XFxuI2VuZGlmXFxuICAgIHJldHVybiBwb3M7XFxuICB9XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZlcnQoKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiBDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIFNSR0JUb0xpbmVhcihjb2xvci5yZ2IpICogY2NfZXhwb3N1cmUudywgdmVjMyhjY19leHBvc3VyZS56KSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxuICB2YXJ5aW5nIHZlYzIgdXZ3O1xcbiAgdmFyeWluZyB2ZWMyIHV2MDtcXG4gIHZhcnlpbmcgdmVjMiB1djE7XFxuICB2YXJ5aW5nIHZlYzIgdXYyO1xcbiAgdmFyeWluZyB2ZWMyIHV2MztcXG4gIHZhcnlpbmcgdmVjMyBkaWZmdXNlO1xcbiAgdmFyeWluZyB2ZWMyIGx1djtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHdlaWdodE1hcDtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGRldGFpbE1hcDA7XFxuICB1bmlmb3JtIHNhbXBsZXIyRCBkZXRhaWxNYXAxO1xcbiAgdW5pZm9ybSBzYW1wbGVyMkQgZGV0YWlsTWFwMjtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGRldGFpbE1hcDM7XFxuICB1bmlmb3JtIHNhbXBsZXIyRCBsaWdodE1hcDtcXG52ZWM0IGZyYWcgKCkge1xcbiAgdmVjNCBjb2xvciA9IHZlYzQoMCwgMCwgMCwgMCk7XFxuICAjaWYgTEFZRVJTID09IDFcXG4gICAgY29sb3IgPSB0ZXh0dXJlMkQoZGV0YWlsTWFwMCwgdXYwKTtcXG4gICNlbGlmIExBWUVSUyA9PSAyXFxuICAgIHZlYzQgdyA9IHRleHR1cmUyRCh3ZWlnaHRNYXAsIHV2dyk7XFxuICAgIGNvbG9yICs9IHRleHR1cmUyRChkZXRhaWxNYXAwLCB1djApICogdy5yO1xcbiAgICBjb2xvciArPSB0ZXh0dXJlMkQoZGV0YWlsTWFwMSwgdXYxKSAqIHcuZztcXG4gICNlbGlmIExBWUVSUyA9PSAzXFxuICAgIHZlYzQgdyA9IHRleHR1cmUyRCh3ZWlnaHRNYXAsIHV2dyk7XFxuICAgIGNvbG9yICs9IHRleHR1cmUyRChkZXRhaWxNYXAwLCB1djApICogdy5yO1xcbiAgICBjb2xvciArPSB0ZXh0dXJlMkQoZGV0YWlsTWFwMSwgdXYxKSAqIHcuZztcXG4gICAgY29sb3IgKz0gdGV4dHVyZTJEKGRldGFpbE1hcDIsIHV2MikgKiB3LmI7XFxuICAjZWxpZiBMQVlFUlMgPT0gNFxcbiAgICB2ZWM0IHcgPSB0ZXh0dXJlMkQod2VpZ2h0TWFwLCB1dncpO1xcbiAgICBjb2xvciArPSB0ZXh0dXJlMkQoZGV0YWlsTWFwMCwgdXYwKSAqIHcucjtcXG4gICAgY29sb3IgKz0gdGV4dHVyZTJEKGRldGFpbE1hcDEsIHV2MSkgKiB3Lmc7XFxuICAgIGNvbG9yICs9IHRleHR1cmUyRChkZXRhaWxNYXAyLCB1djIpICogdy5iO1xcbiAgICBjb2xvciArPSB0ZXh0dXJlMkQoZGV0YWlsTWFwMywgdXYzKSAqIHcuYTtcXG4gICNlbHNlXFxuICAgIGNvbG9yID0gdGV4dHVyZTJEKGRldGFpbE1hcDAsIHV2MCk7XFxuICAjZW5kaWZcXG4gIHZlYzMgbGlnaHRpbmcgPSBkaWZmdXNlO1xcbiAgI2lmIExJR0hUX01BUCA9PSAxXFxuICAgIGxpZ2h0aW5nICs9IHRleHR1cmUyRChsaWdodE1hcCwgbHV2KS5yZ2I7XFxuICAjZW5kaWZcXG4gIGNvbG9yLnJnYiAqPSBsaWdodGluZztcXG4gIHJldHVybiBDQ0ZyYWdPdXRwdXQoY29sb3IpO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX0ZyYWdDb2xvciA9IGZyYWcoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiYnVpbHRpbnNcIjoge1xyXG4gICAgICAgICAgXCJnbG9iYWxzXCI6IHsgXCJibG9ja3NcIjogW3sgXCJuYW1lXCI6IFwiQ0NHbG9iYWxcIiwgXCJkZWZpbmVzXCI6IFtdIH1dLCBcInNhbXBsZXJzXCI6IFtdIH0sXHJcbiAgICAgICAgICBcImxvY2Fsc1wiOiB7IFwiYmxvY2tzXCI6IFt7IFwibmFtZVwiOiBcIkNDTG9jYWxcIiwgXCJkZWZpbmVzXCI6IFtdIH1dLCBcInNhbXBsZXJzXCI6IFtdIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGVmaW5lc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkxJR0hUX01BUFwiLCBcInR5cGVcIjogXCJudW1iZXJcIiwgXCJyYW5nZVwiOiBbMCwgM10gfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX0hEUlwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiTEFZRVJTXCIsIFwidHlwZVwiOiBcIm51bWJlclwiLCBcInJhbmdlXCI6IFswLCA0XSB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcImJsb2Nrc1wiOiBbXHJcbiAgICAgICAgICB7XCJuYW1lXCI6IFwiVGV4Q29vcmRzXCIsIFwiZGVmaW5lc1wiOiBbXSwgXCJiaW5kaW5nXCI6IDAsIFwibWVtYmVyc1wiOiBbXHJcbiAgICAgICAgICAgIHsgXCJuYW1lXCI6IFwiVVZTY2FsZVwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcImxpZ2h0TWFwVVZQYXJhbVwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9XHJcbiAgICAgICAgICBdfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJzYW1wbGVyc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIndlaWdodE1hcFwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMzEgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZGV0YWlsTWFwMFwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMzIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZGV0YWlsTWFwMVwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMzMgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZGV0YWlsTWFwMlwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMzQgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZGV0YWlsTWFwM1wiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMzUgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwibGlnaHRNYXBcIiwgXCJ0eXBlXCI6IDI4LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJiaW5kaW5nXCI6IDM2IH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiYXR0cmlidXRlc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfcG9zaXRpb25cIiwgXCJ0eXBlXCI6IDE1LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMCB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX25vcm1hbFwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiAxIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfdGV4Q29vcmRcIiwgXCJ0eXBlXCI6IDE0LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJmb3JtYXRcIjogMjEsIFwibG9jYXRpb25cIjogMiB9XHJcbiAgICAgICAgXVxyXG4gICAgICB9XHJcbiAgICBdXHJcbiAgfSxcclxuICB7XHJcbiAgICBcIm5hbWVcIjogXCJidWlsdGluLXVubGl0XCIsXHJcbiAgICBcIl91dWlkXCI6IFwiYTNjZDAwOWYtMGFiMC00MjBkLTkyNzgtYjlmZGFiOTM5YmJjXCIsXHJcbiAgICBcInRlY2huaXF1ZXNcIjogW1xyXG4gICAgICB7IFwibmFtZVwiOiBcIm9wYXF1ZVwiLCBcInBhc3Nlc1wiOiBbeyBcInByb2dyYW1cIjogXCJidWlsdGluLXVubGl0fHVubGl0LXZzOnZlcnR8dW5saXQtZnM6ZnJhZ1wiLCBcInByb3BlcnRpZXNcIjogeyBcIm1haW5UZXh0dXJlXCI6IHsgXCJ2YWx1ZVwiOiBcImdyZXlcIiwgXCJ0eXBlXCI6IDI4IH0sIFwidGlsaW5nT2Zmc2V0XCI6IHsgXCJ2YWx1ZVwiOiBbMSwgMSwgMCwgMF0sIFwidHlwZVwiOiAxNiB9LCBcIm1haW5Db2xvclwiOiB7IFwidmFsdWVcIjogWzEsIDEsIDEsIDFdLCBcInR5cGVcIjogMTYgfSwgXCJjb2xvclNjYWxlXCI6IHsgXCJ2YWx1ZVwiOiBbMSwgMSwgMV0sIFwidHlwZVwiOiAxNSwgXCJoYW5kbGVJbmZvXCI6IFtcImNvbG9yU2NhbGVBbmRDdXRvZmZcIiwgMCwgMTVdIH0sIFwiYWxwaGFUaHJlc2hvbGRcIjogeyBcInZhbHVlXCI6IFswLjVdLCBcInR5cGVcIjogMTMsIFwiaGFuZGxlSW5mb1wiOiBbXCJjb2xvclNjYWxlQW5kQ3V0b2ZmXCIsIDMsIDEzXSB9LCBcImNvbG9yXCI6IHsgXCJ0eXBlXCI6IDE2LCBcImhhbmRsZUluZm9cIjogW1wibWFpbkNvbG9yXCIsIDAsIDE2XSB9LCBcImNvbG9yU2NhbGVBbmRDdXRvZmZcIjogeyBcInR5cGVcIjogMTYsIFwidmFsdWVcIjogWzEsIDEsIDEsIDAuNV0gfSB9IH1dIH1cclxuICAgIF0sXHJcbiAgICBcInNoYWRlcnNcIjogW1xyXG4gICAgICB7XHJcbiAgICAgICAgXCJuYW1lXCI6IFwiYnVpbHRpbi11bmxpdHx1bmxpdC12czp2ZXJ0fHVubGl0LWZzOmZyYWdcIixcclxuICAgICAgICBcImhhc2hcIjogMjExMzcyNTc3MSxcclxuICAgICAgICBcImdsc2wzXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbnN0cnVjdCBTdGFuZGFyZFZlcnRJbnB1dCB7XFxuICBoaWdocCB2ZWM0IHBvc2l0aW9uO1xcbiAgdmVjMyBub3JtYWw7XFxuICB2ZWM0IHRhbmdlbnQ7XFxufTtcXG5pbiB2ZWMzIGFfcG9zaXRpb247XFxuI2lmIENDX1VTRV9NT1JQSFxcbiAgICBpbiBmbG9hdCBhX3ZlcnRleElkO1xcbiAgICBpbnQgZ2V0VmVydGV4SWQoKSB7XFxuICAgICAgICByZXR1cm4gaW50KGFfdmVydGV4SWQpO1xcbiAgICB9XFxudW5pZm9ybSBDQ01vcnBoIHtcXG4gICAgdmVjNCBjY19kaXNwbGFjZW1lbnRXZWlnaHRzWzE1XTtcXG4gICAgdmVjNCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mbztcXG59O1xcbiAgICB2ZWM0IGZldGNoRmxhdFBpeGVsKHNhbXBsZXIyRCB0ZXgsIGludCBwaXhlbEluZGV4KSB7XFxuICAgICAgICBmbG9hdCBwaXhlbEluZGV4RiA9IGZsb2F0KHBpeGVsSW5kZXgpO1xcbiAgICAgICAgdmVjMiB0ZXh0dXJlUmVzb2x1dGlvbiA9IHZlYzIoZmxvYXQoY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm8ueCksIGZsb2F0KGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLnkpKTtcXG4gICAgICAgIGZsb2F0IHBpeGVsWCA9IG1vZChwaXhlbEluZGV4RiwgdGV4dHVyZVJlc29sdXRpb24ueCk7XFxuICAgICAgICBmbG9hdCBwaXhlbFkgPSBmbG9vcihwaXhlbEluZGV4RiAvIHRleHR1cmVSZXNvbHV0aW9uLngpO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHBpeGVsWCwgcGl4ZWxZKSArIC41KSAvIHRleHR1cmVSZXNvbHV0aW9uO1xcbiAgICAgICAgcmV0dXJuIHRleHR1cmUodGV4LCB1dik7XFxuICAgIH1cXG5mbG9hdCBnZXREaXNwbGFjZW1lbnRXZWlnaHQoaW50IGluZGV4KSB7XFxuICAgIGZsb2F0IG0gPSBtb2QoZmxvYXQoaW5kZXgpLCA0LjApO1xcbiAgICBpZiAobSA8IDEuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS54O1xcbiAgICB9IGVsc2UgaWYgKG0gPCAyLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0ueTtcXG4gICAgfSBlbHNlIGlmIChtIDwgMy4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLno7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLnc7XFxuICAgIH1cXG59XFxudmVjMyBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoc2FtcGxlcjJEIHRleCwgaW50IHZlcnRleEluZGV4KSB7XFxuI2lmIENDX01PUlBIX1BSRUNPTVBVVEVEXFxuICAgIHJldHVybiBmZXRjaEZsYXRQaXhlbCh0ZXgsIHZlcnRleEluZGV4KS5yZ2I7XFxuI2Vsc2VcXG4gICAgdmVjMyByZXN1bHQgPSB2ZWMzKDAsIDAsIDApO1xcbiAgICBmb3IgKGludCBpVGFyZ2V0ID0gMDsgaVRhcmdldCA8IENDX01PUlBIX1RBUkdFVF9DT1VOVDsgKytpVGFyZ2V0KSB7XFxuICAgICAgICBpbnQgZGF0YVBpeGVsU3RhcnQgPSBpbnQoZmV0Y2hGbGF0UGl4ZWwodGV4LCBpVGFyZ2V0KS5yKTtcXG4gICAgICAgIHJlc3VsdCArPSAoZmV0Y2hGbGF0UGl4ZWwodGV4LCBkYXRhUGl4ZWxTdGFydCArIHZlcnRleEluZGV4KS5yZ2IgKiBnZXREaXNwbGFjZW1lbnRXZWlnaHQoaVRhcmdldCkpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxuI2VuZGlmXFxufVxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGNjX1Bvc2l0aW9uRGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfUG9zaXRpb25EaXNwbGFjZW1lbnRzLCB2ZXJ0ZXhJZCk7XFxuICAgIH1cXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19OT1JNQUxcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfTm9ybWFsRGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXROb3JtYWxEaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX05vcm1hbERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfVGFuZ2VudERpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0VGFuZ2VudERpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfVGFuZ2VudERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbnZvaWQgYXBwbHlNb3JwaCAoaW5vdXQgU3RhbmRhcmRWZXJ0SW5wdXQgYXR0cikge1xcbiAgICBpbnQgdmVydGV4SWQgPSBnZXRWZXJ0ZXhJZCgpO1xcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIGF0dHIucG9zaXRpb24ueHl6ID0gYXR0ci5wb3NpdGlvbi54eXogKyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXFxuICAgIGF0dHIubm9ybWFsLnh5eiA9IGF0dHIubm9ybWFsLnh5eiArIGdldE5vcm1hbERpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfVEFOR0VOVFxcbiAgICBhdHRyLnRhbmdlbnQueHl6ID0gYXR0ci50YW5nZW50Lnh5eiArIGdldFRhbmdlbnREaXNwbGFjZW1lbnQodmVydGV4SWQpO1xcbiNlbmRpZlxcbn1cXG52b2lkIGFwcGx5TW9ycGggKGlub3V0IHZlYzQgcG9zaXRpb24pIHtcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlxcbiAgICBwb3NpdGlvbi54eXogPSBwb3NpdGlvbi54eXogKyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudChnZXRWZXJ0ZXhJZCgpKTtcXG4jZW5kaWZcXG59XFxuI2VuZGlmXFxuI2lmIENDX1VTRV9TS0lOTklOR1xcbmluIHZlYzQgYV93ZWlnaHRzO1xcbmluIHZlYzQgYV9qb2ludHM7XFxuI2lmIENDX1VTRV9CQUtFRF9BTklNQVRJT05cXG4gICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICBpbiBoaWdocCB2ZWM0IGFfam9pbnRBbmltSW5mbztcXG4gICNlbmRpZlxcbiAgdW5pZm9ybSBDQ1NraW5uaW5nVGV4dHVyZSB7XFxuICAgIGhpZ2hwIHZlYzQgY2Nfam9pbnRUZXh0dXJlSW5mbztcXG4gIH07XFxuICB1bmlmb3JtIENDU2tpbm5pbmdBbmltYXRpb24ge1xcbiAgICBoaWdocCB2ZWM0IGNjX2pvaW50QW5pbUluZm87XFxuICB9O1xcbiAgdW5pZm9ybSBzYW1wbGVyMkQgY2Nfam9pbnRUZXh0dXJlO1xcbiAgICAjaWYgIUNDX1NVUFBPUlRfRkxPQVRfVEVYVFVSRVxcbiAgICBoaWdocCBmbG9hdCBkZWNvZGUzMiAoaGlnaHAgdmVjNCByZ2JhKSB7XFxuICAgICAgcmdiYSA9IHJnYmEgKiAyNTUuMDtcXG4gICAgICBoaWdocCBmbG9hdCBTaWduID0gMS4wIC0gc3RlcCgxMjguMCwgcmdiYVszXSkgKiAyLjA7XFxuICAgICAgaGlnaHAgZmxvYXQgRXhwb25lbnQgPSAyLjAgKiBtb2QocmdiYVszXSwgMTI4LjApICsgc3RlcCgxMjguMCwgcmdiYVsyXSkgLSAxMjcuMDtcXG4gICAgICBoaWdocCBmbG9hdCBNYW50aXNzYSA9IG1vZChyZ2JhWzJdLCAxMjguMCkgKiA2NTUzNi4wICsgcmdiYVsxXSAqIDI1Ni4wICsgcmdiYVswXSArIDgzODg2MDguMDtcXG4gICAgICByZXR1cm4gU2lnbiAqIGV4cDIoRXhwb25lbnQgLSAyMy4wKSAqIE1hbnRpc3NhO1xcbiAgICB9XFxuICAjZW5kaWZcXG4jZWxzZVxcbiAgdW5pZm9ybSBDQ1NraW5uaW5nIHtcXG4gICAgaGlnaHAgdmVjNCBjY19qb2ludHNbMzAgKiAzXTtcXG4gIH07XFxuI2VuZGlmXFxuI2lmIENDX1VTRV9CQUtFRF9BTklNQVRJT05cXG4gICNpZiBDQ19TVVBQT1JUX0ZMT0FUX1RFWFRVUkVcXG4gICAgbWF0NCBnZXRKb2ludE1hdHJpeCAoZmxvYXQgaSkge1xcbiAgICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMy4wICogKGFfam9pbnRBbmltSW5mby54ICogYV9qb2ludEFuaW1JbmZvLnkgKyBpKSArIGFfam9pbnRBbmltSW5mby56O1xcbiAgICAjZWxzZVxcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAzLjAgKiAoY2Nfam9pbnRBbmltSW5mby54ICogY2Nfam9pbnRUZXh0dXJlSW5mby55ICsgaSkgKyBjY19qb2ludFRleHR1cmVJbmZvLno7XFxuICAgICNlbmRpZlxcbiAgICBoaWdocCBmbG9hdCBpbnZTaXplID0gY2Nfam9pbnRUZXh0dXJlSW5mby53O1xcbiAgICBoaWdocCBmbG9hdCB5ID0gZmxvb3IoaiAqIGludlNpemUpO1xcbiAgICBoaWdocCBmbG9hdCB4ID0gaiAtIHkgKiBjY19qb2ludFRleHR1cmVJbmZvLng7XFxuICAgIHkgPSAoeSArIDAuNSkgKiBpbnZTaXplO1xcbiAgICAgIHZlYzQgdjEgPSB0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDAuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgdmVjNCB2MiA9IHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMS41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICB2ZWM0IHYzID0gdGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAyLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICAgIH1cXG4gICNlbHNlXFxuICAgIG1hdDQgZ2V0Sm9pbnRNYXRyaXggKGZsb2F0IGkpIHtcXG4gICAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDEyLjAgKiAoYV9qb2ludEFuaW1JbmZvLnggKiBhX2pvaW50QW5pbUluZm8ueSArIGkpICsgYV9qb2ludEFuaW1JbmZvLno7XFxuICAgICNlbHNlXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDEyLjAgKiAoY2Nfam9pbnRBbmltSW5mby54ICogY2Nfam9pbnRUZXh0dXJlSW5mby55ICsgaSkgKyBjY19qb2ludFRleHR1cmVJbmZvLno7XFxuICAgICNlbmRpZlxcbiAgICBoaWdocCBmbG9hdCBpbnZTaXplID0gY2Nfam9pbnRUZXh0dXJlSW5mby53O1xcbiAgICBoaWdocCBmbG9hdCB5ID0gZmxvb3IoaiAqIGludlNpemUpO1xcbiAgICBoaWdocCBmbG9hdCB4ID0gaiAtIHkgKiBjY19qb2ludFRleHR1cmVJbmZvLng7XFxuICAgIHkgPSAoeSArIDAuNSkgKiBpbnZTaXplO1xcbiAgICAgIHZlYzQgdjEgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAwLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDIuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAzLjUpICogaW52U2l6ZSwgeSkpKVxcbiAgICAgICk7XFxuICAgICAgdmVjNCB2MiA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDQuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA1LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNi41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDcuNSkgKiBpbnZTaXplLCB5KSkpXFxuICAgICAgKTtcXG4gICAgICB2ZWM0IHYzID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgOC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDkuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxMC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDExLjUpICogaW52U2l6ZSwgeSkpKVxcbiAgICAgICk7XFxuICAgICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gICAgfVxcbiAgI2VuZGlmXFxuI2Vsc2VcXG4gIG1hdDQgZ2V0Sm9pbnRNYXRyaXggKGZsb2F0IGkpIHtcXG4gICAgaW50IGlkeCA9IGludChpKTtcXG4gICAgdmVjNCB2MSA9IGNjX2pvaW50c1tpZHggKiAzXTtcXG4gICAgdmVjNCB2MiA9IGNjX2pvaW50c1tpZHggKiAzICsgMV07XFxuICAgIHZlYzQgdjMgPSBjY19qb2ludHNbaWR4ICogMyArIDJdO1xcbiAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgfVxcbiNlbmRpZlxcbm1hdDQgc2tpbk1hdHJpeCAoKSB7XFxuICByZXR1cm4gZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueCkgKiBhX3dlaWdodHMueFxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLnkpICogYV93ZWlnaHRzLnlcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy56KSAqIGFfd2VpZ2h0cy56XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMudykgKiBhX3dlaWdodHMudztcXG59XFxudm9pZCBDQ1NraW4gKGlub3V0IHZlYzQgcG9zaXRpb24pIHtcXG4gIG1hdDQgbSA9IHNraW5NYXRyaXgoKTtcXG4gIHBvc2l0aW9uID0gbSAqIHBvc2l0aW9uO1xcbn1cXG52b2lkIENDU2tpbiAoaW5vdXQgU3RhbmRhcmRWZXJ0SW5wdXQgYXR0cikge1xcbiAgbWF0NCBtID0gc2tpbk1hdHJpeCgpO1xcbiAgYXR0ci5wb3NpdGlvbiA9IG0gKiBhdHRyLnBvc2l0aW9uO1xcbiAgYXR0ci5ub3JtYWwgPSAobSAqIHZlYzQoYXR0ci5ub3JtYWwsIDAuMCkpLnh5ejtcXG4gIGF0dHIudGFuZ2VudC54eXogPSAobSAqIHZlYzQoYXR0ci50YW5nZW50Lnh5eiwgMC4wKSkueHl6O1xcbn1cXG4jZW5kaWZcXG51bmlmb3JtIENDR2xvYmFsIHtcXG4gIGhpZ2hwICAgdmVjNCBjY190aW1lO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2NhbGU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbmF0aXZlU2l6ZTtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qSW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qSW52O1xcbiAgaGlnaHAgICB2ZWM0IGNjX2NhbWVyYVBvcztcXG4gIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0RGlyO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXRDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50U2t5O1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRHcm91bmQ7XFxufTtcXG4jaWYgVVNFX0lOU1RBTkNJTkdcXG4gIGluIHZlYzQgYV9tYXRXb3JsZDA7XFxuICBpbiB2ZWM0IGFfbWF0V29ybGQxO1xcbiAgaW4gdmVjNCBhX21hdFdvcmxkMjtcXG4jZWxpZiBVU0VfQkFUQ0hJTkdcXG4gIGluIGZsb2F0IGFfZHluX2JhdGNoX2lkO1xcbiAgdW5pZm9ybSBDQ0xvY2FsQmF0Y2hlZCB7XFxuICAgIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRzWzEwXTtcXG4gIH07XFxuI2Vsc2VcXG51bmlmb3JtIENDTG9jYWwge1xcbiAgaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRJVDtcXG4gIGhpZ2hwIHZlYzQgY2NfbGlnaHRpbmdNYXBVVlBhcmFtO1xcbn07XFxuI2VuZGlmXFxuI2lmIFVTRV9WRVJURVhfQ09MT1JcXG4gIGluIHZlYzQgYV9jb2xvcjtcXG4gIG91dCB2ZWM0IHZfY29sb3I7XFxuI2VuZGlmXFxuI2lmIFVTRV9URVhUVVJFXFxuICBpbiB2ZWMyIGFfdGV4Q29vcmQ7XFxuICBvdXQgdmVjMiB2X3V2O1xcbiAgdW5pZm9ybSBUZXhDb29yZHMge1xcbiAgICB2ZWM0IHRpbGluZ09mZnNldDtcXG4gIH07XFxuI2VuZGlmXFxudmVjNCB2ZXJ0ICgpIHtcXG4gIHZlYzQgcG9zaXRpb247XFxuICBwb3NpdGlvbiA9IHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcXG4gICNpZiBDQ19VU0VfTU9SUEhcXG4gICAgYXBwbHlNb3JwaChwb3NpdGlvbik7XFxuICAjZW5kaWZcXG4gICNpZiBDQ19VU0VfU0tJTk5JTkdcXG4gICAgQ0NTa2luKHBvc2l0aW9uKTtcXG4gICNlbmRpZlxcbiAgbWF0NCBtYXRXb3JsZDtcXG4gICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICBtYXRXb3JsZCA9IG1hdDQoXFxuICAgICAgdmVjNChhX21hdFdvcmxkMC54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMS54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMi54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMC53LCBhX21hdFdvcmxkMS53LCBhX21hdFdvcmxkMi53LCAxLjApXFxuICAgICk7XFxuICAjZWxpZiBVU0VfQkFUQ0hJTkdcXG4gICAgbWF0V29ybGQgPSBjY19tYXRXb3JsZHNbaW50KGFfZHluX2JhdGNoX2lkKV07XFxuICAjZWxzZVxcbiAgICBtYXRXb3JsZCA9IGNjX21hdFdvcmxkO1xcbiAgI2VuZGlmXFxuICAjaWYgVVNFX1RFWFRVUkVcXG4gICAgdl91diA9IGFfdGV4Q29vcmQ7XFxuICAgICNpZiBGTElQX1VWXFxuICAgICAgdl91di55ID0gMS4wIC0gdl91di55O1xcbiAgICAjZW5kaWZcXG4gICAgdl91diA9IHZfdXYgKiB0aWxpbmdPZmZzZXQueHkgKyB0aWxpbmdPZmZzZXQuenc7XFxuICAjZW5kaWZcXG4gICNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICAgIHZfY29sb3IgPSBhX2NvbG9yO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY2NfbWF0UHJvaiAqIChjY19tYXRWaWV3ICogbWF0V29ybGQpICogcG9zaXRpb247XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSB2ZXJ0KCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIENDR2xvYmFsIHtcXG4gIGhpZ2hwICAgdmVjNCBjY190aW1lO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2NhbGU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbmF0aXZlU2l6ZTtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qSW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qSW52O1xcbiAgaGlnaHAgICB2ZWM0IGNjX2NhbWVyYVBvcztcXG4gIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0RGlyO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXRDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50U2t5O1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRHcm91bmQ7XFxufTtcXG52ZWMzIFNSR0JUb0xpbmVhciAodmVjMyBnYW1tYSkge1xcbiAgcmV0dXJuIGdhbW1hICogZ2FtbWE7XFxufVxcbnZlYzQgQ0NGcmFnT3V0cHV0ICh2ZWM0IGNvbG9yKSB7XFxuICAjaWYgQ0NfVVNFX0hEUlxcbiAgICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCBTUkdCVG9MaW5lYXIoY29sb3IucmdiKSAqIGNjX2V4cG9zdXJlLncsIHZlYzMoY2NfZXhwb3N1cmUueikpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY29sb3I7XFxufVxcbiNpZiBVU0VfQUxQSEFfVEVTVFxcbiNlbmRpZlxcbiNpZiBVU0VfVEVYVFVSRVxcbiAgaW4gdmVjMiB2X3V2O1xcbiAgdW5pZm9ybSBzYW1wbGVyMkQgbWFpblRleHR1cmU7XFxuI2VuZGlmXFxudW5pZm9ybSBDb25zdGFudCB7XFxuICB2ZWM0IG1haW5Db2xvcjtcXG4gIHZlYzQgY29sb3JTY2FsZUFuZEN1dG9mZjtcXG59O1xcbiNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICBpbiB2ZWM0IHZfY29sb3I7XFxuI2VuZGlmXFxudmVjNCBmcmFnICgpIHtcXG4gIHZlYzQgbyA9IG1haW5Db2xvcjtcXG4gIG8ucmdiICo9IGNvbG9yU2NhbGVBbmRDdXRvZmYueHl6O1xcbiAgI2lmIFVTRV9WRVJURVhfQ09MT1JcXG4gICAgbyAqPSB2X2NvbG9yO1xcbiAgI2VuZGlmXFxuICAjaWYgVVNFX1RFWFRVUkVcXG4gICAgbyAqPSB0ZXh0dXJlKG1haW5UZXh0dXJlLCB2X3V2KTtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9BTFBIQV9URVNUXFxuICAgIGlmIChvLkFMUEhBX1RFU1RfQ0hBTk5FTCA8IGNvbG9yU2NhbGVBbmRDdXRvZmYudykgZGlzY2FyZDtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIENDRnJhZ091dHB1dChvKTtcXG59XFxub3V0IHZlYzQgY2NfRnJhZ0NvbG9yO1xcbnZvaWQgbWFpbigpIHsgY2NfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJnbHNsMVwiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5zdHJ1Y3QgU3RhbmRhcmRWZXJ0SW5wdXQge1xcbiAgaGlnaHAgdmVjNCBwb3NpdGlvbjtcXG4gIHZlYzMgbm9ybWFsO1xcbiAgdmVjNCB0YW5nZW50O1xcbn07XFxuYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcXG4jaWYgQ0NfVVNFX01PUlBIXFxuICAgIGF0dHJpYnV0ZSBmbG9hdCBhX3ZlcnRleElkO1xcbiAgICBpbnQgZ2V0VmVydGV4SWQoKSB7XFxuICAgICAgICByZXR1cm4gaW50KGFfdmVydGV4SWQpO1xcbiAgICB9XFxudW5pZm9ybSB2ZWM0IGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbMTVdO1xcbnVuaWZvcm0gdmVjNCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mbztcXG4gICAgdmVjNCBmZXRjaEZsYXRQaXhlbChzYW1wbGVyMkQgdGV4LCBpbnQgcGl4ZWxJbmRleCkge1xcbiAgICAgICAgZmxvYXQgcGl4ZWxJbmRleEYgPSBmbG9hdChwaXhlbEluZGV4KTtcXG4gICAgICAgIHZlYzIgdGV4dHVyZVJlc29sdXRpb24gPSB2ZWMyKGZsb2F0KGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLngpLCBmbG9hdChjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby55KSk7XFxuICAgICAgICBmbG9hdCBwaXhlbFggPSBtb2QocGl4ZWxJbmRleEYsIHRleHR1cmVSZXNvbHV0aW9uLngpO1xcbiAgICAgICAgZmxvYXQgcGl4ZWxZID0gZmxvb3IocGl4ZWxJbmRleEYgLyB0ZXh0dXJlUmVzb2x1dGlvbi54KTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMihwaXhlbFgsIHBpeGVsWSkgKyAuNSkgLyB0ZXh0dXJlUmVzb2x1dGlvbjtcXG4gICAgICAgIHJldHVybiB0ZXh0dXJlMkQodGV4LCB1dik7XFxuICAgIH1cXG5mbG9hdCBnZXREaXNwbGFjZW1lbnRXZWlnaHQoaW50IGluZGV4KSB7XFxuICAgIGZsb2F0IG0gPSBtb2QoZmxvYXQoaW5kZXgpLCA0LjApO1xcbiAgICBpZiAobSA8IDEuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS54O1xcbiAgICB9IGVsc2UgaWYgKG0gPCAyLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0ueTtcXG4gICAgfSBlbHNlIGlmIChtIDwgMy4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLno7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLnc7XFxuICAgIH1cXG59XFxudmVjMyBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoc2FtcGxlcjJEIHRleCwgaW50IHZlcnRleEluZGV4KSB7XFxuI2lmIENDX01PUlBIX1BSRUNPTVBVVEVEXFxuICAgIHJldHVybiBmZXRjaEZsYXRQaXhlbCh0ZXgsIHZlcnRleEluZGV4KS5yZ2I7XFxuI2Vsc2VcXG4gICAgdmVjMyByZXN1bHQgPSB2ZWMzKDAsIDAsIDApO1xcbiAgICBmb3IgKGludCBpVGFyZ2V0ID0gMDsgaVRhcmdldCA8IENDX01PUlBIX1RBUkdFVF9DT1VOVDsgKytpVGFyZ2V0KSB7XFxuICAgICAgICBpbnQgZGF0YVBpeGVsU3RhcnQgPSBpbnQoZmV0Y2hGbGF0UGl4ZWwodGV4LCBpVGFyZ2V0KS5yKTtcXG4gICAgICAgIHJlc3VsdCArPSAoZmV0Y2hGbGF0UGl4ZWwodGV4LCBkYXRhUGl4ZWxTdGFydCArIHZlcnRleEluZGV4KS5yZ2IgKiBnZXREaXNwbGFjZW1lbnRXZWlnaHQoaVRhcmdldCkpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxuI2VuZGlmXFxufVxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGNjX1Bvc2l0aW9uRGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfUG9zaXRpb25EaXNwbGFjZW1lbnRzLCB2ZXJ0ZXhJZCk7XFxuICAgIH1cXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19OT1JNQUxcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfTm9ybWFsRGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXROb3JtYWxEaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX05vcm1hbERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfVGFuZ2VudERpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0VGFuZ2VudERpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfVGFuZ2VudERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbnZvaWQgYXBwbHlNb3JwaCAoaW5vdXQgU3RhbmRhcmRWZXJ0SW5wdXQgYXR0cikge1xcbiAgICBpbnQgdmVydGV4SWQgPSBnZXRWZXJ0ZXhJZCgpO1xcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIGF0dHIucG9zaXRpb24ueHl6ID0gYXR0ci5wb3NpdGlvbi54eXogKyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXFxuICAgIGF0dHIubm9ybWFsLnh5eiA9IGF0dHIubm9ybWFsLnh5eiArIGdldE5vcm1hbERpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfVEFOR0VOVFxcbiAgICBhdHRyLnRhbmdlbnQueHl6ID0gYXR0ci50YW5nZW50Lnh5eiArIGdldFRhbmdlbnREaXNwbGFjZW1lbnQodmVydGV4SWQpO1xcbiNlbmRpZlxcbn1cXG52b2lkIGFwcGx5TW9ycGggKGlub3V0IHZlYzQgcG9zaXRpb24pIHtcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlxcbiAgICBwb3NpdGlvbi54eXogPSBwb3NpdGlvbi54eXogKyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudChnZXRWZXJ0ZXhJZCgpKTtcXG4jZW5kaWZcXG59XFxuI2VuZGlmXFxuI2lmIENDX1VTRV9TS0lOTklOR1xcbmF0dHJpYnV0ZSB2ZWM0IGFfd2VpZ2h0cztcXG5hdHRyaWJ1dGUgdmVjNCBhX2pvaW50cztcXG4jaWYgQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlxcbiAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgIGF0dHJpYnV0ZSBoaWdocCB2ZWM0IGFfam9pbnRBbmltSW5mbztcXG4gICNlbmRpZlxcbiAgdW5pZm9ybSBoaWdocCB2ZWM0IGNjX2pvaW50VGV4dHVyZUluZm87XFxuICB1bmlmb3JtIGhpZ2hwIHZlYzQgY2Nfam9pbnRBbmltSW5mbztcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGNjX2pvaW50VGV4dHVyZTtcXG4gICAgI2lmICFDQ19TVVBQT1JUX0ZMT0FUX1RFWFRVUkVcXG4gICAgaGlnaHAgZmxvYXQgZGVjb2RlMzIgKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgICAgIHJnYmEgPSByZ2JhICogMjU1LjA7XFxuICAgICAgaGlnaHAgZmxvYXQgU2lnbiA9IDEuMCAtIHN0ZXAoMTI4LjAsIHJnYmFbM10pICogMi4wO1xcbiAgICAgIGhpZ2hwIGZsb2F0IEV4cG9uZW50ID0gMi4wICogbW9kKHJnYmFbM10sIDEyOC4wKSArIHN0ZXAoMTI4LjAsIHJnYmFbMl0pIC0gMTI3LjA7XFxuICAgICAgaGlnaHAgZmxvYXQgTWFudGlzc2EgPSBtb2QocmdiYVsyXSwgMTI4LjApICogNjU1MzYuMCArIHJnYmFbMV0gKiAyNTYuMCArIHJnYmFbMF0gKyA4Mzg4NjA4LjA7XFxuICAgICAgcmV0dXJuIFNpZ24gKiBleHAyKEV4cG9uZW50IC0gMjMuMCkgKiBNYW50aXNzYTtcXG4gICAgfVxcbiAgI2VuZGlmXFxuI2Vsc2VcXG4gIHVuaWZvcm0gaGlnaHAgdmVjNCBjY19qb2ludHNbOTBdO1xcbiNlbmRpZlxcbiNpZiBDQ19VU0VfQkFLRURfQU5JTUFUSU9OXFxuICAjaWYgQ0NfU1VQUE9SVF9GTE9BVF9URVhUVVJFXFxuICAgIG1hdDQgZ2V0Sm9pbnRNYXRyaXggKGZsb2F0IGkpIHtcXG4gICAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDMuMCAqIChhX2pvaW50QW5pbUluZm8ueCAqIGFfam9pbnRBbmltSW5mby55ICsgaSkgKyBhX2pvaW50QW5pbUluZm8uejtcXG4gICAgI2Vsc2VcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMy4wICogKGNjX2pvaW50QW5pbUluZm8ueCAqIGNjX2pvaW50VGV4dHVyZUluZm8ueSArIGkpICsgY2Nfam9pbnRUZXh0dXJlSW5mby56O1xcbiAgICAjZW5kaWZcXG4gICAgaGlnaHAgZmxvYXQgaW52U2l6ZSA9IGNjX2pvaW50VGV4dHVyZUluZm8udztcXG4gICAgaGlnaHAgZmxvYXQgeSA9IGZsb29yKGogKiBpbnZTaXplKTtcXG4gICAgaGlnaHAgZmxvYXQgeCA9IGogLSB5ICogY2Nfam9pbnRUZXh0dXJlSW5mby54O1xcbiAgICB5ID0gKHkgKyAwLjUpICogaW52U2l6ZTtcXG4gICAgICB2ZWM0IHYxID0gdGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDAuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgdmVjNCB2MiA9IHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHZlYzQgdjMgPSB0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMi41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgICB9XFxuICAjZWxzZVxcbiAgICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAxMi4wICogKGFfam9pbnRBbmltSW5mby54ICogYV9qb2ludEFuaW1JbmZvLnkgKyBpKSArIGFfam9pbnRBbmltSW5mby56O1xcbiAgICAjZWxzZVxcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAxMi4wICogKGNjX2pvaW50QW5pbUluZm8ueCAqIGNjX2pvaW50VGV4dHVyZUluZm8ueSArIGkpICsgY2Nfam9pbnRUZXh0dXJlSW5mby56O1xcbiAgICAjZW5kaWZcXG4gICAgaGlnaHAgZmxvYXQgaW52U2l6ZSA9IGNjX2pvaW50VGV4dHVyZUluZm8udztcXG4gICAgaGlnaHAgZmxvYXQgeSA9IGZsb29yKGogKiBpbnZTaXplKTtcXG4gICAgaGlnaHAgZmxvYXQgeCA9IGogLSB5ICogY2Nfam9pbnRUZXh0dXJlSW5mby54O1xcbiAgICB5ID0gKHkgKyAwLjUpICogaW52U2l6ZTtcXG4gICAgICB2ZWM0IHYxID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAwLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAyLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAzLjUpICogaW52U2l6ZSwgeSkpKVxcbiAgICAgICk7XFxuICAgICAgdmVjNCB2MiA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNi41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNy41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHZlYzQgdjMgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDguNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDkuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEwLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxMS41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICAgIH1cXG4gICNlbmRpZlxcbiNlbHNlXFxuICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgIGludCBpZHggPSBpbnQoaSk7XFxuICAgIHZlYzQgdjEgPSBjY19qb2ludHNbaWR4ICogM107XFxuICAgIHZlYzQgdjIgPSBjY19qb2ludHNbaWR4ICogMyArIDFdO1xcbiAgICB2ZWM0IHYzID0gY2Nfam9pbnRzW2lkeCAqIDMgKyAyXTtcXG4gICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gIH1cXG4jZW5kaWZcXG5tYXQ0IHNraW5NYXRyaXggKCkge1xcbiAgcmV0dXJuIGdldEpvaW50TWF0cml4KGFfam9pbnRzLngpICogYV93ZWlnaHRzLnhcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy55KSAqIGFfd2VpZ2h0cy55XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueikgKiBhX3dlaWdodHMuelxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLncpICogYV93ZWlnaHRzLnc7XFxufVxcbnZvaWQgQ0NTa2luIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XFxuICBtYXQ0IG0gPSBza2luTWF0cml4KCk7XFxuICBwb3NpdGlvbiA9IG0gKiBwb3NpdGlvbjtcXG59XFxudm9pZCBDQ1NraW4gKGlub3V0IFN0YW5kYXJkVmVydElucHV0IGF0dHIpIHtcXG4gIG1hdDQgbSA9IHNraW5NYXRyaXgoKTtcXG4gIGF0dHIucG9zaXRpb24gPSBtICogYXR0ci5wb3NpdGlvbjtcXG4gIGF0dHIubm9ybWFsID0gKG0gKiB2ZWM0KGF0dHIubm9ybWFsLCAwLjApKS54eXo7XFxuICBhdHRyLnRhbmdlbnQueHl6ID0gKG0gKiB2ZWM0KGF0dHIudGFuZ2VudC54eXosIDAuMCkpLnh5ejtcXG59XFxuI2VuZGlmXFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFZpZXc7XFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFByb2o7XFxuI2lmIFVTRV9JTlNUQU5DSU5HXFxuICBhdHRyaWJ1dGUgdmVjNCBhX21hdFdvcmxkMDtcXG4gIGF0dHJpYnV0ZSB2ZWM0IGFfbWF0V29ybGQxO1xcbiAgYXR0cmlidXRlIHZlYzQgYV9tYXRXb3JsZDI7XFxuI2VsaWYgVVNFX0JBVENISU5HXFxuICBhdHRyaWJ1dGUgZmxvYXQgYV9keW5fYmF0Y2hfaWQ7XFxuICB1bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRzWzEwXTtcXG4jZWxzZVxcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG4jZW5kaWZcXG4jaWYgVVNFX1ZFUlRFWF9DT0xPUlxcbiAgYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG4gIHZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbiNlbmRpZlxcbiNpZiBVU0VfVEVYVFVSRVxcbiAgYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDtcXG4gIHZhcnlpbmcgdmVjMiB2X3V2O1xcbiAgdW5pZm9ybSB2ZWM0IHRpbGluZ09mZnNldDtcXG4jZW5kaWZcXG52ZWM0IHZlcnQgKCkge1xcbiAgdmVjNCBwb3NpdGlvbjtcXG4gIHBvc2l0aW9uID0gdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xcbiAgI2lmIENDX1VTRV9NT1JQSFxcbiAgICBhcHBseU1vcnBoKHBvc2l0aW9uKTtcXG4gICNlbmRpZlxcbiAgI2lmIENDX1VTRV9TS0lOTklOR1xcbiAgICBDQ1NraW4ocG9zaXRpb24pO1xcbiAgI2VuZGlmXFxuICBtYXQ0IG1hdFdvcmxkO1xcbiAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgIG1hdFdvcmxkID0gbWF0NChcXG4gICAgICB2ZWM0KGFfbWF0V29ybGQwLnh5eiwgMC4wKSxcXG4gICAgICB2ZWM0KGFfbWF0V29ybGQxLnh5eiwgMC4wKSxcXG4gICAgICB2ZWM0KGFfbWF0V29ybGQyLnh5eiwgMC4wKSxcXG4gICAgICB2ZWM0KGFfbWF0V29ybGQwLncsIGFfbWF0V29ybGQxLncsIGFfbWF0V29ybGQyLncsIDEuMClcXG4gICAgKTtcXG4gICNlbGlmIFVTRV9CQVRDSElOR1xcbiAgICBtYXRXb3JsZCA9IGNjX21hdFdvcmxkc1tpbnQoYV9keW5fYmF0Y2hfaWQpXTtcXG4gICNlbHNlXFxuICAgIG1hdFdvcmxkID0gY2NfbWF0V29ybGQ7XFxuICAjZW5kaWZcXG4gICNpZiBVU0VfVEVYVFVSRVxcbiAgICB2X3V2ID0gYV90ZXhDb29yZDtcXG4gICAgI2lmIEZMSVBfVVZcXG4gICAgICB2X3V2LnkgPSAxLjAgLSB2X3V2Lnk7XFxuICAgICNlbmRpZlxcbiAgICB2X3V2ID0gdl91diAqIHRpbGluZ09mZnNldC54eSArIHRpbGluZ09mZnNldC56dztcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9WRVJURVhfQ09MT1JcXG4gICAgdl9jb2xvciA9IGFfY29sb3I7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjY19tYXRQcm9qICogKGNjX21hdFZpZXcgKiBtYXRXb3JsZCkgKiBwb3NpdGlvbjtcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZlcnQoKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiBDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIFNSR0JUb0xpbmVhcihjb2xvci5yZ2IpICogY2NfZXhwb3N1cmUudywgdmVjMyhjY19leHBvc3VyZS56KSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxuI2lmIFVTRV9BTFBIQV9URVNUXFxuI2VuZGlmXFxuI2lmIFVTRV9URVhUVVJFXFxuICB2YXJ5aW5nIHZlYzIgdl91djtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIG1haW5UZXh0dXJlO1xcbiNlbmRpZlxcbnVuaWZvcm0gdmVjNCBtYWluQ29sb3I7XFxudW5pZm9ybSB2ZWM0IGNvbG9yU2NhbGVBbmRDdXRvZmY7XFxuI2lmIFVTRV9WRVJURVhfQ09MT1JcXG4gIHZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbiNlbmRpZlxcbnZlYzQgZnJhZyAoKSB7XFxuICB2ZWM0IG8gPSBtYWluQ29sb3I7XFxuICBvLnJnYiAqPSBjb2xvclNjYWxlQW5kQ3V0b2ZmLnh5ejtcXG4gICNpZiBVU0VfVkVSVEVYX0NPTE9SXFxuICAgIG8gKj0gdl9jb2xvcjtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9URVhUVVJFXFxuICAgIG8gKj0gdGV4dHVyZTJEKG1haW5UZXh0dXJlLCB2X3V2KTtcXG4gICNlbmRpZlxcbiAgI2lmIFVTRV9BTFBIQV9URVNUXFxuICAgIGlmIChvLkFMUEhBX1RFU1RfQ0hBTk5FTCA8IGNvbG9yU2NhbGVBbmRDdXRvZmYudykgZGlzY2FyZDtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIENDRnJhZ091dHB1dChvKTtcXG59XFxudm9pZCBtYWluKCkgeyBnbF9GcmFnQ29sb3IgPSBmcmFnKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImJ1aWx0aW5zXCI6IHtcclxuICAgICAgICAgIFwiZ2xvYmFsc1wiOiB7IFwiYmxvY2tzXCI6IFt7IFwibmFtZVwiOiBcIkNDR2xvYmFsXCIsIFwiZGVmaW5lc1wiOiBbXSB9XSwgXCJzYW1wbGVyc1wiOiBbXSB9LFxyXG4gICAgICAgICAgXCJsb2NhbHNcIjogeyBcImJsb2Nrc1wiOiBbeyBcIm5hbWVcIjogXCJDQ01vcnBoXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfTU9SUEhcIl0gfSwgeyBcIm5hbWVcIjogXCJDQ1NraW5uaW5nVGV4dHVyZVwiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCIsIFwiQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlwiXSB9LCB7IFwibmFtZVwiOiBcIkNDU2tpbm5pbmdBbmltYXRpb25cIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9TS0lOTklOR1wiLCBcIkNDX1VTRV9CQUtFRF9BTklNQVRJT05cIl0gfSwgeyBcIm5hbWVcIjogXCJDQ1NraW5uaW5nXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfU0tJTk5JTkdcIiwgXCIhQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlwiXSB9LCB7IFwibmFtZVwiOiBcIkNDTG9jYWxCYXRjaGVkXCIsIFwiZGVmaW5lc1wiOiBbXCIhVVNFX0lOU1RBTkNJTkdcIiwgXCJVU0VfQkFUQ0hJTkdcIl0gfSwgeyBcIm5hbWVcIjogXCJDQ0xvY2FsXCIsIFwiZGVmaW5lc1wiOiBbXCIhVVNFX0lOU1RBTkNJTkdcIiwgXCIhVVNFX0JBVENISU5HXCJdIH1dLCBcInNhbXBsZXJzXCI6IFt7IFwibmFtZVwiOiBcImNjX1Bvc2l0aW9uRGlzcGxhY2VtZW50c1wiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX01PUlBIXCIsIFwiQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlwiXSB9LCB7IFwibmFtZVwiOiBcImNjX05vcm1hbERpc3BsYWNlbWVudHNcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9NT1JQSFwiLCBcIkNDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXCJdIH0sIHsgXCJuYW1lXCI6IFwiY2NfVGFuZ2VudERpc3BsYWNlbWVudHNcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9NT1JQSFwiLCBcIkNDX01PUlBIX1RBUkdFVF9IQVNfVEFOR0VOVFwiXSB9LCB7IFwibmFtZVwiOiBcImNjX2pvaW50VGV4dHVyZVwiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCIsIFwiQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlwiXSB9XSB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImRlZmluZXNcIjogW1xyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19VU0VfTU9SUEhcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX01PUlBIX1RBUkdFVF9DT1VOVFwiLCBcInR5cGVcIjogXCJudW1iZXJcIiwgXCJyYW5nZVwiOiBbMiwgOF0gfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfTU9SUEhfUFJFQ09NUFVURURcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9TS0lOTklOR1wiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiVVNFX0lOU1RBTkNJTkdcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1NVUFBPUlRfRkxPQVRfVEVYVFVSRVwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiVVNFX0JBVENISU5HXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJVU0VfVkVSVEVYX0NPTE9SXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJVU0VfVEVYVFVSRVwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiRkxJUF9VVlwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX0hEUlwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiVVNFX0FMUEhBX1RFU1RcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkFMUEhBX1RFU1RfQ0hBTk5FTFwiLCBcInR5cGVcIjogXCJzdHJpbmdcIiwgXCJvcHRpb25zXCI6IFtcImFcIiwgXCJyXCIsIFwiZ1wiLCBcImJcIl0gfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJibG9ja3NcIjogW1xyXG4gICAgICAgICAge1wibmFtZVwiOiBcIlRleENvb3Jkc1wiLCBcImRlZmluZXNcIjogW1wiVVNFX1RFWFRVUkVcIl0sIFwiYmluZGluZ1wiOiAwLCBcIm1lbWJlcnNcIjogW1xyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcInRpbGluZ09mZnNldFwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9XHJcbiAgICAgICAgICBdfSxcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJDb25zdGFudFwiLCBcImRlZmluZXNcIjogW10sIFwiYmluZGluZ1wiOiAxLCBcIm1lbWJlcnNcIjogW1xyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcIm1haW5Db2xvclwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9LFxyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcImNvbG9yU2NhbGVBbmRDdXRvZmZcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEgfVxyXG4gICAgICAgICAgXX1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwic2FtcGxlcnNcIjogW1xyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJtYWluVGV4dHVyZVwiLCBcInR5cGVcIjogMjgsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIlVTRV9URVhUVVJFXCJdLCBcImJpbmRpbmdcIjogMzEgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9wb3NpdGlvblwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiAwIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfdmVydGV4SWRcIiwgXCJ0eXBlXCI6IDEzLCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfTU9SUEhcIl0sIFwiZm9ybWF0XCI6IDExLCBcImxvY2F0aW9uXCI6IDEgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV93ZWlnaHRzXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCJdLCBcImZvcm1hdFwiOiA0MywgXCJsb2NhdGlvblwiOiAyIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfam9pbnRzXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCJdLCBcImZvcm1hdFwiOiA0MywgXCJsb2NhdGlvblwiOiAzIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfam9pbnRBbmltSW5mb1wiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJwcmVjaXNpb25cIjogXCJoaWdocCBcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9TS0lOTklOR1wiLCBcIkNDX1VTRV9CQUtFRF9BTklNQVRJT05cIiwgXCJVU0VfSU5TVEFOQ0lOR1wiXSwgXCJmb3JtYXRcIjogNDMsIFwiaXNJbnN0YW5jZWRcIjogdHJ1ZSwgXCJsb2NhdGlvblwiOiA0IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfbWF0V29ybGQwXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVVNFX0lOU1RBTkNJTkdcIl0sIFwiZm9ybWF0XCI6IDQzLCBcImlzSW5zdGFuY2VkXCI6IHRydWUsIFwibG9jYXRpb25cIjogNSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX21hdFdvcmxkMVwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIlVTRV9JTlNUQU5DSU5HXCJdLCBcImZvcm1hdFwiOiA0MywgXCJpc0luc3RhbmNlZFwiOiB0cnVlLCBcImxvY2F0aW9uXCI6IDYgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9tYXRXb3JsZDJcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJVU0VfSU5TVEFOQ0lOR1wiXSwgXCJmb3JtYXRcIjogNDMsIFwiaXNJbnN0YW5jZWRcIjogdHJ1ZSwgXCJsb2NhdGlvblwiOiA3IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfZHluX2JhdGNoX2lkXCIsIFwidHlwZVwiOiAxMywgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiIVVTRV9JTlNUQU5DSU5HXCIsIFwiVVNFX0JBVENISU5HXCJdLCBcImZvcm1hdFwiOiAxMSwgXCJsb2NhdGlvblwiOiA4IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfY29sb3JcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJVU0VfVkVSVEVYX0NPTE9SXCJdLCBcImZvcm1hdFwiOiA0MywgXCJsb2NhdGlvblwiOiA5IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfdGV4Q29vcmRcIiwgXCJ0eXBlXCI6IDE0LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJVU0VfVEVYVFVSRVwiXSwgXCJmb3JtYXRcIjogMjEsIFwibG9jYXRpb25cIjogMTAgfVxyXG4gICAgICAgIF1cclxuICAgICAgfVxyXG4gICAgXVxyXG4gIH0sXHJcbiAge1xyXG4gICAgXCJuYW1lXCI6IFwicGlwZWxpbmUvcGxhbmFyLXNoYWRvd1wiLFxyXG4gICAgXCJfdXVpZFwiOiBcIjkzNjFmZDkwLWJhNTItNGY4NC1hYTkzLTZlODc4ZmQ1NzZjYVwiLFxyXG4gICAgXCJ0ZWNobmlxdWVzXCI6IFtcclxuICAgICAgeyBcInBhc3Nlc1wiOiBbeyBcInBoYXNlXCI6IFwicGxhbmFyU2hhZG93XCIsIFwiYmxlbmRTdGF0ZVwiOiB7IFwidGFyZ2V0c1wiOiBbeyBcImJsZW5kXCI6IHRydWUsIFwiYmxlbmRTcmNcIjogMiwgXCJibGVuZERzdFwiOiA0LCBcImJsZW5kRHN0QWxwaGFcIjogNCB9XSB9LCBcInByb2dyYW1cIjogXCJwaXBlbGluZS9wbGFuYXItc2hhZG93fHBsYW5hci1zaGFkb3ctdnM6dmVydHxwbGFuYXItc2hhZG93LWZzOmZyYWdcIiwgXCJkZXB0aFN0ZW5jaWxTdGF0ZVwiOiB7IFwiZGVwdGhUZXN0XCI6IHRydWUsIFwiZGVwdGhXcml0ZVwiOiBmYWxzZSwgXCJzdGVuY2lsVGVzdEZyb250XCI6IHRydWUsIFwic3RlbmNpbEZ1bmNGcm9udFwiOiA1LCBcInN0ZW5jaWxQYXNzT3BGcm9udFwiOiAyLCBcInN0ZW5jaWxSZWZCYWNrXCI6IDEyOCwgXCJzdGVuY2lsUmVmRnJvbnRcIjogMTI4LCBcInN0ZW5jaWxSZWFkTWFza0JhY2tcIjogMTI4LCBcInN0ZW5jaWxSZWFkTWFza0Zyb250XCI6IDEyOCwgXCJzdGVuY2lsV3JpdGVNYXNrQmFja1wiOiAxMjgsIFwic3RlbmNpbFdyaXRlTWFza0Zyb250XCI6IDEyOCB9IH1dIH1cclxuICAgIF0sXHJcbiAgICBcInNoYWRlcnNcIjogW1xyXG4gICAgICB7XHJcbiAgICAgICAgXCJuYW1lXCI6IFwicGlwZWxpbmUvcGxhbmFyLXNoYWRvd3xwbGFuYXItc2hhZG93LXZzOnZlcnR8cGxhbmFyLXNoYWRvdy1mczpmcmFnXCIsXHJcbiAgICAgICAgXCJoYXNoXCI6IDMwMjQ0OTQwNDIsXHJcbiAgICAgICAgXCJnbHNsM1wiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5zdHJ1Y3QgU3RhbmRhcmRWZXJ0SW5wdXQge1xcbiAgaGlnaHAgdmVjNCBwb3NpdGlvbjtcXG4gIHZlYzMgbm9ybWFsO1xcbiAgdmVjNCB0YW5nZW50O1xcbn07XFxuaW4gdmVjMyBhX3Bvc2l0aW9uO1xcbiNpZiBDQ19VU0VfTU9SUEhcXG4gICAgaW4gZmxvYXQgYV92ZXJ0ZXhJZDtcXG4gICAgaW50IGdldFZlcnRleElkKCkge1xcbiAgICAgICAgcmV0dXJuIGludChhX3ZlcnRleElkKTtcXG4gICAgfVxcbnVuaWZvcm0gQ0NNb3JwaCB7XFxuICAgIHZlYzQgY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1sxNV07XFxuICAgIHZlYzQgY2NfZGlzcGxhY2VtZW50VGV4dHVyZUluZm87XFxufTtcXG4gICAgdmVjNCBmZXRjaEZsYXRQaXhlbChzYW1wbGVyMkQgdGV4LCBpbnQgcGl4ZWxJbmRleCkge1xcbiAgICAgICAgZmxvYXQgcGl4ZWxJbmRleEYgPSBmbG9hdChwaXhlbEluZGV4KTtcXG4gICAgICAgIHZlYzIgdGV4dHVyZVJlc29sdXRpb24gPSB2ZWMyKGZsb2F0KGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLngpLCBmbG9hdChjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby55KSk7XFxuICAgICAgICBmbG9hdCBwaXhlbFggPSBtb2QocGl4ZWxJbmRleEYsIHRleHR1cmVSZXNvbHV0aW9uLngpO1xcbiAgICAgICAgZmxvYXQgcGl4ZWxZID0gZmxvb3IocGl4ZWxJbmRleEYgLyB0ZXh0dXJlUmVzb2x1dGlvbi54KTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMihwaXhlbFgsIHBpeGVsWSkgKyAuNSkgLyB0ZXh0dXJlUmVzb2x1dGlvbjtcXG4gICAgICAgIHJldHVybiB0ZXh0dXJlKHRleCwgdXYpO1xcbiAgICB9XFxuZmxvYXQgZ2V0RGlzcGxhY2VtZW50V2VpZ2h0KGludCBpbmRleCkge1xcbiAgICBmbG9hdCBtID0gbW9kKGZsb2F0KGluZGV4KSwgNC4wKTtcXG4gICAgaWYgKG0gPCAxLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0ueDtcXG4gICAgfSBlbHNlIGlmIChtIDwgMi4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLnk7XFxuICAgIH0gZWxzZSBpZiAobSA8IDMuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS56O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS53O1xcbiAgICB9XFxufVxcbnZlYzMgZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKHNhbXBsZXIyRCB0ZXgsIGludCB2ZXJ0ZXhJbmRleCkge1xcbiNpZiBDQ19NT1JQSF9QUkVDT01QVVRFRFxcbiAgICByZXR1cm4gZmV0Y2hGbGF0UGl4ZWwodGV4LCB2ZXJ0ZXhJbmRleCkucmdiO1xcbiNlbHNlXFxuICAgIHZlYzMgcmVzdWx0ID0gdmVjMygwLCAwLCAwKTtcXG4gICAgZm9yIChpbnQgaVRhcmdldCA9IDA7IGlUYXJnZXQgPCBDQ19NT1JQSF9UQVJHRVRfQ09VTlQ7ICsraVRhcmdldCkge1xcbiAgICAgICAgaW50IGRhdGFQaXhlbFN0YXJ0ID0gaW50KGZldGNoRmxhdFBpeGVsKHRleCwgaVRhcmdldCkucik7XFxuICAgICAgICByZXN1bHQgKz0gKGZldGNoRmxhdFBpeGVsKHRleCwgZGF0YVBpeGVsU3RhcnQgKyB2ZXJ0ZXhJbmRleCkucmdiICogZ2V0RGlzcGxhY2VtZW50V2VpZ2h0KGlUYXJnZXQpKTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbiNlbmRpZlxcbn1cXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlxcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCBjY19Qb3NpdGlvbkRpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0UG9zaXRpb25EaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX1Bvc2l0aW9uRGlzcGxhY2VtZW50cywgdmVydGV4SWQpO1xcbiAgICB9XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGNjX05vcm1hbERpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0Tm9ybWFsRGlzcGxhY2VtZW50KGludCB2ZXJ0ZXhJZCkge1xcbiAgICAgICAgcmV0dXJuIGdldFZlYzNEaXNwbGFjZW1lbnRGcm9tVGV4dHVyZShjY19Ob3JtYWxEaXNwbGFjZW1lbnRzLCB2ZXJ0ZXhJZCk7XFxuICAgIH1cXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19UQU5HRU5UXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGNjX1RhbmdlbnREaXNwbGFjZW1lbnRzO1xcbiAgICB2ZWMzIGdldFRhbmdlbnREaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX1RhbmdlbnREaXNwbGFjZW1lbnRzLCB2ZXJ0ZXhJZCk7XFxuICAgIH1cXG4jZW5kaWZcXG52b2lkIGFwcGx5TW9ycGggKGlub3V0IFN0YW5kYXJkVmVydElucHV0IGF0dHIpIHtcXG4gICAgaW50IHZlcnRleElkID0gZ2V0VmVydGV4SWQoKTtcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlxcbiAgICBhdHRyLnBvc2l0aW9uLnh5eiA9IGF0dHIucG9zaXRpb24ueHl6ICsgZ2V0UG9zaXRpb25EaXNwbGFjZW1lbnQodmVydGV4SWQpO1xcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX05PUk1BTFxcbiAgICBhdHRyLm5vcm1hbC54eXogPSBhdHRyLm5vcm1hbC54eXogKyBnZXROb3JtYWxEaXNwbGFjZW1lbnQodmVydGV4SWQpO1xcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcXG4gICAgYXR0ci50YW5nZW50Lnh5eiA9IGF0dHIudGFuZ2VudC54eXogKyBnZXRUYW5nZW50RGlzcGxhY2VtZW50KHZlcnRleElkKTtcXG4jZW5kaWZcXG59XFxudm9pZCBhcHBseU1vcnBoIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfUE9TSVRJT05cXG4gICAgcG9zaXRpb24ueHl6ID0gcG9zaXRpb24ueHl6ICsgZ2V0UG9zaXRpb25EaXNwbGFjZW1lbnQoZ2V0VmVydGV4SWQoKSk7XFxuI2VuZGlmXFxufVxcbiNlbmRpZlxcbiNpZiBDQ19VU0VfU0tJTk5JTkdcXG5pbiB2ZWM0IGFfd2VpZ2h0cztcXG5pbiB2ZWM0IGFfam9pbnRzO1xcbiNpZiBDQ19VU0VfQkFLRURfQU5JTUFUSU9OXFxuICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgaW4gaGlnaHAgdmVjNCBhX2pvaW50QW5pbUluZm87XFxuICAjZW5kaWZcXG4gIHVuaWZvcm0gQ0NTa2lubmluZ1RleHR1cmUge1xcbiAgICBoaWdocCB2ZWM0IGNjX2pvaW50VGV4dHVyZUluZm87XFxuICB9O1xcbiAgdW5pZm9ybSBDQ1NraW5uaW5nQW5pbWF0aW9uIHtcXG4gICAgaGlnaHAgdmVjNCBjY19qb2ludEFuaW1JbmZvO1xcbiAgfTtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGNjX2pvaW50VGV4dHVyZTtcXG4gICAgI2lmICFDQ19TVVBQT1JUX0ZMT0FUX1RFWFRVUkVcXG4gICAgaGlnaHAgZmxvYXQgZGVjb2RlMzIgKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgICAgIHJnYmEgPSByZ2JhICogMjU1LjA7XFxuICAgICAgaGlnaHAgZmxvYXQgU2lnbiA9IDEuMCAtIHN0ZXAoMTI4LjAsIHJnYmFbM10pICogMi4wO1xcbiAgICAgIGhpZ2hwIGZsb2F0IEV4cG9uZW50ID0gMi4wICogbW9kKHJnYmFbM10sIDEyOC4wKSArIHN0ZXAoMTI4LjAsIHJnYmFbMl0pIC0gMTI3LjA7XFxuICAgICAgaGlnaHAgZmxvYXQgTWFudGlzc2EgPSBtb2QocmdiYVsyXSwgMTI4LjApICogNjU1MzYuMCArIHJnYmFbMV0gKiAyNTYuMCArIHJnYmFbMF0gKyA4Mzg4NjA4LjA7XFxuICAgICAgcmV0dXJuIFNpZ24gKiBleHAyKEV4cG9uZW50IC0gMjMuMCkgKiBNYW50aXNzYTtcXG4gICAgfVxcbiAgI2VuZGlmXFxuI2Vsc2VcXG4gIHVuaWZvcm0gQ0NTa2lubmluZyB7XFxuICAgIGhpZ2hwIHZlYzQgY2Nfam9pbnRzWzMwICogM107XFxuICB9O1xcbiNlbmRpZlxcbiNpZiBDQ19VU0VfQkFLRURfQU5JTUFUSU9OXFxuICAjaWYgQ0NfU1VQUE9SVF9GTE9BVF9URVhUVVJFXFxuICAgIG1hdDQgZ2V0Sm9pbnRNYXRyaXggKGZsb2F0IGkpIHtcXG4gICAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDMuMCAqIChhX2pvaW50QW5pbUluZm8ueCAqIGFfam9pbnRBbmltSW5mby55ICsgaSkgKyBhX2pvaW50QW5pbUluZm8uejtcXG4gICAgI2Vsc2VcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMy4wICogKGNjX2pvaW50QW5pbUluZm8ueCAqIGNjX2pvaW50VGV4dHVyZUluZm8ueSArIGkpICsgY2Nfam9pbnRUZXh0dXJlSW5mby56O1xcbiAgICAjZW5kaWZcXG4gICAgaGlnaHAgZmxvYXQgaW52U2l6ZSA9IGNjX2pvaW50VGV4dHVyZUluZm8udztcXG4gICAgaGlnaHAgZmxvYXQgeSA9IGZsb29yKGogKiBpbnZTaXplKTtcXG4gICAgaGlnaHAgZmxvYXQgeCA9IGogLSB5ICogY2Nfam9pbnRUZXh0dXJlSW5mby54O1xcbiAgICB5ID0gKHkgKyAwLjUpICogaW52U2l6ZTtcXG4gICAgICB2ZWM0IHYxID0gdGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAwLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHZlYzQgdjIgPSB0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgdmVjNCB2MyA9IHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMi41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgICB9XFxuICAjZWxzZVxcbiAgICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAxMi4wICogKGFfam9pbnRBbmltSW5mby54ICogYV9qb2ludEFuaW1JbmZvLnkgKyBpKSArIGFfam9pbnRBbmltSW5mby56O1xcbiAgICAjZWxzZVxcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAxMi4wICogKGNjX2pvaW50QW5pbUluZm8ueCAqIGNjX2pvaW50VGV4dHVyZUluZm8ueSArIGkpICsgY2Nfam9pbnRUZXh0dXJlSW5mby56O1xcbiAgICAjZW5kaWZcXG4gICAgaGlnaHAgZmxvYXQgaW52U2l6ZSA9IGNjX2pvaW50VGV4dHVyZUluZm8udztcXG4gICAgaGlnaHAgZmxvYXQgeSA9IGZsb29yKGogKiBpbnZTaXplKTtcXG4gICAgaGlnaHAgZmxvYXQgeCA9IGogLSB5ICogY2Nfam9pbnRUZXh0dXJlSW5mby54O1xcbiAgICB5ID0gKHkgKyAwLjUpICogaW52U2l6ZTtcXG4gICAgICB2ZWM0IHYxID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAyLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMy41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHZlYzQgdjIgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA0LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDYuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA3LjUpICogaW52U2l6ZSwgeSkpKVxcbiAgICAgICk7XFxuICAgICAgdmVjNCB2MyA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDguNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyA5LjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMTAuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZShjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxMS41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICAgIH1cXG4gICNlbmRpZlxcbiNlbHNlXFxuICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgIGludCBpZHggPSBpbnQoaSk7XFxuICAgIHZlYzQgdjEgPSBjY19qb2ludHNbaWR4ICogM107XFxuICAgIHZlYzQgdjIgPSBjY19qb2ludHNbaWR4ICogMyArIDFdO1xcbiAgICB2ZWM0IHYzID0gY2Nfam9pbnRzW2lkeCAqIDMgKyAyXTtcXG4gICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gIH1cXG4jZW5kaWZcXG5tYXQ0IHNraW5NYXRyaXggKCkge1xcbiAgcmV0dXJuIGdldEpvaW50TWF0cml4KGFfam9pbnRzLngpICogYV93ZWlnaHRzLnhcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy55KSAqIGFfd2VpZ2h0cy55XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueikgKiBhX3dlaWdodHMuelxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLncpICogYV93ZWlnaHRzLnc7XFxufVxcbnZvaWQgQ0NTa2luIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XFxuICBtYXQ0IG0gPSBza2luTWF0cml4KCk7XFxuICBwb3NpdGlvbiA9IG0gKiBwb3NpdGlvbjtcXG59XFxudm9pZCBDQ1NraW4gKGlub3V0IFN0YW5kYXJkVmVydElucHV0IGF0dHIpIHtcXG4gIG1hdDQgbSA9IHNraW5NYXRyaXgoKTtcXG4gIGF0dHIucG9zaXRpb24gPSBtICogYXR0ci5wb3NpdGlvbjtcXG4gIGF0dHIubm9ybWFsID0gKG0gKiB2ZWM0KGF0dHIubm9ybWFsLCAwLjApKS54eXo7XFxuICBhdHRyLnRhbmdlbnQueHl6ID0gKG0gKiB2ZWM0KGF0dHIudGFuZ2VudC54eXosIDAuMCkpLnh5ejtcXG59XFxuI2VuZGlmXFxudW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbn07XFxuI2lmIFVTRV9JTlNUQU5DSU5HXFxuICBpbiB2ZWM0IGFfbWF0V29ybGQwO1xcbiAgaW4gdmVjNCBhX21hdFdvcmxkMTtcXG4gIGluIHZlYzQgYV9tYXRXb3JsZDI7XFxuI2VsaWYgVVNFX0JBVENISU5HXFxuICBpbiBmbG9hdCBhX2R5bl9iYXRjaF9pZDtcXG4gIHVuaWZvcm0gQ0NMb2NhbEJhdGNoZWQge1xcbiAgICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkc1sxMF07XFxuICB9O1xcbiNlbHNlXFxudW5pZm9ybSBDQ0xvY2FsIHtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGQ7XFxuICBoaWdocCBtYXQ0IGNjX21hdFdvcmxkSVQ7XFxuICBoaWdocCB2ZWM0IGNjX2xpZ2h0aW5nTWFwVVZQYXJhbTtcXG59O1xcbiNlbmRpZlxcbnVuaWZvcm0gQ0NTaGFkb3cge1xcbiAgaGlnaHAgbWF0NCBjY19tYXRMaWdodFBsYW5lUHJvajtcXG4gIGxvd3AgdmVjNCBjY19zaGFkb3dDb2xvcjtcXG59O1xcbnZlYzQgdmVydCAoKSB7XFxuICB2ZWM0IHBvc2l0aW9uO1xcbiAgcG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XFxuICAjaWYgQ0NfVVNFX01PUlBIXFxuICAgIGFwcGx5TW9ycGgocG9zaXRpb24pO1xcbiAgI2VuZGlmXFxuICAjaWYgQ0NfVVNFX1NLSU5OSU5HXFxuICAgIENDU2tpbihwb3NpdGlvbik7XFxuICAjZW5kaWZcXG4gIG1hdDQgbWF0V29ybGQ7XFxuICAjaWYgVVNFX0lOU1RBTkNJTkdcXG4gICAgbWF0V29ybGQgPSBtYXQ0KFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDAueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDEueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDIueHl6LCAwLjApLFxcbiAgICAgIHZlYzQoYV9tYXRXb3JsZDAudywgYV9tYXRXb3JsZDEudywgYV9tYXRXb3JsZDIudywgMS4wKVxcbiAgICApO1xcbiAgI2VsaWYgVVNFX0JBVENISU5HXFxuICAgIG1hdFdvcmxkID0gY2NfbWF0V29ybGRzW2ludChhX2R5bl9iYXRjaF9pZCldO1xcbiAgI2Vsc2VcXG4gICAgbWF0V29ybGQgPSBjY19tYXRXb3JsZDtcXG4gICNlbmRpZlxcbiAgcG9zaXRpb24gPSBjY19tYXRQcm9qICogKGNjX21hdFZpZXcgKiBjY19tYXRMaWdodFBsYW5lUHJvaiAqIG1hdFdvcmxkKSAqIHBvc2l0aW9uO1xcbiAgcG9zaXRpb24ueiAtPSAwLjAwMDE7XFxuICByZXR1cm4gcG9zaXRpb247XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfUG9zaXRpb24gPSB2ZXJ0KCk7IH1gLFxyXG4gICAgICAgICAgXCJmcmFnXCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIENDU2hhZG93IHtcXG4gIGhpZ2hwIG1hdDQgY2NfbWF0TGlnaHRQbGFuZVByb2o7XFxuICBsb3dwIHZlYzQgY2Nfc2hhZG93Q29sb3I7XFxufTtcXG51bmlmb3JtIENDR2xvYmFsIHtcXG4gIGhpZ2hwICAgdmVjNCBjY190aW1lO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2NhbGU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbmF0aXZlU2l6ZTtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qSW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qSW52O1xcbiAgaGlnaHAgICB2ZWM0IGNjX2NhbWVyYVBvcztcXG4gIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0RGlyO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXRDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50U2t5O1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRHcm91bmQ7XFxufTtcXG52ZWMzIFNSR0JUb0xpbmVhciAodmVjMyBnYW1tYSkge1xcbiAgcmV0dXJuIGdhbW1hICogZ2FtbWE7XFxufVxcbnZlYzQgQ0NGcmFnT3V0cHV0ICh2ZWM0IGNvbG9yKSB7XFxuICAjaWYgQ0NfVVNFX0hEUlxcbiAgICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCBTUkdCVG9MaW5lYXIoY29sb3IucmdiKSAqIGNjX2V4cG9zdXJlLncsIHZlYzMoY2NfZXhwb3N1cmUueikpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gY29sb3I7XFxufVxcbnZlYzQgZnJhZyAoKSB7XFxuICByZXR1cm4gQ0NGcmFnT3V0cHV0KGNjX3NoYWRvd0NvbG9yKTtcXG59XFxub3V0IHZlYzQgY2NfRnJhZ0NvbG9yO1xcbnZvaWQgbWFpbigpIHsgY2NfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJnbHNsMVwiOiB7XHJcbiAgICAgICAgICBcInZlcnRcIjogYFxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5zdHJ1Y3QgU3RhbmRhcmRWZXJ0SW5wdXQge1xcbiAgaGlnaHAgdmVjNCBwb3NpdGlvbjtcXG4gIHZlYzMgbm9ybWFsO1xcbiAgdmVjNCB0YW5nZW50O1xcbn07XFxuYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcXG4jaWYgQ0NfVVNFX01PUlBIXFxuICAgIGF0dHJpYnV0ZSBmbG9hdCBhX3ZlcnRleElkO1xcbiAgICBpbnQgZ2V0VmVydGV4SWQoKSB7XFxuICAgICAgICByZXR1cm4gaW50KGFfdmVydGV4SWQpO1xcbiAgICB9XFxudW5pZm9ybSB2ZWM0IGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbMTVdO1xcbnVuaWZvcm0gdmVjNCBjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mbztcXG4gICAgdmVjNCBmZXRjaEZsYXRQaXhlbChzYW1wbGVyMkQgdGV4LCBpbnQgcGl4ZWxJbmRleCkge1xcbiAgICAgICAgZmxvYXQgcGl4ZWxJbmRleEYgPSBmbG9hdChwaXhlbEluZGV4KTtcXG4gICAgICAgIHZlYzIgdGV4dHVyZVJlc29sdXRpb24gPSB2ZWMyKGZsb2F0KGNjX2Rpc3BsYWNlbWVudFRleHR1cmVJbmZvLngpLCBmbG9hdChjY19kaXNwbGFjZW1lbnRUZXh0dXJlSW5mby55KSk7XFxuICAgICAgICBmbG9hdCBwaXhlbFggPSBtb2QocGl4ZWxJbmRleEYsIHRleHR1cmVSZXNvbHV0aW9uLngpO1xcbiAgICAgICAgZmxvYXQgcGl4ZWxZID0gZmxvb3IocGl4ZWxJbmRleEYgLyB0ZXh0dXJlUmVzb2x1dGlvbi54KTtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMihwaXhlbFgsIHBpeGVsWSkgKyAuNSkgLyB0ZXh0dXJlUmVzb2x1dGlvbjtcXG4gICAgICAgIHJldHVybiB0ZXh0dXJlMkQodGV4LCB1dik7XFxuICAgIH1cXG5mbG9hdCBnZXREaXNwbGFjZW1lbnRXZWlnaHQoaW50IGluZGV4KSB7XFxuICAgIGZsb2F0IG0gPSBtb2QoZmxvYXQoaW5kZXgpLCA0LjApO1xcbiAgICBpZiAobSA8IDEuMCkge1xcbiAgICAgICAgcmV0dXJuIGNjX2Rpc3BsYWNlbWVudFdlaWdodHNbaW5kZXggLyA0XS54O1xcbiAgICB9IGVsc2UgaWYgKG0gPCAyLjApIHtcXG4gICAgICAgIHJldHVybiBjY19kaXNwbGFjZW1lbnRXZWlnaHRzW2luZGV4IC8gNF0ueTtcXG4gICAgfSBlbHNlIGlmIChtIDwgMy4wKSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLno7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gY2NfZGlzcGxhY2VtZW50V2VpZ2h0c1tpbmRleCAvIDRdLnc7XFxuICAgIH1cXG59XFxudmVjMyBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoc2FtcGxlcjJEIHRleCwgaW50IHZlcnRleEluZGV4KSB7XFxuI2lmIENDX01PUlBIX1BSRUNPTVBVVEVEXFxuICAgIHJldHVybiBmZXRjaEZsYXRQaXhlbCh0ZXgsIHZlcnRleEluZGV4KS5yZ2I7XFxuI2Vsc2VcXG4gICAgdmVjMyByZXN1bHQgPSB2ZWMzKDAsIDAsIDApO1xcbiAgICBmb3IgKGludCBpVGFyZ2V0ID0gMDsgaVRhcmdldCA8IENDX01PUlBIX1RBUkdFVF9DT1VOVDsgKytpVGFyZ2V0KSB7XFxuICAgICAgICBpbnQgZGF0YVBpeGVsU3RhcnQgPSBpbnQoZmV0Y2hGbGF0UGl4ZWwodGV4LCBpVGFyZ2V0KS5yKTtcXG4gICAgICAgIHJlc3VsdCArPSAoZmV0Y2hGbGF0UGl4ZWwodGV4LCBkYXRhUGl4ZWxTdGFydCArIHZlcnRleEluZGV4KS5yZ2IgKiBnZXREaXNwbGFjZW1lbnRXZWlnaHQoaVRhcmdldCkpO1xcbiAgICB9XFxuICAgIHJldHVybiByZXN1bHQ7XFxuI2VuZGlmXFxufVxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIHVuaWZvcm0gc2FtcGxlcjJEIGNjX1Bvc2l0aW9uRGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfUG9zaXRpb25EaXNwbGFjZW1lbnRzLCB2ZXJ0ZXhJZCk7XFxuICAgIH1cXG4jZW5kaWZcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19OT1JNQUxcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfTm9ybWFsRGlzcGxhY2VtZW50cztcXG4gICAgdmVjMyBnZXROb3JtYWxEaXNwbGFjZW1lbnQoaW50IHZlcnRleElkKSB7XFxuICAgICAgICByZXR1cm4gZ2V0VmVjM0Rpc3BsYWNlbWVudEZyb21UZXh0dXJlKGNjX05vcm1hbERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1RBTkdFTlRcXG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgY2NfVGFuZ2VudERpc3BsYWNlbWVudHM7XFxuICAgIHZlYzMgZ2V0VGFuZ2VudERpc3BsYWNlbWVudChpbnQgdmVydGV4SWQpIHtcXG4gICAgICAgIHJldHVybiBnZXRWZWMzRGlzcGxhY2VtZW50RnJvbVRleHR1cmUoY2NfVGFuZ2VudERpc3BsYWNlbWVudHMsIHZlcnRleElkKTtcXG4gICAgfVxcbiNlbmRpZlxcbnZvaWQgYXBwbHlNb3JwaCAoaW5vdXQgU3RhbmRhcmRWZXJ0SW5wdXQgYXR0cikge1xcbiAgICBpbnQgdmVydGV4SWQgPSBnZXRWZXJ0ZXhJZCgpO1xcbiNpZiBDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXFxuICAgIGF0dHIucG9zaXRpb24ueHl6ID0gYXR0ci5wb3NpdGlvbi54eXogKyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfTk9STUFMXFxuICAgIGF0dHIubm9ybWFsLnh5eiA9IGF0dHIubm9ybWFsLnh5eiArIGdldE5vcm1hbERpc3BsYWNlbWVudCh2ZXJ0ZXhJZCk7XFxuI2VuZGlmXFxuI2lmIENDX01PUlBIX1RBUkdFVF9IQVNfVEFOR0VOVFxcbiAgICBhdHRyLnRhbmdlbnQueHl6ID0gYXR0ci50YW5nZW50Lnh5eiArIGdldFRhbmdlbnREaXNwbGFjZW1lbnQodmVydGV4SWQpO1xcbiNlbmRpZlxcbn1cXG52b2lkIGFwcGx5TW9ycGggKGlub3V0IHZlYzQgcG9zaXRpb24pIHtcXG4jaWYgQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlxcbiAgICBwb3NpdGlvbi54eXogPSBwb3NpdGlvbi54eXogKyBnZXRQb3NpdGlvbkRpc3BsYWNlbWVudChnZXRWZXJ0ZXhJZCgpKTtcXG4jZW5kaWZcXG59XFxuI2VuZGlmXFxuI2lmIENDX1VTRV9TS0lOTklOR1xcbmF0dHJpYnV0ZSB2ZWM0IGFfd2VpZ2h0cztcXG5hdHRyaWJ1dGUgdmVjNCBhX2pvaW50cztcXG4jaWYgQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlxcbiAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgIGF0dHJpYnV0ZSBoaWdocCB2ZWM0IGFfam9pbnRBbmltSW5mbztcXG4gICNlbmRpZlxcbiAgdW5pZm9ybSBoaWdocCB2ZWM0IGNjX2pvaW50VGV4dHVyZUluZm87XFxuICB1bmlmb3JtIGhpZ2hwIHZlYzQgY2Nfam9pbnRBbmltSW5mbztcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIGNjX2pvaW50VGV4dHVyZTtcXG4gICAgI2lmICFDQ19TVVBQT1JUX0ZMT0FUX1RFWFRVUkVcXG4gICAgaGlnaHAgZmxvYXQgZGVjb2RlMzIgKGhpZ2hwIHZlYzQgcmdiYSkge1xcbiAgICAgIHJnYmEgPSByZ2JhICogMjU1LjA7XFxuICAgICAgaGlnaHAgZmxvYXQgU2lnbiA9IDEuMCAtIHN0ZXAoMTI4LjAsIHJnYmFbM10pICogMi4wO1xcbiAgICAgIGhpZ2hwIGZsb2F0IEV4cG9uZW50ID0gMi4wICogbW9kKHJnYmFbM10sIDEyOC4wKSArIHN0ZXAoMTI4LjAsIHJnYmFbMl0pIC0gMTI3LjA7XFxuICAgICAgaGlnaHAgZmxvYXQgTWFudGlzc2EgPSBtb2QocmdiYVsyXSwgMTI4LjApICogNjU1MzYuMCArIHJnYmFbMV0gKiAyNTYuMCArIHJnYmFbMF0gKyA4Mzg4NjA4LjA7XFxuICAgICAgcmV0dXJuIFNpZ24gKiBleHAyKEV4cG9uZW50IC0gMjMuMCkgKiBNYW50aXNzYTtcXG4gICAgfVxcbiAgI2VuZGlmXFxuI2Vsc2VcXG4gIHVuaWZvcm0gaGlnaHAgdmVjNCBjY19qb2ludHNbOTBdO1xcbiNlbmRpZlxcbiNpZiBDQ19VU0VfQkFLRURfQU5JTUFUSU9OXFxuICAjaWYgQ0NfU1VQUE9SVF9GTE9BVF9URVhUVVJFXFxuICAgIG1hdDQgZ2V0Sm9pbnRNYXRyaXggKGZsb2F0IGkpIHtcXG4gICAgI2lmIFVTRV9JTlNUQU5DSU5HXFxuICAgICAgaGlnaHAgZmxvYXQgaiA9IDMuMCAqIChhX2pvaW50QW5pbUluZm8ueCAqIGFfam9pbnRBbmltSW5mby55ICsgaSkgKyBhX2pvaW50QW5pbUluZm8uejtcXG4gICAgI2Vsc2VcXG4gICAgICBoaWdocCBmbG9hdCBqID0gMy4wICogKGNjX2pvaW50QW5pbUluZm8ueCAqIGNjX2pvaW50VGV4dHVyZUluZm8ueSArIGkpICsgY2Nfam9pbnRUZXh0dXJlSW5mby56O1xcbiAgICAjZW5kaWZcXG4gICAgaGlnaHAgZmxvYXQgaW52U2l6ZSA9IGNjX2pvaW50VGV4dHVyZUluZm8udztcXG4gICAgaGlnaHAgZmxvYXQgeSA9IGZsb29yKGogKiBpbnZTaXplKTtcXG4gICAgaGlnaHAgZmxvYXQgeCA9IGogLSB5ICogY2Nfam9pbnRUZXh0dXJlSW5mby54O1xcbiAgICB5ID0gKHkgKyAwLjUpICogaW52U2l6ZTtcXG4gICAgICB2ZWM0IHYxID0gdGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDAuNSkgKiBpbnZTaXplLCB5KSk7XFxuICAgICAgdmVjNCB2MiA9IHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpO1xcbiAgICAgIHZlYzQgdjMgPSB0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgMi41KSAqIGludlNpemUsIHkpKTtcXG4gICAgICByZXR1cm4gbWF0NCh2ZWM0KHYxLnh5eiwgMC4wKSwgdmVjNCh2Mi54eXosIDAuMCksIHZlYzQodjMueHl6LCAwLjApLCB2ZWM0KHYxLncsIHYyLncsIHYzLncsIDEuMCkpO1xcbiAgICB9XFxuICAjZWxzZVxcbiAgICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAxMi4wICogKGFfam9pbnRBbmltSW5mby54ICogYV9qb2ludEFuaW1JbmZvLnkgKyBpKSArIGFfam9pbnRBbmltSW5mby56O1xcbiAgICAjZWxzZVxcbiAgICAgIGhpZ2hwIGZsb2F0IGogPSAxMi4wICogKGNjX2pvaW50QW5pbUluZm8ueCAqIGNjX2pvaW50VGV4dHVyZUluZm8ueSArIGkpICsgY2Nfam9pbnRUZXh0dXJlSW5mby56O1xcbiAgICAjZW5kaWZcXG4gICAgaGlnaHAgZmxvYXQgaW52U2l6ZSA9IGNjX2pvaW50VGV4dHVyZUluZm8udztcXG4gICAgaGlnaHAgZmxvYXQgeSA9IGZsb29yKGogKiBpbnZTaXplKTtcXG4gICAgaGlnaHAgZmxvYXQgeCA9IGogLSB5ICogY2Nfam9pbnRUZXh0dXJlSW5mby54O1xcbiAgICB5ID0gKHkgKyAwLjUpICogaW52U2l6ZTtcXG4gICAgICB2ZWM0IHYxID0gdmVjNChcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAwLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAyLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAzLjUpICogaW52U2l6ZSwgeSkpKVxcbiAgICAgICk7XFxuICAgICAgdmVjNCB2MiA9IHZlYzQoXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNC41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNS41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNi41KSAqIGludlNpemUsIHkpKSksXFxuICAgICAgICBkZWNvZGUzMih0ZXh0dXJlMkQoY2Nfam9pbnRUZXh0dXJlLCB2ZWMyKCh4ICsgNy41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHZlYzQgdjMgPSB2ZWM0KFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDguNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDkuNSkgKiBpbnZTaXplLCB5KSkpLFxcbiAgICAgICAgZGVjb2RlMzIodGV4dHVyZTJEKGNjX2pvaW50VGV4dHVyZSwgdmVjMigoeCArIDEwLjUpICogaW52U2l6ZSwgeSkpKSxcXG4gICAgICAgIGRlY29kZTMyKHRleHR1cmUyRChjY19qb2ludFRleHR1cmUsIHZlYzIoKHggKyAxMS41KSAqIGludlNpemUsIHkpKSlcXG4gICAgICApO1xcbiAgICAgIHJldHVybiBtYXQ0KHZlYzQodjEueHl6LCAwLjApLCB2ZWM0KHYyLnh5eiwgMC4wKSwgdmVjNCh2My54eXosIDAuMCksIHZlYzQodjEudywgdjIudywgdjMudywgMS4wKSk7XFxuICAgIH1cXG4gICNlbmRpZlxcbiNlbHNlXFxuICBtYXQ0IGdldEpvaW50TWF0cml4IChmbG9hdCBpKSB7XFxuICAgIGludCBpZHggPSBpbnQoaSk7XFxuICAgIHZlYzQgdjEgPSBjY19qb2ludHNbaWR4ICogM107XFxuICAgIHZlYzQgdjIgPSBjY19qb2ludHNbaWR4ICogMyArIDFdO1xcbiAgICB2ZWM0IHYzID0gY2Nfam9pbnRzW2lkeCAqIDMgKyAyXTtcXG4gICAgcmV0dXJuIG1hdDQodmVjNCh2MS54eXosIDAuMCksIHZlYzQodjIueHl6LCAwLjApLCB2ZWM0KHYzLnh5eiwgMC4wKSwgdmVjNCh2MS53LCB2Mi53LCB2My53LCAxLjApKTtcXG4gIH1cXG4jZW5kaWZcXG5tYXQ0IHNraW5NYXRyaXggKCkge1xcbiAgcmV0dXJuIGdldEpvaW50TWF0cml4KGFfam9pbnRzLngpICogYV93ZWlnaHRzLnhcXG4gICAgICAgKyBnZXRKb2ludE1hdHJpeChhX2pvaW50cy55KSAqIGFfd2VpZ2h0cy55XFxuICAgICAgICsgZ2V0Sm9pbnRNYXRyaXgoYV9qb2ludHMueikgKiBhX3dlaWdodHMuelxcbiAgICAgICArIGdldEpvaW50TWF0cml4KGFfam9pbnRzLncpICogYV93ZWlnaHRzLnc7XFxufVxcbnZvaWQgQ0NTa2luIChpbm91dCB2ZWM0IHBvc2l0aW9uKSB7XFxuICBtYXQ0IG0gPSBza2luTWF0cml4KCk7XFxuICBwb3NpdGlvbiA9IG0gKiBwb3NpdGlvbjtcXG59XFxudm9pZCBDQ1NraW4gKGlub3V0IFN0YW5kYXJkVmVydElucHV0IGF0dHIpIHtcXG4gIG1hdDQgbSA9IHNraW5NYXRyaXgoKTtcXG4gIGF0dHIucG9zaXRpb24gPSBtICogYXR0ci5wb3NpdGlvbjtcXG4gIGF0dHIubm9ybWFsID0gKG0gKiB2ZWM0KGF0dHIubm9ybWFsLCAwLjApKS54eXo7XFxuICBhdHRyLnRhbmdlbnQueHl6ID0gKG0gKiB2ZWM0KGF0dHIudGFuZ2VudC54eXosIDAuMCkpLnh5ejtcXG59XFxuI2VuZGlmXFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFZpZXc7XFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFByb2o7XFxuI2lmIFVTRV9JTlNUQU5DSU5HXFxuICBhdHRyaWJ1dGUgdmVjNCBhX21hdFdvcmxkMDtcXG4gIGF0dHJpYnV0ZSB2ZWM0IGFfbWF0V29ybGQxO1xcbiAgYXR0cmlidXRlIHZlYzQgYV9tYXRXb3JsZDI7XFxuI2VsaWYgVVNFX0JBVENISU5HXFxuICBhdHRyaWJ1dGUgZmxvYXQgYV9keW5fYmF0Y2hfaWQ7XFxuICB1bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0V29ybGRzWzEwXTtcXG4jZWxzZVxcbnVuaWZvcm0gaGlnaHAgbWF0NCBjY19tYXRXb3JsZDtcXG4jZW5kaWZcXG51bmlmb3JtIGhpZ2hwIG1hdDQgY2NfbWF0TGlnaHRQbGFuZVByb2o7XFxudmVjNCB2ZXJ0ICgpIHtcXG4gIHZlYzQgcG9zaXRpb247XFxuICBwb3NpdGlvbiA9IHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcXG4gICNpZiBDQ19VU0VfTU9SUEhcXG4gICAgYXBwbHlNb3JwaChwb3NpdGlvbik7XFxuICAjZW5kaWZcXG4gICNpZiBDQ19VU0VfU0tJTk5JTkdcXG4gICAgQ0NTa2luKHBvc2l0aW9uKTtcXG4gICNlbmRpZlxcbiAgbWF0NCBtYXRXb3JsZDtcXG4gICNpZiBVU0VfSU5TVEFOQ0lOR1xcbiAgICBtYXRXb3JsZCA9IG1hdDQoXFxuICAgICAgdmVjNChhX21hdFdvcmxkMC54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMS54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMi54eXosIDAuMCksXFxuICAgICAgdmVjNChhX21hdFdvcmxkMC53LCBhX21hdFdvcmxkMS53LCBhX21hdFdvcmxkMi53LCAxLjApXFxuICAgICk7XFxuICAjZWxpZiBVU0VfQkFUQ0hJTkdcXG4gICAgbWF0V29ybGQgPSBjY19tYXRXb3JsZHNbaW50KGFfZHluX2JhdGNoX2lkKV07XFxuICAjZWxzZVxcbiAgICBtYXRXb3JsZCA9IGNjX21hdFdvcmxkO1xcbiAgI2VuZGlmXFxuICBwb3NpdGlvbiA9IGNjX21hdFByb2ogKiAoY2NfbWF0VmlldyAqIGNjX21hdExpZ2h0UGxhbmVQcm9qICogbWF0V29ybGQpICogcG9zaXRpb247XFxuICBwb3NpdGlvbi56IC09IDAuMDAwMTtcXG4gIHJldHVybiBwb3NpdGlvbjtcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZlcnQoKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gbG93cCB2ZWM0IGNjX3NoYWRvd0NvbG9yO1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiBDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIFNSR0JUb0xpbmVhcihjb2xvci5yZ2IpICogY2NfZXhwb3N1cmUudywgdmVjMyhjY19leHBvc3VyZS56KSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxudmVjNCBmcmFnICgpIHtcXG4gIHJldHVybiBDQ0ZyYWdPdXRwdXQoY2Nfc2hhZG93Q29sb3IpO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX0ZyYWdDb2xvciA9IGZyYWcoKTsgfWBcclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiYnVpbHRpbnNcIjoge1xyXG4gICAgICAgICAgXCJnbG9iYWxzXCI6IHsgXCJibG9ja3NcIjogW3sgXCJuYW1lXCI6IFwiQ0NHbG9iYWxcIiwgXCJkZWZpbmVzXCI6IFtdIH0sIHsgXCJuYW1lXCI6IFwiQ0NTaGFkb3dcIiwgXCJkZWZpbmVzXCI6IFtdIH1dLCBcInNhbXBsZXJzXCI6IFtdIH0sXHJcbiAgICAgICAgICBcImxvY2Fsc1wiOiB7IFwiYmxvY2tzXCI6IFt7IFwibmFtZVwiOiBcIkNDTW9ycGhcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9NT1JQSFwiXSB9LCB7IFwibmFtZVwiOiBcIkNDU2tpbm5pbmdUZXh0dXJlXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfU0tJTk5JTkdcIiwgXCJDQ19VU0VfQkFLRURfQU5JTUFUSU9OXCJdIH0sIHsgXCJuYW1lXCI6IFwiQ0NTa2lubmluZ0FuaW1hdGlvblwiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCIsIFwiQ0NfVVNFX0JBS0VEX0FOSU1BVElPTlwiXSB9LCB7IFwibmFtZVwiOiBcIkNDU2tpbm5pbmdcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9TS0lOTklOR1wiLCBcIiFDQ19VU0VfQkFLRURfQU5JTUFUSU9OXCJdIH0sIHsgXCJuYW1lXCI6IFwiQ0NMb2NhbEJhdGNoZWRcIiwgXCJkZWZpbmVzXCI6IFtcIiFVU0VfSU5TVEFOQ0lOR1wiLCBcIlVTRV9CQVRDSElOR1wiXSB9LCB7IFwibmFtZVwiOiBcIkNDTG9jYWxcIiwgXCJkZWZpbmVzXCI6IFtcIiFVU0VfSU5TVEFOQ0lOR1wiLCBcIiFVU0VfQkFUQ0hJTkdcIl0gfV0sIFwic2FtcGxlcnNcIjogW3sgXCJuYW1lXCI6IFwiY2NfUG9zaXRpb25EaXNwbGFjZW1lbnRzXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfTU9SUEhcIiwgXCJDQ19NT1JQSF9UQVJHRVRfSEFTX1BPU0lUSU9OXCJdIH0sIHsgXCJuYW1lXCI6IFwiY2NfTm9ybWFsRGlzcGxhY2VtZW50c1wiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX01PUlBIXCIsIFwiQ0NfTU9SUEhfVEFSR0VUX0hBU19OT1JNQUxcIl0gfSwgeyBcIm5hbWVcIjogXCJjY19UYW5nZW50RGlzcGxhY2VtZW50c1wiLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX01PUlBIXCIsIFwiQ0NfTU9SUEhfVEFSR0VUX0hBU19UQU5HRU5UXCJdIH0sIHsgXCJuYW1lXCI6IFwiY2Nfam9pbnRUZXh0dXJlXCIsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfU0tJTk5JTkdcIiwgXCJDQ19VU0VfQkFLRURfQU5JTUFUSU9OXCJdIH1dIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGVmaW5lc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9NT1JQSFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfTU9SUEhfVEFSR0VUX0NPVU5UXCIsIFwidHlwZVwiOiBcIm51bWJlclwiLCBcInJhbmdlXCI6IFsyLCA4XSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19NT1JQSF9QUkVDT01QVVRFRFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfTU9SUEhfVEFSR0VUX0hBU19QT1NJVElPTlwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfTU9SUEhfVEFSR0VUX0hBU19OT1JNQUxcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX01PUlBIX1RBUkdFVF9IQVNfVEFOR0VOVFwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX1NLSU5OSU5HXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJDQ19VU0VfQkFLRURfQU5JTUFUSU9OXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJVU0VfSU5TVEFOQ0lOR1wiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfU1VQUE9SVF9GTE9BVF9URVhUVVJFXCIsIFwidHlwZVwiOiBcImJvb2xlYW5cIiB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJVU0VfQkFUQ0hJTkdcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9IRFJcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiYmxvY2tzXCI6IFtdLFxyXG4gICAgICAgIFwic2FtcGxlcnNcIjogW10sXHJcbiAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9wb3NpdGlvblwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiAwIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfdmVydGV4SWRcIiwgXCJ0eXBlXCI6IDEzLCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJDQ19VU0VfTU9SUEhcIl0sIFwiZm9ybWF0XCI6IDExLCBcImxvY2F0aW9uXCI6IDEgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV93ZWlnaHRzXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCJdLCBcImZvcm1hdFwiOiA0MywgXCJsb2NhdGlvblwiOiAyIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfam9pbnRzXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiQ0NfVVNFX1NLSU5OSU5HXCJdLCBcImZvcm1hdFwiOiA0MywgXCJsb2NhdGlvblwiOiAzIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfam9pbnRBbmltSW5mb1wiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJwcmVjaXNpb25cIjogXCJoaWdocCBcIiwgXCJkZWZpbmVzXCI6IFtcIkNDX1VTRV9TS0lOTklOR1wiLCBcIkNDX1VTRV9CQUtFRF9BTklNQVRJT05cIiwgXCJVU0VfSU5TVEFOQ0lOR1wiXSwgXCJmb3JtYXRcIjogNDMsIFwiaXNJbnN0YW5jZWRcIjogdHJ1ZSwgXCJsb2NhdGlvblwiOiA0IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfbWF0V29ybGQwXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiVVNFX0lOU1RBTkNJTkdcIl0sIFwiZm9ybWF0XCI6IDQzLCBcImlzSW5zdGFuY2VkXCI6IHRydWUsIFwibG9jYXRpb25cIjogNSB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX21hdFdvcmxkMVwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtcIlVTRV9JTlNUQU5DSU5HXCJdLCBcImZvcm1hdFwiOiA0MywgXCJpc0luc3RhbmNlZFwiOiB0cnVlLCBcImxvY2F0aW9uXCI6IDYgfSxcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9tYXRXb3JsZDJcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXCJVU0VfSU5TVEFOQ0lOR1wiXSwgXCJmb3JtYXRcIjogNDMsIFwiaXNJbnN0YW5jZWRcIjogdHJ1ZSwgXCJsb2NhdGlvblwiOiA3IH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfZHluX2JhdGNoX2lkXCIsIFwidHlwZVwiOiAxMywgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW1wiIVVTRV9JTlNUQU5DSU5HXCIsIFwiVVNFX0JBVENISU5HXCJdLCBcImZvcm1hdFwiOiAxMSwgXCJsb2NhdGlvblwiOiA4IH1cclxuICAgICAgICBdXHJcbiAgICAgIH1cclxuICAgIF1cclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcInBpcGVsaW5lL3NreWJveFwiLFxyXG4gICAgXCJfdXVpZFwiOiBcIjUxMWQyNjMzLTA5YTctNGJkZC1hYzQyLWY3NzgwMzIxMjRiM1wiLFxyXG4gICAgXCJ0ZWNobmlxdWVzXCI6IFtcclxuICAgICAgeyBcInBhc3Nlc1wiOiBbeyBcInJhc3Rlcml6ZXJTdGF0ZVwiOiB7IFwiY3VsbE1vZGVcIjogMCB9LCBcInByb2dyYW1cIjogXCJwaXBlbGluZS9za3lib3h8c2t5LXZzOnZlcnR8c2t5LWZzOmZyYWdcIiwgXCJwcmlvcml0eVwiOiAyNDUsIFwiZGVwdGhTdGVuY2lsU3RhdGVcIjogeyBcImRlcHRoVGVzdFwiOiB0cnVlLCBcImRlcHRoV3JpdGVcIjogZmFsc2UgfSB9XSB9XHJcbiAgICBdLFxyXG4gICAgXCJzaGFkZXJzXCI6IFtcclxuICAgICAge1xyXG4gICAgICAgIFwibmFtZVwiOiBcInBpcGVsaW5lL3NreWJveHxza3ktdnM6dmVydHxza3ktZnM6ZnJhZ1wiLFxyXG4gICAgICAgIFwiaGFzaFwiOiAxNDQ5NzAwNjcyLFxyXG4gICAgICAgIFwiZ2xzbDNcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxudW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbn07XFxuc3RydWN0IFN0YW5kYXJkVmVydElucHV0IHtcXG4gIGhpZ2hwIHZlYzQgcG9zaXRpb247XFxuICB2ZWMzIG5vcm1hbDtcXG4gIHZlYzQgdGFuZ2VudDtcXG59O1xcbmluIHZlYzMgYV9wb3NpdGlvbjtcXG5vdXQgdmVjNCB2aWV3RGlyO1xcbnZlYzQgdmVydCAoKSB7XFxuICB2aWV3RGlyID0gdmVjNChhX3Bvc2l0aW9uLCAxLjApO1xcbiAgbWF0NCBtYXRWaWV3Um90T25seSA9IG1hdDQobWF0MyhjY19tYXRWaWV3KSk7XFxuICB2ZWM0IHBvcyA9IG1hdFZpZXdSb3RPbmx5ICogdmlld0RpcjtcXG4gIHZlYzIgZiA9IGNjX21hdFByb2pbM11bM10gPiAwLjAgPyB2ZWMyKDQuOCwgMi40KSA6IHZlYzIoY2NfbWF0UHJvalsxXVsxXSk7XFxuICBwb3MueHkgKj0gdmVjMihjY19zY3JlZW5TaXplLnkgKiBjY19zY3JlZW5TaXplLnosIDEuMCkgKiBmO1xcbiAgcG9zLnp3ID0gdmVjMigtMC45OTk5OSAqIHBvcy56LCAtcG9zLnopO1xcbiAgcmV0dXJuIHBvcztcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZlcnQoKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gQ0NHbG9iYWwge1xcbiAgaGlnaHAgICB2ZWM0IGNjX3RpbWU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TY2FsZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19uYXRpdmVTaXplO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXc7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld0ludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2pJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0Vmlld1Byb2pJbnY7XFxuICBoaWdocCAgIHZlYzQgY2NfY2FtZXJhUG9zO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXREaXI7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdENvbG9yO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRTa3k7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudEdyb3VuZDtcXG59O1xcbnVuaWZvcm0gc2FtcGxlckN1YmUgY2NfZW52aXJvbm1lbnQ7XFxudmVjMyB1bnBhY2tSR0JFICh2ZWM0IHJnYmUpIHtcXG4gIHJldHVybiByZ2JlLnJnYiAqIHBvdygyLjAsIHJnYmUuYSAqIDI1NS4wIC0gMTI4LjApO1xcbn1cXG52ZWMzIFNSR0JUb0xpbmVhciAodmVjMyBnYW1tYSkge1xcbiAgcmV0dXJuIGdhbW1hICogZ2FtbWE7XFxufVxcbnZlYzMgQUNFU1RvbmVNYXAgKHZlYzMgY29sb3IpIHtcXG4gIGNvbG9yID0gbWluKGNvbG9yLCB2ZWMzKDguMCkpO1xcbiAgY29uc3QgZmxvYXQgQSA9IDIuNTE7XFxuICBjb25zdCBmbG9hdCBCID0gMC4wMztcXG4gIGNvbnN0IGZsb2F0IEMgPSAyLjQzO1xcbiAgY29uc3QgZmxvYXQgRCA9IDAuNTk7XFxuICBjb25zdCBmbG9hdCBFID0gMC4xNDtcXG4gIHJldHVybiAoY29sb3IgKiAoQSAqIGNvbG9yICsgQikpIC8gKGNvbG9yICogKEMgKiBjb2xvciArIEQpICsgRSk7XFxufVxcbnZlYzQgQ0NGcmFnT3V0cHV0ICh2ZWM0IGNvbG9yKSB7XFxuICAjaWYgIUNDX1VTRV9IRFJcXG4gICAgY29sb3IucmdiID0gc3FydChBQ0VTVG9uZU1hcChjb2xvci5yZ2IpKTtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIGNvbG9yO1xcbn1cXG5pbiB2ZWM0IHZpZXdEaXI7XFxudmVjNCBmcmFnICgpIHtcXG4gICNpZiBVU0VfUkdCRV9DVUJFTUFQXFxuICAgIHZlYzMgYyA9IHVucGFja1JHQkUodGV4dHVyZShjY19lbnZpcm9ubWVudCwgdmlld0Rpci54eXopKTtcXG4gICNlbHNlXFxuICAgIHZlYzMgYyA9IFNSR0JUb0xpbmVhcih0ZXh0dXJlKGNjX2Vudmlyb25tZW50LCB2aWV3RGlyLnh5eikucmdiKTtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIENDRnJhZ091dHB1dCh2ZWM0KGMgKiBjY19hbWJpZW50U2t5LncsIDEuMCkpO1xcbn1cXG5vdXQgdmVjNCBjY19GcmFnQ29sb3I7XFxudm9pZCBtYWluKCkgeyBjY19GcmFnQ29sb3IgPSBmcmFnKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImdsc2wxXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFZpZXc7XFxudW5pZm9ybSBoaWdocCBtYXQ0IGNjX21hdFByb2o7XFxuc3RydWN0IFN0YW5kYXJkVmVydElucHV0IHtcXG4gIGhpZ2hwIHZlYzQgcG9zaXRpb247XFxuICB2ZWMzIG5vcm1hbDtcXG4gIHZlYzQgdGFuZ2VudDtcXG59O1xcbmF0dHJpYnV0ZSB2ZWMzIGFfcG9zaXRpb247XFxudmFyeWluZyB2ZWM0IHZpZXdEaXI7XFxudmVjNCB2ZXJ0ICgpIHtcXG4gIHZpZXdEaXIgPSB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XFxuICBtYXQ0IG1hdFZpZXdSb3RPbmx5ID0gbWF0NChtYXQzKGNjX21hdFZpZXcpKTtcXG4gIHZlYzQgcG9zID0gbWF0Vmlld1JvdE9ubHkgKiB2aWV3RGlyO1xcbiAgdmVjMiBmID0gY2NfbWF0UHJvalszXVszXSA+IDAuMCA/IHZlYzIoNC44LCAyLjQpIDogdmVjMihjY19tYXRQcm9qWzFdWzFdKTtcXG4gIHBvcy54eSAqPSB2ZWMyKGNjX3NjcmVlblNpemUueSAqIGNjX3NjcmVlblNpemUueiwgMS4wKSAqIGY7XFxuICBwb3MuencgPSB2ZWMyKC0wLjk5OTk5ICogcG9zLnosIC1wb3Mueik7XFxuICByZXR1cm4gcG9zO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdmVydCgpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG51bmlmb3JtIHNhbXBsZXJDdWJlIGNjX2Vudmlyb25tZW50O1xcbnZlYzMgdW5wYWNrUkdCRSAodmVjNCByZ2JlKSB7XFxuICByZXR1cm4gcmdiZS5yZ2IgKiBwb3coMi4wLCByZ2JlLmEgKiAyNTUuMCAtIDEyOC4wKTtcXG59XFxudmVjMyBTUkdCVG9MaW5lYXIgKHZlYzMgZ2FtbWEpIHtcXG4gIHJldHVybiBnYW1tYSAqIGdhbW1hO1xcbn1cXG52ZWMzIEFDRVNUb25lTWFwICh2ZWMzIGNvbG9yKSB7XFxuICBjb2xvciA9IG1pbihjb2xvciwgdmVjMyg4LjApKTtcXG4gIGNvbnN0IGZsb2F0IEEgPSAyLjUxO1xcbiAgY29uc3QgZmxvYXQgQiA9IDAuMDM7XFxuICBjb25zdCBmbG9hdCBDID0gMi40MztcXG4gIGNvbnN0IGZsb2F0IEQgPSAwLjU5O1xcbiAgY29uc3QgZmxvYXQgRSA9IDAuMTQ7XFxuICByZXR1cm4gKGNvbG9yICogKEEgKiBjb2xvciArIEIpKSAvIChjb2xvciAqIChDICogY29sb3IgKyBEKSArIEUpO1xcbn1cXG52ZWM0IENDRnJhZ091dHB1dCAodmVjNCBjb2xvcikge1xcbiAgI2lmICFDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IHNxcnQoQUNFU1RvbmVNYXAoY29sb3IucmdiKSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxudmFyeWluZyB2ZWM0IHZpZXdEaXI7XFxudmVjNCBmcmFnICgpIHtcXG4gICNpZiBVU0VfUkdCRV9DVUJFTUFQXFxuICAgIHZlYzMgYyA9IHVucGFja1JHQkUodGV4dHVyZUN1YmUoY2NfZW52aXJvbm1lbnQsIHZpZXdEaXIueHl6KSk7XFxuICAjZWxzZVxcbiAgICB2ZWMzIGMgPSBTUkdCVG9MaW5lYXIodGV4dHVyZUN1YmUoY2NfZW52aXJvbm1lbnQsIHZpZXdEaXIueHl6KS5yZ2IpO1xcbiAgI2VuZGlmXFxuICByZXR1cm4gQ0NGcmFnT3V0cHV0KHZlYzQoYyAqIGNjX2FtYmllbnRTa3kudywgMS4wKSk7XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJidWlsdGluc1wiOiB7XHJcbiAgICAgICAgICBcImdsb2JhbHNcIjogeyBcImJsb2Nrc1wiOiBbeyBcIm5hbWVcIjogXCJDQ0dsb2JhbFwiLCBcImRlZmluZXNcIjogW10gfV0sIFwic2FtcGxlcnNcIjogW3sgXCJuYW1lXCI6IFwiY2NfZW52aXJvbm1lbnRcIiwgXCJkZWZpbmVzXCI6IFtdIH1dIH0sXHJcbiAgICAgICAgICBcImxvY2Fsc1wiOiB7IFwiYmxvY2tzXCI6IFtdLCBcInNhbXBsZXJzXCI6IFtdIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwiZGVmaW5lc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9JQkxcIiwgXCJ0eXBlXCI6IFwibnVtYmVyXCIsIFwicmFuZ2VcIjogWzAsIDJdIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIkNDX1VTRV9IRFJcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH0sXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcIlVTRV9SR0JFX0NVQkVNQVBcIiwgXCJ0eXBlXCI6IFwiYm9vbGVhblwiIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiYmxvY2tzXCI6IFtdLFxyXG4gICAgICAgIFwic2FtcGxlcnNcIjogW10sXHJcbiAgICAgICAgXCJhdHRyaWJ1dGVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYV9wb3NpdGlvblwiLCBcInR5cGVcIjogMTUsIFwiY291bnRcIjogMSwgXCJkZWZpbmVzXCI6IFtdLCBcImZvcm1hdFwiOiAzMiwgXCJsb2NhdGlvblwiOiAwIH1cclxuICAgICAgICBdXHJcbiAgICAgIH1cclxuICAgIF1cclxuICB9LFxyXG4gIHtcclxuICAgIFwibmFtZVwiOiBcInV0aWwvcHJvZmlsZXJcIixcclxuICAgIFwiX3V1aWRcIjogXCI4NzFjM2I2Yy03Mzc5LTQxOWQtYmRhMy03OTRiMjM5YWI5MGRcIixcclxuICAgIFwidGVjaG5pcXVlc1wiOiBbXHJcbiAgICAgIHsgXCJwYXNzZXNcIjogW3sgXCJibGVuZFN0YXRlXCI6IHsgXCJ0YXJnZXRzXCI6IFt7IFwiYmxlbmRcIjogdHJ1ZSwgXCJibGVuZFNyY1wiOiAyLCBcImJsZW5kRHN0XCI6IDQsIFwiYmxlbmREc3RBbHBoYVwiOiA0IH1dIH0sIFwicmFzdGVyaXplclN0YXRlXCI6IHsgXCJjdWxsTW9kZVwiOiAwIH0sIFwicHJvZ3JhbVwiOiBcInV0aWwvcHJvZmlsZXJ8cHJvZmlsZXItdnM6dmVydHxwcm9maWxlci1mczpmcmFnXCIsIFwiZGVwdGhTdGVuY2lsU3RhdGVcIjogeyBcImRlcHRoVGVzdFwiOiBmYWxzZSwgXCJkZXB0aFdyaXRlXCI6IGZhbHNlIH0gfV0gfVxyXG4gICAgXSxcclxuICAgIFwic2hhZGVyc1wiOiBbXHJcbiAgICAgIHtcclxuICAgICAgICBcIm5hbWVcIjogXCJ1dGlsL3Byb2ZpbGVyfHByb2ZpbGVyLXZzOnZlcnR8cHJvZmlsZXItZnM6ZnJhZ1wiLFxyXG4gICAgICAgIFwiaGFzaFwiOiAzNDM4NzEwNzM1LFxyXG4gICAgICAgIFwiZ2xzbDNcIjoge1xyXG4gICAgICAgICAgXCJ2ZXJ0XCI6IGBcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG51bmlmb3JtIENDR2xvYmFsIHtcXG4gIGhpZ2hwICAgdmVjNCBjY190aW1lO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNpemU7XFxuICBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2NhbGU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbmF0aXZlU2l6ZTtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdJbnY7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRQcm9qSW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qO1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFZpZXdQcm9qSW52O1xcbiAgaGlnaHAgICB2ZWM0IGNjX2NhbWVyYVBvcztcXG4gIG1lZGl1bXAgdmVjNCBjY19leHBvc3VyZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0RGlyO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX21haW5MaXRDb2xvcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50U2t5O1xcbiAgbWVkaXVtcCB2ZWM0IGNjX2FtYmllbnRHcm91bmQ7XFxufTtcXG5zdHJ1Y3QgU3RhbmRhcmRWZXJ0SW5wdXQge1xcbiAgaGlnaHAgdmVjNCBwb3NpdGlvbjtcXG4gIHZlYzMgbm9ybWFsO1xcbiAgdmVjNCB0YW5nZW50O1xcbn07XFxuaW4gdmVjMyBhX3Bvc2l0aW9uO1xcbmluIHZlYzQgYV9jb2xvcjtcXG5vdXQgdmVjMiB2X3V2O1xcbnVuaWZvcm0gQ29uc3RhbnRzIHtcXG4gIHZlYzQgb2Zmc2V0O1xcbn07XFxudW5pZm9ybSBQZXJGcmFtZUluZm8ge1xcbiAgdmVjNCBkaWdpdHNbOCAqIDEwIC8gNF07XFxufTtcXG5mbG9hdCBnZXRDb21wb25lbnQodmVjNCB2LCBmbG9hdCBpKSB7XFxuICBpZiAoaSA8IDEuMCkgeyByZXR1cm4gdi54OyB9XFxuICBlbHNlIGlmIChpIDwgMi4wKSB7IHJldHVybiB2Lnk7IH1cXG4gIGVsc2UgaWYgKGkgPCAzLjApIHsgcmV0dXJuIHYuejsgfVxcbiAgZWxzZSB7IHJldHVybiB2Lnc7IH1cXG59XFxudmVjNCB2ZXJ0ICgpIHtcXG4gIHZlYzQgcG9zaXRpb247XFxuICBwb3NpdGlvbiA9IHZlYzQoYV9wb3NpdGlvbiwgMS4wKTtcXG4gIHBvc2l0aW9uLnggKj0gY2Nfc2NyZWVuU2l6ZS55ICogY2Nfc2NyZWVuU2l6ZS56O1xcbiAgcG9zaXRpb24ueHkgKz0gb2Zmc2V0Lnh5ICsgYWJzKHBvc2l0aW9uLnh5KTtcXG4gIHZfdXYgPSBhX2NvbG9yLnh5O1xcbiAgaWYgKGFfY29sb3IueiA+PSAwLjApIHtcXG4gICAgZmxvYXQgbiA9IGdldENvbXBvbmVudChkaWdpdHNbaW50KGFfY29sb3IueildLCBhX2NvbG9yLncpO1xcbiAgICB2X3V2ICs9IHZlYzIob2Zmc2V0LnogKiBuLCAwLjApO1xcbiAgfVxcbiAgcmV0dXJuIHBvc2l0aW9uO1xcbn1cXG52b2lkIG1haW4oKSB7IGdsX1Bvc2l0aW9uID0gdmVydCgpOyB9YCxcclxuICAgICAgICAgIFwiZnJhZ1wiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBDQ0dsb2JhbCB7XFxuICBoaWdocCAgIHZlYzQgY2NfdGltZTtcXG4gIG1lZGl1bXAgdmVjNCBjY19zY3JlZW5TaXplO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX3NjcmVlblNjYWxlO1xcbiAgbWVkaXVtcCB2ZWM0IGNjX25hdGl2ZVNpemU7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0VmlldztcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3SW52O1xcbiAgaGlnaHAgICBtYXQ0IGNjX21hdFByb2o7XFxuICBoaWdocCAgIG1hdDQgY2NfbWF0UHJvakludjtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvajtcXG4gIGhpZ2hwICAgbWF0NCBjY19tYXRWaWV3UHJvakludjtcXG4gIGhpZ2hwICAgdmVjNCBjY19jYW1lcmFQb3M7XFxuICBtZWRpdW1wIHZlYzQgY2NfZXhwb3N1cmU7XFxuICBtZWRpdW1wIHZlYzQgY2NfbWFpbkxpdERpcjtcXG4gIG1lZGl1bXAgdmVjNCBjY19tYWluTGl0Q29sb3I7XFxuICBtZWRpdW1wIHZlYzQgY2NfYW1iaWVudFNreTtcXG4gIG1lZGl1bXAgdmVjNCBjY19hbWJpZW50R3JvdW5kO1xcbn07XFxudmVjMyBTUkdCVG9MaW5lYXIgKHZlYzMgZ2FtbWEpIHtcXG4gIHJldHVybiBnYW1tYSAqIGdhbW1hO1xcbn1cXG52ZWM0IENDRnJhZ091dHB1dCAodmVjNCBjb2xvcikge1xcbiAgI2lmIENDX1VTRV9IRFJcXG4gICAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgU1JHQlRvTGluZWFyKGNvbG9yLnJnYikgKiBjY19leHBvc3VyZS53LCB2ZWMzKGNjX2V4cG9zdXJlLnopKTtcXG4gICNlbmRpZlxcbiAgcmV0dXJuIGNvbG9yO1xcbn1cXG5pbiB2ZWMyIHZfdXY7XFxudW5pZm9ybSBzYW1wbGVyMkQgbWFpblRleHR1cmU7XFxudmVjNCBmcmFnICgpIHtcXG4gIHJldHVybiBDQ0ZyYWdPdXRwdXQodGV4dHVyZShtYWluVGV4dHVyZSwgdl91dikpO1xcbn1cXG5vdXQgdmVjNCBjY19GcmFnQ29sb3I7XFxudm9pZCBtYWluKCkgeyBjY19GcmFnQ29sb3IgPSBmcmFnKCk7IH1gXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImdsc2wxXCI6IHtcclxuICAgICAgICAgIFwidmVydFwiOiBgXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxudW5pZm9ybSBtZWRpdW1wIHZlYzQgY2Nfc2NyZWVuU2l6ZTtcXG5zdHJ1Y3QgU3RhbmRhcmRWZXJ0SW5wdXQge1xcbiAgaGlnaHAgdmVjNCBwb3NpdGlvbjtcXG4gIHZlYzMgbm9ybWFsO1xcbiAgdmVjNCB0YW5nZW50O1xcbn07XFxuYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbnZhcnlpbmcgdmVjMiB2X3V2O1xcbnVuaWZvcm0gdmVjNCBvZmZzZXQ7XFxudW5pZm9ybSB2ZWM0IGRpZ2l0c1syMF07XFxuZmxvYXQgZ2V0Q29tcG9uZW50KHZlYzQgdiwgZmxvYXQgaSkge1xcbiAgaWYgKGkgPCAxLjApIHsgcmV0dXJuIHYueDsgfVxcbiAgZWxzZSBpZiAoaSA8IDIuMCkgeyByZXR1cm4gdi55OyB9XFxuICBlbHNlIGlmIChpIDwgMy4wKSB7IHJldHVybiB2Lno7IH1cXG4gIGVsc2UgeyByZXR1cm4gdi53OyB9XFxufVxcbnZlYzQgdmVydCAoKSB7XFxuICB2ZWM0IHBvc2l0aW9uO1xcbiAgcG9zaXRpb24gPSB2ZWM0KGFfcG9zaXRpb24sIDEuMCk7XFxuICBwb3NpdGlvbi54ICo9IGNjX3NjcmVlblNpemUueSAqIGNjX3NjcmVlblNpemUuejtcXG4gIHBvc2l0aW9uLnh5ICs9IG9mZnNldC54eSArIGFicyhwb3NpdGlvbi54eSk7XFxuICB2X3V2ID0gYV9jb2xvci54eTtcXG4gIGlmIChhX2NvbG9yLnogPj0gMC4wKSB7XFxuICAgIGZsb2F0IG4gPSBnZXRDb21wb25lbnQoZGlnaXRzW2ludChhX2NvbG9yLnopXSwgYV9jb2xvci53KTtcXG4gICAgdl91diArPSB2ZWMyKG9mZnNldC56ICogbiwgMC4wKTtcXG4gIH1cXG4gIHJldHVybiBwb3NpdGlvbjtcXG59XFxudm9pZCBtYWluKCkgeyBnbF9Qb3NpdGlvbiA9IHZlcnQoKTsgfWAsXHJcbiAgICAgICAgICBcImZyYWdcIjogYFxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbnVuaWZvcm0gbWVkaXVtcCB2ZWM0IGNjX2V4cG9zdXJlO1xcbnZlYzMgU1JHQlRvTGluZWFyICh2ZWMzIGdhbW1hKSB7XFxuICByZXR1cm4gZ2FtbWEgKiBnYW1tYTtcXG59XFxudmVjNCBDQ0ZyYWdPdXRwdXQgKHZlYzQgY29sb3IpIHtcXG4gICNpZiBDQ19VU0VfSERSXFxuICAgIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIFNSR0JUb0xpbmVhcihjb2xvci5yZ2IpICogY2NfZXhwb3N1cmUudywgdmVjMyhjY19leHBvc3VyZS56KSk7XFxuICAjZW5kaWZcXG4gIHJldHVybiBjb2xvcjtcXG59XFxudmFyeWluZyB2ZWMyIHZfdXY7XFxudW5pZm9ybSBzYW1wbGVyMkQgbWFpblRleHR1cmU7XFxudmVjNCBmcmFnICgpIHtcXG4gIHJldHVybiBDQ0ZyYWdPdXRwdXQodGV4dHVyZTJEKG1haW5UZXh0dXJlLCB2X3V2KSk7XFxufVxcbnZvaWQgbWFpbigpIHsgZ2xfRnJhZ0NvbG9yID0gZnJhZygpOyB9YFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJidWlsdGluc1wiOiB7XHJcbiAgICAgICAgICBcImdsb2JhbHNcIjogeyBcImJsb2Nrc1wiOiBbeyBcIm5hbWVcIjogXCJDQ0dsb2JhbFwiLCBcImRlZmluZXNcIjogW10gfV0sIFwic2FtcGxlcnNcIjogW10gfSxcclxuICAgICAgICAgIFwibG9jYWxzXCI6IHsgXCJibG9ja3NcIjogW10sIFwic2FtcGxlcnNcIjogW10gfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgXCJkZWZpbmVzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwiQ0NfVVNFX0hEUlwiLCBcInR5cGVcIjogXCJib29sZWFuXCIgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgXCJibG9ja3NcIjogW1xyXG4gICAgICAgICAge1wibmFtZVwiOiBcIkNvbnN0YW50c1wiLCBcImRlZmluZXNcIjogW10sIFwiYmluZGluZ1wiOiAwLCBcIm1lbWJlcnNcIjogW1xyXG4gICAgICAgICAgICB7IFwibmFtZVwiOiBcIm9mZnNldFwiLCBcInR5cGVcIjogMTYsIFwiY291bnRcIjogMSB9XHJcbiAgICAgICAgICBdfSxcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCJQZXJGcmFtZUluZm9cIiwgXCJkZWZpbmVzXCI6IFtdLCBcImJpbmRpbmdcIjogMSwgXCJtZW1iZXJzXCI6IFtcclxuICAgICAgICAgICAgeyBcIm5hbWVcIjogXCJkaWdpdHNcIiwgXCJ0eXBlXCI6IDE2LCBcImNvdW50XCI6IDIwIH1cclxuICAgICAgICAgIF19XHJcbiAgICAgICAgXSxcclxuICAgICAgICBcInNhbXBsZXJzXCI6IFtcclxuICAgICAgICAgIHsgXCJuYW1lXCI6IFwibWFpblRleHR1cmVcIiwgXCJ0eXBlXCI6IDI4LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJiaW5kaW5nXCI6IDMxIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIFwiYXR0cmlidXRlc1wiOiBbXHJcbiAgICAgICAgICB7IFwibmFtZVwiOiBcImFfcG9zaXRpb25cIiwgXCJ0eXBlXCI6IDE1LCBcImNvdW50XCI6IDEsIFwiZGVmaW5lc1wiOiBbXSwgXCJmb3JtYXRcIjogMzIsIFwibG9jYXRpb25cIjogMCB9LFxyXG4gICAgICAgICAgeyBcIm5hbWVcIjogXCJhX2NvbG9yXCIsIFwidHlwZVwiOiAxNiwgXCJjb3VudFwiOiAxLCBcImRlZmluZXNcIjogW10sIFwiZm9ybWF0XCI6IDQzLCBcImxvY2F0aW9uXCI6IDEgfVxyXG4gICAgICAgIF1cclxuICAgICAgfVxyXG4gICAgXVxyXG4gIH1cclxuXTtcclxuIl19